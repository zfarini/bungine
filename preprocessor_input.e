# 1 "code/game.cpp"
# 1 "/nfs/homes/zfarini/3dGame//"
# 1 "<built-in>"
#define __STDC__ 1
#define __cplusplus 201703L
#define __STDC_UTF_16__ 1
#define __STDC_UTF_32__ 1
#define __STDC_HOSTED__ 1
#define __GNUC__ 10
#define __GNUC_MINOR__ 5
#define __GNUC_PATCHLEVEL__ 0
#define __VERSION__ "10.5.0"
#define __ATOMIC_RELAXED 0
#define __ATOMIC_SEQ_CST 5
#define __ATOMIC_ACQUIRE 2
#define __ATOMIC_RELEASE 3
#define __ATOMIC_ACQ_REL 4
#define __ATOMIC_CONSUME 1
#define __pic__ 2
#define __PIC__ 2
#define __pie__ 2
#define __PIE__ 2
#define __SANITIZE_ADDRESS__ 1
#define __FINITE_MATH_ONLY__ 0
#define _LP64 1
#define __LP64__ 1
#define __SIZEOF_INT__ 4
#define __SIZEOF_LONG__ 8
#define __SIZEOF_LONG_LONG__ 8
#define __SIZEOF_SHORT__ 2
#define __SIZEOF_FLOAT__ 4
#define __SIZEOF_DOUBLE__ 8
#define __SIZEOF_LONG_DOUBLE__ 16
#define __SIZEOF_SIZE_T__ 8
#define __CHAR_BIT__ 8
#define __BIGGEST_ALIGNMENT__ 16
#define __ORDER_LITTLE_ENDIAN__ 1234
#define __ORDER_BIG_ENDIAN__ 4321
#define __ORDER_PDP_ENDIAN__ 3412
#define __BYTE_ORDER__ __ORDER_LITTLE_ENDIAN__
#define __FLOAT_WORD_ORDER__ __ORDER_LITTLE_ENDIAN__
#define __SIZEOF_POINTER__ 8
#define __GNUG__ 10
#define __SIZE_TYPE__ long unsigned int
#define __PTRDIFF_TYPE__ long int
#define __WCHAR_TYPE__ int
#define __WINT_TYPE__ unsigned int
#define __INTMAX_TYPE__ long int
#define __UINTMAX_TYPE__ long unsigned int
#define __CHAR16_TYPE__ short unsigned int
#define __CHAR32_TYPE__ unsigned int
#define __SIG_ATOMIC_TYPE__ int
#define __INT8_TYPE__ signed char
#define __INT16_TYPE__ short int
#define __INT32_TYPE__ int
#define __INT64_TYPE__ long int
#define __UINT8_TYPE__ unsigned char
#define __UINT16_TYPE__ short unsigned int
#define __UINT32_TYPE__ unsigned int
#define __UINT64_TYPE__ long unsigned int
#define __INT_LEAST8_TYPE__ signed char
#define __INT_LEAST16_TYPE__ short int
#define __INT_LEAST32_TYPE__ int
#define __INT_LEAST64_TYPE__ long int
#define __UINT_LEAST8_TYPE__ unsigned char
#define __UINT_LEAST16_TYPE__ short unsigned int
#define __UINT_LEAST32_TYPE__ unsigned int
#define __UINT_LEAST64_TYPE__ long unsigned int
#define __INT_FAST8_TYPE__ signed char
#define __INT_FAST16_TYPE__ long int
#define __INT_FAST32_TYPE__ long int
#define __INT_FAST64_TYPE__ long int
#define __UINT_FAST8_TYPE__ unsigned char
#define __UINT_FAST16_TYPE__ long unsigned int
#define __UINT_FAST32_TYPE__ long unsigned int
#define __UINT_FAST64_TYPE__ long unsigned int
#define __INTPTR_TYPE__ long int
#define __UINTPTR_TYPE__ long unsigned int
#define __GXX_WEAK__ 1
#define __DEPRECATED 1
#define __GXX_RTTI 1
#define __cpp_rtti 199711L
#define __GXX_EXPERIMENTAL_CXX0X__ 1
#define __cpp_binary_literals 201304L
#define __cpp_hex_float 201603L
#define __cpp_runtime_arrays 198712L
#define __cpp_raw_strings 200710L
#define __cpp_unicode_literals 200710L
#define __cpp_user_defined_literals 200809L
#define __cpp_lambdas 200907L
#define __cpp_decltype 200707L
#define __cpp_attributes 200809L
#define __cpp_rvalue_reference 200610L
#define __cpp_rvalue_references 200610L
#define __cpp_variadic_templates 200704L
#define __cpp_initializer_lists 200806L
#define __cpp_delegating_constructors 200604L
#define __cpp_nsdmi 200809L
#define __cpp_inheriting_constructors 201511L
#define __cpp_ref_qualifiers 200710L
#define __cpp_alias_templates 200704L
#define __cpp_return_type_deduction 201304L
#define __cpp_init_captures 201304L
#define __cpp_generic_lambdas 201304L
#define __cpp_decltype_auto 201304L
#define __cpp_aggregate_nsdmi 201304L
#define __cpp_variable_templates 201304L
#define __cpp_digit_separators 201309L
#define __cpp_unicode_characters 201411L
#define __cpp_static_assert 201411L
#define __cpp_namespace_attributes 201411L
#define __cpp_enumerator_attributes 201411L
#define __cpp_nested_namespace_definitions 201411L
#define __cpp_fold_expressions 201603L
#define __cpp_nontype_template_args 201411L
#define __cpp_range_based_for 201603L
#define __cpp_constexpr 201603L
#define __cpp_if_constexpr 201606L
#define __cpp_capture_star_this 201603L
#define __cpp_inline_variables 201606L
#define __cpp_aggregate_bases 201603L
#define __cpp_deduction_guides 201703L
#define __cpp_noexcept_function_type 201510L
#define __cpp_template_auto 201606L
#define __cpp_structured_bindings 201606L
#define __cpp_variadic_using 201611L
#define __cpp_guaranteed_copy_elision 201606L
#define __cpp_nontype_template_parameter_auto 201606L
#define __cpp_sized_deallocation 201309L
#define __cpp_aligned_new 201606L
#define __STDCPP_DEFAULT_NEW_ALIGNMENT__ 16
#define __cpp_template_template_args 201611L
#define __cpp_threadsafe_static_init 200806L
#define __EXCEPTIONS 1
#define __cpp_exceptions 199711L
#define __GXX_ABI_VERSION 1014
#define __SCHAR_MAX__ 0x7f
#define __SHRT_MAX__ 0x7fff
#define __INT_MAX__ 0x7fffffff
#define __LONG_MAX__ 0x7fffffffffffffffL
#define __LONG_LONG_MAX__ 0x7fffffffffffffffLL
#define __WCHAR_MAX__ 0x7fffffff
#define __WCHAR_MIN__ (-__WCHAR_MAX__ - 1)
#define __WINT_MAX__ 0xffffffffU
#define __WINT_MIN__ 0U
#define __PTRDIFF_MAX__ 0x7fffffffffffffffL
#define __SIZE_MAX__ 0xffffffffffffffffUL
#define __SCHAR_WIDTH__ 8
#define __SHRT_WIDTH__ 16
#define __INT_WIDTH__ 32
#define __LONG_WIDTH__ 64
#define __LONG_LONG_WIDTH__ 64
#define __WCHAR_WIDTH__ 32
#define __WINT_WIDTH__ 32
#define __PTRDIFF_WIDTH__ 64
#define __SIZE_WIDTH__ 64
#define __INTMAX_MAX__ 0x7fffffffffffffffL
#define __INTMAX_C(c) c ## L
#define __UINTMAX_MAX__ 0xffffffffffffffffUL
#define __UINTMAX_C(c) c ## UL
#define __INTMAX_WIDTH__ 64
#define __SIG_ATOMIC_MAX__ 0x7fffffff
#define __SIG_ATOMIC_MIN__ (-__SIG_ATOMIC_MAX__ - 1)
#define __SIG_ATOMIC_WIDTH__ 32
#define __INT8_MAX__ 0x7f
#define __INT16_MAX__ 0x7fff
#define __INT32_MAX__ 0x7fffffff
#define __INT64_MAX__ 0x7fffffffffffffffL
#define __UINT8_MAX__ 0xff
#define __UINT16_MAX__ 0xffff
#define __UINT32_MAX__ 0xffffffffU
#define __UINT64_MAX__ 0xffffffffffffffffUL
#define __INT_LEAST8_MAX__ 0x7f
#define __INT8_C(c) c
#define __INT_LEAST8_WIDTH__ 8
#define __INT_LEAST16_MAX__ 0x7fff
#define __INT16_C(c) c
#define __INT_LEAST16_WIDTH__ 16
#define __INT_LEAST32_MAX__ 0x7fffffff
#define __INT32_C(c) c
#define __INT_LEAST32_WIDTH__ 32
#define __INT_LEAST64_MAX__ 0x7fffffffffffffffL
#define __INT64_C(c) c ## L
#define __INT_LEAST64_WIDTH__ 64
#define __UINT_LEAST8_MAX__ 0xff
#define __UINT8_C(c) c
#define __UINT_LEAST16_MAX__ 0xffff
#define __UINT16_C(c) c
#define __UINT_LEAST32_MAX__ 0xffffffffU
#define __UINT32_C(c) c ## U
#define __UINT_LEAST64_MAX__ 0xffffffffffffffffUL
#define __UINT64_C(c) c ## UL
#define __INT_FAST8_MAX__ 0x7f
#define __INT_FAST8_WIDTH__ 8
#define __INT_FAST16_MAX__ 0x7fffffffffffffffL
#define __INT_FAST16_WIDTH__ 64
#define __INT_FAST32_MAX__ 0x7fffffffffffffffL
#define __INT_FAST32_WIDTH__ 64
#define __INT_FAST64_MAX__ 0x7fffffffffffffffL
#define __INT_FAST64_WIDTH__ 64
#define __UINT_FAST8_MAX__ 0xff
#define __UINT_FAST16_MAX__ 0xffffffffffffffffUL
#define __UINT_FAST32_MAX__ 0xffffffffffffffffUL
#define __UINT_FAST64_MAX__ 0xffffffffffffffffUL
#define __INTPTR_MAX__ 0x7fffffffffffffffL
#define __INTPTR_WIDTH__ 64
#define __UINTPTR_MAX__ 0xffffffffffffffffUL
#define __GCC_IEC_559 2
#define __GCC_IEC_559_COMPLEX 2
#define __FLT_EVAL_METHOD__ 0
#define __FLT_EVAL_METHOD_TS_18661_3__ 0
#define __DEC_EVAL_METHOD__ 2
#define __FLT_RADIX__ 2
#define __FLT_MANT_DIG__ 24
#define __FLT_DIG__ 6
#define __FLT_MIN_EXP__ (-125)
#define __FLT_MIN_10_EXP__ (-37)
#define __FLT_MAX_EXP__ 128
#define __FLT_MAX_10_EXP__ 38
#define __FLT_DECIMAL_DIG__ 9
#define __FLT_MAX__ 3.40282346638528859811704183484516925e+38F
#define __FLT_NORM_MAX__ 3.40282346638528859811704183484516925e+38F
#define __FLT_MIN__ 1.17549435082228750796873653722224568e-38F
#define __FLT_EPSILON__ 1.19209289550781250000000000000000000e-7F
#define __FLT_DENORM_MIN__ 1.40129846432481707092372958328991613e-45F
#define __FLT_HAS_DENORM__ 1
#define __FLT_HAS_INFINITY__ 1
#define __FLT_HAS_QUIET_NAN__ 1
#define __DBL_MANT_DIG__ 53
#define __DBL_DIG__ 15
#define __DBL_MIN_EXP__ (-1021)
#define __DBL_MIN_10_EXP__ (-307)
#define __DBL_MAX_EXP__ 1024
#define __DBL_MAX_10_EXP__ 308
#define __DBL_DECIMAL_DIG__ 17
#define __DBL_MAX__ double(1.79769313486231570814527423731704357e+308L)
#define __DBL_NORM_MAX__ double(1.79769313486231570814527423731704357e+308L)
#define __DBL_MIN__ double(2.22507385850720138309023271733240406e-308L)
#define __DBL_EPSILON__ double(2.22044604925031308084726333618164062e-16L)
#define __DBL_DENORM_MIN__ double(4.94065645841246544176568792868221372e-324L)
#define __DBL_HAS_DENORM__ 1
#define __DBL_HAS_INFINITY__ 1
#define __DBL_HAS_QUIET_NAN__ 1
#define __LDBL_MANT_DIG__ 64
#define __LDBL_DIG__ 18
#define __LDBL_MIN_EXP__ (-16381)
#define __LDBL_MIN_10_EXP__ (-4931)
#define __LDBL_MAX_EXP__ 16384
#define __LDBL_MAX_10_EXP__ 4932
#define __DECIMAL_DIG__ 21
#define __LDBL_DECIMAL_DIG__ 21
#define __LDBL_MAX__ 1.18973149535723176502126385303097021e+4932L
#define __LDBL_NORM_MAX__ 1.18973149535723176502126385303097021e+4932L
#define __LDBL_MIN__ 3.36210314311209350626267781732175260e-4932L
#define __LDBL_EPSILON__ 1.08420217248550443400745280086994171e-19L
#define __LDBL_DENORM_MIN__ 3.64519953188247460252840593361941982e-4951L
#define __LDBL_HAS_DENORM__ 1
#define __LDBL_HAS_INFINITY__ 1
#define __LDBL_HAS_QUIET_NAN__ 1
#define __FLT32_MANT_DIG__ 24
#define __FLT32_DIG__ 6
#define __FLT32_MIN_EXP__ (-125)
#define __FLT32_MIN_10_EXP__ (-37)
#define __FLT32_MAX_EXP__ 128
#define __FLT32_MAX_10_EXP__ 38
#define __FLT32_DECIMAL_DIG__ 9
#define __FLT32_MAX__ 3.40282346638528859811704183484516925e+38F32
#define __FLT32_NORM_MAX__ 3.40282346638528859811704183484516925e+38F32
#define __FLT32_MIN__ 1.17549435082228750796873653722224568e-38F32
#define __FLT32_EPSILON__ 1.19209289550781250000000000000000000e-7F32
#define __FLT32_DENORM_MIN__ 1.40129846432481707092372958328991613e-45F32
#define __FLT32_HAS_DENORM__ 1
#define __FLT32_HAS_INFINITY__ 1
#define __FLT32_HAS_QUIET_NAN__ 1
#define __FLT64_MANT_DIG__ 53
#define __FLT64_DIG__ 15
#define __FLT64_MIN_EXP__ (-1021)
#define __FLT64_MIN_10_EXP__ (-307)
#define __FLT64_MAX_EXP__ 1024
#define __FLT64_MAX_10_EXP__ 308
#define __FLT64_DECIMAL_DIG__ 17
#define __FLT64_MAX__ 1.79769313486231570814527423731704357e+308F64
#define __FLT64_NORM_MAX__ 1.79769313486231570814527423731704357e+308F64
#define __FLT64_MIN__ 2.22507385850720138309023271733240406e-308F64
#define __FLT64_EPSILON__ 2.22044604925031308084726333618164062e-16F64
#define __FLT64_DENORM_MIN__ 4.94065645841246544176568792868221372e-324F64
#define __FLT64_HAS_DENORM__ 1
#define __FLT64_HAS_INFINITY__ 1
#define __FLT64_HAS_QUIET_NAN__ 1
#define __FLT128_MANT_DIG__ 113
#define __FLT128_DIG__ 33
#define __FLT128_MIN_EXP__ (-16381)
#define __FLT128_MIN_10_EXP__ (-4931)
#define __FLT128_MAX_EXP__ 16384
#define __FLT128_MAX_10_EXP__ 4932
#define __FLT128_DECIMAL_DIG__ 36
#define __FLT128_MAX__ 1.18973149535723176508575932662800702e+4932F128
#define __FLT128_NORM_MAX__ 1.18973149535723176508575932662800702e+4932F128
#define __FLT128_MIN__ 3.36210314311209350626267781732175260e-4932F128
#define __FLT128_EPSILON__ 1.92592994438723585305597794258492732e-34F128
#define __FLT128_DENORM_MIN__ 6.47517511943802511092443895822764655e-4966F128
#define __FLT128_HAS_DENORM__ 1
#define __FLT128_HAS_INFINITY__ 1
#define __FLT128_HAS_QUIET_NAN__ 1
#define __FLT32X_MANT_DIG__ 53
#define __FLT32X_DIG__ 15
#define __FLT32X_MIN_EXP__ (-1021)
#define __FLT32X_MIN_10_EXP__ (-307)
#define __FLT32X_MAX_EXP__ 1024
#define __FLT32X_MAX_10_EXP__ 308
#define __FLT32X_DECIMAL_DIG__ 17
#define __FLT32X_MAX__ 1.79769313486231570814527423731704357e+308F32x
#define __FLT32X_NORM_MAX__ 1.79769313486231570814527423731704357e+308F32x
#define __FLT32X_MIN__ 2.22507385850720138309023271733240406e-308F32x
#define __FLT32X_EPSILON__ 2.22044604925031308084726333618164062e-16F32x
#define __FLT32X_DENORM_MIN__ 4.94065645841246544176568792868221372e-324F32x
#define __FLT32X_HAS_DENORM__ 1
#define __FLT32X_HAS_INFINITY__ 1
#define __FLT32X_HAS_QUIET_NAN__ 1
#define __FLT64X_MANT_DIG__ 64
#define __FLT64X_DIG__ 18
#define __FLT64X_MIN_EXP__ (-16381)
#define __FLT64X_MIN_10_EXP__ (-4931)
#define __FLT64X_MAX_EXP__ 16384
#define __FLT64X_MAX_10_EXP__ 4932
#define __FLT64X_DECIMAL_DIG__ 21
#define __FLT64X_MAX__ 1.18973149535723176502126385303097021e+4932F64x
#define __FLT64X_NORM_MAX__ 1.18973149535723176502126385303097021e+4932F64x
#define __FLT64X_MIN__ 3.36210314311209350626267781732175260e-4932F64x
#define __FLT64X_EPSILON__ 1.08420217248550443400745280086994171e-19F64x
#define __FLT64X_DENORM_MIN__ 3.64519953188247460252840593361941982e-4951F64x
#define __FLT64X_HAS_DENORM__ 1
#define __FLT64X_HAS_INFINITY__ 1
#define __FLT64X_HAS_QUIET_NAN__ 1
#define __DEC32_MANT_DIG__ 7
#define __DEC32_MIN_EXP__ (-94)
#define __DEC32_MAX_EXP__ 97
#define __DEC32_MIN__ 1E-95DF
#define __DEC32_MAX__ 9.999999E96DF
#define __DEC32_EPSILON__ 1E-6DF
#define __DEC32_SUBNORMAL_MIN__ 0.000001E-95DF
#define __DEC64_MANT_DIG__ 16
#define __DEC64_MIN_EXP__ (-382)
#define __DEC64_MAX_EXP__ 385
#define __DEC64_MIN__ 1E-383DD
#define __DEC64_MAX__ 9.999999999999999E384DD
#define __DEC64_EPSILON__ 1E-15DD
#define __DEC64_SUBNORMAL_MIN__ 0.000000000000001E-383DD
#define __DEC128_MANT_DIG__ 34
#define __DEC128_MIN_EXP__ (-6142)
#define __DEC128_MAX_EXP__ 6145
#define __DEC128_MIN__ 1E-6143DL
#define __DEC128_MAX__ 9.999999999999999999999999999999999E6144DL
#define __DEC128_EPSILON__ 1E-33DL
#define __DEC128_SUBNORMAL_MIN__ 0.000000000000000000000000000000001E-6143DL
#define __REGISTER_PREFIX__ 
#define __USER_LABEL_PREFIX__ 
#define __GNUC_STDC_INLINE__ 1
#define __NO_INLINE__ 1
#define __STRICT_ANSI__ 1
#define __GCC_HAVE_SYNC_COMPARE_AND_SWAP_1 1
#define __GCC_HAVE_SYNC_COMPARE_AND_SWAP_2 1
#define __GCC_HAVE_SYNC_COMPARE_AND_SWAP_4 1
#define __GCC_HAVE_SYNC_COMPARE_AND_SWAP_8 1
#define __GCC_ATOMIC_BOOL_LOCK_FREE 2
#define __GCC_ATOMIC_CHAR_LOCK_FREE 2
#define __GCC_ATOMIC_CHAR16_T_LOCK_FREE 2
#define __GCC_ATOMIC_CHAR32_T_LOCK_FREE 2
#define __GCC_ATOMIC_WCHAR_T_LOCK_FREE 2
#define __GCC_ATOMIC_SHORT_LOCK_FREE 2
#define __GCC_ATOMIC_INT_LOCK_FREE 2
#define __GCC_ATOMIC_LONG_LOCK_FREE 2
#define __GCC_ATOMIC_LLONG_LOCK_FREE 2
#define __GCC_ATOMIC_TEST_AND_SET_TRUEVAL 1
#define __GCC_ATOMIC_POINTER_LOCK_FREE 2
#define __HAVE_SPECULATION_SAFE_VALUE 1
#define __GCC_HAVE_DWARF2_CFI_ASM 1
#define __PRAGMA_REDEFINE_EXTNAME 1
#define __SSP_STRONG__ 3
#define __SIZEOF_INT128__ 16
#define __SIZEOF_WCHAR_T__ 4
#define __SIZEOF_WINT_T__ 4
#define __SIZEOF_PTRDIFF_T__ 8
#define __amd64 1
#define __amd64__ 1
#define __x86_64 1
#define __x86_64__ 1
#define __SIZEOF_FLOAT80__ 16
#define __SIZEOF_FLOAT128__ 16
#define __ATOMIC_HLE_ACQUIRE 65536
#define __ATOMIC_HLE_RELEASE 131072
#define __GCC_ASM_FLAG_OUTPUTS__ 1
#define __k8 1
#define __k8__ 1
#define __code_model_small__ 1
#define __MMX__ 1
#define __SSE__ 1
#define __SSE2__ 1
#define __FXSR__ 1
#define __SSE_MATH__ 1
#define __SSE2_MATH__ 1
#define __MMX_WITH_SSE__ 1
#define __SEG_FS 1
#define __SEG_GS 1
#define __CET__ 3
#define __gnu_linux__ 1
#define __linux 1
#define __linux__ 1
#define __unix 1
#define __unix__ 1
#define __ELF__ 1
#define __DECIMAL_BID_FORMAT__ 1
# 1 "<command-line>"
#define _GNU_SOURCE 1
#define DISABLE_PREPROCESSOR 1
#define RENDERER_OPENGL 1
# 1 "/usr/include/stdc-predef.h" 1 3 4
# 19 "/usr/include/stdc-predef.h" 3 4
#define _STDC_PREDEF_H 1
# 38 "/usr/include/stdc-predef.h" 3 4
#define __STDC_IEC_559__ 1
#define __STDC_IEC_60559_BFP__ 201404L
# 48 "/usr/include/stdc-predef.h" 3 4
#define __STDC_IEC_559_COMPLEX__ 1
#define __STDC_IEC_60559_COMPLEX__ 201404L
# 62 "/usr/include/stdc-predef.h" 3 4
#define __STDC_ISO_10646__ 201706L
# 1 "<command-line>" 2
# 1 "code/game.cpp"
# 15 "code/game.cpp"
# 1 "code/common.h" 1
       

#define function static
#define global static
#define ARRAY_SIZE(arr) (sizeof(arr) / sizeof(*arr))

#define ENUM_STRING(type,value) get_enum_ ##type ##_str(value)

typedef uint8_t u8;
typedef uint16_t u16;
typedef uint32_t u32;
typedef uint64_t u64;
typedef int8_t i8;
typedef int16_t i16;
typedef int32_t i32;
typedef int64_t i64;
typedef float f32;
typedef double f64;
typedef i32 b32;
typedef size_t usize;
# 16 "code/game.cpp" 2
# 1 "code/arena.h" 1
       

struct Arena
{
 void *data;
 usize used;
 usize size;
};

static Arena make_arena(void *memory, usize size)
{
 Arena arena = {};

 arena.data = memory;
 arena.size = size;
 return arena;
}

#define arena_alloc(arena,size) _arena_alloc(__FILE__, __func__, __LINE__, arena, size)

static void *_arena_alloc(const char *filename, const char *func, int line, Arena *arena, usize size)
{
 if (!size)
  return 0;
 int alignement = 16;

 int misalign = ((uintptr_t)((char *)arena->data + arena->used)) & (alignement - 1);
 misalign = misalign ? alignement - misalign : 0;

 if (arena->used + size + misalign > arena->size) {
  printf("%s: %s:%d: failed to allocate %zd bytes (used: %zd, size: %zd, left: %zd, misalign: %d)\n", filename, func, line, size,
   arena->used, arena->size, arena->size - arena->used, misalign);
  assert(0);
  return 0;
 }


 void *ptr = (char *)arena->data + arena->used + misalign;
 arena->used += size + misalign;
 return ptr;
}

static void *arena_alloc_zero(Arena *arena, usize size)
{
 void *mem = _arena_alloc("code/arena.h", __func__, 45, arena, size);
 memset(mem, 0, size);
 return mem;
}

struct TempArena {
 Arena arena;
 usize last_used[16];
 int last_used_count;
};

static TempArena *g_temp_arena;

static Arena *begin_temp_memory()
{
 assert(g_temp_arena->last_used_count < (sizeof(g_temp_arena->last_used) / sizeof(*g_temp_arena->last_used)));
 g_temp_arena->last_used[g_temp_arena->last_used_count++] = g_temp_arena->arena.used;
 return &g_temp_arena->arena;
}

static void end_temp_memory()
{
 assert(g_temp_arena->last_used_count > 0);
 g_temp_arena->arena.used = g_temp_arena->last_used[--g_temp_arena->last_used_count];
}
# 17 "code/game.cpp" 2
# 1 "code/utils.h" 1
#define Kilobyte(x) (1024ULL * x)
#define Megabyte(x) (1024ULL * Kilobyte(x))
#define GigaByte(x) (1024ULL * Megabyte(x))

template <typename T> T min(T a, T b) { return (a < b ? a : b); }

template <typename T> T max(T a, T b) { return (a > b ? a : b); }

template <typename T> void swap(T &a, T &b) {
    T tmp = a;

    a = b;
    b = tmp;
}

template <typename T> struct Array {
    T *data;
    usize count;
    usize capacity;

    T &operator[](int index) {
        assert(index >= 0 && index < count);
        return data[index];
    }

    T &operator[](usize index) {
        assert(index < count);
        return data[index];
    }

    void push(const T &value) {
        assert(count < capacity);
        data[count++] = value;
    }

    T &back() {
        assert(count);
        return data[count - 1];
    }
};

template <typename T> Array<T> make_array_max(Arena *arena, usize capacity) {
    Array<T> result;

    result.count = 0;
    result.capacity = capacity;
    result.data = (T *)_arena_alloc("code/utils.h", __func__, 47, arena, capacity * sizeof(T));
    return result;
}

template <typename T>
Array<T> make_array(Arena *arena, usize count, const T *data = 0) {
    Array<T> result = make_array_max<T>(arena, count);

    result.count = count;
    if (data && count)
        memcpy(result.data, data, count * sizeof(T));
    return result;
}

template <typename T> Array<T> make_zero_array(Arena *arena, usize count) {
    Array<T> result = make_array<T>(arena, count);
    memset(result.data, 0, sizeof(T) * count);

    return result;
}

template <typename T> Array<T> make_array(T *data, usize count) {
    Array<T> result;

    result.capacity = result.count = count;
    result.data = data;
    return result;
}


template <typename T> Array<T> clone_array(Arena *arena, Array<T> &array) {
    Array<T> result;

    result.data = (T *)_arena_alloc("code/utils.h", __func__, 80, arena, array.capacity * sizeof(T));
    memcpy(result.data, array.data, sizeof(T) * array.count);
    result.count = array.count;
    result.capacity = array.capacity;
    return result;
}







typedef Array<char> String;

String make_string(Arena *arena, usize count, const char *data = 0) {
    return make_array<char>(arena, count, data);
}
b32 strings_equal(const String &a, const String &b) {
    if (a.count != b.count)
        return false;
    for (usize i = 0; i < a.count; i++)
        if (a.data[i] != b.data[i])
            return false;
    return true;
}

String make_cstring(const char *cstr) {
    usize len = 0;
    while (cstr[len])
        len++;
    String s;
    s.data = (char *)cstr;
    s.capacity = len + 1;
    s.count = len;
    return s;
}

String concact_string(Arena *arena, String a, String b) {
    String result = make_string(arena, a.count + b.count);

    memcpy(result.data, a.data, a.count);
    memcpy(result.data + a.count, b.data, b.count);
    return result;
}
#define str_format(str) (int)str.count, str.data

# 1 "/usr/include/c++/10/cstdio" 1 3
# 39 "/usr/include/c++/10/cstdio" 3
       
# 40 "/usr/include/c++/10/cstdio" 3

# 1 "/usr/include/x86_64-linux-gnu/c++/10/bits/c++config.h" 1 3
# 31 "/usr/include/x86_64-linux-gnu/c++/10/bits/c++config.h" 3
#define _GLIBCXX_CXX_CONFIG_H 1


#define _GLIBCXX_RELEASE 10


#define __GLIBCXX__ 20230707
# 46 "/usr/include/x86_64-linux-gnu/c++/10/bits/c++config.h" 3
#define _GLIBCXX_PURE __attribute__ ((__pure__))



#define _GLIBCXX_CONST __attribute__ ((__const__))



#define _GLIBCXX_NORETURN __attribute__ ((__noreturn__))
# 67 "/usr/include/x86_64-linux-gnu/c++/10/bits/c++config.h" 3
#define _GLIBCXX_HAVE_ATTRIBUTE_VISIBILITY 1


#define _GLIBCXX_VISIBILITY(V) __attribute__ ((__visibility__ (#V)))
# 84 "/usr/include/x86_64-linux-gnu/c++/10/bits/c++config.h" 3
#define _GLIBCXX_USE_DEPRECATED 1



#define _GLIBCXX_DEPRECATED __attribute__ ((__deprecated__))
#define _GLIBCXX_DEPRECATED_SUGGEST(ALT) __attribute__ ((__deprecated__ ("use '" ALT "' instead")))







#define _GLIBCXX17_DEPRECATED [[__deprecated__]]







#define _GLIBCXX20_DEPRECATED(MSG) 




#define _GLIBCXX_ABI_TAG_CXX11 __attribute ((__abi_tag__ ("cxx11")))




#define _GLIBCXX_NODISCARD [[__nodiscard__]]
# 127 "/usr/include/x86_64-linux-gnu/c++/10/bits/c++config.h" 3
#define _GLIBCXX_CONSTEXPR constexpr
#define _GLIBCXX_USE_CONSTEXPR constexpr
# 137 "/usr/include/x86_64-linux-gnu/c++/10/bits/c++config.h" 3
#define _GLIBCXX14_CONSTEXPR constexpr







#define _GLIBCXX17_CONSTEXPR constexpr
# 155 "/usr/include/x86_64-linux-gnu/c++/10/bits/c++config.h" 3
#define _GLIBCXX20_CONSTEXPR 





#define _GLIBCXX17_INLINE inline
# 170 "/usr/include/x86_64-linux-gnu/c++/10/bits/c++config.h" 3
#define _GLIBCXX_NOEXCEPT noexcept
#define _GLIBCXX_NOEXCEPT_IF(...) noexcept(__VA_ARGS__)
#define _GLIBCXX_USE_NOEXCEPT noexcept
#define _GLIBCXX_THROW(_EXC) 
# 183 "/usr/include/x86_64-linux-gnu/c++/10/bits/c++config.h" 3
#define _GLIBCXX_NOTHROW _GLIBCXX_USE_NOEXCEPT




#define _GLIBCXX_THROW_OR_ABORT(_EXC) (throw (_EXC))






#define _GLIBCXX_NOEXCEPT_PARM , bool _NE
#define _GLIBCXX_NOEXCEPT_QUAL noexcept (_NE)
# 212 "/usr/include/x86_64-linux-gnu/c++/10/bits/c++config.h" 3
#define _GLIBCXX_EXTERN_TEMPLATE 1
# 262 "/usr/include/x86_64-linux-gnu/c++/10/bits/c++config.h" 3

# 262 "/usr/include/x86_64-linux-gnu/c++/10/bits/c++config.h" 3
namespace std
{
  typedef long unsigned int size_t;
  typedef long int ptrdiff_t;


  typedef decltype(nullptr) nullptr_t;

}

#define _GLIBCXX_USE_DUAL_ABI 1







#define _GLIBCXX_USE_CXX11_ABI 1



namespace std
{
  inline namespace __cxx11 __attribute__((__abi_tag__ ("cxx11"))) { }
}
namespace __gnu_cxx
{
  inline namespace __cxx11 __attribute__((__abi_tag__ ("cxx11"))) { }
}
#define _GLIBCXX_NAMESPACE_CXX11 __cxx11::
#define _GLIBCXX_BEGIN_NAMESPACE_CXX11 namespace __cxx11 {
#define _GLIBCXX_END_NAMESPACE_CXX11 }
#define _GLIBCXX_DEFAULT_ABI_TAG _GLIBCXX_ABI_TAG_CXX11
# 304 "/usr/include/x86_64-linux-gnu/c++/10/bits/c++config.h" 3
#define _GLIBCXX_INLINE_VERSION 0
# 334 "/usr/include/x86_64-linux-gnu/c++/10/bits/c++config.h" 3
#define _GLIBCXX_BEGIN_NAMESPACE_VERSION 
#define _GLIBCXX_END_NAMESPACE_VERSION 
# 393 "/usr/include/x86_64-linux-gnu/c++/10/bits/c++config.h" 3
#define _GLIBCXX_STD_C std
#define _GLIBCXX_BEGIN_NAMESPACE_CONTAINER 
#define _GLIBCXX_END_NAMESPACE_CONTAINER 
# 404 "/usr/include/x86_64-linux-gnu/c++/10/bits/c++config.h" 3
#define _GLIBCXX_STD_A std
#define _GLIBCXX_BEGIN_NAMESPACE_ALGO 
#define _GLIBCXX_END_NAMESPACE_ALGO 




#undef _GLIBCXX_LONG_DOUBLE_COMPAT
# 423 "/usr/include/x86_64-linux-gnu/c++/10/bits/c++config.h" 3
#define _GLIBCXX_NAMESPACE_LDBL 
#define _GLIBCXX_BEGIN_NAMESPACE_LDBL 
#define _GLIBCXX_END_NAMESPACE_LDBL 


#define _GLIBCXX_NAMESPACE_LDBL_OR_CXX11 _GLIBCXX_NAMESPACE_CXX11
#define _GLIBCXX_BEGIN_NAMESPACE_LDBL_OR_CXX11 _GLIBCXX_BEGIN_NAMESPACE_CXX11
#define _GLIBCXX_END_NAMESPACE_LDBL_OR_CXX11 _GLIBCXX_END_NAMESPACE_CXX11
# 476 "/usr/include/x86_64-linux-gnu/c++/10/bits/c++config.h" 3
#define __glibcxx_assert(_Condition) 
# 501 "/usr/include/x86_64-linux-gnu/c++/10/bits/c++config.h" 3
#define _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(A) 


#define _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(A) 



#define _GLIBCXX_BEGIN_EXTERN_C extern "C" {
#define _GLIBCXX_END_EXTERN_C }

#define _GLIBCXX_USE_ALLOCATOR_NEW 1
# 522 "/usr/include/x86_64-linux-gnu/c++/10/bits/c++config.h" 3
# 1 "/usr/include/x86_64-linux-gnu/c++/10/bits/os_defines.h" 1 3
# 31 "/usr/include/x86_64-linux-gnu/c++/10/bits/os_defines.h" 3
#define _GLIBCXX_OS_DEFINES 1





#define __NO_CTYPE 1

# 1 "/usr/include/features.h" 1 3 4
# 19 "/usr/include/features.h" 3 4
#define _FEATURES_H 1
# 126 "/usr/include/features.h" 3 4
#undef __USE_ISOC11
#undef __USE_ISOC99
#undef __USE_ISOC95
#undef __USE_ISOCXX11
#undef __USE_POSIX
#undef __USE_POSIX2
#undef __USE_POSIX199309
#undef __USE_POSIX199506
#undef __USE_XOPEN
#undef __USE_XOPEN_EXTENDED
#undef __USE_UNIX98
#undef __USE_XOPEN2K
#undef __USE_XOPEN2KXSI
#undef __USE_XOPEN2K8
#undef __USE_XOPEN2K8XSI
#undef __USE_LARGEFILE
#undef __USE_LARGEFILE64
#undef __USE_FILE_OFFSET64
#undef __USE_MISC
#undef __USE_ATFILE
#undef __USE_DYNAMIC_STACK_SIZE
#undef __USE_GNU
#undef __USE_FORTIFY_LEVEL
#undef __KERNEL_STRICT_NAMES
#undef __GLIBC_USE_ISOC2X
#undef __GLIBC_USE_DEPRECATED_GETS
#undef __GLIBC_USE_DEPRECATED_SCANF




#define __KERNEL_STRICT_NAMES 
# 168 "/usr/include/features.h" 3 4
#define __GNUC_PREREQ(maj,min) ((__GNUC__ << 16) + __GNUC_MINOR__ >= ((maj) << 16) + (min))
# 182 "/usr/include/features.h" 3 4
#define __glibc_clang_prereq(maj,min) 0



#define __GLIBC_USE(F) __GLIBC_USE_ ## F
# 201 "/usr/include/features.h" 3 4
#undef _ISOC95_SOURCE
#define _ISOC95_SOURCE 1
#undef _ISOC99_SOURCE
#define _ISOC99_SOURCE 1
#undef _ISOC11_SOURCE
#define _ISOC11_SOURCE 1
#undef _ISOC2X_SOURCE
#define _ISOC2X_SOURCE 1
#undef _POSIX_SOURCE
#define _POSIX_SOURCE 1
#undef _POSIX_C_SOURCE
#define _POSIX_C_SOURCE 200809L
#undef _XOPEN_SOURCE
#define _XOPEN_SOURCE 700
#undef _XOPEN_SOURCE_EXTENDED
#define _XOPEN_SOURCE_EXTENDED 1
#undef _LARGEFILE64_SOURCE
#define _LARGEFILE64_SOURCE 1
#undef _DEFAULT_SOURCE
#define _DEFAULT_SOURCE 1
#undef _ATFILE_SOURCE
#define _ATFILE_SOURCE 1
#undef _DYNAMIC_STACK_SIZE_SOURCE
#define _DYNAMIC_STACK_SIZE_SOURCE 1
# 235 "/usr/include/features.h" 3 4
#undef _DEFAULT_SOURCE
#define _DEFAULT_SOURCE 1





#define __GLIBC_USE_ISOC2X 1







#define __USE_ISOC11 1






#define __USE_ISOC99 1






#define __USE_ISOC95 1





#define __USE_ISOC11 1




#define __USE_ISOCXX11 1
#define __USE_ISOC99 1
# 287 "/usr/include/features.h" 3 4
#undef _POSIX_SOURCE
#define _POSIX_SOURCE 1
#undef _POSIX_C_SOURCE
#define _POSIX_C_SOURCE 200809L
# 325 "/usr/include/features.h" 3 4
#define __USE_POSIX 1



#define __USE_POSIX2 1



#define __USE_POSIX199309 1



#define __USE_POSIX199506 1



#define __USE_XOPEN2K 1
#undef __USE_ISOC95
#define __USE_ISOC95 1
#undef __USE_ISOC99
#define __USE_ISOC99 1



#define __USE_XOPEN2K8 1
#undef _ATFILE_SOURCE
#define _ATFILE_SOURCE 1



#define __USE_XOPEN 1

#define __USE_XOPEN_EXTENDED 1
#define __USE_UNIX98 1
#undef _LARGEFILE_SOURCE
#define _LARGEFILE_SOURCE 1


#define __USE_XOPEN2K8 1
#define __USE_XOPEN2K8XSI 1

#define __USE_XOPEN2K 1
#define __USE_XOPEN2KXSI 1
#undef __USE_ISOC95
#define __USE_ISOC95 1
#undef __USE_ISOC99
#define __USE_ISOC99 1
# 381 "/usr/include/features.h" 3 4
#define __USE_LARGEFILE 1



#define __USE_LARGEFILE64 1






# 1 "/usr/include/features-time64.h" 1 3 4
# 20 "/usr/include/features-time64.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4



#define __WORDSIZE 64







#define __WORDSIZE_TIME64_COMPAT32 1

#define __SYSCALL_WORDSIZE 64
# 21 "/usr/include/features-time64.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/timesize.h" 1 3 4
# 19 "/usr/include/x86_64-linux-gnu/bits/timesize.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4



#define __WORDSIZE 64







#define __WORDSIZE_TIME64_COMPAT32 1

#define __SYSCALL_WORDSIZE 64
# 20 "/usr/include/x86_64-linux-gnu/bits/timesize.h" 2 3 4






#define __TIMESIZE __WORDSIZE
# 22 "/usr/include/features-time64.h" 2 3 4
# 393 "/usr/include/features.h" 2 3 4


#define __USE_MISC 1



#define __USE_ATFILE 1



#define __USE_DYNAMIC_STACK_SIZE 1



#define __USE_GNU 1
# 428 "/usr/include/features.h" 3 4
#define __USE_FORTIFY_LEVEL 0







#define __GLIBC_USE_DEPRECATED_GETS 0
# 459 "/usr/include/features.h" 3 4
#define __GLIBC_USE_DEPRECATED_SCANF 0
# 472 "/usr/include/features.h" 3 4
#undef __GNU_LIBRARY__
#define __GNU_LIBRARY__ 6



#define __GLIBC__ 2
#define __GLIBC_MINOR__ 35

#define __GLIBC_PREREQ(maj,min) ((__GLIBC__ << 16) + __GLIBC_MINOR__ >= ((maj) << 16) + (min))





# 1 "/usr/include/x86_64-linux-gnu/sys/cdefs.h" 1 3 4
# 20 "/usr/include/x86_64-linux-gnu/sys/cdefs.h" 3 4
#define _SYS_CDEFS_H 1
# 35 "/usr/include/x86_64-linux-gnu/sys/cdefs.h" 3 4
#undef __P
#undef __PMT
# 45 "/usr/include/x86_64-linux-gnu/sys/cdefs.h" 3 4
#define __glibc_has_attribute(attr) __has_attribute (attr)




#define __glibc_has_builtin(name) __has_builtin (name)






#define __glibc_has_extension(ext) 0







#define __LEAF , __leaf__
#define __LEAF_ATTR __attribute__ ((__leaf__))
# 86 "/usr/include/x86_64-linux-gnu/sys/cdefs.h" 3 4
#define __THROW noexcept (true)



#define __THROWNL __THROW
#define __NTH(fct) __LEAF_ATTR fct __THROW
#define __NTHNL(fct) fct __THROW
# 118 "/usr/include/x86_64-linux-gnu/sys/cdefs.h" 3 4
#define __P(args) args
#define __PMT(args) args




#define __CONCAT(x,y) x ## y
#define __STRING(x) #x


#define __ptr_t void *




#define __BEGIN_DECLS extern "C" {
#define __END_DECLS }







#define __bos(ptr) __builtin_object_size (ptr, __USE_FORTIFY_LEVEL > 1)
#define __bos0(ptr) __builtin_object_size (ptr, 0)







#define __glibc_objsize0(__o) __bos0 (__o)
#define __glibc_objsize(__o) __bos (__o)






#define __glibc_safe_len_cond(__l,__s,__osz) ((__l) <= (__osz) / (__s))
#define __glibc_unsigned_or_positive(__l) ((__typeof (__l)) 0 < (__typeof (__l)) -1 || (__builtin_constant_p (__l) && (__l) > 0))






#define __glibc_safe_or_unknown_len(__l,__s,__osz) (__glibc_unsigned_or_positive (__l) && __builtin_constant_p (__glibc_safe_len_cond ((__SIZE_TYPE__) (__l), __s, __osz)) && __glibc_safe_len_cond ((__SIZE_TYPE__) (__l), __s, __osz))
# 176 "/usr/include/x86_64-linux-gnu/sys/cdefs.h" 3 4
#define __glibc_unsafe_len(__l,__s,__osz) (__glibc_unsigned_or_positive (__l) && __builtin_constant_p (__glibc_safe_len_cond ((__SIZE_TYPE__) (__l), __s, __osz)) && !__glibc_safe_len_cond ((__SIZE_TYPE__) (__l), __s, __osz))
# 185 "/usr/include/x86_64-linux-gnu/sys/cdefs.h" 3 4
#define __glibc_fortify(f,__l,__s,__osz,...) (__glibc_safe_or_unknown_len (__l, __s, __osz) ? __ ## f ## _alias (__VA_ARGS__) : (__glibc_unsafe_len (__l, __s, __osz) ? __ ## f ## _chk_warn (__VA_ARGS__, __osz) : __ ## f ## _chk (__VA_ARGS__, __osz)))
# 195 "/usr/include/x86_64-linux-gnu/sys/cdefs.h" 3 4
#define __glibc_fortify_n(f,__l,__s,__osz,...) (__glibc_safe_or_unknown_len (__l, __s, __osz) ? __ ## f ## _alias (__VA_ARGS__) : (__glibc_unsafe_len (__l, __s, __osz) ? __ ## f ## _chk_warn (__VA_ARGS__, (__osz) / (__s)) : __ ## f ## _chk (__VA_ARGS__, (__osz) / (__s))))







#define __warnattr(msg) __attribute__((__warning__ (msg)))
#define __errordecl(name,msg) extern void name (void) __attribute__((__error__ (msg)))
# 221 "/usr/include/x86_64-linux-gnu/sys/cdefs.h" 3 4
#define __flexarr []
#define __glibc_c99_flexarr_available 1
# 247 "/usr/include/x86_64-linux-gnu/sys/cdefs.h" 3 4
#define __REDIRECT(name,proto,alias) name proto __asm__ (__ASMNAME (#alias))

#define __REDIRECT_NTH(name,proto,alias) name proto __THROW __asm__ (__ASMNAME (#alias))

#define __REDIRECT_NTHNL(name,proto,alias) name proto __THROWNL __asm__ (__ASMNAME (#alias))







#define __ASMNAME(cname) __ASMNAME2 (__USER_LABEL_PREFIX__, cname)
#define __ASMNAME2(prefix,cname) __STRING (prefix) cname
# 281 "/usr/include/x86_64-linux-gnu/sys/cdefs.h" 3 4
#define __attribute_malloc__ __attribute__ ((__malloc__))







#define __attribute_alloc_size__(params) __attribute__ ((__alloc_size__ params))
# 298 "/usr/include/x86_64-linux-gnu/sys/cdefs.h" 3 4
#define __attribute_alloc_align__(param) __attribute__ ((__alloc_align__ param))
# 308 "/usr/include/x86_64-linux-gnu/sys/cdefs.h" 3 4
#define __attribute_pure__ __attribute__ ((__pure__))






#define __attribute_const__ __attribute__ ((__const__))





#define __attribute_maybe_unused__ __attribute__ ((__unused__))
# 330 "/usr/include/x86_64-linux-gnu/sys/cdefs.h" 3 4
#define __attribute_used__ __attribute__ ((__used__))
#define __attribute_noinline__ __attribute__ ((__noinline__))







#define __attribute_deprecated__ __attribute__ ((__deprecated__))
# 349 "/usr/include/x86_64-linux-gnu/sys/cdefs.h" 3 4
#define __attribute_deprecated_msg__(msg) __attribute__ ((__deprecated__ (msg)))
# 362 "/usr/include/x86_64-linux-gnu/sys/cdefs.h" 3 4
#define __attribute_format_arg__(x) __attribute__ ((__format_arg__ (x)))
# 372 "/usr/include/x86_64-linux-gnu/sys/cdefs.h" 3 4
#define __attribute_format_strfmon__(a,b) __attribute__ ((__format__ (__strfmon__, a, b)))
# 384 "/usr/include/x86_64-linux-gnu/sys/cdefs.h" 3 4
#define __attribute_nonnull__(params) __attribute__ ((__nonnull__ params))





#define __nonnull(params) __attribute_nonnull__ (params)






#define __returns_nonnull __attribute__ ((__returns_nonnull__))
# 406 "/usr/include/x86_64-linux-gnu/sys/cdefs.h" 3 4
#define __attribute_warn_unused_result__ __attribute__ ((__warn_unused_result__))
# 415 "/usr/include/x86_64-linux-gnu/sys/cdefs.h" 3 4
#define __wur 







#undef __always_inline
#define __always_inline __inline __attribute__ ((__always_inline__))
# 433 "/usr/include/x86_64-linux-gnu/sys/cdefs.h" 3 4
#define __attribute_artificial__ __attribute__ ((__artificial__))
# 451 "/usr/include/x86_64-linux-gnu/sys/cdefs.h" 3 4
#define __extern_inline extern __inline __attribute__ ((__gnu_inline__))
#define __extern_always_inline extern __always_inline __attribute__ ((__gnu_inline__))
# 461 "/usr/include/x86_64-linux-gnu/sys/cdefs.h" 3 4
#define __fortify_function __extern_always_inline __attribute_artificial__





#define __va_arg_pack() __builtin_va_arg_pack ()
#define __va_arg_pack_len() __builtin_va_arg_pack_len ()
# 498 "/usr/include/x86_64-linux-gnu/sys/cdefs.h" 3 4
#define __restrict_arr 
# 510 "/usr/include/x86_64-linux-gnu/sys/cdefs.h" 3 4
#define __glibc_unlikely(cond) __builtin_expect ((cond), 0)
#define __glibc_likely(cond) __builtin_expect ((cond), 1)
# 532 "/usr/include/x86_64-linux-gnu/sys/cdefs.h" 3 4
#define __attribute_nonstring__ __attribute__ ((__nonstring__))





#undef __attribute_copy__



#define __attribute_copy__(arg) __attribute__ ((__copy__ (arg)))
# 559 "/usr/include/x86_64-linux-gnu/sys/cdefs.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4



#define __WORDSIZE 64







#define __WORDSIZE_TIME64_COMPAT32 1

#define __SYSCALL_WORDSIZE 64
# 560 "/usr/include/x86_64-linux-gnu/sys/cdefs.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/long-double.h" 1 3 4
# 21 "/usr/include/x86_64-linux-gnu/bits/long-double.h" 3 4
#define __LDOUBLE_REDIRECTS_TO_FLOAT128_ABI 0
# 561 "/usr/include/x86_64-linux-gnu/sys/cdefs.h" 2 3 4
# 616 "/usr/include/x86_64-linux-gnu/sys/cdefs.h" 3 4
#define __LDBL_REDIR1(name,proto,alias) name proto
#define __LDBL_REDIR(name,proto) name proto
#define __LDBL_REDIR1_NTH(name,proto,alias) name proto __THROW
#define __LDBL_REDIR_NTH(name,proto) name proto __THROW
#define __LDBL_REDIR2_DECL(name) 
#define __LDBL_REDIR_DECL(name) 

#define __REDIRECT_LDBL(name,proto,alias) __REDIRECT (name, proto, alias)
#define __REDIRECT_NTH_LDBL(name,proto,alias) __REDIRECT_NTH (name, proto, alias)
# 635 "/usr/include/x86_64-linux-gnu/sys/cdefs.h" 3 4
#define __glibc_macro_warning1(message) _Pragma (#message)
#define __glibc_macro_warning(message) __glibc_macro_warning1 (GCC warning message)
# 656 "/usr/include/x86_64-linux-gnu/sys/cdefs.h" 3 4
#define __HAVE_GENERIC_SELECTION 0
# 665 "/usr/include/x86_64-linux-gnu/sys/cdefs.h" 3 4
#define __attr_access(x) __attribute__ ((__access__ x))







#define __fortified_attr_access(a,o,s) __attr_access ((a, o, s))




#define __attr_access_none(argno) 
# 693 "/usr/include/x86_64-linux-gnu/sys/cdefs.h" 3 4
#define __attr_dealloc(dealloc,argno) 
#define __attr_dealloc_free 





#define __attribute_returns_twice__ __attribute__ ((__returns_twice__))
# 487 "/usr/include/features.h" 2 3 4
# 510 "/usr/include/features.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/gnu/stubs.h" 1 3 4
# 10 "/usr/include/x86_64-linux-gnu/gnu/stubs.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/gnu/stubs-64.h" 1 3 4
# 10 "/usr/include/x86_64-linux-gnu/gnu/stubs-64.h" 3 4
#define __stub___compat_bdflush 
#define __stub_chflags 
#define __stub_fchflags 
#define __stub_gtty 
#define __stub_revoke 
#define __stub_setlogin 
#define __stub_sigreturn 
#define __stub_stty 
# 11 "/usr/include/x86_64-linux-gnu/gnu/stubs.h" 2 3 4
# 511 "/usr/include/features.h" 2 3 4
# 40 "/usr/include/x86_64-linux-gnu/c++/10/bits/os_defines.h" 2 3





#undef _GLIBCXX_HAVE_GETS




#define _GLIBCXX_NO_OBSOLETE_ISINF_ISNAN_DYNAMIC __GLIBC_PREREQ(2,23)




#define _GLIBCXX_NATIVE_THREAD_ID pthread_self()
# 69 "/usr/include/x86_64-linux-gnu/c++/10/bits/os_defines.h" 3
#define _GLIBCXX_GTHREAD_USE_WEAK 0
# 523 "/usr/include/x86_64-linux-gnu/c++/10/bits/c++config.h" 2 3


# 1 "/usr/include/x86_64-linux-gnu/c++/10/bits/cpu_defines.h" 1 3
# 31 "/usr/include/x86_64-linux-gnu/c++/10/bits/cpu_defines.h" 3
#define _GLIBCXX_CPU_DEFINES 1
# 526 "/usr/include/x86_64-linux-gnu/c++/10/bits/c++config.h" 2 3




#define _GLIBCXX_PSEUDO_VISIBILITY(V) 






#define _GLIBCXX_WEAK_DEFINITION 







#define _GLIBCXX_USE_WEAK_REF __GXX_WEAK__
# 558 "/usr/include/x86_64-linux-gnu/c++/10/bits/c++config.h" 3
#define _GLIBCXX_TXN_SAFE 
#define _GLIBCXX_TXN_SAFE_DYN 




#define _GLIBCXX_USE_STD_SPEC_FUNCS 1
# 577 "/usr/include/x86_64-linux-gnu/c++/10/bits/c++config.h" 3
#define _GLIBCXX_FAST_MATH 0






#define __N(msgid) (msgid)


#undef min
#undef max





#define _GLIBCXX_USE_C99_MATH _GLIBCXX11_USE_C99_MATH


#define _GLIBCXX_USE_C99_COMPLEX _GLIBCXX11_USE_C99_COMPLEX


#define _GLIBCXX_USE_C99_STDIO _GLIBCXX11_USE_C99_STDIO


#define _GLIBCXX_USE_C99_STDLIB _GLIBCXX11_USE_C99_STDLIB


#define _GLIBCXX_USE_C99_WCHAR _GLIBCXX11_USE_C99_WCHAR
# 639 "/usr/include/x86_64-linux-gnu/c++/10/bits/c++config.h" 3
#define _GLIBCXX_USE_FLOAT128 1




#define _GLIBCXX_HAVE_BUILTIN_HAS_UNIQ_OBJ_REP 1
#define _GLIBCXX_HAVE_BUILTIN_IS_AGGREGATE 1
#define _GLIBCXX_HAVE_BUILTIN_LAUNDER 1
#define _GLIBCXX_BUILTIN_IS_SAME_AS(T,U) __is_same_as(T, U)

#define _GLIBCXX_HAVE_BUILTIN_IS_CONSTANT_EVALUATED 1
# 680 "/usr/include/x86_64-linux-gnu/c++/10/bits/c++config.h" 3
#define _GLIBCXX_USE_TBB_PAR_BACKEND __has_include(<tbb/tbb.h>)





#define _PSTL_PAR_BACKEND_SERIAL 


#define _PSTL_ASSERT(_Condition) __glibcxx_assert(_Condition)
#define _PSTL_ASSERT_MSG(_Condition,_Message) __glibcxx_assert(_Condition)

# 1 "/usr/include/c++/10/pstl/pstl_config.h" 1 3
# 11 "/usr/include/c++/10/pstl/pstl_config.h" 3
#define _PSTL_CONFIG_H 


#define _PSTL_VERSION 9000
#define _PSTL_VERSION_MAJOR (_PSTL_VERSION / 1000)
#define _PSTL_VERSION_MINOR ((_PSTL_VERSION % 1000) / 10)
#define _PSTL_VERSION_PATCH (_PSTL_VERSION % 10)
# 29 "/usr/include/c++/10/pstl/pstl_config.h" 3
#define _PSTL_USAGE_WARNINGS 0






#define _PSTL_PRAGMA(x) _Pragma(#x)


#define _PSTL_STRING_AUX(x) #x
#define _PSTL_STRING(x) _PSTL_STRING_AUX(x)
#define _PSTL_STRING_CONCAT(x,y) x #y



#define _PSTL_GCC_VERSION (__GNUC__ * 10000 + __GNUC_MINOR__ * 100 + __GNUC_PATCHLEVEL__)
# 54 "/usr/include/c++/10/pstl/pstl_config.h" 3
#define _PSTL_PRAGMA_SIMD _PSTL_PRAGMA(omp simd)
#define _PSTL_PRAGMA_DECLARE_SIMD _PSTL_PRAGMA(omp declare simd)
#define _PSTL_PRAGMA_SIMD_REDUCTION(PRM) _PSTL_PRAGMA(omp simd reduction(PRM))
# 70 "/usr/include/c++/10/pstl/pstl_config.h" 3
#define _PSTL_PRAGMA_FORCEINLINE 



#define _PSTL_PRAGMA_SIMD_SCAN(PRM) _PSTL_PRAGMA(omp simd reduction(inscan, PRM))
#define _PSTL_PRAGMA_SIMD_INCLUSIVE_SCAN(PRM) _PSTL_PRAGMA(omp scan inclusive(PRM))
#define _PSTL_PRAGMA_SIMD_EXCLUSIVE_SCAN(PRM) _PSTL_PRAGMA(omp scan exclusive(PRM))







#define _PSTL_CPP17_EXECUTION_POLICIES_PRESENT (_MSC_VER >= 1912)

#define _PSTL_CPP14_2RANGE_MISMATCH_EQUAL_PRESENT (_MSC_VER >= 1900 || __cplusplus >= 201300L || __cpp_lib_robust_nonmodifying_seq_ops == 201304)

#define _PSTL_CPP14_MAKE_REVERSE_ITERATOR_PRESENT (_MSC_VER >= 1900 || __cplusplus >= 201402L || __cpp_lib_make_reverse_iterator == 201402)

#define _PSTL_CPP14_INTEGER_SEQUENCE_PRESENT (_MSC_VER >= 1900 || __cplusplus >= 201402L)
#define _PSTL_CPP14_VARIABLE_TEMPLATES_PRESENT (!__INTEL_COMPILER || __INTEL_COMPILER >= 1700) && (_MSC_FULL_VER >= 190023918 || __cplusplus >= 201402L)


#define _PSTL_EARLYEXIT_PRESENT (__INTEL_COMPILER >= 1800)
#define _PSTL_MONOTONIC_PRESENT (__INTEL_COMPILER >= 1800)


#define _PSTL_UDR_PRESENT 1





#define _PSTL_UDS_PRESENT 1







#define _PSTL_PRAGMA_SIMD_EARLYEXIT 






#define _PSTL_PRAGMA_SIMD_ORDERED_MONOTONIC(PRM) 
#define _PSTL_PRAGMA_SIMD_ORDERED_MONOTONIC_2ARGS(PRM1,PRM2) 
# 130 "/usr/include/c++/10/pstl/pstl_config.h" 3
#define _PSTL_PRAGMA_DECLARE_REDUCTION(NAME,OP) _PSTL_PRAGMA(omp declare reduction(NAME:OP : omp_out(omp_in)) initializer(omp_priv = omp_orig))





#define _PSTL_PRAGMA_VECTOR_UNALIGNED 






#define _PSTL_USE_NONTEMPORAL_STORES_IF_ALLOWED 





#define _PSTL_PRAGMA_LOCATION " [Parallel STL message]: "


#define _PSTL_PRAGMA_MESSAGE_IMPL(x) _PSTL_PRAGMA(message(_PSTL_STRING_CONCAT(_PSTL_PRAGMA_LOCATION, x)))





#define _PSTL_PRAGMA_MESSAGE(x) 
#define _PSTL_PRAGMA_MESSAGE_POLICIES(x) 



#define _PSTL_CPP11_STD_ROTATE_BROKEN ((__GLIBCXX__ && __GLIBCXX__ < 20150716) || (_MSC_VER && _MSC_VER < 1800))

#define _PSTL_ICC_18_OMP_SIMD_BROKEN (__INTEL_COMPILER == 1800)
# 693 "/usr/include/x86_64-linux-gnu/c++/10/bits/c++config.h" 2 3
# 701 "/usr/include/x86_64-linux-gnu/c++/10/bits/c++config.h" 3
#define _GLIBCXX_HAVE_ACOSF 1


#define _GLIBCXX_HAVE_ACOSL 1


#define _GLIBCXX_HAVE_ALIGNED_ALLOC 1


#define _GLIBCXX_HAVE_ARPA_INET_H 1


#define _GLIBCXX_HAVE_ASINF 1


#define _GLIBCXX_HAVE_ASINL 1


#define _GLIBCXX_HAVE_AS_SYMVER_DIRECTIVE 1


#define _GLIBCXX_HAVE_ATAN2F 1


#define _GLIBCXX_HAVE_ATAN2L 1


#define _GLIBCXX_HAVE_ATANF 1


#define _GLIBCXX_HAVE_ATANL 1


#define _GLIBCXX_HAVE_ATOMIC_LOCK_POLICY 1


#define _GLIBCXX_HAVE_AT_QUICK_EXIT 1





#define _GLIBCXX_HAVE_CEILF 1


#define _GLIBCXX_HAVE_CEILL 1


#define _GLIBCXX_HAVE_COMPLEX_H 1


#define _GLIBCXX_HAVE_COSF 1


#define _GLIBCXX_HAVE_COSHF 1


#define _GLIBCXX_HAVE_COSHL 1


#define _GLIBCXX_HAVE_COSL 1


#define _GLIBCXX_HAVE_DIRENT_H 1


#define _GLIBCXX_HAVE_DLFCN_H 1


#define _GLIBCXX_HAVE_ENDIAN_H 1


#define _GLIBCXX_HAVE_EXCEPTION_PTR_SINCE_GCC46 1


#define _GLIBCXX_HAVE_EXECINFO_H 1


#define _GLIBCXX_HAVE_EXPF 1


#define _GLIBCXX_HAVE_EXPL 1


#define _GLIBCXX_HAVE_FABSF 1


#define _GLIBCXX_HAVE_FABSL 1


#define _GLIBCXX_HAVE_FCNTL_H 1


#define _GLIBCXX_HAVE_FENV_H 1


#define _GLIBCXX_HAVE_FINITE 1


#define _GLIBCXX_HAVE_FINITEF 1


#define _GLIBCXX_HAVE_FINITEL 1


#define _GLIBCXX_HAVE_FLOAT_H 1


#define _GLIBCXX_HAVE_FLOORF 1


#define _GLIBCXX_HAVE_FLOORL 1


#define _GLIBCXX_HAVE_FMODF 1


#define _GLIBCXX_HAVE_FMODL 1
# 827 "/usr/include/x86_64-linux-gnu/c++/10/bits/c++config.h" 3
#define _GLIBCXX_HAVE_FREXPF 1


#define _GLIBCXX_HAVE_FREXPL 1


#define _GLIBCXX_HAVE_GETIPINFO 1


#define _GLIBCXX_HAVE_GETS 1


#define _GLIBCXX_HAVE_HYPOT 1


#define _GLIBCXX_HAVE_HYPOTF 1


#define _GLIBCXX_HAVE_HYPOTL 1


#define _GLIBCXX_HAVE_ICONV 1





#define _GLIBCXX_HAVE_INT64_T 1


#define _GLIBCXX_HAVE_INT64_T_LONG 1





#define _GLIBCXX_HAVE_INTTYPES_H 1





#define _GLIBCXX_HAVE_ISINFF 1


#define _GLIBCXX_HAVE_ISINFL 1





#define _GLIBCXX_HAVE_ISNANF 1


#define _GLIBCXX_HAVE_ISNANL 1


#define _GLIBCXX_HAVE_ISWBLANK 1


#define _GLIBCXX_HAVE_LC_MESSAGES 1


#define _GLIBCXX_HAVE_LDEXPF 1


#define _GLIBCXX_HAVE_LDEXPL 1


#define _GLIBCXX_HAVE_LIBINTL_H 1


#define _GLIBCXX_HAVE_LIMIT_AS 1


#define _GLIBCXX_HAVE_LIMIT_DATA 1


#define _GLIBCXX_HAVE_LIMIT_FSIZE 1


#define _GLIBCXX_HAVE_LIMIT_RSS 1


#define _GLIBCXX_HAVE_LIMIT_VMEM 0


#define _GLIBCXX_HAVE_LINK 1


#define _GLIBCXX_HAVE_LINUX_FUTEX 1


#define _GLIBCXX_HAVE_LINUX_RANDOM_H 1


#define _GLIBCXX_HAVE_LINUX_TYPES_H 1


#define _GLIBCXX_HAVE_LOCALE_H 1


#define _GLIBCXX_HAVE_LOG10F 1


#define _GLIBCXX_HAVE_LOG10L 1


#define _GLIBCXX_HAVE_LOGF 1


#define _GLIBCXX_HAVE_LOGL 1
# 947 "/usr/include/x86_64-linux-gnu/c++/10/bits/c++config.h" 3
#define _GLIBCXX_HAVE_MBSTATE_T 1


#define _GLIBCXX_HAVE_MEMALIGN 1


#define _GLIBCXX_HAVE_MEMORY_H 1


#define _GLIBCXX_HAVE_MODF 1


#define _GLIBCXX_HAVE_MODFF 1


#define _GLIBCXX_HAVE_MODFL 1





#define _GLIBCXX_HAVE_NETDB_H 1


#define _GLIBCXX_HAVE_NETINET_IN_H 1


#define _GLIBCXX_HAVE_NETINET_TCP_H 1
# 983 "/usr/include/x86_64-linux-gnu/c++/10/bits/c++config.h" 3
#define _GLIBCXX_HAVE_POLL 1


#define _GLIBCXX_HAVE_POLL_H 1


#define _GLIBCXX_HAVE_POSIX_MEMALIGN 1


#define _GLIBCXX_HAVE_POWF 1


#define _GLIBCXX_HAVE_POWL 1





#define _GLIBCXX_HAVE_QUICK_EXIT 1


#define _GLIBCXX_HAVE_READLINK 1


#define _GLIBCXX_HAVE_SETENV 1


#define _GLIBCXX_HAVE_SINCOS 1


#define _GLIBCXX_HAVE_SINCOSF 1


#define _GLIBCXX_HAVE_SINCOSL 1


#define _GLIBCXX_HAVE_SINF 1


#define _GLIBCXX_HAVE_SINHF 1


#define _GLIBCXX_HAVE_SINHL 1


#define _GLIBCXX_HAVE_SINL 1





#define _GLIBCXX_HAVE_SOCKATMARK 1


#define _GLIBCXX_HAVE_SQRTF 1


#define _GLIBCXX_HAVE_SQRTL 1


#define _GLIBCXX_HAVE_STDALIGN_H 1


#define _GLIBCXX_HAVE_STDBOOL_H 1


#define _GLIBCXX_HAVE_STDINT_H 1


#define _GLIBCXX_HAVE_STDLIB_H 1


#define _GLIBCXX_HAVE_STRERROR_L 1


#define _GLIBCXX_HAVE_STRERROR_R 1


#define _GLIBCXX_HAVE_STRINGS_H 1


#define _GLIBCXX_HAVE_STRING_H 1


#define _GLIBCXX_HAVE_STRTOF 1


#define _GLIBCXX_HAVE_STRTOLD 1


#define _GLIBCXX_HAVE_STRUCT_DIRENT_D_TYPE 1


#define _GLIBCXX_HAVE_STRXFRM_L 1


#define _GLIBCXX_HAVE_SYMLINK 1



#define _GLIBCXX_HAVE_SYMVER_SYMBOL_RENAMING_RUNTIME_SUPPORT 1





#define _GLIBCXX_HAVE_SYS_IOCTL_H 1


#define _GLIBCXX_HAVE_SYS_IPC_H 1
# 1101 "/usr/include/x86_64-linux-gnu/c++/10/bits/c++config.h" 3
#define _GLIBCXX_HAVE_SYS_PARAM_H 1


#define _GLIBCXX_HAVE_SYS_RESOURCE_H 1


#define _GLIBCXX_HAVE_SYS_SDT_H 1


#define _GLIBCXX_HAVE_SYS_SEM_H 1


#define _GLIBCXX_HAVE_SYS_SOCKET_H 1


#define _GLIBCXX_HAVE_SYS_STATVFS_H 1


#define _GLIBCXX_HAVE_SYS_STAT_H 1


#define _GLIBCXX_HAVE_SYS_SYSINFO_H 1


#define _GLIBCXX_HAVE_SYS_TIME_H 1


#define _GLIBCXX_HAVE_SYS_TYPES_H 1


#define _GLIBCXX_HAVE_SYS_UIO_H 1





#define _GLIBCXX_HAVE_S_ISREG 1


#define _GLIBCXX_HAVE_TANF 1


#define _GLIBCXX_HAVE_TANHF 1


#define _GLIBCXX_HAVE_TANHL 1


#define _GLIBCXX_HAVE_TANL 1


#define _GLIBCXX_HAVE_TGMATH_H 1


#define _GLIBCXX_HAVE_TIMESPEC_GET 1


#define _GLIBCXX_HAVE_TLS 1


#define _GLIBCXX_HAVE_TRUNCATE 1


#define _GLIBCXX_HAVE_UCHAR_H 1


#define _GLIBCXX_HAVE_UNISTD_H 1





#define _GLIBCXX_HAVE_UTIME_H 1


#define _GLIBCXX_HAVE_VFWSCANF 1


#define _GLIBCXX_HAVE_VSWSCANF 1


#define _GLIBCXX_HAVE_VWSCANF 1


#define _GLIBCXX_HAVE_WCHAR_H 1


#define _GLIBCXX_HAVE_WCSTOF 1


#define _GLIBCXX_HAVE_WCTYPE_H 1





#define _GLIBCXX_HAVE_WRITEV 1
# 1395 "/usr/include/x86_64-linux-gnu/c++/10/bits/c++config.h" 3
#define _GLIBCXX_HAVE___CXA_THREAD_ATEXIT_IMPL 1


#define _GLIBCXX_ICONV_CONST 



#define _GLIBCXX_LT_OBJDIR ".libs/"





#define _GLIBCXX_PACKAGE_BUGREPORT ""


#define _GLIBCXX_PACKAGE_NAME "package-unused"


#define _GLIBCXX_PACKAGE_STRING "package-unused version-unused"


#define _GLIBCXX_PACKAGE_TARNAME "libstdc++"


#define _GLIBCXX_PACKAGE_URL ""


#define _GLIBCXX_PACKAGE__GLIBCXX_VERSION "version-unused"
# 1441 "/usr/include/x86_64-linux-gnu/c++/10/bits/c++config.h" 3
#define _GLIBCXX_STDC_HEADERS 1






#define _GLIBCXX_DARWIN_USE_64_BIT_INODE 1
# 1457 "/usr/include/x86_64-linux-gnu/c++/10/bits/c++config.h" 3
#define _GLIBCXX11_USE_C99_COMPLEX 1



#define _GLIBCXX11_USE_C99_MATH 1



#define _GLIBCXX11_USE_C99_STDIO 1



#define _GLIBCXX11_USE_C99_STDLIB 1



#define _GLIBCXX11_USE_C99_WCHAR 1




#define _GLIBCXX98_USE_C99_COMPLEX 1



#define _GLIBCXX98_USE_C99_MATH 1



#define _GLIBCXX98_USE_C99_STDIO 1



#define _GLIBCXX98_USE_C99_STDLIB 1



#define _GLIBCXX98_USE_C99_WCHAR 1


#define _GLIBCXX_ATOMIC_BUILTINS 1






#define _GLIBCXX_FULLY_DYNAMIC_STRING 0


#define _GLIBCXX_HAS_GTHREADS 1


#define _GLIBCXX_HOSTED 1




#define _GLIBCXX_MANGLE_SIZE_T m
# 1524 "/usr/include/x86_64-linux-gnu/c++/10/bits/c++config.h" 3
#define _GLIBCXX_RES_LIMITS 1





#define _GLIBCXX_STDIO_EOF -1


#define _GLIBCXX_STDIO_SEEK_CUR 1


#define _GLIBCXX_STDIO_SEEK_END 2


#define _GLIBCXX_SYMVER 1





#define _GLIBCXX_SYMVER_GNU 1
# 1555 "/usr/include/x86_64-linux-gnu/c++/10/bits/c++config.h" 3
#define _GLIBCXX_USE_C11_UCHAR_CXX11 1



#define _GLIBCXX_USE_C99 1




#define _GLIBCXX_USE_C99_COMPLEX_TR1 1



#define _GLIBCXX_USE_C99_CTYPE_TR1 1



#define _GLIBCXX_USE_C99_FENV_TR1 1



#define _GLIBCXX_USE_C99_INTTYPES_TR1 1



#define _GLIBCXX_USE_C99_INTTYPES_WCHAR_T_TR1 1



#define _GLIBCXX_USE_C99_MATH_TR1 1



#define _GLIBCXX_USE_C99_STDINT_TR1 1






#define _GLIBCXX_USE_CLOCK_MONOTONIC 1


#define _GLIBCXX_USE_CLOCK_REALTIME 1



#define _GLIBCXX_USE_DECIMAL_FLOAT 1



#define _GLIBCXX_USE_DEV_RANDOM 1


#define _GLIBCXX_USE_FCHMOD 1


#define _GLIBCXX_USE_FCHMODAT 1


#define _GLIBCXX_USE_GETTIMEOFDAY 1


#define _GLIBCXX_USE_GET_NPROCS 1


#define _GLIBCXX_USE_INT128 1


#define _GLIBCXX_USE_LFS 1


#define _GLIBCXX_USE_LONG_LONG 1


#define _GLIBCXX_USE_LSTAT 1


#define _GLIBCXX_USE_NANOSLEEP 1


#define _GLIBCXX_USE_NLS 1





#define _GLIBCXX_USE_PTHREAD_COND_CLOCKWAIT 1


#define _GLIBCXX_USE_PTHREAD_MUTEX_CLOCKLOCK 1



#define _GLIBCXX_USE_PTHREAD_RWLOCK_CLOCKLOCK 1


#define _GLIBCXX_USE_PTHREAD_RWLOCK_T 1



#define _GLIBCXX_USE_RANDOM_TR1 1


#define _GLIBCXX_USE_REALPATH 1


#define _GLIBCXX_USE_SCHED_YIELD 1


#define _GLIBCXX_USE_SC_NPROCESSORS_ONLN 1





#define _GLIBCXX_USE_SENDFILE 1


#define _GLIBCXX_USE_ST_MTIM 1





#define _GLIBCXX_USE_TMPNAM 1


#define _GLIBCXX_USE_UTIME 1



#define _GLIBCXX_USE_UTIMENSAT 1


#define _GLIBCXX_USE_WCHAR_T 1


#define _GLIBCXX_VERBOSE 1


#define _GLIBCXX_X86_RDRAND 1


#define _GLIBCXX_X86_RDSEED 1


#define _GTHREAD_USE_MUTEX_TIMEDLOCK 1
# 42 "/usr/include/c++/10/cstdio" 2 3
# 1 "/usr/include/stdio.h" 1 3 4
# 24 "/usr/include/stdio.h" 3 4
#define _STDIO_H 1

#define __GLIBC_INTERNAL_STARTING_HEADER_IMPLEMENTATION 
# 1 "/usr/include/x86_64-linux-gnu/bits/libc-header-start.h" 1 3 4
# 31 "/usr/include/x86_64-linux-gnu/bits/libc-header-start.h" 3 4
#undef __GLIBC_INTERNAL_STARTING_HEADER_IMPLEMENTATION





#undef __GLIBC_USE_LIB_EXT2


#define __GLIBC_USE_LIB_EXT2 1
# 67 "/usr/include/x86_64-linux-gnu/bits/libc-header-start.h" 3 4
#undef __GLIBC_USE_IEC_60559_BFP_EXT

#define __GLIBC_USE_IEC_60559_BFP_EXT 1



#undef __GLIBC_USE_IEC_60559_BFP_EXT_C2X

#define __GLIBC_USE_IEC_60559_BFP_EXT_C2X 1



#undef __GLIBC_USE_IEC_60559_EXT

#define __GLIBC_USE_IEC_60559_EXT 1
# 90 "/usr/include/x86_64-linux-gnu/bits/libc-header-start.h" 3 4
#undef __GLIBC_USE_IEC_60559_FUNCS_EXT

#define __GLIBC_USE_IEC_60559_FUNCS_EXT 1



#undef __GLIBC_USE_IEC_60559_FUNCS_EXT_C2X

#define __GLIBC_USE_IEC_60559_FUNCS_EXT_C2X 1






#undef __GLIBC_USE_IEC_60559_TYPES_EXT

#define __GLIBC_USE_IEC_60559_TYPES_EXT 1
# 28 "/usr/include/stdio.h" 2 3 4

extern "C" {

#define __need_size_t 
#define __need_NULL 
# 1 "/usr/lib/gcc/x86_64-linux-gnu/10/include/stddef.h" 1 3 4
# 181 "/usr/lib/gcc/x86_64-linux-gnu/10/include/stddef.h" 3 4
#define __size_t__ 
#define __SIZE_T__ 
#define _SIZE_T 
#define _SYS_SIZE_T_H 
#define _T_SIZE_ 
#define _T_SIZE 
#define __SIZE_T 
#define _SIZE_T_ 
#define _BSD_SIZE_T_ 
#define _SIZE_T_DEFINED_ 
#define _SIZE_T_DEFINED 
#define _BSD_SIZE_T_DEFINED_ 
#define _SIZE_T_DECLARED 
#define ___int_size_t_h 
#define _GCC_SIZE_T 
#define _SIZET_ 






#define __size_t 





typedef long unsigned int size_t;
# 231 "/usr/lib/gcc/x86_64-linux-gnu/10/include/stddef.h" 3 4
#undef __need_size_t
# 390 "/usr/lib/gcc/x86_64-linux-gnu/10/include/stddef.h" 3 4
#undef NULL

#define NULL __null
# 401 "/usr/lib/gcc/x86_64-linux-gnu/10/include/stddef.h" 3 4
#undef __need_NULL
# 34 "/usr/include/stdio.h" 2 3 4

#define __need___va_list 
# 1 "/usr/lib/gcc/x86_64-linux-gnu/10/include/stdarg.h" 1 3 4
# 34 "/usr/lib/gcc/x86_64-linux-gnu/10/include/stdarg.h" 3 4
#undef __need___va_list




#define __GNUC_VA_LIST 
typedef __builtin_va_list __gnuc_va_list;
# 37 "/usr/include/stdio.h" 2 3 4

# 1 "/usr/include/x86_64-linux-gnu/bits/types.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/types.h" 3 4
#define _BITS_TYPES_H 1


# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4



#define __WORDSIZE 64







#define __WORDSIZE_TIME64_COMPAT32 1

#define __SYSCALL_WORDSIZE 64
# 28 "/usr/include/x86_64-linux-gnu/bits/types.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/timesize.h" 1 3 4
# 19 "/usr/include/x86_64-linux-gnu/bits/timesize.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4



#define __WORDSIZE 64







#define __WORDSIZE_TIME64_COMPAT32 1

#define __SYSCALL_WORDSIZE 64
# 20 "/usr/include/x86_64-linux-gnu/bits/timesize.h" 2 3 4






#define __TIMESIZE __WORDSIZE
# 29 "/usr/include/x86_64-linux-gnu/bits/types.h" 2 3 4


typedef unsigned char __u_char;
typedef unsigned short int __u_short;
typedef unsigned int __u_int;
typedef unsigned long int __u_long;


typedef signed char __int8_t;
typedef unsigned char __uint8_t;
typedef signed short int __int16_t;
typedef unsigned short int __uint16_t;
typedef signed int __int32_t;
typedef unsigned int __uint32_t;

typedef signed long int __int64_t;
typedef unsigned long int __uint64_t;






typedef __int8_t __int_least8_t;
typedef __uint8_t __uint_least8_t;
typedef __int16_t __int_least16_t;
typedef __uint16_t __uint_least16_t;
typedef __int32_t __int_least32_t;
typedef __uint32_t __uint_least32_t;
typedef __int64_t __int_least64_t;
typedef __uint64_t __uint_least64_t;



typedef long int __quad_t;
typedef unsigned long int __u_quad_t;







typedef long int __intmax_t;
typedef unsigned long int __uintmax_t;
# 109 "/usr/include/x86_64-linux-gnu/bits/types.h" 3 4
#define __S16_TYPE short int
#define __U16_TYPE unsigned short int
#define __S32_TYPE int
#define __U32_TYPE unsigned int
#define __SLONGWORD_TYPE long int
#define __ULONGWORD_TYPE unsigned long int
# 128 "/usr/include/x86_64-linux-gnu/bits/types.h" 3 4
#define __SQUAD_TYPE long int
#define __UQUAD_TYPE unsigned long int
#define __SWORD_TYPE long int
#define __UWORD_TYPE unsigned long int
#define __SLONG32_TYPE int
#define __ULONG32_TYPE unsigned int
#define __S64_TYPE long int
#define __U64_TYPE unsigned long int

#define __STD_TYPE typedef



# 1 "/usr/include/x86_64-linux-gnu/bits/typesizes.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/typesizes.h" 3 4
#define _BITS_TYPESIZES_H 1
# 34 "/usr/include/x86_64-linux-gnu/bits/typesizes.h" 3 4
#define __SYSCALL_SLONG_TYPE __SLONGWORD_TYPE
#define __SYSCALL_ULONG_TYPE __ULONGWORD_TYPE


#define __DEV_T_TYPE __UQUAD_TYPE
#define __UID_T_TYPE __U32_TYPE
#define __GID_T_TYPE __U32_TYPE
#define __INO_T_TYPE __SYSCALL_ULONG_TYPE
#define __INO64_T_TYPE __UQUAD_TYPE
#define __MODE_T_TYPE __U32_TYPE

#define __NLINK_T_TYPE __SYSCALL_ULONG_TYPE
#define __FSWORD_T_TYPE __SYSCALL_SLONG_TYPE




#define __OFF_T_TYPE __SYSCALL_SLONG_TYPE
#define __OFF64_T_TYPE __SQUAD_TYPE
#define __PID_T_TYPE __S32_TYPE
#define __RLIM_T_TYPE __SYSCALL_ULONG_TYPE
#define __RLIM64_T_TYPE __UQUAD_TYPE
#define __BLKCNT_T_TYPE __SYSCALL_SLONG_TYPE
#define __BLKCNT64_T_TYPE __SQUAD_TYPE
#define __FSBLKCNT_T_TYPE __SYSCALL_ULONG_TYPE
#define __FSBLKCNT64_T_TYPE __UQUAD_TYPE
#define __FSFILCNT_T_TYPE __SYSCALL_ULONG_TYPE
#define __FSFILCNT64_T_TYPE __UQUAD_TYPE
#define __ID_T_TYPE __U32_TYPE
#define __CLOCK_T_TYPE __SYSCALL_SLONG_TYPE
#define __TIME_T_TYPE __SYSCALL_SLONG_TYPE
#define __USECONDS_T_TYPE __U32_TYPE
#define __SUSECONDS_T_TYPE __SYSCALL_SLONG_TYPE
#define __SUSECONDS64_T_TYPE __SQUAD_TYPE
#define __DADDR_T_TYPE __S32_TYPE
#define __KEY_T_TYPE __S32_TYPE
#define __CLOCKID_T_TYPE __S32_TYPE
#define __TIMER_T_TYPE void *
#define __BLKSIZE_T_TYPE __SYSCALL_SLONG_TYPE
#define __FSID_T_TYPE struct { int __val[2]; }
#define __SSIZE_T_TYPE __SWORD_TYPE
#define __CPU_MASK_TYPE __SYSCALL_ULONG_TYPE





#define __OFF_T_MATCHES_OFF64_T 1


#define __INO_T_MATCHES_INO64_T 1


#define __RLIM_T_MATCHES_RLIM64_T 1


#define __STATFS_MATCHES_STATFS64 1


#define __KERNEL_OLD_TIMEVAL_MATCHES_TIMEVAL64 1
# 103 "/usr/include/x86_64-linux-gnu/bits/typesizes.h" 3 4
#define __FD_SETSIZE 1024
# 142 "/usr/include/x86_64-linux-gnu/bits/types.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/time64.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/time64.h" 3 4
#define _BITS_TIME64_H 1





#define __TIME64_T_TYPE __TIME_T_TYPE
# 143 "/usr/include/x86_64-linux-gnu/bits/types.h" 2 3 4


typedef unsigned long int __dev_t;
typedef unsigned int __uid_t;
typedef unsigned int __gid_t;
typedef unsigned long int __ino_t;
typedef unsigned long int __ino64_t;
typedef unsigned int __mode_t;
typedef unsigned long int __nlink_t;
typedef long int __off_t;
typedef long int __off64_t;
typedef int __pid_t;
typedef struct { int __val[2]; } __fsid_t;
typedef long int __clock_t;
typedef unsigned long int __rlim_t;
typedef unsigned long int __rlim64_t;
typedef unsigned int __id_t;
typedef long int __time_t;
typedef unsigned int __useconds_t;
typedef long int __suseconds_t;
typedef long int __suseconds64_t;

typedef int __daddr_t;
typedef int __key_t;


typedef int __clockid_t;


typedef void * __timer_t;


typedef long int __blksize_t;




typedef long int __blkcnt_t;
typedef long int __blkcnt64_t;


typedef unsigned long int __fsblkcnt_t;
typedef unsigned long int __fsblkcnt64_t;


typedef unsigned long int __fsfilcnt_t;
typedef unsigned long int __fsfilcnt64_t;


typedef long int __fsword_t;

typedef long int __ssize_t;


typedef long int __syscall_slong_t;

typedef unsigned long int __syscall_ulong_t;



typedef __off64_t __loff_t;
typedef char *__caddr_t;


typedef long int __intptr_t;


typedef unsigned int __socklen_t;




typedef int __sig_atomic_t;
# 226 "/usr/include/x86_64-linux-gnu/bits/types.h" 3 4
#undef __STD_TYPE
# 39 "/usr/include/stdio.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/__fpos_t.h" 1 3 4

#define _____fpos_t_defined 1


# 1 "/usr/include/x86_64-linux-gnu/bits/types/__mbstate_t.h" 1 3 4

#define ____mbstate_t_defined 1
# 13 "/usr/include/x86_64-linux-gnu/bits/types/__mbstate_t.h" 3 4
typedef struct
{
  int __count;
  union
  {
    unsigned int __wch;
    char __wchb[4];
  } __value;
} __mbstate_t;
# 6 "/usr/include/x86_64-linux-gnu/bits/types/__fpos_t.h" 2 3 4




typedef struct _G_fpos_t
{
  __off_t __pos;
  __mbstate_t __state;
} __fpos_t;
# 40 "/usr/include/stdio.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/__fpos64_t.h" 1 3 4

#define _____fpos64_t_defined 1







typedef struct _G_fpos64_t
{
  __off64_t __pos;
  __mbstate_t __state;
} __fpos64_t;
# 41 "/usr/include/stdio.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/__FILE.h" 1 3 4

#define ____FILE_defined 1

struct _IO_FILE;
typedef struct _IO_FILE __FILE;
# 42 "/usr/include/stdio.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/FILE.h" 1 3 4

#define __FILE_defined 1

struct _IO_FILE;


typedef struct _IO_FILE FILE;
# 43 "/usr/include/stdio.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/struct_FILE.h" 1 3 4
# 19 "/usr/include/x86_64-linux-gnu/bits/types/struct_FILE.h" 3 4
#define __struct_FILE_defined 1
# 35 "/usr/include/x86_64-linux-gnu/bits/types/struct_FILE.h" 3 4
struct _IO_FILE;
struct _IO_marker;
struct _IO_codecvt;
struct _IO_wide_data;




typedef void _IO_lock_t;





struct _IO_FILE
{
  int _flags;


  char *_IO_read_ptr;
  char *_IO_read_end;
  char *_IO_read_base;
  char *_IO_write_base;
  char *_IO_write_ptr;
  char *_IO_write_end;
  char *_IO_buf_base;
  char *_IO_buf_end;


  char *_IO_save_base;
  char *_IO_backup_base;
  char *_IO_save_end;

  struct _IO_marker *_markers;

  struct _IO_FILE *_chain;

  int _fileno;
  int _flags2;
  __off_t _old_offset;


  unsigned short _cur_column;
  signed char _vtable_offset;
  char _shortbuf[1];

  _IO_lock_t *_lock;







  __off64_t _offset;

  struct _IO_codecvt *_codecvt;
  struct _IO_wide_data *_wide_data;
  struct _IO_FILE *_freeres_list;
  void *_freeres_buf;
  size_t __pad5;
  int _mode;

  char _unused2[15 * sizeof (int) - 4 * sizeof (void *) - sizeof (size_t)];
};


#define __getc_unlocked_body(_fp) (__glibc_unlikely ((_fp)->_IO_read_ptr >= (_fp)->_IO_read_end) ? __uflow (_fp) : *(unsigned char *) (_fp)->_IO_read_ptr++)



#define __putc_unlocked_body(_ch,_fp) (__glibc_unlikely ((_fp)->_IO_write_ptr >= (_fp)->_IO_write_end) ? __overflow (_fp, (unsigned char) (_ch)) : (unsigned char) (*(_fp)->_IO_write_ptr++ = (_ch)))




#define _IO_EOF_SEEN 0x0010
#define __feof_unlocked_body(_fp) (((_fp)->_flags & _IO_EOF_SEEN) != 0)

#define _IO_ERR_SEEN 0x0020
#define __ferror_unlocked_body(_fp) (((_fp)->_flags & _IO_ERR_SEEN) != 0)

#define _IO_USER_LOCK 0x8000
# 44 "/usr/include/stdio.h" 2 3 4


# 1 "/usr/include/x86_64-linux-gnu/bits/types/cookie_io_functions_t.h" 1 3 4
# 19 "/usr/include/x86_64-linux-gnu/bits/types/cookie_io_functions_t.h" 3 4
#define __cookie_io_functions_t_defined 1







typedef __ssize_t cookie_read_function_t (void *__cookie, char *__buf,
                                          size_t __nbytes);







typedef __ssize_t cookie_write_function_t (void *__cookie, const char *__buf,
                                           size_t __nbytes);







typedef int cookie_seek_function_t (void *__cookie, __off64_t *__pos, int __w);


typedef int cookie_close_function_t (void *__cookie);






typedef struct _IO_cookie_io_functions_t
{
  cookie_read_function_t *read;
  cookie_write_function_t *write;
  cookie_seek_function_t *seek;
  cookie_close_function_t *close;
} cookie_io_functions_t;
# 47 "/usr/include/stdio.h" 2 3 4





typedef __gnuc_va_list va_list;
#define _VA_LIST_DEFINED 
# 63 "/usr/include/stdio.h" 3 4
typedef __off_t off_t;



#define __off_t_defined 


typedef __off64_t off64_t;
#define __off64_t_defined 





typedef __ssize_t ssize_t;
#define __ssize_t_defined 





typedef __fpos_t fpos_t;




typedef __fpos64_t fpos64_t;



#define _IOFBF 0
#define _IOLBF 1
#define _IONBF 2



#define BUFSIZ 8192




#define EOF (-1)




#define SEEK_SET 0
#define SEEK_CUR 1
#define SEEK_END 2

#define SEEK_DATA 3
#define SEEK_HOLE 4





#define P_tmpdir "/tmp"
# 133 "/usr/include/stdio.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/stdio_lim.h" 1 3 4
# 19 "/usr/include/x86_64-linux-gnu/bits/stdio_lim.h" 3 4
#define _BITS_STDIO_LIM_H 1





#define L_tmpnam 20
#define TMP_MAX 238328
#define FILENAME_MAX 4096


#define L_ctermid 9

#define L_cuserid 9



#undef FOPEN_MAX
#define FOPEN_MAX 16
# 134 "/usr/include/stdio.h" 2 3 4




#define _PRINTF_NAN_LEN_MAX 4




extern FILE *stdin;
extern FILE *stdout;
extern FILE *stderr;

#define stdin stdin
#define stdout stdout
#define stderr stderr


extern int remove (const char *__filename) noexcept (true);

extern int rename (const char *__old, const char *__new) noexcept (true);



extern int renameat (int __oldfd, const char *__old, int __newfd,
       const char *__new) noexcept (true);




#define RENAME_NOREPLACE (1 << 0)
#define RENAME_EXCHANGE (1 << 1)
#define RENAME_WHITEOUT (1 << 2)



extern int renameat2 (int __oldfd, const char *__old, int __newfd,
        const char *__new, unsigned int __flags) noexcept (true);






extern int fclose (FILE *__stream);

#undef __attr_dealloc_fclose
#define __attr_dealloc_fclose __attr_dealloc (fclose, 1)






extern FILE *tmpfile (void)
  __attribute__ ((__malloc__)) ;
# 200 "/usr/include/stdio.h" 3 4
extern FILE *tmpfile64 (void)
   __attribute__ ((__malloc__)) ;



extern char *tmpnam (char[20]) noexcept (true) ;




extern char *tmpnam_r (char __s[20]) noexcept (true) ;
# 222 "/usr/include/stdio.h" 3 4
extern char *tempnam (const char *__dir, const char *__pfx)
   noexcept (true) __attribute__ ((__malloc__)) ;






extern int fflush (FILE *__stream);
# 239 "/usr/include/stdio.h" 3 4
extern int fflush_unlocked (FILE *__stream);
# 249 "/usr/include/stdio.h" 3 4
extern int fcloseall (void);
# 258 "/usr/include/stdio.h" 3 4
extern FILE *fopen (const char *__restrict __filename,
      const char *__restrict __modes)
  __attribute__ ((__malloc__)) ;




extern FILE *freopen (const char *__restrict __filename,
        const char *__restrict __modes,
        FILE *__restrict __stream) ;
# 283 "/usr/include/stdio.h" 3 4
extern FILE *fopen64 (const char *__restrict __filename,
        const char *__restrict __modes)
  __attribute__ ((__malloc__)) ;
extern FILE *freopen64 (const char *__restrict __filename,
   const char *__restrict __modes,
   FILE *__restrict __stream) ;




extern FILE *fdopen (int __fd, const char *__modes) noexcept (true)
  __attribute__ ((__malloc__)) ;





extern FILE *fopencookie (void *__restrict __magic_cookie,
     const char *__restrict __modes,
     cookie_io_functions_t __io_funcs) noexcept (true)
  __attribute__ ((__malloc__)) ;




extern FILE *fmemopen (void *__s, size_t __len, const char *__modes)
  noexcept (true) __attribute__ ((__malloc__)) ;




extern FILE *open_memstream (char **__bufloc, size_t *__sizeloc) noexcept (true)
  __attribute__ ((__malloc__)) ;
# 328 "/usr/include/stdio.h" 3 4
extern void setbuf (FILE *__restrict __stream, char *__restrict __buf) noexcept (true);



extern int setvbuf (FILE *__restrict __stream, char *__restrict __buf,
      int __modes, size_t __n) noexcept (true);




extern void setbuffer (FILE *__restrict __stream, char *__restrict __buf,
         size_t __size) noexcept (true);


extern void setlinebuf (FILE *__stream) noexcept (true);







extern int fprintf (FILE *__restrict __stream,
      const char *__restrict __format, ...);




extern int printf (const char *__restrict __format, ...);

extern int sprintf (char *__restrict __s,
      const char *__restrict __format, ...) noexcept (true);





extern int vfprintf (FILE *__restrict __s, const char *__restrict __format,
       __gnuc_va_list __arg);




extern int vprintf (const char *__restrict __format, __gnuc_va_list __arg);

extern int vsprintf (char *__restrict __s, const char *__restrict __format,
       __gnuc_va_list __arg) noexcept (true);



extern int snprintf (char *__restrict __s, size_t __maxlen,
       const char *__restrict __format, ...)
     noexcept (true) __attribute__ ((__format__ (__printf__, 3, 4)));

extern int vsnprintf (char *__restrict __s, size_t __maxlen,
        const char *__restrict __format, __gnuc_va_list __arg)
     noexcept (true) __attribute__ ((__format__ (__printf__, 3, 0)));





extern int vasprintf (char **__restrict __ptr, const char *__restrict __f,
        __gnuc_va_list __arg)
     noexcept (true) __attribute__ ((__format__ (__printf__, 2, 0))) ;
extern int __asprintf (char **__restrict __ptr,
         const char *__restrict __fmt, ...)
     noexcept (true) __attribute__ ((__format__ (__printf__, 2, 3))) ;
extern int asprintf (char **__restrict __ptr,
       const char *__restrict __fmt, ...)
     noexcept (true) __attribute__ ((__format__ (__printf__, 2, 3))) ;




extern int vdprintf (int __fd, const char *__restrict __fmt,
       __gnuc_va_list __arg)
     __attribute__ ((__format__ (__printf__, 2, 0)));
extern int dprintf (int __fd, const char *__restrict __fmt, ...)
     __attribute__ ((__format__ (__printf__, 2, 3)));







extern int fscanf (FILE *__restrict __stream,
     const char *__restrict __format, ...) ;




extern int scanf (const char *__restrict __format, ...) ;

extern int sscanf (const char *__restrict __s,
     const char *__restrict __format, ...) noexcept (true);





# 1 "/usr/include/x86_64-linux-gnu/bits/floatn.h" 1 3 4
# 20 "/usr/include/x86_64-linux-gnu/bits/floatn.h" 3 4
#define _BITS_FLOATN_H 
# 32 "/usr/include/x86_64-linux-gnu/bits/floatn.h" 3 4
#define __HAVE_FLOAT128 1







#define __HAVE_DISTINCT_FLOAT128 1







#define __HAVE_FLOAT64X 1





#define __HAVE_FLOAT64X_LONG_DOUBLE 1
# 63 "/usr/include/x86_64-linux-gnu/bits/floatn.h" 3 4
#define __f128(x) x ##q
# 74 "/usr/include/x86_64-linux-gnu/bits/floatn.h" 3 4
typedef _Complex float __cfloat128 __attribute__ ((__mode__ (__TC__)));
#define __CFLOAT128 __cfloat128
# 86 "/usr/include/x86_64-linux-gnu/bits/floatn.h" 3 4
typedef __float128 _Float128;
# 119 "/usr/include/x86_64-linux-gnu/bits/floatn.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/floatn-common.h" 1 3 4
# 21 "/usr/include/x86_64-linux-gnu/bits/floatn-common.h" 3 4
#define _BITS_FLOATN_COMMON_H 


# 1 "/usr/include/x86_64-linux-gnu/bits/long-double.h" 1 3 4
# 21 "/usr/include/x86_64-linux-gnu/bits/long-double.h" 3 4
#define __LDOUBLE_REDIRECTS_TO_FLOAT128_ABI 0
# 25 "/usr/include/x86_64-linux-gnu/bits/floatn-common.h" 2 3 4
# 34 "/usr/include/x86_64-linux-gnu/bits/floatn-common.h" 3 4
#define __HAVE_FLOAT16 0
#define __HAVE_FLOAT32 1
#define __HAVE_FLOAT64 1
#define __HAVE_FLOAT32X 1
#define __HAVE_FLOAT128X 0
# 52 "/usr/include/x86_64-linux-gnu/bits/floatn-common.h" 3 4
#define __HAVE_DISTINCT_FLOAT16 __HAVE_FLOAT16
#define __HAVE_DISTINCT_FLOAT32 0
#define __HAVE_DISTINCT_FLOAT64 0
#define __HAVE_DISTINCT_FLOAT32X 0
#define __HAVE_DISTINCT_FLOAT64X 0
#define __HAVE_DISTINCT_FLOAT128X __HAVE_FLOAT128X





#define __HAVE_FLOAT128_UNLIKE_LDBL (__HAVE_DISTINCT_FLOAT128 && __LDBL_MANT_DIG__ != 113)
# 72 "/usr/include/x86_64-linux-gnu/bits/floatn-common.h" 3 4
#define __HAVE_FLOATN_NOT_TYPEDEF 0
# 91 "/usr/include/x86_64-linux-gnu/bits/floatn-common.h" 3 4
#define __f32(x) x ##f
# 102 "/usr/include/x86_64-linux-gnu/bits/floatn-common.h" 3 4
#define __f64(x) x
# 111 "/usr/include/x86_64-linux-gnu/bits/floatn-common.h" 3 4
#define __f32x(x) x
# 120 "/usr/include/x86_64-linux-gnu/bits/floatn-common.h" 3 4
#define __f64x(x) x ##l
# 149 "/usr/include/x86_64-linux-gnu/bits/floatn-common.h" 3 4
#define __CFLOAT32 _Complex float
# 160 "/usr/include/x86_64-linux-gnu/bits/floatn-common.h" 3 4
#define __CFLOAT64 _Complex double
# 169 "/usr/include/x86_64-linux-gnu/bits/floatn-common.h" 3 4
#define __CFLOAT32X _Complex double
# 178 "/usr/include/x86_64-linux-gnu/bits/floatn-common.h" 3 4
#define __CFLOAT64X _Complex long double
# 214 "/usr/include/x86_64-linux-gnu/bits/floatn-common.h" 3 4
typedef float _Float32;
# 251 "/usr/include/x86_64-linux-gnu/bits/floatn-common.h" 3 4
typedef double _Float64;
# 268 "/usr/include/x86_64-linux-gnu/bits/floatn-common.h" 3 4
typedef double _Float32x;
# 285 "/usr/include/x86_64-linux-gnu/bits/floatn-common.h" 3 4
typedef long double _Float64x;
# 120 "/usr/include/x86_64-linux-gnu/bits/floatn.h" 2 3 4
# 431 "/usr/include/stdio.h" 2 3 4



extern int fscanf (FILE *__restrict __stream, const char *__restrict __format, ...) __asm__ ("" "__isoc99_fscanf")

                               ;
extern int scanf (const char *__restrict __format, ...) __asm__ ("" "__isoc99_scanf")
                              ;
extern int sscanf (const char *__restrict __s, const char *__restrict __format, ...) noexcept (true) __asm__ ("" "__isoc99_sscanf")

                      ;
# 459 "/usr/include/stdio.h" 3 4
extern int vfscanf (FILE *__restrict __s, const char *__restrict __format,
      __gnuc_va_list __arg)
     __attribute__ ((__format__ (__scanf__, 2, 0))) ;





extern int vscanf (const char *__restrict __format, __gnuc_va_list __arg)
     __attribute__ ((__format__ (__scanf__, 1, 0))) ;


extern int vsscanf (const char *__restrict __s,
      const char *__restrict __format, __gnuc_va_list __arg)
     noexcept (true) __attribute__ ((__format__ (__scanf__, 2, 0)));





extern int vfscanf (FILE *__restrict __s, const char *__restrict __format, __gnuc_va_list __arg) __asm__ ("" "__isoc99_vfscanf")



     __attribute__ ((__format__ (__scanf__, 2, 0))) ;
extern int vscanf (const char *__restrict __format, __gnuc_va_list __arg) __asm__ ("" "__isoc99_vscanf")

     __attribute__ ((__format__ (__scanf__, 1, 0))) ;
extern int vsscanf (const char *__restrict __s, const char *__restrict __format, __gnuc_va_list __arg) noexcept (true) __asm__ ("" "__isoc99_vsscanf")



     __attribute__ ((__format__ (__scanf__, 2, 0)));
# 513 "/usr/include/stdio.h" 3 4
extern int fgetc (FILE *__stream);
extern int getc (FILE *__stream);





extern int getchar (void);






extern int getc_unlocked (FILE *__stream);
extern int getchar_unlocked (void);
# 538 "/usr/include/stdio.h" 3 4
extern int fgetc_unlocked (FILE *__stream);
# 549 "/usr/include/stdio.h" 3 4
extern int fputc (int __c, FILE *__stream);
extern int putc (int __c, FILE *__stream);





extern int putchar (int __c);
# 565 "/usr/include/stdio.h" 3 4
extern int fputc_unlocked (int __c, FILE *__stream);







extern int putc_unlocked (int __c, FILE *__stream);
extern int putchar_unlocked (int __c);






extern int getw (FILE *__stream);


extern int putw (int __w, FILE *__stream);







extern char *fgets (char *__restrict __s, int __n, FILE *__restrict __stream)
     __attribute__ ((__access__ (__write_only__, 1, 2)));
# 615 "/usr/include/stdio.h" 3 4
extern char *fgets_unlocked (char *__restrict __s, int __n,
        FILE *__restrict __stream)
    __attribute__ ((__access__ (__write_only__, 1, 2)));
# 632 "/usr/include/stdio.h" 3 4
extern __ssize_t __getdelim (char **__restrict __lineptr,
                             size_t *__restrict __n, int __delimiter,
                             FILE *__restrict __stream) ;
extern __ssize_t getdelim (char **__restrict __lineptr,
                           size_t *__restrict __n, int __delimiter,
                           FILE *__restrict __stream) ;







extern __ssize_t getline (char **__restrict __lineptr,
                          size_t *__restrict __n,
                          FILE *__restrict __stream) ;







extern int fputs (const char *__restrict __s, FILE *__restrict __stream);





extern int puts (const char *__s);






extern int ungetc (int __c, FILE *__stream);






extern size_t fread (void *__restrict __ptr, size_t __size,
       size_t __n, FILE *__restrict __stream) ;




extern size_t fwrite (const void *__restrict __ptr, size_t __size,
        size_t __n, FILE *__restrict __s);
# 691 "/usr/include/stdio.h" 3 4
extern int fputs_unlocked (const char *__restrict __s,
      FILE *__restrict __stream);
# 702 "/usr/include/stdio.h" 3 4
extern size_t fread_unlocked (void *__restrict __ptr, size_t __size,
         size_t __n, FILE *__restrict __stream) ;
extern size_t fwrite_unlocked (const void *__restrict __ptr, size_t __size,
          size_t __n, FILE *__restrict __stream);







extern int fseek (FILE *__stream, long int __off, int __whence);




extern long int ftell (FILE *__stream) ;




extern void rewind (FILE *__stream);
# 736 "/usr/include/stdio.h" 3 4
extern int fseeko (FILE *__stream, __off_t __off, int __whence);




extern __off_t ftello (FILE *__stream) ;
# 760 "/usr/include/stdio.h" 3 4
extern int fgetpos (FILE *__restrict __stream, fpos_t *__restrict __pos);




extern int fsetpos (FILE *__stream, const fpos_t *__pos);
# 779 "/usr/include/stdio.h" 3 4
extern int fseeko64 (FILE *__stream, __off64_t __off, int __whence);
extern __off64_t ftello64 (FILE *__stream) ;
extern int fgetpos64 (FILE *__restrict __stream, fpos64_t *__restrict __pos);
extern int fsetpos64 (FILE *__stream, const fpos64_t *__pos);



extern void clearerr (FILE *__stream) noexcept (true);

extern int feof (FILE *__stream) noexcept (true) ;

extern int ferror (FILE *__stream) noexcept (true) ;



extern void clearerr_unlocked (FILE *__stream) noexcept (true);
extern int feof_unlocked (FILE *__stream) noexcept (true) ;
extern int ferror_unlocked (FILE *__stream) noexcept (true) ;







extern void perror (const char *__s);




extern int fileno (FILE *__stream) noexcept (true) ;




extern int fileno_unlocked (FILE *__stream) noexcept (true) ;
# 823 "/usr/include/stdio.h" 3 4
extern int pclose (FILE *__stream);





extern FILE *popen (const char *__command, const char *__modes)
  __attribute__ ((__malloc__)) ;






extern char *ctermid (char *__s) noexcept (true)
  __attribute__ ((__access__ (__write_only__, 1)));





extern char *cuserid (char *__s)
  __attribute__ ((__access__ (__write_only__, 1)));




struct obstack;


extern int obstack_printf (struct obstack *__restrict __obstack,
      const char *__restrict __format, ...)
     noexcept (true) __attribute__ ((__format__ (__printf__, 2, 3)));
extern int obstack_vprintf (struct obstack *__restrict __obstack,
       const char *__restrict __format,
       __gnuc_va_list __args)
     noexcept (true) __attribute__ ((__format__ (__printf__, 2, 0)));







extern void flockfile (FILE *__stream) noexcept (true);



extern int ftrylockfile (FILE *__stream) noexcept (true) ;


extern void funlockfile (FILE *__stream) noexcept (true);
# 885 "/usr/include/stdio.h" 3 4
extern int __uflow (FILE *);
extern int __overflow (FILE *, int);
# 902 "/usr/include/stdio.h" 3 4
}
# 43 "/usr/include/c++/10/cstdio" 2 3


#define _GLIBCXX_CSTDIO 1






#undef clearerr
#undef fclose
#undef feof
#undef ferror
#undef fflush
#undef fgetc
#undef fgetpos
#undef fgets
#undef fopen
#undef fprintf
#undef fputc
#undef fputs
#undef fread
#undef freopen
#undef fscanf
#undef fseek
#undef fsetpos
#undef ftell
#undef fwrite
#undef getc
#undef getchar



#undef perror
#undef printf
#undef putc
#undef putchar
#undef puts
#undef remove
#undef rename
#undef rewind
#undef scanf
#undef setbuf
#undef setvbuf
#undef sprintf
#undef sscanf
#undef tmpfile
#undef tmpnam
#undef ungetc
#undef vfprintf
#undef vprintf
#undef vsprintf

namespace std
{
  using ::FILE;
  using ::fpos_t;

  using ::clearerr;
  using ::fclose;
  using ::feof;
  using ::ferror;
  using ::fflush;
  using ::fgetc;
  using ::fgetpos;
  using ::fgets;
  using ::fopen;
  using ::fprintf;
  using ::fputc;
  using ::fputs;
  using ::fread;
  using ::freopen;
  using ::fscanf;
  using ::fseek;
  using ::fsetpos;
  using ::ftell;
  using ::fwrite;
  using ::getc;
  using ::getchar;




  using ::perror;
  using ::printf;
  using ::putc;
  using ::putchar;
  using ::puts;
  using ::remove;
  using ::rename;
  using ::rewind;
  using ::scanf;
  using ::setbuf;
  using ::setvbuf;
  using ::sprintf;
  using ::sscanf;
  using ::tmpfile;

  using ::tmpnam;

  using ::ungetc;
  using ::vfprintf;
  using ::vprintf;
  using ::vsprintf;
}



#undef snprintf
#undef vfscanf
#undef vscanf
#undef vsnprintf
#undef vsscanf

namespace __gnu_cxx
{
# 175 "/usr/include/c++/10/cstdio" 3
  using ::snprintf;
  using ::vfscanf;
  using ::vscanf;
  using ::vsnprintf;
  using ::vsscanf;

}

namespace std
{
  using ::__gnu_cxx::snprintf;
  using ::__gnu_cxx::vfscanf;
  using ::__gnu_cxx::vscanf;
  using ::__gnu_cxx::vsnprintf;
  using ::__gnu_cxx::vsscanf;
}
# 128 "code/utils.h" 2


# 129 "code/utils.h"
String load_entire_file(Arena *arena, String filename) {
    assert(filename.count < filename.capacity &&
           filename.data[filename.count] == 0);
    String result = {};

    FILE *file = fopen(filename.data, "rb");
    if (!file) {
        printf("failed to open file %.*s\n", (int)filename.count, filename.data);
        assert(0);
        return result;
    }
    fseek(file, 0, 
# 140 "code/utils.h" 3 4
                  2
# 140 "code/utils.h"
                          );
    usize size = ftell(file);
    fseek(file, 0, 
# 142 "code/utils.h" 3 4
                  0
# 142 "code/utils.h"
                          );

    result = make_string(arena, size);

    while (size > 0) {
        size_t bytes_read = fread(result.data, 1, size, file);
        if (bytes_read <= 0)
            assert(0);
        size -= bytes_read;
    }
    return result;
}


int align_to(int x, int alignement) {
    return alignement * ((x + alignement - 1) / alignement);
}
# 18 "code/game.cpp" 2
# 1 "code/math.h" 1
       

#define PI 3.14159265359f
#define DEG2RAD (PI / 180.f)
#define RAD2DEG (180.f / PI)

int sign(float x) {
    if (x < 0)
        return -1;
    else if (x > 0)
        return 1;
    return 0;
}


union v2 {
    struct {
        float x, y;
    };
    struct {
        float u, v;
    };
    float e[2];
};

v2 V2(float x) { return v2{x, x}; }
v2 V2(float x, float y) { return v2{x, y}; }

v2 operator+(v2 a, v2 b) { return v2{a.x + b.x, a.y + b.y}; }

v2 operator-(v2 a, v2 b) { return v2{a.x - b.x, a.y - b.y}; }

v2 operator*(v2 a, float b) { return v2{a.x * b, a.y * b}; }

v2 operator*(float a, v2 b) { return v2{a * b.x, a * b.y}; }

v2 operator*(v2 a, v2 b) { return v2{a.x * b.x, a.y * b.y}; }

v2 operator/(v2 a, float b) {
    float inv = 1.f / b;
    return v2{a.x * inv, a.y * inv};
}

v2 &operator+=(v2 &a, v2 b) { return a = a + b; }

v2 &operator-=(v2 &a, v2 b) { return a = a - b; }

v2 &operator*=(v2 &a, v2 b) { return a = a * b; }

v2 &operator*=(v2 &a, float b) { return a = a * b; }

v2 &operator/=(v2 &a, float b) { return a = a / b; }

float dot(v2 a, v2 b) { return a.x * b.x + a.y * b.y; }

float length_sq(v2 a) { return dot(a, a); }

float length(v2 a) { return sqrtf(dot(a, a)); }

v2 normalize(v2 a) {
    float len = length_sq(a);


    if (len < 1e-9)
        return {};
    else
        return a / sqrtf(len);
}


union v3 {
    struct {
        float x, y, z;
    };
    struct {
        float r, g, b;
    };
    struct {
        float u, v, w;
    };
    v2 xy;
    float e[3];
};

v3 V3(float x) { return v3{x, x, x}; }

v3 V3(float x, float y, float z) {
    v3 result;

    result.x = x;
    result.y = y;
    result.z = z;
    return result;
}

v3 operator+(v3 a, v3 b) { return v3{a.x + b.x, a.y + b.y, a.z + b.z}; }

v3 operator-(v3 a, v3 b) { return v3{a.x - b.x, a.y - b.y, a.z - b.z}; }

v3 operator*(v3 a, float b) { return v3{a.x * b, a.y * b, a.z * b}; }

v3 operator*(float a, v3 b) { return v3{a * b.x, a * b.y, a * b.z}; }

v3 operator/(v3 a, float b) {
    float inv = 1.f / b;
    return v3{a.x * inv, a.y * inv, a.z * inv};
}

v3 operator*(v3 a, v3 b) { return v3{a.x * b.x, a.y * b.y, a.z * b.z}; }

v3 operator-(v3 a) { return v3{-a.x, -a.y, -a.z}; }

v3 &operator+=(v3 &a, v3 b) { return a = a + b; }

v3 &operator-=(v3 &a, v3 b) { return a = a - b; }

v3 &operator*=(v3 &a, v3 b) { return a = a * b; }

v3 &operator*=(v3 &a, float b) { return a = a * b; }

v3 &operator/=(v3 &a, float b) { return a = a / b; }

v3 operator/(float a, v3 b) { return v3{a / b.x, a / b.y, a / b.z}; }

float dot(v3 a, v3 b) { return a.x * b.x + a.y * b.y + a.z * b.z; }

float length_sq(v3 a) { return dot(a, a); }

float length(v3 a) { return sqrtf(dot(a, a)); }

v3 normalize(v3 a) {
    float len = length_sq(a);

    if (len < 1e-9)
        return {};
    else
        return a / sqrtf(len);
}

v3 cross(v3 a, v3 b) {
    return v3{a.y * b.z - a.z * b.y, a.z * b.x - a.x * b.z,
              a.x * b.y - a.y * b.x};
}

v3 min(v3 a, v3 b) { return V3(min(a.x, b.x), min(a.y, b.y), min(a.z, b.z)); }

v3 max(v3 a, v3 b) { return V3(max(a.x, b.x), max(a.y, b.y), max(a.z, b.z)); }

bool v3_equal(v3 a, v3 b, float eps = 1e-6) {
    return fabsf(a.x - b.x) < eps && fabsf(a.y - b.y) < eps &&
           fabsf(a.z - b.z) < eps;
}

union v3i {
    struct {
        int x, y, z;
    };
    int e[3];
};

v3i V3i(int x, int y, int z) { return v3i{x, y, z}; }

v3i V3i(int x) { return v3i{x, x, x}; }

v3 V3(v3i v) { return v3{(float)v.x, (float)v.y, (float)v.z}; }

v3i operator+(v3i a, v3i b) { return v3i{a.x + b.x, a.y + b.y, a.z + b.z}; }

v3i operator-(v3i a, v3i b) { return v3i{a.x - b.x, a.y - b.y, a.z - b.z}; }

v3i operator-(v3i a) { return v3i{-a.x, -a.y, -a.z}; }

v3i max(v3i a, v3i b) {
    return V3i(max(a.x, b.x), max(a.y, b.y), max(a.z, b.z));
}

v3i min(v3i a, v3i b) {
    return V3i(min(a.x, b.x), min(a.y, b.y), min(a.z, b.z));
}


union v4 {
    struct {
        float x, y, z, w;
    };
    struct {
        float r, g, b, a;
    };
    v3 xyz;
    float e[4];
};

v4 V4(float x, float y, float z, float w) {
    v4 v;

    v.x = x, v.y = y, v.z = z, v.w = w;
    return v;
}

v4 V4(v3 xyz, float w) {
    v4 v;

    v.xyz = xyz;
    v.w = w;
    return v;
}

v4 operator+(v4 a, v4 b) {
    return v4{a.x + b.x, a.y + b.y, a.z + b.z, a.w + b.w};
}

v4 operator-(v4 a, v4 b) {
    return v4{a.x - b.x, a.y - b.y, a.z - b.z, a.w - b.w};
}

v4 operator*(v4 a, float b) { return v4{a.x * b, a.y * b, a.z * b, a.w * b}; }

float dot(v4 a, v4 b) { return a.x * b.x + a.y * b.y + a.z * b.z + a.w * b.w; }

v4 operator-(v4 a) { return v4{-a.x, -a.y, -a.z, -a.w}; }

float length(v4 a) { return sqrtf(dot(a, a)); }


union mat4 {
    float e[4][4];
    float v[16];
};

mat4 mat4_rows(v4 r0, v4 r1, v4 r2, v4 r3) {
    mat4 m;

    m.e[0][0] = r0.e[0], m.e[0][1] = r0.e[1], m.e[0][2] = r0.e[2],
    m.e[0][3] = r0.e[3];
    m.e[1][0] = r1.e[0], m.e[3][1] = r1.e[1], m.e[1][2] = r1.e[2],
    m.e[1][3] = r1.e[3];
    m.e[2][0] = r2.e[0], m.e[2][1] = r2.e[1], m.e[2][2] = r2.e[2],
    m.e[2][3] = r2.e[3];
    m.e[3][0] = r3.e[0], m.e[1][1] = r3.e[1], m.e[3][2] = r3.e[2],
    m.e[3][3] = r3.e[3];
    return m;
}

mat4 mat4_cols(v4 c0, v4 c1, v4 c2, v4 c3) {
    mat4 m;

    m.e[0][0] = c0.e[0], m.e[1][0] = c0.e[1], m.e[2][0] = c0.e[2],
    m.e[3][0] = c0.e[3];
    m.e[0][1] = c1.e[0], m.e[1][1] = c1.e[1], m.e[2][1] = c1.e[2],
    m.e[3][1] = c1.e[3];
    m.e[0][2] = c2.e[0], m.e[1][2] = c2.e[1], m.e[2][2] = c2.e[2],
    m.e[3][2] = c2.e[3];
    m.e[0][3] = c3.e[0], m.e[1][3] = c3.e[1], m.e[2][3] = c3.e[2],
    m.e[3][3] = c3.e[3];
    return m;
}

mat4 transpose(mat4 a) {
    mat4 b;

    for (int i = 0; i < 4; i++)
        for (int j = 0; j < 4; j++)
            b.e[i][j] = a.e[j][i];
    return b;
}

mat4 operator*(mat4 a, mat4 b) {
    mat4 c = {};

    for (int i = 0; i < 4; i++)
        for (int j = 0; j < 4; j++)
            for (int k = 0; k < 4; k++)
                c.e[i][j] += a.e[i][k] * b.e[k][j];
    return c;
}

v4 operator*(mat4 a, v4 b) {
    v4 c;

    c.e[0] = a.e[0][0] * b.e[0] + a.e[0][1] * b.e[1] + a.e[0][2] * b.e[2] +
             a.e[0][3] * b.e[3];
    c.e[1] = a.e[1][0] * b.e[0] + a.e[1][1] * b.e[1] + a.e[1][2] * b.e[2] +
             a.e[1][3] * b.e[3];
    c.e[2] = a.e[2][0] * b.e[0] + a.e[2][1] * b.e[1] + a.e[2][2] * b.e[2] +
             a.e[2][3] * b.e[3];
    c.e[3] = a.e[3][0] * b.e[0] + a.e[3][1] * b.e[1] + a.e[3][2] * b.e[2] +
             a.e[3][3] * b.e[3];

    return c;
}

mat4 scale(float a) {
    mat4 S = {};

    S.e[0][0] = S.e[1][1] = S.e[2][2] = a;
    S.e[3][3] = 1;
    return S;
}

mat4 scale(float x, float y, float z) {
    mat4 S = {};

    S.e[0][0] = x;
    S.e[1][1] = y;
    S.e[2][2] = z;
    S.e[3][3] = 1;
    return S;
}

mat4 scale(v3 v) { return scale(v.x, v.y, v.z); }

mat4 identity() { return scale(1); }

mat4 translate(float x, float y, float z) {
    mat4 T = identity();

    T.e[0][3] = x;
    T.e[1][3] = y;
    T.e[2][3] = z;
    return T;
}

mat4 translate(v3 t) { return translate(t.x, t.y, t.z); }

mat4 operator*(float a, mat4 b) {
    mat4 c;

    for (int i = 0; i < 4; i++)
        for (int j = 0; j < 4; j++)
            c.e[i][j] = a * b.e[i][j];
    return c;
}

mat4 zrotation(float a) {
    float c = cosf(a);
    float s = sinf(a);

    return {c, -s, 0, 0, s, c, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1};
}

mat4 xrotation(float a) {
    float c = cosf(a);
    float s = sinf(a);

    return {1, 0, 0, 0, 0, c, -s, 0, 0, s, c, 0, 0, 0, 0, 1};
}

mat4 yrotation(float a) {
    float c = cosf(a);
    float s = sinf(a);

    return {c, 0, s, 0, 0, 1, 0, 0, -s, 0, c, 0, 0, 0, 0, 1};
}

mat4 rotate_around_axis(v3 u, float a) {
    u = normalize(u);
    float c = cosf(a);
    float s = sinf(a);

    return {c + u.x * u.x * (1 - c),
            u.x * u.y * (1 - c) - u.z * s,
            u.x * u.z * (1 - c) + u.y * s,
            0,
            u.y * u.x * (1 - c) + u.z * s,
            c + u.y * u.y * (1 - c),
            u.y * u.z * (1 - c) - u.x * s,
            0,
            u.z * u.x * (1 - c) - u.y * s,
            u.z * u.y * (1 - c) + u.x * s,
            c + u.z * u.z * (1 - c),
            0,
            0,
            0,
            0,
            1};
}

mat4 perspective_projection(float znear, float zfar, float width, float height) {
    return {znear * 2 / width,
            0,
            0,
            0,
            0,
            znear * 2 / height,
            0,
            0,






            0,
            0,
            (zfar + znear) / (znear - zfar),
            2 * znear * zfar / (znear - zfar),

            0,
            0,
            -1,
            0};
}

mat4 orthographic_projection(float znear, float zfar, float width, float height) {
    return {2.f / width,
            0,
            0,
            0,
            0,
            2.f / height,
            0,
            0,






            0,
            0,
            -2.f / (zfar - znear),
            (-znear - zfar) / (zfar - znear),

            0,
            0,
            0,
            1};
}

mat4 lookat(v3 position, v3 dir, v3 up) {
    v3 z_axis = normalize(-dir);


    v3 x_axis = normalize(cross(up, z_axis));
    v3 y_axis = normalize(cross(z_axis, x_axis));

    mat4 transform = {
        x_axis.x, x_axis.y, x_axis.z, 0, y_axis.x, y_axis.y, y_axis.z, 0,
        z_axis.x, z_axis.y, z_axis.z, 0, 0, 0, 0, 1};

    return transform * translate(-position);
}

using quat = v4;

quat Quat(float x, float y, float z, float w) { return {x, y, z, w}; }

quat operator*(quat a, quat b) {
    return {
        a.w * b.x + a.x * b.w + a.y * b.z - a.z * b.y,
        a.w * b.y - a.x * b.z + a.y * b.w + a.z * b.x,
        a.w * b.z + a.x * b.y - a.y * b.x + a.z * b.w,
        a.w * b.w - a.x * b.x - a.y * b.y - a.z * b.z,
    };
}

mat4 quat_to_mat(quat a) {
    float x = a.x;
    float y = a.y;
    float z = a.z;
    float w = a.w;

    mat4 matrix;

    float wx, wy, wz, xx, yy, yz, xy, xz, zz;

    xx = x * x;
    xy = x * y;
    xz = x * z;
    yy = y * y;
    zz = z * z;
    yz = y * z;

    wx = w * x;
    wy = w * y;
    wz = w * z;

    matrix.v[0] = 1.0f - 2.0f * (yy + zz);
    matrix.v[4] = 2.0f * (xy - wz);
    matrix.v[8] = 2.0f * (xz + wy);
    matrix.v[12] = 0.0;

    matrix.v[1] = 2.0f * (xy + wz);
    matrix.v[5] = 1.0f - 2.0f * (xx + zz);
    matrix.v[9] = 2.0f * (yz - wx);
    matrix.v[13] = 0.0;

    matrix.v[2] = 2.0f * (xz - wy);
    matrix.v[6] = 2.0f * (yz + wx);
    matrix.v[10] = 1.0f - 2.0f * (xx + yy);
    matrix.v[14] = 0.0;

    matrix.v[3] = 0;
    matrix.v[7] = 0;
    matrix.v[11] = 0;
    matrix.v[15] = 1;

    return transpose(matrix);
}

quat quat_lerp(quat a, quat b, float t) {
    float l2 = dot(a, b);
    if (l2 < 0.0f)
        b = -b;
    v4 c;
    c.x = a.x - t * (a.x - b.x);
    c.y = a.y - t * (a.y - b.y);
    c.z = a.z - t * (a.z - b.z);
    c.w = a.w - t * (a.w - b.w);
    return c * (1.f / length(c));
}

mat4 inverse(mat4 matrix) {
    const float *m = (float *)matrix.e;

    float t0 = m[10] * m[15];
    float t1 = m[14] * m[11];
    float t2 = m[6] * m[15];
    float t3 = m[14] * m[7];
    float t4 = m[6] * m[11];
    float t5 = m[10] * m[7];
    float t6 = m[2] * m[15];
    float t7 = m[14] * m[3];
    float t8 = m[2] * m[11];
    float t9 = m[10] * m[3];
    float t10 = m[2] * m[7];
    float t11 = m[6] * m[3];
    float t12 = m[8] * m[13];
    float t13 = m[12] * m[9];
    float t14 = m[4] * m[13];
    float t15 = m[12] * m[5];
    float t16 = m[4] * m[9];
    float t17 = m[8] * m[5];
    float t18 = m[0] * m[13];
    float t19 = m[12] * m[1];
    float t20 = m[0] * m[9];
    float t21 = m[8] * m[1];
    float t22 = m[0] * m[5];
    float t23 = m[4] * m[1];

    mat4 out_matrix;
    float *o = (float *)out_matrix.e;

    o[0] = (t0 * m[5] + t3 * m[9] + t4 * m[13]) -
           (t1 * m[5] + t2 * m[9] + t5 * m[13]);
    o[1] = (t1 * m[1] + t6 * m[9] + t9 * m[13]) -
           (t0 * m[1] + t7 * m[9] + t8 * m[13]);
    o[2] = (t2 * m[1] + t7 * m[5] + t10 * m[13]) -
           (t3 * m[1] + t6 * m[5] + t11 * m[13]);
    o[3] = (t5 * m[1] + t8 * m[5] + t11 * m[9]) -
           (t4 * m[1] + t9 * m[5] + t10 * m[9]);

    float d = 1.0f / (m[0] * o[0] + m[4] * o[1] + m[8] * o[2] + m[12] * o[3]);

    o[0] = d * o[0];
    o[1] = d * o[1];
    o[2] = d * o[2];
    o[3] = d * o[3];
    o[4] = d * ((t1 * m[4] + t2 * m[8] + t5 * m[12]) -
                (t0 * m[4] + t3 * m[8] + t4 * m[12]));
    o[5] = d * ((t0 * m[0] + t7 * m[8] + t8 * m[12]) -
                (t1 * m[0] + t6 * m[8] + t9 * m[12]));
    o[6] = d * ((t3 * m[0] + t6 * m[4] + t11 * m[12]) -
                (t2 * m[0] + t7 * m[4] + t10 * m[12]));
    o[7] = d * ((t4 * m[0] + t9 * m[4] + t10 * m[8]) -
                (t5 * m[0] + t8 * m[4] + t11 * m[8]));
    o[8] = d * ((t12 * m[7] + t15 * m[11] + t16 * m[15]) -
                (t13 * m[7] + t14 * m[11] + t17 * m[15]));
    o[9] = d * ((t13 * m[3] + t18 * m[11] + t21 * m[15]) -
                (t12 * m[3] + t19 * m[11] + t20 * m[15]));
    o[10] = d * ((t14 * m[3] + t19 * m[7] + t22 * m[15]) -
                 (t15 * m[3] + t18 * m[7] + t23 * m[15]));
    o[11] = d * ((t17 * m[3] + t20 * m[7] + t23 * m[11]) -
                 (t16 * m[3] + t21 * m[7] + t22 * m[11]));
    o[12] = d * ((t14 * m[10] + t17 * m[14] + t13 * m[6]) -
                 (t16 * m[14] + t12 * m[6] + t15 * m[10]));
    o[13] = d * ((t20 * m[14] + t12 * m[2] + t19 * m[10]) -
                 (t18 * m[10] + t21 * m[14] + t13 * m[2]));
    o[14] = d * ((t18 * m[6] + t23 * m[14] + t15 * m[2]) -
                 (t22 * m[14] + t14 * m[2] + t19 * m[6]));
    o[15] = d * ((t22 * m[10] + t16 * m[2] + t21 * m[6]) -
                 (t20 * m[6] + t23 * m[10] + t17 * m[2]));

    return out_matrix;
}

template <typename T> T lerp(const T a, const T b, float t) {
    return (1 - t) * a + t * b;
}

bool ray_hit_plane(v3 ray_origin, v3 ray_dir, v3 plane_normal, v3 plane_point,
                   float *hit_t) {
    float denom = dot(ray_dir, plane_normal);
    if (fabsf(denom) < 1e-5)
        return false;
    float t = (dot(plane_normal, plane_point) - dot(ray_origin, plane_normal)) /
              denom;
    if (t >= 0) {
        if (hit_t)
            *hit_t = t;
        return true;
    }
    return false;
}

void push_cube_outline(v3 p, v3 r, v3 color);

float ray_hit_box(v3 ray_origin, v3 ray_dir, v3 box_center, v3 box_xaxis,
                  v3 box_yaxis, v3 box_zaxis) {
    struct {
        v3 normal;
        v3 p;
    } planes[6];

    planes[0] = {box_xaxis, box_center + box_xaxis};
    planes[1] = {-box_xaxis, box_center - box_xaxis};
    planes[2] = {box_yaxis, box_center + box_yaxis};
    planes[3] = {-box_yaxis, box_center - box_yaxis};
    planes[4] = {box_zaxis, box_center + box_zaxis};
    planes[5] = {-box_zaxis, box_center - box_zaxis};

    float lx = length(box_xaxis);
    float ly = length(box_yaxis);
    float lz = length(box_zaxis);

    v3 xaxis = normalize(box_xaxis);
    v3 yaxis = normalize(box_yaxis);
    v3 zaxis = normalize(box_zaxis);

    float min_t = FLT_MAX;
    for (int i = 0; i < 6; i++) {







        float denom = dot(ray_dir, planes[i].normal);
        if (fabsf(denom) < 1e-6)
            continue;
        float t = (dot(planes[i].normal, planes[i].p) -
                   dot(ray_origin, planes[i].normal)) /
                  denom;
        if (t >= 0 && t < min_t) {
            v3 p = ray_origin + t * ray_dir - box_center;
            float eps = 1e-4;
            if (dot(p, xaxis) >= -lx - eps && dot(p, xaxis) <= lx + eps &&
                dot(p, yaxis) >= -ly - eps && dot(p, yaxis) <= ly + eps &&
                dot(p, zaxis) >= -lz - eps && dot(p, zaxis) <= lz + eps)
                min_t = t;
        }
    }
    if (min_t == FLT_MAX)
        return -1;
    return min_t;
}

quat rotate_around_axis_quat(v3 axis, float a) {
    axis = normalize(axis);
    float s = sinf(a / 2);
    float c = cosf(a / 2);
    return V4(axis * s, c);
}

quat zrotation_quat(float a) { return rotate_around_axis_quat(V3(0, 0, 1), a); }

quat identity_quat() { return Quat(0, 0, 0, 1); }
# 19 "code/game.cpp" 2
# 1 "code/platform.h" 1
       

enum GameButtonType {
    BUTTON_A,
    BUTTON_B,
    BUTTON_C,
    BUTTON_D,
    BUTTON_E,
    BUTTON_F,
    BUTTON_G,
    BUTTON_H,
    BUTTON_I,
    BUTTON_J,
    BUTTON_K,
    BUTTON_L,
    BUTTON_M,
    BUTTON_N,
    BUTTON_O,
    BUTTON_P,
    BUTTON_Q,
    BUTTON_R,
    BUTTON_S,
    BUTTON_T,
    BUTTON_U,
    BUTTON_V,
    BUTTON_W,
    BUTTON_X,
    BUTTON_Y,
    BUTTON_Z,

    BUTTON_LEFT_CONTROL,
    BUTTON_LEFT_SHIFT,
    BUTTON_MOUSE_LEFT,
    BUTTON_MOUSE_RIGHT,
    BUTTON_SPACE,
    BUTTON_ESCAPE,
    BUTTON_F1,
    BUTTON_F2,
    BUTTON_F3,
    BUTTON_F4,
    BUTTON_F5,
    BUTTON_F6,
    BUTTON_F7,
    BUTTON_F8,
    BUTTON_F9,
    BUTTON_F10,
    BUTTON_F11,
    BUTTON_F12,
    BUTTON_COUNT
};

#define BUTTON_CAMERA_FORWARD BUTTON_W
#define BUTTON_CAMERA_BACKWARD BUTTON_S
#define BUTTON_CAMERA_LEFT BUTTON_A
#define BUTTON_CAMERA_RIGHT BUTTON_D
#define BUTTON_CAMERA_UP BUTTON_Q
#define BUTTON_CAMERA_DOWN BUTTON_E
#define BUTTON_PLAYER_FORWARD BUTTON_F
#define BUTTON_PLAYER_BACKWARD BUTTON_G
#define BUTTON_PLAYER_JUMP BUTTON_SPACE
#define TOGGLE_EDITOR_BUTTON BUTTON_F1

struct GameButton {
    b32 is_down;
    b32 was_down;
};

struct GameInput {
    GameButton buttons[BUTTON_COUNT];
    v2 mouse_dp;
    v2 mouse_p;
    v2 last_mouse_p;
};

#define IsDown(input,button) (input.buttons[button].is_down)
#define IsKeyboardButton(button) (button != BUTTON_MOUSE_LEFT && button != BUTTON_MOUSE_RIGHT)
#define WasDown(input,button) (input.buttons[button].was_down)
#define IsDownFirstTime(input,button) (IsDown(input, button) && !WasDown(input, button))



#define GL_FUNCTIONS(X) X(PFNGLENABLEPROC, glEnable) X(PFNGLDISABLEPROC, glDisable) X(PFNGLBLENDFUNCPROC, glBlendFunc) X(PFNGLVIEWPORTPROC, glViewport) X(PFNGLCLEARCOLORPROC, glClearColor) X(PFNGLCLEARPROC, glClear) X(PFNGLDRAWARRAYSPROC, glDrawArrays) X(PFNGLCREATEBUFFERSPROC, glCreateBuffers) X(PFNGLNAMEDBUFFERSTORAGEPROC, glNamedBufferStorage) X(PFNGLBINDVERTEXARRAYPROC, glBindVertexArray) X(PFNGLCREATEVERTEXARRAYSPROC, glCreateVertexArrays) X(PFNGLVERTEXARRAYATTRIBBINDINGPROC, glVertexArrayAttribBinding) X(PFNGLVERTEXARRAYVERTEXBUFFERPROC, glVertexArrayVertexBuffer) X(PFNGLVERTEXARRAYATTRIBFORMATPROC, glVertexArrayAttribFormat) X(PFNGLENABLEVERTEXARRAYATTRIBPROC, glEnableVertexArrayAttrib) X(PFNGLCREATESHADERPROGRAMVPROC, glCreateShaderProgramv) X(PFNGLGETPROGRAMIVPROC, glGetProgramiv) X(PFNGLGETPROGRAMINFOLOGPROC, glGetProgramInfoLog) X(PFNGLGENPROGRAMPIPELINESPROC, glGenProgramPipelines) X(PFNGLUSEPROGRAMSTAGESPROC, glUseProgramStages) X(PFNGLBINDPROGRAMPIPELINEPROC, glBindProgramPipeline) X(PFNGLPROGRAMUNIFORMMATRIX2FVPROC, glProgramUniformMatrix2fv) X(PFNGLBINDTEXTUREUNITPROC, glBindTextureUnit) X(PFNGLCREATETEXTURESPROC, glCreateTextures) X(PFNGLTEXTUREPARAMETERIPROC, glTextureParameteri) X(PFNGLTEXTURESTORAGE2DPROC, glTextureStorage2D) X(PFNGLTEXTURESUBIMAGE2DPROC, glTextureSubImage2D) X(PFNGLDEBUGMESSAGECALLBACKPROC, glDebugMessageCallback) X(PFNGLGETINTEGERVPROC, glGetIntegerv) X(PFNGLDEBUGMESSAGECONTROLPROC, glDebugMessageControl) X(PFNGLCREATESHADERPROC, glCreateShader) X(PFNGLSHADERSOURCEPROC, glShaderSource) X(PFNGLCOMPILESHADERPROC, glCompileShader) X(PFNGLGETSHADERIVPROC, glGetShaderiv) X(PFNGLGETSHADERINFOLOGPROC, glGetShaderInfoLog) X(PFNGLACTIVETEXTUREPROC, glActiveTexture) X(PFNGLBINDTEXTUREPROC, glBindTexture) X(PFNGLGENTEXTURESPROC, glGenTextures) X(PFNGLTEXIMAGE2DPROC, glTexImage2D) X(PFNGLGENERATEMIPMAPPROC, glGenerateMipmap) X(PFNGLTEXPARAMETERIPROC, glTexParameteri) X(PFNGLCLEARDEPTHPROC, glClearDepth) X(PFNGLBINDFRAMEBUFFERPROC, glBindFrameBuffer) X(PFNGLCULLFACEPROC, glCullFace) X(PFNGLCREATEPROGRAMPROC, glCreateProgram) X(PFNGLATTACHSHADERPROC, glAttachShader) X(PFNGLLINKPROGRAMPROC, glLinkProgram) X(PFNGLUSEPROGRAMPROC, glUseProgram) X(PFNGLGENVERTEXARRAYSPROC, glGenVertexArrays) X(PFNGLGENBUFFERSPROC, glGenBuffers) X(PFNGLBINDBUFFERPROC, glBindBuffer) X(PFNGLBINDBUFFERBASEPROC, glBindBufferBase) X(PFNGLBUFFERDATAPROC, glBufferData) X(PFNGLBUFFERSUBDATAPROC, glBufferSubData) X(PFNGLVERTEXATTRIBPOINTERPROC, glVertexAttribPointer) X(PFNGLENABLEVERTEXATTRIBARRAYPROC, glEnableVertexAttribArray) X(PFNGLPOLYGONMODEPROC, glPolygonMode)
# 143 "code/platform.h"
#define THREAD_WORK_FUNC(name) void name(void *data)

typedef void ThreadWorkFn(void *data);

struct ThreadWork {
 ThreadWorkFn *callback;
 void *data;
};

static ThreadWork thread_work_queue[256];
#define THREAD_MASK(x) ((x) & (ARRAY_SIZE(thread_work_queue) - 1))
static volatile int thread_work_queue_read_index;
static volatile int thread_work_queue_write_index;
static volatile int thread_work_queue_occupied_index;
static void *thread_work_semaphore;

typedef bool AddThreadWorkFn(ThreadWorkFn *callback, void *data);

struct Platform {
    void *render_context;
    void *imgui_context;
    TempArena temp_arena;

    AddThreadWorkFn *add_thread_work;
};

#define GAME_UPDATE_AND_RENDER(name) void name(Platform &platform, Arena *memory, GameInput &input, float dt)

typedef void game_update_and_render_fn(Platform &platform, Arena *memory, GameInput &input, float dt);
# 20 "code/game.cpp" 2
# 1 "code/renderer.h" 1
       

enum TextureState {
    TEXTURE_STATE_UNLOADED,
    TEXTURE_STATE_LOADING,
    TEXTURE_STATE_LOADED,
};

struct Texture {



    uint32_t id;

    String name;
    int width;
    int height;
    b32 valid;


    int state;
};

enum ShaderType {
    SHADER_TYPE_VERTEX,
    SHADER_TYPE_FRAGMENT,
};

struct Shader {
    ShaderType type;
# 39 "code/renderer.h"
    uint32_t id;

};

enum InputElementType {
    INPUT_ELEMENT_FLOAT,
    INPUT_ELEMENT_SIGNED_INT,
};

struct VertexInputElement {
    int offset;
    int count;
    InputElementType type;
    const char *name;
};

enum PrimitiveType {
    PRIMITIVE_TRIANGLES,
    PRIMITIVE_LINES,
};

enum VertexBufferUsage {
    VERTEX_BUFFER_IMMUTABLE,
    VERTEX_BUFFER_DYNAMIC,
};

struct VertexBuffer {
    usize size;
    VertexBufferUsage usage;




    uint32_t vao;
    uint32_t vbo;

};

struct IndexBuffer {

    uint32_t ebo;


};

struct FrameBuffer {




    uint32_t id;


    Texture color_texture;
    Texture depth_texture;
};

struct DepthStencilState {
    bool enable_depth;



};

enum RasterizerFillMode { RASTERIZER_FILL_SOLID, RASTERIZER_FILL_WIREFRAME };

enum RasterizerCullMode {
    RASTERIZER_CULL_NONE,
    RASTERIZER_CULL_FRONT,
    RASTERIZER_CULL_BACK,
};

struct RasterizerState {
    RasterizerFillMode fillmode;
    RasterizerCullMode cullmode;



};

struct VertexInputLayout {
    VertexInputElement elements[64];
    int element_count;
    int vertex_size;



};

struct RenderPass {
    PrimitiveType primitive_type;

    Shader vs;
    Shader fs;
    DepthStencilState depth_stencil_state;
    RasterizerState rasterizer_state;
    VertexInputLayout input_layout;

    uint32_t program;
};

struct RenderContext {
    int window_width;
    int window_height;

    FrameBuffer window_framebuffer;
# 158 "code/renderer.h"
    Array<Texture> loaded_textures;

    RenderPass *render_pass;
    Texture white_texture;

    Array<v3> debug_lines;

    uintptr_t active_framebuffer_id;
};

usize get_input_element_size(int type) {
    if (type == INPUT_ELEMENT_FLOAT)
        return sizeof(float);
    else if (type == INPUT_ELEMENT_SIGNED_INT)
        return sizeof(int);
    else
        assert(0);
    return 0;
}



enum ConstantBufferElementType {
    CONSTANT_BUFFER_ELEMENT_MAT4,
    CONSTANT_BUFFER_ELEMENT_VEC4,
    CONSTANT_BUFFER_ELEMENT_VEC3,
    CONSTANT_BUFFER_ELEMENT_VEC2,
    CONSTANT_BUFFER_ELEMENT_FLOAT,
    CONSTANT_BUFFER_ELEMENT_INT,
    CONSTANT_BUFFER_ELEMENT_COUNT
};

const char *get_constant_buffer_element_typename(ConstantBufferElementType type) {
 switch (type) {
    case CONSTANT_BUFFER_ELEMENT_MAT4:
  return "mat4";
    case CONSTANT_BUFFER_ELEMENT_VEC4:
  return "v4";
    case CONSTANT_BUFFER_ELEMENT_VEC3:
  return "v3";
    case CONSTANT_BUFFER_ELEMENT_VEC2:
  return "v2";
    case CONSTANT_BUFFER_ELEMENT_FLOAT:
  return "float";
    case CONSTANT_BUFFER_ELEMENT_INT:
  return "int";
    default:
        assert(0);
    }
 return "";
}

int get_c_type_alignement(ConstantBufferElementType type) {
    switch (type) {
    case CONSTANT_BUFFER_ELEMENT_MAT4:
        return alignof(mat4);
    case CONSTANT_BUFFER_ELEMENT_VEC4:
        return alignof(v4);
    case CONSTANT_BUFFER_ELEMENT_VEC3:
        return alignof(v3);
    case CONSTANT_BUFFER_ELEMENT_VEC2:
        return alignof(v2);
    case CONSTANT_BUFFER_ELEMENT_FLOAT:
        return alignof(float);
    case CONSTANT_BUFFER_ELEMENT_INT:
        return alignof(int);
    default:
        assert(0);
    }
    return 0;
}

struct ConstantBufferElement {
    ConstantBufferElementType type;
    int array_size;
};

struct ConstantBuffer {
    usize size;
    ConstantBufferElement elements[64];
    int element_count;



    uint32_t id;

};
# 21 "code/game.cpp" 2


static RenderContext *g_rc;
#define RENDERER_DEBUG 



# 1 "code/renderer_opengl.cpp" 1
Texture create_texture(String name, void *data, int width, int height, bool srgb = true,
  bool mipmapping = true)
{
 Texture texture = {};

 texture.width = width;
 texture.height = height;
 texture.name = name;
 texture.valid = true;

 uint32_t internal_format, format;

 if (srgb)
  internal_format = GL_SRGB_ALPHA;
 else
  internal_format = GL_RGBA;

 format = GL_RGBA;

 uint32_t tex;
 glGenTextures(1, &tex);

 glBindTexture(GL_TEXTURE_2D, tex);
 glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);
 glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);
 if (mipmapping)
  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER,
    GL_LINEAR_MIPMAP_LINEAR);
 else
  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER,
    GL_LINEAR);
 glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);

 glTexImage2D(GL_TEXTURE_2D, 0, internal_format, width, height, 0, format,
   GL_UNSIGNED_BYTE, data);
 if (mipmapping)
  glGenerateMipmap(GL_TEXTURE_2D);

 texture.id = tex;
 return texture;
}

void bind_texture(int index, Texture &texture)
{
 glActiveTexture(GL_TEXTURE0 + index);
 glBindTexture(GL_TEXTURE_2D, (uintptr_t)texture.id);
}

Shader load_shader(String filename, ShaderType type, const char *main = "")
{
 (void)main;

 Shader result = {};

 result.type = type;

 Arena *temp = begin_temp_memory();

 String content = load_entire_file(temp, filename);
 int gl_type = 0;
 if (type == SHADER_TYPE_VERTEX)
  gl_type = GL_VERTEX_SHADER;
 else if (type == SHADER_TYPE_FRAGMENT)
  gl_type = GL_FRAGMENT_SHADER;
 else
  assert(0);

 uint32_t shader = glCreateShader(gl_type);
 glShaderSource(shader, 1, &content.data, (GLint *)&content.count);

 end_temp_memory();

 glCompileShader(shader);

 int success;
 glGetShaderiv(shader, GL_COMPILE_STATUS, &success);
 if (!success) {
  printf("OPENGL: failed to compile shader \"%.*s\": ", (int)filename.count, filename.data);

  char info_log[2048];
  glGetShaderInfoLog(shader, sizeof(info_log), 0, info_log);
  printf("%s\n", info_log);
  assert(0);
 }

 result.id = shader;
 return result;

}

RasterizerState create_rasterizer_state(RasterizerFillMode fillmode, RasterizerCullMode cullmode)
{
 RasterizerState result = {};

 result.fillmode = fillmode;
 result.cullmode = cullmode;

 return result;
}

DepthStencilState create_depth_stencil_state(bool enable_depth)
{
 DepthStencilState result = {};

 result.enable_depth = enable_depth;
 return result;
}

void bind_rasterizer_state(const RasterizerState &state)
{
 if (state.fillmode == RASTERIZER_FILL_SOLID)
  glPolygonMode(GL_FRONT_AND_BACK, GL_FILL);
 else if (state.fillmode == RASTERIZER_FILL_WIREFRAME)
  glPolygonMode(GL_FRONT_AND_BACK, GL_LINE);

 if (state.cullmode == RASTERIZER_CULL_NONE)
  glDisable(GL_CULL_FACE);
 else if (state.cullmode == RASTERIZER_CULL_FRONT) {
  glEnable(GL_CULL_FACE);
  glCullFace(GL_FRONT);
 }
 else if (state.cullmode == RASTERIZER_CULL_BACK) {
  glEnable(GL_CULL_FACE);
  glCullFace(GL_BACK);
 }
}

void bind_depth_stencil_state(const DepthStencilState &state)
{
 if (state.enable_depth)
  glEnable(GL_DEPTH_TEST);
 else
  glDisable(GL_DEPTH_TEST);
}

VertexInputLayout create_vertex_input_layout(VertexInputElement *elements, int element_count,
  int vertex_size)
{
 VertexInputLayout result = {};

 result.vertex_size = vertex_size;
 result.element_count = element_count;
 for (int i = 0; i < element_count; i++)
  result.elements[i] = elements[i];

 return result;
}

RenderPass create_render_pass(Shader vs, Shader fs,
  PrimitiveType primitive_type, const DepthStencilState &depth_stencil_state,
  const RasterizerState &rasterizer_state, const VertexInputLayout &input_layout)
{
 RenderPass rp = {};

 rp.vs = vs;
 rp.fs = fs;
 rp.depth_stencil_state = depth_stencil_state;
 rp.rasterizer_state = rasterizer_state;
 rp.primitive_type = primitive_type;
 rp.input_layout = input_layout;

 rp.program = glCreateProgram();

 glAttachShader(rp.program, vs.id);
 glAttachShader(rp.program, fs.id);
 glLinkProgram(rp.program);

 int success;
 glGetProgramiv(rp.program, GL_LINK_STATUS, &success);
 if (!success) {
  char info_log[2048];
  glGetProgramInfoLog(rp.program, sizeof(info_log), 0, info_log);
  printf("failed to link program: %s\n", info_log);
  assert(0);
 }

 return rp;
}

void begin_render_pass(RenderPass &rp)
{
 g_rc->render_pass = &rp;
 glUseProgram(rp.program);
 bind_depth_stencil_state(rp.depth_stencil_state);
 bind_rasterizer_state(rp.rasterizer_state);
}

void end_render_pass()
{
 g_rc->render_pass = 0;
}

void set_viewport(float top_left_x, float top_left_y, float width, float height)
{
 glViewport(top_left_x, top_left_y, width, height);
}

void bind_framebuffer(FrameBuffer &framebuffer)
{

 glBindFramebuffer(GL_FRAMEBUFFER, framebuffer.id);
}

void clear_framebuffer_color(FrameBuffer &framebuffer, v4 color)
{
 bind_framebuffer(framebuffer);
 glClearColor(color.x, color.y, color.z, color.w);
 glClear(GL_COLOR_BUFFER_BIT);
}

void clear_framebuffer_depth(FrameBuffer &framebuffer, float depth)
{
 bind_framebuffer(framebuffer);
 glClearDepth(depth);
 glClear(GL_DEPTH_BUFFER_BIT);
}

IndexBuffer create_index_buffer(usize size, uint32_t *indices)
{
 IndexBuffer result = {};

 glGenBuffers(1, &result.ebo);
 glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, result.ebo);
 glBufferData(GL_ELEMENT_ARRAY_BUFFER, size * sizeof(uint32_t), indices, GL_STATIC_DRAW);

 return result;
}

VertexBuffer create_vertex_buffer(VertexBufferUsage usage, usize size, void *data = 0)
{
 VertexBuffer result = {};

 result.usage = usage;
 result.size = size;

 glGenVertexArrays(1, &result.vao);
 glBindVertexArray(result.vao);

 glGenBuffers(1, &result.vbo);
 glBindBuffer(GL_ARRAY_BUFFER, result.vbo);
 if (data)
  glBufferData(GL_ARRAY_BUFFER, size, data, usage == VERTEX_BUFFER_IMMUTABLE ? GL_STATIC_DRAW : GL_DYNAMIC_DRAW);

 return result;
}

void update_vertex_buffer(VertexBuffer &vb, int size, void *data)
{
 assert(vb.usage == VERTEX_BUFFER_DYNAMIC);
 glBindVertexArray(vb.vao);
 glBindBuffer(GL_ARRAY_BUFFER, vb.vbo);
 glBufferData(GL_ARRAY_BUFFER, size, data, GL_DYNAMIC_DRAW);
}

void bind_vertex_buffer(VertexBuffer &vb)
{
 auto &layout = g_rc->render_pass->input_layout;

 glBindVertexArray(vb.vao);
 glBindBuffer(GL_ARRAY_BUFFER, vb.vbo);

 for (int i = 0; i < layout.element_count; i++) {
  int type = 0;
  if (layout.elements[i].type == INPUT_ELEMENT_FLOAT)
   type = GL_FLOAT;
  else if (layout.elements[i].type == INPUT_ELEMENT_SIGNED_INT)
   type = GL_INT;
  else
   assert(0);

  glVertexAttribPointer(i, layout.elements[i].count,
    type, GL_FALSE, (GLsizei) layout.vertex_size, (void *)layout.elements[i].offset);
  glEnableVertexAttribArray(i);
 }
}


void bind_index_buffer(IndexBuffer &ib)
{
 assert(g_rc->render_pass);
 glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, ib.ebo);
}

void draw(int offset, int vertices_count)
{
 int mode = 0;
 if (g_rc->render_pass->primitive_type == PRIMITIVE_TRIANGLES)
  mode = GL_TRIANGLES;
 else if (g_rc->render_pass->primitive_type == PRIMITIVE_LINES)
  mode = GL_LINES;
 else
  assert(0);
 glDrawArrays(mode, offset, vertices_count);
}

void draw_indexed(int offset, int indices_count)
{
 int mode = 0;
 if (g_rc->render_pass->primitive_type == PRIMITIVE_TRIANGLES)
  mode = GL_TRIANGLES;
 else if (g_rc->render_pass->primitive_type == PRIMITIVE_LINES)
  mode = GL_LINES;
 else
  assert(0);
 glDrawElements(mode, indices_count, GL_UNSIGNED_INT, (void *)offset);
}

int get_constant_buffer_element_size(int type)
{
 int size[] = {
  sizeof(mat4),
  sizeof(v4),
  sizeof(v3),
  sizeof(v2),
  sizeof(float),
  sizeof(int)
 };
 static_assert((sizeof(size) / sizeof(*size)) == CONSTANT_BUFFER_ELEMENT_COUNT);
 return size[type];
}


int get_constant_buffer_element_alignement(int type)
{
 int align[] = {
  alignof(mat4),
  alignof(v4),
  alignof(v3),
  alignof(v2),
  alignof(float),
  alignof(int)
 };
 static_assert((sizeof(align) / sizeof(*align)) == CONSTANT_BUFFER_ELEMENT_COUNT);
 return align[type];
}

int get_type_alignement(ConstantBufferElement e)
{
 int align = 0;
 if (e.array_size > 0)
  align = 4 * alignof(float);
 else if (e.type == CONSTANT_BUFFER_ELEMENT_VEC2)
  align = 2 * alignof(float);
 else if (e.type == CONSTANT_BUFFER_ELEMENT_VEC3 || e.type == CONSTANT_BUFFER_ELEMENT_VEC4
   || e.type == CONSTANT_BUFFER_ELEMENT_MAT4)
  align = 4 * alignof(float);
 else if (e.type == CONSTANT_BUFFER_ELEMENT_INT || e.type == CONSTANT_BUFFER_ELEMENT_FLOAT)
  align = alignof(float);
 else
  assert(0);
 return align;
}

int get_type_size(ConstantBufferElement e)
{
 return get_constant_buffer_element_size(e.type);
}


ConstantBuffer create_constant_buffer(Array<ConstantBufferElement> elements)
{
 ConstantBuffer result = {};

 assert(elements.count < (sizeof(result.elements) / sizeof(*result.elements)));
 int offset = 0;
 for (int i = 0; i < elements.count; i++) {
  result.elements[i] = elements[i];

  if (elements[i].array_size) {


   offset = align_to(offset, get_type_alignement(elements[i]));
   int stride = align_to(get_type_size(elements[i]), sizeof(v4));
   offset += stride * elements[i].array_size;
   offset = align_to(offset, get_type_alignement(elements[i]));
  }
  else
   offset = align_to(offset, get_type_alignement(elements[i])) + get_type_size(elements[i]);
 }
 printf("%d\n", offset);

 result.element_count = (int)elements.count;
 result.size = offset;

 glGenBuffers(1, &result.id);
 glBindBuffer(GL_UNIFORM_BUFFER, result.id);

 glBufferData(GL_UNIFORM_BUFFER, result.size, 0, GL_DYNAMIC_DRAW);

 return result;
}

void update_constant_buffer(ConstantBuffer &buffer, void *data)
{
 char dest[sizeof(mat4) * 512] = {};

 assert(buffer.size < sizeof(dest));

 int cstruct_offset = 0;
 int ubo_offset = 0;

 for (int i = 0; i < buffer.element_count; i++) {
  ConstantBufferElement e = buffer.elements[i];

  ubo_offset = align_to(ubo_offset, get_type_alignement(e));
  cstruct_offset = align_to(cstruct_offset, get_constant_buffer_element_alignement(e.type));

  int count = e.array_size ? e.array_size : 1;
  for (int j = 0; j < count; j++) {
   memcpy(dest + ubo_offset, (char *)data + cstruct_offset, get_constant_buffer_element_size(e.type));
   ubo_offset += get_type_size(e);
   cstruct_offset += get_constant_buffer_element_size(e.type);
  }
 }


 glBindBuffer(GL_UNIFORM_BUFFER, buffer.id);
 glBufferSubData(GL_UNIFORM_BUFFER, 0, buffer.size, (void *)dest);
}

void bind_constant_buffer(ConstantBuffer &cbuffer, int index)
{
 glBindBufferBase(GL_UNIFORM_BUFFER, index, cbuffer.id);
}

void begin_render_frame()
{
 g_rc->debug_lines.count = 0;



 ImGui_ImplGlfw_NewFrame();

 ImGui_ImplOpenGL3_NewFrame();
 ImGui::NewFrame();
}

void end_render_frame()
{
 bind_framebuffer(g_rc->window_framebuffer);
 ImGui::Render();
 ImGui_ImplOpenGL3_RenderDrawData(ImGui::GetDrawData());
}

void APIENTRY gl_debug_output(GLenum source, GLenum type, unsigned int id,
  GLenum severity, GLsizei length,
  const char *message, const void *userParam) {

 if (id == 131169 || id == 131185 || id == 131218 || id == 131204)
  return;

 printf("---------------\nOPENGL Debug: (%d): %s\n", id, message);
 printf("Sorce: ");
 switch (source) {
  case GL_DEBUG_SOURCE_API: printf("API"); break;
  case GL_DEBUG_SOURCE_WINDOW_SYSTEM: printf("Window System"); break;
  case GL_DEBUG_SOURCE_SHADER_COMPILER: printf("Shader Compiled"); break;
  case GL_DEBUG_SOURCE_THIRD_PARTY: printf("Third Party"); break;
  case GL_DEBUG_SOURCE_APPLICATION: printf("Application"); break;
  case GL_DEBUG_SOURCE_OTHER: printf("Other"); break;
 }
 printf("\nType: ");

 switch (type) {
  case GL_DEBUG_TYPE_ERROR: printf("Error"); break;
  case GL_DEBUG_TYPE_DEPRECATED_BEHAVIOR: printf("Deprecated Behaviour"); break ;
  case GL_DEBUG_TYPE_UNDEFINED_BEHAVIOR: printf("Undefined Behaviour"); break;
  case GL_DEBUG_TYPE_PORTABILITY: printf("Portability"); break;
  case GL_DEBUG_TYPE_PERFORMANCE: printf("Performance"); break;
  case GL_DEBUG_TYPE_MARKER: printf("Marker"); break;
  case GL_DEBUG_TYPE_PUSH_GROUP: printf("Push Group"); break;
  case GL_DEBUG_TYPE_POP_GROUP: printf("Pop Group"); break;
  case GL_DEBUG_TYPE_OTHER: printf("Other"); break;
 }
 printf("\nSeverity: ");

 switch (severity) {
  case GL_DEBUG_SEVERITY_HIGH: printf("high"); break;
  case GL_DEBUG_SEVERITY_MEDIUM: printf("meduim"); break;
  case GL_DEBUG_SEVERITY_LOW: printf("low"); break;
  case GL_DEBUG_SEVERITY_NOTIFICATION: printf("notification"); break;
 }
 printf("\n\n");
}

void init_render_context_opengl(RenderContext &rc, Platform &platform)
{

 int flags;
 glGetIntegerv(GL_CONTEXT_FLAGS, &flags);
 if (flags & GL_CONTEXT_FLAG_DEBUG_BIT) {
  glEnable(GL_DEBUG_OUTPUT_SYNCHRONOUS);
  glEnable(GL_DEBUG_OUTPUT);
  glDebugMessageCallback(gl_debug_output, nullptr);
  glDebugMessageControl(GL_DONT_CARE, GL_DONT_CARE, GL_DONT_CARE, 0,
    nullptr, GL_TRUE);
 }

 rc.window_framebuffer.id = 0;
 glEnable(GL_FRAMEBUFFER_SRGB);
 glLineWidth(1.5f);
}


Texture create_depth_texture(int width, int height)
{
 Texture result = {};

 uint32_t texture;

 glGenTextures(1, &texture);
 glBindTexture(GL_TEXTURE_2D, texture);
 glTexImage2D(GL_TEXTURE_2D, 0, GL_DEPTH_COMPONENT, width, height,
   0, GL_DEPTH_COMPONENT, GL_FLOAT, 0);
 glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
 glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
 glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
 glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);

 result.id = texture;
 result.valid = true;
 result.name = make_cstring("shadow map depth texture");
 return result;
}

FrameBuffer create_frame_buffer(bool depth_only = false, bool read = false)
{
 FrameBuffer result = {};
 uint32_t fbo;

 glGenFramebuffers(1, &fbo);
 glBindFramebuffer(GL_FRAMEBUFFER, fbo);
 glDrawBuffer(GL_NONE);
 glReadBuffer(GL_NONE);

 if (!depth_only) {
  if (read)
   glReadBuffer(GL_COLOR_ATTACHMENT0);
  GLenum buffers[] = {GL_COLOR_ATTACHMENT0};
  glDrawBuffers(1, buffers);
 }



 result.id = fbo;
 return result;
}

void bind_framebuffer_depthbuffer(FrameBuffer &framebuffer, Texture &texture)
{
 framebuffer.depth_texture = texture;
 bind_framebuffer(framebuffer);
 glFramebufferTexture2D(GL_FRAMEBUFFER, GL_DEPTH_ATTACHMENT, GL_TEXTURE_2D,
   texture.id, 0);
}

void bind_framebuffer_color(FrameBuffer &framebuffer, Texture &texture)
{
 framebuffer.color_texture = texture;
 bind_framebuffer(framebuffer);
 glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D,
   texture.id, 0);
}
# 29 "code/game.cpp" 2


# 1 "code/scene.h" 1
       

#define MAX_BONE_WEIGHTS 4

typedef usize SceneID;


struct Vertex {
    v3 position;
    v3 normal;
    v2 uv;



    float weights[4];
    float indices[4];
};


VertexInputElement g_vertex_input_elements[] = {
    {offsetof(Vertex, position), 3, INPUT_ELEMENT_FLOAT, "POSITION"},
    {offsetof(Vertex, normal), 3, INPUT_ELEMENT_FLOAT, "NORMAL"},
    {offsetof(Vertex, uv), 2, INPUT_ELEMENT_FLOAT, "TEXCOORD"},
    {offsetof(Vertex, weights), 4, INPUT_ELEMENT_FLOAT,
     "BLENDWEIGHT"},
    {offsetof(Vertex, indices), 4, INPUT_ELEMENT_FLOAT,
     "BLENDINDICES"},
};

struct Material {
    Texture diffuse;
    Texture normal_map;
    Texture specular;
    Texture ambient;
    Texture specular_exponent;

    float diffuse_factor;
    float specular_factor;
    float specular_exponent_factor;
};

struct MeshPart {
    Material material;
    usize indices_count;
    usize offset;
};

struct Bone {
    String name;
    mat4 transform;
    mat4 inv_bind;
    int parent;
};

struct Mesh {
    String name;
    Array<MeshPart> parts;

    VertexBuffer vertex_buffer;
    IndexBuffer index_buffer;

    Array<Bone> bones;
    v3 box_min;
    v3 box_max;
    mat4 transform;
 mat4 default_transform;

    usize vertices_count;
    usize indices_count;


    Array<v3> vertices;
 Array<u32> indices;
};

struct NodeAnimation {
    String name;
    Array<v3> position;
    Array<v3> scale;
    Array<quat> rotation;

    v3 const_position;
    v3 const_scale;
    quat const_rotation;

    mat4 transform;
};

struct Animation {
    float timebegin;
    float duration;

    float frametime;

    int frame_count;

    Array<NodeAnimation> nodes;
};

struct SceneNode {
    String name;
    SceneNode *parent;
    Array<SceneNode *> childs;
    Mesh *mesh;
    mat4 local_transform;
    mat4 geometry_transform;
    int id;
    b32 skip_render;
};

struct MeshTriangle {
    v3 v0, v1, v2;
};

struct Scene {
 meta(ui: const) SceneID id;
    meta(ui) String path;
 meta(ui) String name;
 Array<Mesh> meshes;
};
# 32 "code/game.cpp" 2
# 1 "code/game.h" 1
       

#define WORLD_UP V3(0, 0, 1)

struct CollisionMesh {
 meta(serialize) Array<v3> vertices;
 meta(serialize) SceneID scene;
};

struct CollisionShape
{
 CollisionMesh collision_mesh;
 v3 ellipsoid_radius;
 bool ellipsoid;

 mat4 transform;
 v3 scale;
};

struct CollisionInfo
{
 v3 hit_p;
 v3 hit_normal;
 float t;
};

enum EntityType {
    EntityType_Player,
    EntityType_Enemy,
    EntityType_Static,
    EntityType_Projectile,
 EntityType_PointLight,
    EntityType_Count,
};

typedef usize entity_id;

struct Entity {
    meta(ui: const, serialize) entity_id id;

 entity_id parent;

    meta(ui, serialize) EntityType type;
    meta(ui, serialize) v3 position;
    meta(ui, serialize) v3 dp;

    meta(ui, serialize) quat rotation;
    meta(ui, serialize) v3 scale;

    meta(ui: color, serialize) v3 color;

    meta(ui, serialize) b32 moved;
    meta(ui, serialize) b32 run;
    meta(ui, serialize) b32 shooting;
    meta(ui, serialize) b32 can_jump;
    meta(ui, serialize) b32 on_ground;
    meta(ui, serialize) b32 pressing_jump;
    meta(ui, serialize) b32 aiming;

 meta(ui, serialize) bool ellipsoid_collision_shape;
 meta(ui, serialize) v3 ellipsoid_radius;

    meta(ui, serialize) SceneID scene_id;

    meta(ui, serialize) mat4 scene_transform;

 meta(ui, serialize) bool disable_collision;


    Animation *curr_anim;
    Animation *next_anim;
    float anim_time;
    float blend_time;

    Animation *animation;

    float speed;

    meta(ui: const, serialize) float height_above_ground;

 meta(ui, serialize) float point_light_scale;

    float z_rot;
    int last_move;

    float last_gun_time;
};

enum AnimationType {
    ANIMATION_JUMP,
    ANIMATION_SHOOT,
    ANIMATION_RUN,
    ANIMATION_FORWARD_GUN_WALK,
    ANIMATION_BACKWARD_GUN_WALK,
    ANIMATION_GUN_IDLE,
    ANIMATION_COUNT
};

struct ShadowMap {
    FrameBuffer framebuffer;
    v3 light_dir;
    v3 light_p;
    mat4 view;
    mat4 projection;
    int tex_width, tex_height;

    float znear, zfar;
    float width, height;

    Texture depth_texture;
};

enum CameraType {
    CAMERA_TYPE_PERSPECTIVE,
    CAMERA_TYPE_ORTHOGRAPHIC,
};

struct Camera {
    CameraType type;

    v3 position;
    mat4 view;
    mat4 projection;

    float znear, zfar, width, height;
    v3 forward, right, up;
};

enum GizmoMode { GIZMO_TRANSLATION, GIZMO_SCALE, GIZMO_ROTATION };

enum EditorOpType {
    EDITOR_OP_TRANSLATE_ENTITY,
    EDITOR_OP_ROTATE_ENTITY,
    EDITOR_OP_SCALE_ENTITY,
    EDITOR_OP_PASTE_ENTITY,
    EDITOR_OP_DELETE_ENTITY,
    EDITOR_OP_SPAWN_ENTITY,
};

struct EditorOp {
    int type;
    entity_id entity;

    union {
        struct {
            v3 prev_p;
            v3 new_p;
        } translate;
        struct {
            quat prev_rot;
            quat new_rot;
        } rotate;
        struct {
            v3 prev_scale;
            v3 new_scale;
        } scale;
        struct {
            entity_id copy_from;
            entity_id id;
   int mesh_index;
            v3 p;
        } paste;
        struct {
            Entity entity_data;
        } del;
    };
};

struct Editor {
    Array<EditorOp> ops;
    Array<EditorOp> undos;

    Entity init_entity;

 meta(ui) bool edit_collision_mesh;

    meta(ui) bool in_gizmo;
    meta(ui) entity_id selected_entity;
 meta(ui) int selected_entity_mesh;

    meta(ui) entity_id copied_entity;

    meta(ui) GizmoMode gizmo_mode;

    meta(ui) int dragging_axis;
    meta(ui) bool did_drag;

    meta(ui) v3 p_init_drag;

    meta(ui) float s_init_scale;
    meta(ui) float s_init_drag;

    meta(ui) quat r_init_rot;
    meta(ui) float r_init_drag;
    meta(ui) v3 r_right_axis;
    meta(ui) v3 r_up_axis;
    meta(ui) v3 r_axis;

    meta(ui) v3 last_camera_p;

 meta(ui) bool copy_entity_mesh;
};

struct World {
    Arena arena;

    meta(ui) Editor editor;

    meta(ui, serialize) Array<Entity> entities;

    std::unordered_map<entity_id, usize> entities_id_map;
 std::unordered_map<SceneID, int> scene_collision_mesh;

    meta(serialize) entity_id next_entity_id;

    meta(serialize) v3 player_camera_p;
    meta(serialize) v3 player_camera_rotation;
    meta(serialize) v3 player_camera_drotation;

    meta(serialize) v3 editor_camera_p;
    meta(serialize) v3 editor_camera_rotation;

    meta(ui) entity_id editor_selected_entity;
    meta(serialize) entity_id player_id;

    entity_id moving_box;

    Camera last_game_camera;

    float aim_camera_transition_t;

 meta(serialize) Array<CollisionMesh> collision_meshes;
};

struct LoadedSound
{
    int sample_count;
    float *samples;
};

struct SoundPlaying
{
    entity_id entity;
    int samples_played;
    LoadedSound *sound;
    SoundPlaying *next;
    SoundPlaying *prev;
};

struct SoundState
{
 float *buffer;
    int sample_count;

 std::atomic_int32_t read_index;
 std::atomic_int32_t write_index;
};


struct Game {

    Arena *memory;


    std::atomic_bool is_initialized;

    World *world;

    ShadowMap shadow_map;

    RenderPass mesh_render_pass;
    RenderPass shadow_map_render_pass;
    RenderPass outline_render_pass;
    ConstantBuffer constant_buffer;

    RenderPass debug_lines_render_pass;
    VertexBuffer debug_lines_vertex_buffer;
    ConstantBuffer debug_lines_constant_buffer;

    Arena asset_arena;

 meta(ui) Array<Scene> scenes;
 usize next_scene_id;

    Animation animations[ANIMATION_COUNT];

    b32 in_editor;
    meta(ui) bool debug_collision;

    meta(ui) int frame;
    meta(ui) float time;

    RasterizerState default_rasterizer_state, wireframe_rasterizer_state;
    DepthStencilState default_depth_stencil_state;
    DepthStencilState disable_depth_state;

    FrameBuffer debug_asset_fb;
    Texture debug_asset_tex;

    SoundState sound_state;

    SoundPlaying *first_playing_sound;
    LoadedSound loaded_sounds[32];

 Scene default_scene;

    meta(ui) bool show_normals;
    meta(ui) bool render_bones;
    meta(ui) bool frustum_culling;
    meta(ui) float master_volume;
};

struct Constants {
    mat4 view;
    mat4 projection;
    mat4 model;
    mat4 light_transform;
    mat4 bones[96];

 int point_light_count;
 v4 point_light_color[8];
 v4 point_light_position[8];

    v3 camera_p;
    v3 player_p;
    v3 color;
    float diffuse_factor;

    float specular_factor;
    float specular_exponent_factor;
    int skinned;
    int has_normal_map;
    int show_normals;
};
# 33 "code/game.cpp" 2
# 1 "code/scene.cpp" 1



v3 ufbx_to_v3(ufbx_vec3 v)
{
 return v3{(float)v.x, (float)v.y, (float)v.z};
}

v2 ufbx_to_v2(ufbx_vec2 v)
{
 return v2{(float)v.x, (float)v.y};
}

quat ufbx_to_quat(ufbx_quat q)
{
 return quat{(float)q.x, (float)q.y, (float)q.z, (float)q.w};
}

mat4 ufbx_to_mat4(ufbx_matrix m)
{
 mat4 result = {};

 for (int i = 0; i < 4; i++) {
  result.e[0][i] = m.cols[i].x;
  result.e[1][i] = m.cols[i].y;
  result.e[2][i] = m.cols[i].z;
 }

 result.e[3][3] = 1;

 return (result);
}
# 50 "code/scene.cpp"
Texture load_texture(Arena *arena, Scene &scene, ufbx_texture *utex, bool srgb = true)
{
 assert(utex->type == UFBX_TEXTURE_FILE);


 stbi_set_flip_vertically_on_load(true);

 String name = make_string(arena, utex->filename.length, utex->filename.data);
 assert(name.count);

 if (name.count) {
  for (int i = 0; i < g_rc->loaded_textures.count; i++) {
   if (strings_equal(g_rc->loaded_textures[i].name, name))
    return g_rc->loaded_textures[i];
  }
 }
 void *data;
 int width, height, n_channels;
 Arena *temp = begin_temp_memory();
 if (utex->content.size) {
  data = stbi_load_from_memory((stbi_uc *)utex->content.data,
    (int)utex->content.size, &width, &height,
    &n_channels, 4);
 } else {
  int last_slash = (int)utex->filename.length - 1;

  while (last_slash >= 0 &&
    (utex->filename.data[last_slash] != '/' &&
     utex->filename.data[last_slash] != '\\'))
   last_slash--;
  last_slash++;

  String path = concact_string(temp, scene.path, make_string(temp, utex->filename.length - last_slash, utex->filename.data + last_slash));
  path = concact_string(temp, path, make_string(temp, 1, ""));


  data = stbi_load(path.data, &width, &height, &n_channels, 4);
  if (!data)
   printf("failed to load texture file: %s\n", path.data);
 }

 end_temp_memory();

 Texture texture = create_texture(name, data, width, height, srgb);
 if (name.count)
  g_rc->loaded_textures.push(texture);

 return texture;
}

Material load_material(Arena *arena, Scene &scene, ufbx_material *umat)
{
 Material mat = {};

 if (umat->fbx.diffuse_color.texture_enabled)
  mat.diffuse = load_texture(arena, scene, umat->fbx.diffuse_color.texture);
 if (umat->fbx.specular_color.texture_enabled)
  mat.specular = load_texture(arena, scene, umat->fbx.specular_color.texture);
 if (umat->fbx.normal_map.texture_enabled)
  mat.normal_map = load_texture(arena, scene, umat->fbx.normal_map.texture, false);
 else if (umat->fbx.bump.texture_enabled)
  mat.normal_map = load_texture(arena, scene, umat->fbx.bump.texture, false);

 if (umat->fbx.specular_exponent.texture_enabled)
  mat.specular_exponent = load_texture(arena, scene, umat->fbx.specular_exponent.texture, false);

 mat.diffuse_factor = umat->fbx.diffuse_factor.has_value ? umat->fbx.diffuse_factor.value_real : 1;
 mat.specular_factor = umat->fbx.specular_factor.has_value ? umat->fbx.specular_factor.value_real : 1;
 mat.specular_exponent_factor = umat->fbx.specular_exponent.has_value ? umat->fbx.specular_exponent.value_real : 20;
 return mat;
}

Vertex get_ufbx_vertex(ufbx_mesh *umesh, ufbx_skin_deformer *skin, int index)
{
 Vertex v = {};

 v.position = ufbx_to_v3(ufbx_get_vertex_vec3(&umesh->vertex_position, index));
 v.normal = ufbx_to_v3(ufbx_get_vertex_vec3(&umesh->vertex_normal, index));
 if (umesh->vertex_uv.exists)
  v.uv = ufbx_to_v2(ufbx_get_vertex_vec2(&umesh->vertex_uv, index));

 if (skin) {
  uint32_t vertex = umesh->vertex_indices.data[index];

  ufbx_skin_vertex skin_vertex = skin->vertices.data[vertex];
  size_t num_weights = skin_vertex.num_weights;
  if (num_weights > 4)
   num_weights = 4;

  float total_weight = 0.0f;
  for (size_t i = 0; i < num_weights; i++) {
   ufbx_skin_weight skin_weight = skin->weights.data[skin_vertex.weight_begin + i];
   v.indices[i] = skin_weight.cluster_index;
   v.weights[i] = (float)skin_weight.weight;
   total_weight += (float)skin_weight.weight;
  }

  for (size_t i = 0; i < num_weights; i++)
   v.weights[i] /= total_weight;
 }
 return v;
}

void make_bones_transform_relative_to_parent(Array<Bone> bones, usize index, Array<bool> computed)
{
 if (computed[index] || bones[index].parent == -1)
  return ;
 make_bones_transform_relative_to_parent(bones, bones[index].parent, computed);
 mat4 M = identity();
 int i = bones[index].parent;
 while (i != -1)
 {
  M = bones[i].transform * M;
  i = bones[i].parent;
 }
 bones[index].transform = inverse(M) * bones[index].transform;
 computed[index] = true;
}

Mesh load_mesh(Arena *arena, Scene &scene, ufbx_node *unode)
{
 ufbx_mesh *umesh = unode->mesh;

 Mesh mesh = {};

 mesh.name = make_string(arena, unode->name.length, unode->name.data);
 mesh.parts = make_array<MeshPart>(arena, umesh->material_parts.count);

 Arena *tmp_arena = begin_temp_memory();

 Array<uint32_t> tri_indices = make_array<uint32_t>(tmp_arena, umesh->max_face_triangles * 3);

 Array<Vertex> vertices = make_array_max<Vertex>(tmp_arena, umesh->num_triangles * 3);
 Array<uint32_t> indices = make_array_max<uint32_t>(tmp_arena, umesh->num_triangles * 3);

 ufbx_skin_deformer *skin = 0;

 if (umesh->skin_deformers.count) {
  assert(umesh->skin_deformers.count == 1);
  skin = umesh->skin_deformers.data[0];
  assert(skin->skinning_method == UFBX_SKINNING_METHOD_LINEAR);


  mesh.bones = make_array<Bone>(arena, skin->clusters.count);
  for (usize i = 0; i < mesh.bones.count; i++) {
   ufbx_skin_cluster *cluster = skin->clusters.data[i];

   mesh.bones[i].inv_bind = ufbx_to_mat4(cluster->geometry_to_bone);
   mesh.bones[i].transform = inverse(mesh.bones[i].inv_bind);
   mesh.bones[i].parent = -1;
   mesh.bones[i].name = make_string(arena, cluster->bone_node->name.length,
     cluster->bone_node->name.data);


   for (int j = 0; j < mesh.bones.count; j++) {
    if (cluster->bone_node->parent == skin->clusters.data[j]->bone_node) {
     mesh.bones[i].parent = j;
     break ;
    }
   }






   if (mesh.bones[i].parent == -1)
    assert(cluster->bone_node->parent->bone == 0);
  }
  Array<bool> computed = make_zero_array<bool>(tmp_arena, mesh.bones.count);
  for (usize i = 0; i < mesh.bones.count; i++)
   make_bones_transform_relative_to_parent(mesh.bones, i, computed);
 }
 uint32_t max_used_index = 0;
 for (usize part_idx = 0; part_idx < umesh->material_parts.count; part_idx++) {
  MeshPart &part = mesh.parts[part_idx];
  part.offset = indices.count;

  ufbx_mesh_part upart = umesh->material_parts.data[part_idx];
  uint32_t num_vertices = 0;

  for (usize face_idx = 0; face_idx < upart.num_faces; face_idx++) {
   ufbx_face face = umesh->faces.data[upart.face_indices.data[face_idx]];
   uint32_t num_tris = ufbx_triangulate_face(tri_indices.data, tri_indices.count, umesh, face);

   for (size_t i = 0; i < num_tris * 3; i++) {
    max_used_index = max(max_used_index, tri_indices[i]);
    indices.push(tri_indices[i]);
   }
  }
  if (upart.face_indices.count && umesh->face_material.count) {

   part.material = load_material(arena, scene,
     umesh->materials.data[umesh->face_material.data[upart.face_indices.data[0]]]);
  }

  part.indices_count = indices.count - part.offset;
 }

 for (uint32_t index = 0; index < max_used_index + 1; index++)
  vertices.push(get_ufbx_vertex(umesh, skin, index));

 mesh.vertex_buffer = create_vertex_buffer(VERTEX_BUFFER_IMMUTABLE,
   vertices.count * sizeof(Vertex), vertices.data);
 mesh.index_buffer = create_index_buffer(indices.count, indices.data);


 mesh.box_min = V3(1e18);
 mesh.box_max = V3(-1e18);
 for (usize i = 0; i < indices.count; i++) {
  mesh.box_min = min(mesh.box_min, vertices[(int)indices[i]].position);
  mesh.box_max = max(mesh.box_max, vertices[(int)indices[i]].position);
 }

 mesh.vertices_count = vertices.count;
 mesh.indices_count = indices.count;

 mesh.vertices = make_array<v3>(arena, vertices.count);


 for (usize i = 0; i < vertices.count; i++) {
  mesh.vertices[i] = vertices[i].position;
 }


 mesh.indices = clone_array(arena, indices);
# 285 "code/scene.cpp"
 end_temp_memory();
 return mesh;
}

void *ufbx_arena_realloc(void *user, void *old_ptr, size_t old_size, size_t new_size)
{
 Arena *arena = (Arena *)user;

 void *data = _arena_alloc("code/scene.cpp", __func__, 293, arena, new_size);

 if (old_size > new_size)
  old_size = new_size;
 if (old_size)
  memcpy(data, old_ptr, old_size);
 return data;
}

b32 quat_equal(quat a, quat b)
{
 const float eps = 1e-9;
 return fabsf(a.x - b.x) < eps &&
  fabsf(a.y - b.y) < eps &&
  fabsf(a.z - b.z) < eps &&
  fabsf(a.w - b.w) < eps;
}

mat4 get_animated_node_transform(Animation &anim, NodeAnimation &node, float anim_time)
{
 int frame = anim_time / anim.frametime;
 if (frame >= anim.frame_count)
  frame = anim.frame_count - 1;

 int next_frame = frame + 1 == anim.frame_count ? frame : frame + 1;
 float t = (anim_time - frame * anim.frametime) / anim.frametime;

 v3 position = node.const_position;
 quat rotation = node.const_rotation;
 v3 s = node.const_scale;

 if (node.position.count)
  position = lerp(node.position[frame], node.position[next_frame], t);
 if (node.rotation.count)
  rotation = quat_lerp(node.rotation[frame], node.rotation[next_frame], t);
 if (node.scale.count)
  s = lerp(node.scale[frame], node.scale[next_frame], t);
 return translate(position) * quat_to_mat(rotation) * scale(s);
}

void get_animated_node_transform(Animation &anim, NodeAnimation &node, float anim_time,
  v3 &position, v3 &s, quat &rotation)
{
 int frame = anim_time / anim.frametime;
 if (frame >= anim.frame_count)
  frame = anim.frame_count - 1;

 int next_frame = frame + 1 == anim.frame_count ? frame : frame + 1;
 float t = (anim_time - frame * anim.frametime) / anim.frametime;

 position = node.const_position;
 rotation = node.const_rotation;
 s = node.const_scale;

 if (node.position.count)
  position = lerp(node.position[frame], node.position[next_frame], t);
 if (node.rotation.count)
  rotation = quat_lerp(node.rotation[frame], node.rotation[next_frame], t);
 if (node.scale.count)
  s = lerp(node.scale[frame], node.scale[next_frame], t);
}

Animation load_animation(Arena *arena, ufbx_scene *uscene, ufbx_anim_stack *stack)
{
 Arena *temp = begin_temp_memory();

 Animation anim = {};

 anim.timebegin = stack->time_begin;
 anim.duration = stack->time_end - stack->time_begin;
 int target_framerate = 60;

 anim.frame_count = (u32)(anim.duration * target_framerate);
 if (anim.frame_count < 2)
  anim.frame_count = 2;
 anim.frametime = anim.duration / (anim.frame_count - 1);

 Array<v3> position = make_array<v3>(temp, anim.frame_count);
 Array<quat> rotation = make_array<quat>(temp, anim.frame_count);
 Array<v3> scale = make_array<v3>(temp, anim.frame_count);

 anim.nodes = make_array_max<NodeAnimation>(arena, uscene->nodes.count);
 for (usize j = 0; j < uscene->nodes.count; j++) {
  ufbx_node *node = uscene->nodes.data[j];
  if (node->is_root)
   continue ;
  NodeAnimation node_anim = {};
  node_anim.name = make_string(arena, (usize)node->name.length, (char *)node->name.data);

  b32 const_position = true;
  b32 const_scale = true;
  b32 const_rotation = true;

  for (usize frame = 0; frame < anim.frame_count; frame++) {
   float t = anim.timebegin + frame * anim.frametime;
   ufbx_transform transform = ufbx_evaluate_transform(stack->anim, node, t);

   position[frame] = ufbx_to_v3(transform.translation);
   rotation[frame] = ufbx_to_quat(transform.rotation);
   scale[frame] = ufbx_to_v3(transform.scale);

   if (frame) {



    if (dot(rotation[frame], rotation[frame - 1]) < 0.0f)
     rotation[frame] = -rotation[frame];

    if (!v3_equal(position[frame - 1], position[frame]))
     const_position = false;
    if (!quat_equal(rotation[frame - 1], rotation[frame]))
     const_rotation = false;
    if (!v3_equal(scale[frame - 1], scale[frame]))
     const_scale = false;
   }

  }



  if (const_position)
   node_anim.const_position = position[0];
  else
   node_anim.position = clone_array(arena, position);
  if (const_rotation)
   node_anim.const_rotation = rotation[0];
  else
   node_anim.rotation = clone_array(arena, rotation);
  if (const_scale)
   node_anim.const_scale = scale[0];
  else
   node_anim.scale = clone_array(arena, scale);

  anim.nodes.push(node_anim);
 }

 end_temp_memory();

 return anim;
}

Animation load_animation(Arena *arena, Game &game, const char *filename)
{
 Scene scene = {};

 Arena *temp = begin_temp_memory();

 ufbx_load_opts opts = {};

 opts.target_axes.right = UFBX_COORDINATE_AXIS_POSITIVE_X;
 opts.target_axes.up = UFBX_COORDINATE_AXIS_POSITIVE_Z;
 opts.target_axes.front = UFBX_COORDINATE_AXIS_POSITIVE_Y;
 opts.target_unit_meters = 1;
 opts.temp_allocator.allocator.realloc_fn = ufbx_arena_realloc;
 opts.temp_allocator.allocator.user = temp;
 opts.result_allocator.allocator.realloc_fn = ufbx_arena_realloc;
 opts.result_allocator.allocator.user = temp;

 ufbx_error error;
 ufbx_scene *uscene = ufbx_load_file(filename, &opts, &error);
 if (!uscene) {
  fprintf(
# 454 "code/scene.cpp" 3 4
         stderr
# 454 "code/scene.cpp"
               , "Failed to load animation %s: %s\n", filename, error.description.data);
  exit(1);
 }
 assert(uscene->anim_stacks.count);
 return load_animation(arena, uscene, uscene->anim_stacks.data[0]);
}

Scene *load_scene(Arena *arena, Game &game, const char *filename)
{
 Scene scene = {};

 Arena *temp = begin_temp_memory();
 {
  int slash = -1;

  for (int i = 0; filename[i]; i++) {
   if (filename[i] == '/' || filename[i] == '\\')
    slash = i;
  }

  int len = strlen(filename);
  scene.path = make_string(arena, slash + 1, filename);
  scene.name = make_string(arena, len - (slash + 1), filename + slash + 1);
 }

 ufbx_load_opts opts = {};

 opts.target_axes.right = UFBX_COORDINATE_AXIS_POSITIVE_X;
 opts.target_axes.up = UFBX_COORDINATE_AXIS_POSITIVE_Z;
 opts.target_axes.front = UFBX_COORDINATE_AXIS_POSITIVE_Y;
 opts.target_unit_meters = 1;

 opts.temp_allocator.allocator.realloc_fn = ufbx_arena_realloc;
 opts.temp_allocator.allocator.user = temp;
 opts.result_allocator.allocator.realloc_fn = ufbx_arena_realloc;
 opts.result_allocator.allocator.user = temp;
 opts.generate_missing_normals = true;
 opts.load_external_files = true;




 ufbx_error error;
 ufbx_scene *uscene = ufbx_load_file(filename, &opts, &error);
 if (!uscene) {
  fprintf(
# 499 "code/scene.cpp" 3 4
         stderr
# 499 "code/scene.cpp"
               , "Failed to load %s: %s\n", filename, error.description.data);
  exit(1);
 }


 usize total_num_triangles = 0;
 for (size_t i = 0; i < uscene->nodes.count; i++)
  if (uscene->nodes.data[i]->mesh)
   total_num_triangles += uscene->nodes.data[i]->mesh->num_triangles;

 printf("loading scene %s (%zd meshes, %zd triangles)\n", filename, uscene->meshes.count, total_num_triangles);

 mat4 root_transform = ufbx_to_mat4(uscene->root_node->node_to_parent);

 scene.meshes = make_array_max<Mesh>(arena, uscene->meshes.count);

 for (usize i = 0; i < uscene->nodes.count; i++) {
  if (uscene->nodes.data[i]->mesh) {
   Mesh mesh = load_mesh(arena, scene, uscene->nodes.data[i]);
   mesh.transform = ufbx_to_mat4(uscene->nodes.data[i]->geometry_to_world);

   double center[3] = {};
   for (usize j = 0; j < mesh.vertices.count; j++)
    for (int k = 0; k < 3; k++)
     center[k] += mesh.vertices[j].e[k];
   for (int k = 0; k < 3; k++)
    center[k] /= mesh.vertices.count;

   mesh.default_transform = root_transform * translate(-V3(center[0], center[1], center[2]));

   scene.meshes.push(mesh);
  }
 }

 end_temp_memory();
 scene.id = ++game.next_scene_id;
 game.scenes.push(scene);
 return &game.scenes[game.scenes.count - 1];
}
# 34 "code/game.cpp" 2

SceneID get_scene_id_by_name(Game &game, String name)
{
 for (int i = 0; i < game.scenes.count; i++) {
  if (strings_equal(game.scenes[i].name, name))
   return game.scenes[i].id;
 }
 printf("WARN: couldn't find scene %.*s\n", (int)name.count, name.data);
 return 0;
}

Scene &get_scene_by_id(Game &game, SceneID id)
{
 for (int i = 0; i < game.scenes.count; i++) {
  if (game.scenes[i].id == id)
   return game.scenes[i];
 }
 return game.default_scene;
}

Camera make_perspective_camera(mat4 view, float znear, float zfar, float width_fov_degree, float height_over_width)
{
 Camera camera = {};

 camera.type = CAMERA_TYPE_PERSPECTIVE;
 camera.znear = znear;
 camera.zfar = zfar;
 camera.width = 2 * znear * tanf((3.14159265359f / 180.f) * (width_fov_degree / 2));
 camera.height = camera.width * height_over_width;
 camera.view = view;
 camera.projection = perspective_projection(znear, zfar, camera.width, camera.height);

 mat4 inv_view = inverse(view);
 camera.position = V3(inv_view.e[0][3], inv_view.e[1][3], inv_view.e[2][3]);
 camera.right = V3(inv_view.e[0][0], inv_view.e[1][0], inv_view.e[2][0]);
 camera.up = V3(inv_view.e[0][1], inv_view.e[1][1], inv_view.e[2][1]);
 camera.forward = -V3(inv_view.e[0][2], inv_view.e[1][2], inv_view.e[2][2]);

 return camera;
}

Camera make_orthographic_camera(mat4 view, float znear, float zfar, float width, float height)
{
 Camera camera = {};

 camera.type = CAMERA_TYPE_ORTHOGRAPHIC;
 camera.znear = znear;
 camera.zfar = zfar;
 camera.width = width;
 camera.height = height;
 camera.view = view;
 camera.projection = orthographic_projection(znear, zfar, width, height);
 mat4 inv_view = inverse(view);
 camera.position = V3(inv_view.e[0][3], inv_view.e[1][3], inv_view.e[2][3]);
 camera.right = V3(inv_view.e[0][0], inv_view.e[0][1], inv_view.e[0][2]);
 camera.up = V3(inv_view.e[1][0], inv_view.e[1][1], inv_view.e[1][2]);
 camera.forward = V3(inv_view.e[2][0], inv_view.e[2][1], inv_view.e[2][2]);

 return camera;
}

Entity *get_entity(World &world, entity_id id);
mat4 get_entity_transform(World &world, Entity &e);
v3 get_world_p(World &world, entity_id id);





# 1 "code/sound.cpp" 1
#define SOUND_CHANNEL_COUNT 2
#define SOUND_SAMPLE_RATE 48000

LoadedSound load_wav_file(Arena *arena, const char *filename)
{
    ma_decoder_config config = ma_decoder_config_init(ma_format_f32, 2, 48000);

    ma_decoder decoder;
    ma_result result = ma_decoder_init_file(filename, &config, &decoder);
    if (result != MA_SUCCESS)
        assert(0);
    LoadedSound sound = {};

    ma_uint64 samplesToRead = 1024;
 sound.samples = (float *)_arena_alloc("code/sound.cpp", __func__, 15, arena, samplesToRead * sizeof(float) * 2);

    while (1) {
        ma_uint64 samplesRead = 0;
        result = ma_decoder_read_pcm_frames(&decoder, sound.samples + sound.sample_count*2,
   samplesToRead, &samplesRead);
        sound.sample_count += samplesRead;
        if (samplesRead < samplesToRead)
            break ;

  _arena_alloc("code/sound.cpp", __func__, 25, arena, samplesToRead * sizeof(float) * 2);
    }
 printf("loaded sound %s, %d samples\n", filename, sound.sample_count);
    return sound;
}

void audio_write_callback(ma_device* device, void* output, const void* input, ma_uint32 frame_count)
{
 Game &game = *((Game *)device->pUserData);
 if (!game.is_initialized)
  return ;

 int read_index = game.sound_state.read_index;
 int write_index = game.sound_state.write_index;


 if (read_index == write_index)
  return ;

 if (read_index < write_index) {
  int samples_to_read = min(write_index - read_index, (int)frame_count);
  memcpy(output, game.sound_state.buffer + read_index * 2,
   samples_to_read * 2 * sizeof(float));
  game.sound_state.read_index = read_index + samples_to_read;
 }
 else {
  int samples_to_copy = min((int)frame_count, game.sound_state.sample_count - read_index);
  memcpy(output, game.sound_state.buffer + read_index * 2,
   samples_to_copy * 2 * sizeof(float));
  frame_count -= samples_to_copy;
  memcpy(output, game.sound_state.buffer,
   min(write_index, (int)frame_count) * 2 * sizeof(float));

  game.sound_state.read_index = (read_index + samples_to_copy
   + min(write_index, (int)frame_count)) % game.sound_state.sample_count;
 }
# 82 "code/sound.cpp"
}

void play_sound(Game &game, LoadedSound &loaded_sound, entity_id entity = 0)
{
 SoundPlaying *sound = (SoundPlaying *)arena_alloc_zero(game.memory, sizeof(SoundPlaying));
 sound->sound = &loaded_sound;
 sound->entity = entity;

 sound->next = game.first_playing_sound;
 if (game.first_playing_sound)
  game.first_playing_sound->prev = sound;
 game.first_playing_sound = sound;
}

void update_sound(Game &game, World &world)
{
 if (!game.first_playing_sound)
  return ;

 SoundState &state = game.sound_state;



 int frames_to_write = 1;
 int fps = 60;
 int max_samples_to_write = ((48000 * frames_to_write) / fps);


 int write_index = state.write_index;
 int read_index = state.read_index;


 int can_write = 0;
 if (read_index <= write_index)
  can_write = read_index + state.sample_count - write_index;
 else
  can_write = read_index - write_index;

 can_write -= 1;

 max_samples_to_write = min(max_samples_to_write, can_write);

 if (max_samples_to_write <= 0)
  return ;

 Entity *player = get_entity(world, world.player_id);
 v3 player_forward = normalize(V3(cosf(world.player_camera_rotation.z), sinf(world.player_camera_rotation.z), 0));
 v3 player_up = V3(0, 0, 1);
 v3 player_right = normalize(cross(player_forward, player_up));

 int index = write_index;
 for (int sample = 0; sample < max_samples_to_write; sample++) {
  for (int i = 0; i < 2; i++)
   state.buffer[index * 2 + i] = 0;
  index++;
  if (index == state.sample_count)
   index = 0;
 }


 for (SoundPlaying *playing_sound = game.first_playing_sound;
  playing_sound;) {

  Entity *e = get_entity(world, playing_sound->entity);
  float volume[2] = {1, 1};
  if (e) {
   v3 to_e = normalize(e->position - world.player_camera_p);
   float x = dot(to_e, player_right);
   float y = dot(to_e, player_forward);
   float a = fabsf(atan2(y, x));
   a = a / 3.14159265359f;
   volume[0] = a;
   volume[1] = 1 - a;

   float dist = 1 - logf(length(e->position - world.player_camera_p)) / 5;
   if (dist < 0)
    dist = 0;
   volume[0] *= dist;
   volume[1] *= dist;
  }

  int samples_to_write = min(max_samples_to_write,
  playing_sound->sound->sample_count - playing_sound->samples_played);

  index = write_index;
  for (int sample = 0; sample < samples_to_write; sample++) {
   for (int i = 0; i < 2; i++) {
    state.buffer[index * 2 + i] +=
     playing_sound->sound->samples[playing_sound->samples_played
      * 2 + i] * volume[i] * game.master_volume;
   }
   playing_sound->samples_played++;
   index++;
   if (index == state.sample_count)
    index = 0;
  }
  SoundPlaying *next = playing_sound->next;
  if (playing_sound->samples_played == playing_sound->sound->sample_count) {
   if (next)
    next->prev = playing_sound->prev;
   if (playing_sound->prev)
    playing_sound->prev->next = next;
   if (game.first_playing_sound == playing_sound)
    game.first_playing_sound = next;
  }
  playing_sound = next;
 }


 int new_write_index = (write_index + max_samples_to_write) % state.sample_count;
 state.write_index = new_write_index;
}
# 104 "code/game.cpp" 2
# 1 "code/renderer.cpp" 1
void init_render_context(Arena *arena, RenderContext &rc, Platform &platform)
{

 init_render_context_opengl(rc, platform);



 rc.loaded_textures = make_array_max<Texture>(arena, 256);
 rc.debug_lines = make_array_max<v3>(arena, 4 * 500000);

 uint32_t white_color = 0xffffffff;
 rc.white_texture = create_texture(make_cstring("__white_texture"), &white_color, 1, 1, true);
}

void push_line(v3 a, v3 b, v3 color = V3(1))
{
 g_rc->debug_lines.push(a);
 g_rc->debug_lines.push(color);
 g_rc->debug_lines.push(b);
 g_rc->debug_lines.push(color);
}

void push_cube_outline(v3 center, v3 radius, v3 color = V3(1))
{
 v3 p00 = center + V3(-radius.x, -radius.y, -radius.z);
 v3 p01 = center + V3(+radius.x, -radius.y, -radius.z);
 v3 p02 = center + V3(+radius.x, +radius.y, -radius.z);
 v3 p03 = center + V3(-radius.x, +radius.y, -radius.z);
 v3 p10 = center + V3(-radius.x, -radius.y, +radius.z);
 v3 p11 = center + V3(+radius.x, -radius.y, +radius.z);
 v3 p12 = center + V3(+radius.x, +radius.y, +radius.z);
 v3 p13 = center + V3(-radius.x, +radius.y, +radius.z);

 push_line(p00, p01, color);
 push_line(p01, p02, color);
 push_line(p02, p03, color);
 push_line(p03, p00, color);

 push_line(p10, p11, color);
 push_line(p11, p12, color);
 push_line(p12, p13, color);
 push_line(p13, p10, color);

 push_line(p00, p10, color);
 push_line(p01, p11, color);
 push_line(p02, p12, color);
 push_line(p03, p13, color);
}

void push_box_outline(v3 center,
  v3 x_axis, v3 y_axis, v3 z_axis, v3 color = V3(1))
{
# 65 "code/renderer.cpp"
 v3 p[8];
 int i = 0;






 for (int dz = -1; dz <= 1; dz++) {
  for (int dy = -1; dy <= 1; dy++) {
   for (int dx = -1; dx <= 1; dx++) {
    if (dx && dy && dz) {
     p[i++] = center + x_axis * dx
      + y_axis * dy
      + z_axis * dz;
    }
   }
  }
 }

 v3 p00 = p[0];
 v3 p01 = p[1];
 v3 p02 = p[3];
 v3 p03 = p[2];

 v3 p10 = p[4];
 v3 p11 = p[5];
 v3 p12 = p[7];
 v3 p13 = p[6];


 push_line(p00, p01, color);
 push_line(p01, p02, color);
 push_line(p02, p03, color);
 push_line(p03, p00, color);

 push_line(p10, p11, color);
 push_line(p11, p12, color);
 push_line(p12, p13, color);
 push_line(p13, p10, color);

 push_line(p00, p10, color);
 push_line(p01, p11, color);
 push_line(p02, p12, color);
 push_line(p03, p13, color);
}

void push_triangle_outline(v3 p0, v3 p1, v3 p2, v3 color = V3(1))
{
 push_line(p0, p1, color);
 push_line(p1, p2, color);
 push_line(p2, p0, color);
}

void push_ellipsoid_outline(v3 p, v3 r, v3 color = V3(1))
{
 v3 x = V3(r.x, 0, 0);
 v3 y = V3(0, r.y, 0);
 v3 z = V3(0, 0, r.z);

 int itr_count = 60;
 float a = (2 * 3.14159265359f) / itr_count;

 for (int itr = 0; itr < itr_count; itr++)
 {
  float a0 = a * itr;
  float a1 = a * (itr + 1);

  v3 px0 = p + x * cosf(a0) + y * sinf(a0);
  v3 px1 = p + x * cosf(a1) + y * sinf(a1);

  v3 py0 = p + y * cosf(a0) + z * sinf(a0);
  v3 py1 = p + y * cosf(a1) + z * sinf(a1);

  v3 pz0 = p + x * cosf(a0) + z * sinf(a0);
  v3 pz1 = p + x * cosf(a1) + z * sinf(a1);

  push_line(px0, px1, color);
  push_line(py0, py1, color);
  push_line(pz0, pz1, color);
 }
}

void push_circle(v3 p, float r, v3 right_axis, v3 up_axis, v3 color = V3(1))
{
 right_axis = normalize(right_axis);
 up_axis = normalize(up_axis);

 int itr_count = 60;
 float a = (2 * 3.14159265359f) / itr_count;

 for (int itr = 0; itr < itr_count; itr++)
 {
  float a0 = a * itr;
  float a1 = a * (itr + 1);

  v3 p0 = p + r * (right_axis * cosf(a0) + up_axis * sinf(a0));
  v3 p1 = p + r * (right_axis * cosf(a1) + up_axis * sinf(a1));

  push_line(p0, p1, color);
 }
}

void compute_bone_transform(Array<Bone> bones, int i, Array<bool> computed)
{
 if (computed[i] || bones[i].parent == -1)
  return ;
 compute_bone_transform(bones, bones[i].parent, computed);
 bones[i].transform = bones[bones[i].parent].transform * bones[i].transform;
 computed[i] = true;
}

void render_bones(Array<Bone> bones, mat4 transform, Animation *anim, float anim_time)
{
 if (bones.count == 0)
  return ;

 Arena *temp = begin_temp_memory();

 Array<Bone> anim_bones = clone_array(temp, bones);

 if (anim) {
  for (usize i = 0; i < bones.count; i++) {
   int index = -1;
   for (usize j = 0; j < anim->nodes.count; j++) {
    if (strings_equal(anim->nodes[j].name, anim_bones[i].name)) {
     index = (int)j;
     break ;
    }
   }
   if (index != -1)
    anim_bones[i].transform = anim->nodes[index].transform;
  }
 }

 Array<bool> computed = make_array<bool>(temp, anim_bones.count);
 for (int i = 0; i < anim_bones.count; i++)
  computed[i] = false;
 for (int i = 0; i < anim_bones.count; i++)
  compute_bone_transform(anim_bones, i, computed);
 for (int i = 0; i < anim_bones.count; i++)
  anim_bones[i].transform = transform * anim_bones[i].transform;

 for (usize i = 0; i < anim_bones.count; i++) {
  v3 P = (anim_bones[i].transform * v4{0, 0, 0, 1}).xyz;

  if (anim_bones[i].parent != -1) {
   v3 parentP = (anim_bones[anim_bones[i].parent].transform * v4{0, 0, 0, 1}).xyz;
   push_line(P, parentP);
  }
 }

 end_temp_memory();
}

Array<Bone> get_animated_bones(Arena *arena, Array<Bone> bones, mat4 transform, Animation *anim, float anim_time)
{
 Array<Bone> anim_bones = clone_array(arena, bones);

 for (usize i = 0; i < bones.count; i++) {
  int index = -1;
  for (usize j = 0; j < anim->nodes.count; j++) {
   if (strings_equal(anim->nodes[j].name, anim_bones[i].name)) {
    index = (int)j;
    break ;
   }
  }
  if (index != -1) {
   anim_bones[i].transform = anim->nodes[index].transform;
  }
 }

 Array<bool> computed = make_zero_array<bool>(arena, anim_bones.count);
 for (int i = 0; i < anim_bones.count; i++)
  compute_bone_transform(anim_bones, i, computed);
 for (int i = 0; i < anim_bones.count; i++)
  anim_bones[i].transform = transform * anim_bones[i].transform;

 return anim_bones;
}

void render_scene(Game &game, World &world, SceneID scene_id, Camera camera, mat4 transform, Animation *anim = 0, float anim_time = 0, v3 color = V3(1))
{
 if (!scene_id)
  return ;
 if (anim)
  anim_time = fmod(anim_time, anim->duration);
 Scene &scene = get_scene_by_id(game, scene_id);

 for (usize mesh_idx = 0; mesh_idx < scene.meshes.count; mesh_idx++) {
  Mesh &mesh = scene.meshes[mesh_idx];

  Constants constants = {};
  constants.view = camera.view;
  constants.projection = camera.projection;
  constants.camera_p = camera.position;
  constants.light_transform = game.shadow_map.projection * game.shadow_map.view;
  constants.color = color;
  constants.player_p = get_entity(*game.world, game.world->player_id)->position;
  constants.show_normals = game.show_normals;


  {
   for (int i = 0; i < game.world->entities.count; i++) {
    Entity &e = game.world->entities[i];

    if (constants.point_light_count == (sizeof(constants.point_light_color) / sizeof(*constants.point_light_color)))
     break ;
    if (e.type == EntityType_PointLight) {
     int j = constants.point_light_count++;
     constants.point_light_position[j].xyz = e.position;
     constants.point_light_color[j].xyz = e.color * e.point_light_scale;
    }
   }
  }

  mat4 mesh_transform = transform * mesh.transform;

  constants.model = mesh_transform;

  if (mesh.bones.count && anim) {
   constants.skinned = 1;
   Arena *temp = begin_temp_memory();
   Array<Bone> bones = get_animated_bones(temp, mesh.bones, mesh_transform, anim, anim_time);

   for (usize j = 0; j < bones.count; j++)
    constants.bones[j] = bones[j].transform * bones[j].inv_bind;

   if (game.render_bones)
    render_bones(bones, mesh_transform, anim, anim_time);
   end_temp_memory();
  }




  bool cull_mesh = false;

  if (!constants.skinned && game.frustum_culling)
  {
   Camera cam = camera;


   v3 c[2] = {mesh.box_min, mesh.box_max};
   v3 p[8];
   mat4 to_camera = cam.view * mesh_transform;
   for (int x = 0; x < 2; x++)
   for (int y = 0; y < 2; y++)
   for (int z = 0; z < 2; z++)
    p[(x<<2)|(y<<1)|z] = (to_camera * V4(c[x].x, c[y].y, c[z].z, 1)).xyz;

   v3 frustum_points[8];

   float zfar_width, zfar_height;

   if (cam.type == CAMERA_TYPE_ORTHOGRAPHIC)
    zfar_width = cam.width, zfar_height = cam.height;
   else
    zfar_width = cam.width * (cam.zfar / cam.znear), zfar_height = cam.height * (cam.zfar /cam.znear);


   frustum_points[0] = V3(-0.5f * cam.width, -0.5f * cam.height, -cam.znear);
   frustum_points[1] = V3(+0.5f * cam.width, -0.5f * cam.height, -cam.znear);
   frustum_points[2] = V3(+0.5f * cam.width, +0.5f * cam.height, -cam.znear);
   frustum_points[3] = V3(-0.5f * cam.width, +0.5f * cam.height, -cam.znear);

   frustum_points[4] = V3(-0.5f * zfar_width, -0.5f * zfar_height, -cam.zfar);
   frustum_points[5] = V3(+0.5f * zfar_width, -0.5f * zfar_height, -cam.zfar);
   frustum_points[6] = V3(+0.5f * zfar_width, +0.5f * zfar_height, -cam.zfar);
   frustum_points[7] = V3(-0.5f * zfar_width, +0.5f * zfar_height, -cam.zfar);

   v3 frustum_planes[6][3] = {
    {frustum_points[0], frustum_points[3], frustum_points[4]},
    {frustum_points[2], frustum_points[1], frustum_points[5]},
    {frustum_points[3], frustum_points[2], frustum_points[6]},
    {frustum_points[1], frustum_points[0], frustum_points[4]},
    {frustum_points[0], frustum_points[1], frustum_points[2]},
    {frustum_points[5], frustum_points[4], frustum_points[6]},
   };

   for (int i = 0; i < (sizeof(frustum_planes) / sizeof(*frustum_planes)); i++) {
    v3 normal = cross(frustum_planes[i][1] - frustum_planes[i][0], frustum_planes[i][2] - frustum_planes[i][0]);
    bool cull = true;
    for (int j = 0; j < (sizeof(p) / sizeof(*p)); j++) {
     if (dot(p[j] - frustum_planes[i][0], normal) < 0) {
      cull = false;
      break ;
     }
    }
    if (cull) {
     cull_mesh = true;
     break ;
    }
   }
  }

  if (!cull_mesh) {
   for (usize j = 0; j < mesh.parts.count; j++) {
    MeshPart &part = mesh.parts[j];

    bind_texture(0, part.material.diffuse.valid ? part.material.diffuse : g_rc->white_texture);
    bind_texture(1, part.material.specular.valid ? part.material.specular : g_rc->white_texture);
    bind_texture(2, part.material.normal_map);
    bind_texture(3, part.material.specular_exponent.valid ? part.material.specular_exponent : g_rc->white_texture);

    constants.diffuse_factor = part.material.diffuse_factor;
    constants.specular_factor = part.material.specular_factor;
    constants.specular_exponent_factor = part.material.specular_exponent_factor;
    constants.has_normal_map = part.material.normal_map.valid;

    update_constant_buffer(game.constant_buffer, &constants);
    bind_vertex_buffer(mesh.vertex_buffer);
    bind_index_buffer(mesh.index_buffer);

    draw_indexed((int)part.offset, (int)part.indices_count);
   }
  }
 }
}
# 105 "code/game.cpp" 2
# 1 "code/collision.cpp" 1
#define SMALLEST_VELOCITY 0.01f
#define SLIDE_ITERATION_COUNT 4
#define SLIDE_COEFF 1.2f

void intersect_line(v3 A, v3 B, v3 dir, CollisionInfo &info)
{
 v3 D = dir;
 v3 d = normalize(B - A);
 v3 V = (A - dot(A, d) * d);
 v3 X = D - d * dot(D, d);

 float a = dot(X, X);
 float b = -2*dot(X, V);
 float c = dot(V, V) - 1;
 float delta = b * b - 4 * a * c;
 if (delta < 0 || fabsf(a) < 1e-6)
  return ;
 delta = sqrtf(delta);

 auto check_t = [&](float t) {
  if (t < 0 || t >= info.t)
   return ;

  v3 h = t * dir;
  v3 p = h - ((h - A) - d * dot(h - A, d));
  if (dot(p - A, B - A) >= 0 && length_sq(p - A) <= length_sq(B - A)) {
   info.t = t;
   info.hit_p = p;
  }
 };
 check_t((-b + delta)/(2*a));
 check_t((-b - delta)/(2*a));
}

void intersect_vertex(v3 p, v3 dir, CollisionInfo &info)
{
 float a = dot(dir, dir);
 float b = -2*dot(dir, p);
 float c = dot(p, p) - 1;
 float delta = b * b - 4 * a * c;
 if (delta < 0)
  return ;
 delta = sqrtf(delta);
 float t0 = (-b - delta)/(2*a);
 float t1 = (-b + delta)/(2*a);

 if (t1 >= 0 && t1 < t0)
  t0 = t1;

 if (t0 >= 0 && t0 <= info.t) {
  info.t = t0;
  info.hit_p = p;
 }
}

void intersect_triangle_plane(v3 v0, v3 v1, v3 v2, v3 dir, CollisionInfo &info)
{
 v3 u = v1 - v0;
 v3 v = v2 - v0;
 v3 n = cross(u, v);

 v3 normal = normalize(n);

 if (fabsf(dot(normal, dir)) < 1e-6)
  return ;

 if (dot(normal, dir) > 0)
  normal *= -1;

 float t0 = (1 + dot(v0, normal)) / (dot(normal, dir));
 float t1 = (-1 + dot(v0, normal)) / (dot(normal, dir));

 float one_over_length_n_sq = 1.f / dot(n, n);

 auto check_t = [&](float t) {
  if (t >= info.t || t < 0)
   return ;

  v3 p = t * dir;
  p = v0 + (p-v0)-dot(p - v0, normal)*normal;
# 89 "code/collision.cpp"
  float A = dot(cross(p - v0, v), n) * one_over_length_n_sq;
  float B = -dot(cross(p - v0, u), n) * one_over_length_n_sq;

  if (A >= 0 && B >= 0 && A + B <= 1) {
   info.t = t;
   info.hit_p = p;
  }
 };
 check_t(t0);
 check_t(t1);
}

CollisionInfo ellipsoid_intersect_triangle(v3 targetP, v3 ep, v3 er, v3 v0, v3 v1, v3 v2)
{
 CollisionInfo info = {};

 info.t = FLT_MAX;

 v3 inv_r = V3(1/er.x, 1/er.y, 1/er.z);
# 118 "code/collision.cpp"
 v3 t0 = inv_r * (v0 - ep);
 v3 t1 = inv_r * (v1 - ep);
 v3 t2 = inv_r * (v2 - ep);
 v3 dir = inv_r * (targetP - ep);

 intersect_triangle_plane(t0, t1, t2, dir, info);

 intersect_vertex(t0, dir, info);
 intersect_vertex(t1, dir, info);
 intersect_vertex(t2, dir, info);

 intersect_line(t0, t1, dir, info);
 intersect_line(t1, t2, dir, info);
 intersect_line(t0, t2, dir, info);




 info.hit_normal = inv_r * (info.t * dir - info.hit_p);
 info.hit_p = ep + (info.hit_p * er);

 return info;
}

CollisionInfo ellipsoid_intersect_ellipsoid(v3 targetP, v3 ep, v3 er, v3 tp, v3 tr)
{
 CollisionInfo info = {};

 info.t = FLT_MAX;







 v3 radius = er + tr;

 mat4 m = translate(tp) * scale(radius);
 mat4 M = scale(1 / radius) * translate(-tp);

 v3 ray_origin = (M * V4(ep, 1)).xyz;
 v3 ray_dir = (M * V4(targetP, 1)).xyz - ray_origin;

 float a = dot(ray_dir, ray_dir);
 float b = 2 * dot(ray_origin, ray_dir);
 float c = dot(ray_origin, ray_origin) - 1;

 float delta = b * b - 4 * a * c;

 if (delta < 0)
  return info;

 delta = sqrtf(delta);
 float t0 = (-b - delta) / (2 * a);
 float t1 = (-b + delta) / (2 * a);

 if (t1 >= 0 && t1 < t0)
  t0 = t1;

 if (t0 >= 0) {
  info.t = t0;


  info.hit_normal = (transpose(M) * V4(ray_origin + t0*ray_dir, 0)).xyz;
 }
 return info;
}

CollisionInfo move_entity(World &world, Entity &e, v3 delta_p, Array<CollisionShape> shapes)
{
 CollisionInfo first_hit = {};

 v3 e_radius = e.scale * e.ellipsoid_radius;

 for (int itr = 0; itr < 4; itr++) {
  if (length_sq(delta_p) < 0.01f*0.01f)
   break ;

  CollisionInfo hit_info = {};
  hit_info.t = FLT_MAX;

  for (int i = 0; i < shapes.count; i++) {
   CollisionInfo info;

   if (!shapes[i].ellipsoid) {
    for (int j = 0; j + 2 < shapes[i].collision_mesh.vertices.count; j += 3) {
     v3 p0 = (shapes[i].transform * V4(shapes[i].collision_mesh.vertices[j + 0], 1)).xyz;
     v3 p1 = (shapes[i].transform * V4(shapes[i].collision_mesh.vertices[j + 1], 1)).xyz;
     v3 p2 = (shapes[i].transform * V4(shapes[i].collision_mesh.vertices[j + 2], 1)).xyz;

     info = ellipsoid_intersect_triangle(e.position + delta_p, e.position, e_radius,
       p0, p1, p2);
     if (info.t < hit_info.t)
      hit_info = info;
    }
   }
   else {
    info = ellipsoid_intersect_ellipsoid(e.position + delta_p, e.position, e_radius,
      V3(shapes[i].transform.e[0][3],
       shapes[i].transform.e[1][3],
       shapes[i].transform.e[2][3]),
      shapes[i].ellipsoid_radius
      * shapes[i].scale);
    if (info.t < hit_info.t)
     hit_info = info;
   }
  }

  if (!itr)
   first_hit = hit_info;


  if (hit_info.t >= 1) {
   if (hit_info.t != FLT_MAX && length_sq(delta_p * (hit_info.t - 1)) < 0.01f * 0.01f)
    e.position += normalize(delta_p) * (length(delta_p) - (0.01f - length(delta_p * (hit_info.t - 1))));
   else
    e.position += delta_p;
   break ;
  }

  if (length_sq(delta_p*hit_info.t) >= 0.01f*0.01f)
   e.position += normalize(delta_p) * (length(delta_p)*hit_info.t - 0.01f);

  v3 normal = normalize(hit_info.hit_normal);

  v3 old_delta_p = delta_p;
  delta_p *= (1 - hit_info.t);
  delta_p = delta_p - normal*dot(normal, delta_p)*1.2f;
 }

 return first_hit;
}

void move_entity(World &world, Entity &e, v3 delta_p)
{
 assert(e.ellipsoid_collision_shape);

 Arena *temp = begin_temp_memory();

 Array<CollisionShape> shapes = make_array_max<CollisionShape>(temp, world.entities.count + 64);

 for (int i = 0; i < world.entities.count; i++) {
  Entity &test = world.entities[i];

  if (test.id == e.id || test.disable_collision)
   continue ;

  CollisionShape shape = {};
  if (test.ellipsoid_collision_shape) {
   shape.ellipsoid = true;
   shape.ellipsoid_radius = test.ellipsoid_radius;
   shape.transform = get_entity_transform(world, test);
   shape.scale = test.scale;
  }
  else {
   if (!world.scene_collision_mesh.count(test.scene_id))
    continue ;
   shape.collision_mesh = world.collision_meshes[world.scene_collision_mesh[test.scene_id]];
   shape.transform = get_entity_transform(world, test) * test.scene_transform;
  }
  shapes.push(shape);
 }
# 289 "code/collision.cpp"
 v3 old_p = e.position;
 move_entity(world, e, V3(delta_p.x, delta_p.y, 0), shapes);

 int itr = 1 + roundf(fabsf(delta_p.z) / (0.01f*3.5f));
 for (int i = 0; i < itr; i++)
  move_entity(world, e, V3(0, 0, delta_p.z / itr), shapes);

 if (fabsf(e.position.x - old_p.x) < 1e-7)
  e.dp.x = 0;
 if (fabsf(e.position.y - old_p.y) < 1e-7)
  e.dp.y = 0;
 if (fabsf(e.position.z - old_p.z) < 1e-7)
  e.dp.z = 0;


 v3 save_p = e.position;

 CollisionInfo collision = move_entity(world, e, V3(0, 0, -1), shapes);
 e.position = save_p;



 float height_above_ground = e.position.z - collision.hit_p.z - e.scale.z*e.ellipsoid_radius.z
  - 0.01f;
 if (collision.t < 0 || collision.t == FLT_MAX)
  height_above_ground = 10000;
 if (height_above_ground < 0)
  height_above_ground = 0;
 e.height_above_ground = height_above_ground;

 if (e.height_above_ground > 0.6)
  e.can_jump = false;
 e.on_ground = e.height_above_ground < 0.01f;
 if (e.on_ground)
  e.can_jump = true;

 end_temp_memory();
}
# 106 "code/game.cpp" 2
# 1 "code/world.cpp" 1
Entity *make_entity(World &world)
{
 Entity e = {};

 e.id = ++world.next_entity_id;
 world.entities.push(e);
 world.entities_id_map[e.id] = world.entities.count - 1;
 return &world.entities[world.entities.count - 1];
}

Entity *make_entity(World &world, EntityType type, SceneID scene_id, v3 position, mat4 scene_transform = identity())
{
 Entity *e = make_entity(world);

 e->type = type;
 e->position = position;
 e->scene_id = scene_id;
 e->scene_transform = scene_transform;
 e->color = V3(1);
 e->scale = V3(1);
 e->rotation = identity_quat();
 return e;
}

Entity *get_entity(World &world, entity_id id)
{






 auto it = world.entities_id_map.find(id);
 if (it != world.entities_id_map.end())
  return &world.entities[it->second];

 return 0;
}

void remove_entity(World &world, entity_id id)
{
 assert(world.entities_id_map.count(id));

 usize index = world.entities_id_map[id];
 world.entities_id_map.erase(id);
 if (index != world.entities.count - 1) {
  world.entities[index] = world.entities[world.entities.count - 1];
  world.entities_id_map[world.entities[index].id] = index;
 }
 world.entities.count--;
}

v3 get_world_p(World &world, entity_id id)
{
 Entity *e = get_entity(world, id);
 assert(e);

 v3 position = e->position;
 while (e->parent)
 {
  Entity *p = get_entity(world, e->parent);
  assert(p);
  position += p->position;
  e = p;
 }
 return position;
}

mat4 get_entity_transform(World &world, Entity &e)
{




 return translate(get_world_p(world, e.id))
  * quat_to_mat(e.rotation) * scale(e.scale);

}

void render_player(Game &game, World &world, Camera camera, Entity &e, bool shadow_map_pass)
{
 mat4 entity_transform = get_entity_transform(world, e);
 mat4 scene_transform = entity_transform * e.scene_transform;
 Arena *temp = begin_temp_memory();
 Animation *final_anim = 0;
 Animation anim = {};

 if (e.id == world.player_id && e.curr_anim) {
  usize max_nodes_count = e.curr_anim->nodes.count;
  if (e.next_anim && e.next_anim->nodes.count > max_nodes_count)
   max_nodes_count = e.next_anim->nodes.count;

  anim.nodes = make_array<NodeAnimation>(temp, max_nodes_count);
  if (e.next_anim)
   assert(e.curr_anim->nodes.count == e.next_anim->nodes.count);

  float blend_duration = e.next_anim ? e.next_anim->duration*0.2f : 0;
  if (e.blend_time > blend_duration && e.next_anim) {
   e.curr_anim = e.next_anim;
   e.anim_time = e.blend_time;
   e.next_anim = 0;
  }

  if (!e.next_anim) {
   assert(e.curr_anim);
   for (int j = 0; j < e.curr_anim->nodes.count; j++) {
    anim.nodes[j].name = e.curr_anim->nodes[j].name;
    anim.nodes[j].transform = get_animated_node_transform(*e.curr_anim,
      e.curr_anim->nodes[j], fmod(e.anim_time, e.curr_anim->duration));
   }
  } else {
   float t1 = fmod(e.anim_time, e.curr_anim->duration);
   float t2 = fmod(e.blend_time, e.next_anim->duration);
   float t3 = (e.blend_time) / blend_duration;


   for (int j = 0; j < e.curr_anim->nodes.count; j++) {
    quat q1, q2;
    v3 p1, s1, p2, s2;
    assert(strings_equal(e.curr_anim->nodes[j].name, e.next_anim->nodes[j].name));
    get_animated_node_transform(*e.curr_anim, e.curr_anim->nodes[j], t1, p1, s1, q1);
    get_animated_node_transform(*e.next_anim, e.next_anim->nodes[j], t2, p2, s2, q2);

    anim.nodes[j].name = e.curr_anim->nodes[j].name;

    v3 p = lerp(p1, p2, t3);
    quat q = quat_lerp(q1, q2, t3);
    v3 s = lerp(s1, s2, t3);

    anim.nodes[j].transform = translate(p) * quat_to_mat(q) * scale(s);

   }
  }
  final_anim = &anim;
 }
 else
  assert(!final_anim);

 render_scene(game, world, e.scene_id, camera, scene_transform, final_anim, 0, e.color);

 end_temp_memory();
}

void render_entities(Game &game, World &world, Camera camera, bool shadow_map_pass = false)
{


 bind_constant_buffer(game.constant_buffer, 0);

 for (usize i = 0; i < world.entities.count; i++) {
  Entity &e = world.entities[i];
  if (!e.scene_id)
   continue ;

  if (e.id == world.player_id) {
   render_player(game, world, camera, e, shadow_map_pass);
   continue ;
  }

  mat4 entity_transform = get_entity_transform(world, e);
  mat4 scene_transform = entity_transform * e.scene_transform;

  render_scene(game, world, e.scene_id, camera, scene_transform, 0, 0, e.color);
 }

}

void update_player(Game &game, World &world, GameInput &input, float dt)
{

 Entity *_player = get_entity(world, world.player_id);
 if (!_player)
  return ;
 Entity &player = *_player;

 b32 camera_shoot_mode = false;
 b32 walk_backward = false;
 {
  v3 player_forward = normalize(V3(cosf(world.player_camera_rotation.z), sinf(world.player_camera_rotation.z), 0));
  v3 player_up = V3(0, 0, 1);
  v3 player_right = normalize(cross(player_forward, player_up));
  v3 a = {};

  bool forward = false;

  if ((input.buttons[BUTTON_F].is_down))
  {
   a += player_forward;
   forward = true;
  }
  if ((input.buttons[BUTTON_G].is_down))
  {
   a -= player_forward;
   walk_backward = true;
  }
  a = normalize(a);

  player.moved = forward;
  player.run = input.buttons[BUTTON_LEFT_SHIFT].is_down && forward;
  if (!(input.buttons[BUTTON_MOUSE_LEFT].is_down) || player.moved)
   player.shooting = false;
  else
  {
   player.shooting = true;
   player.run = false;
   player.moved = false;
   a = {};
  }

  if (!(input.buttons[BUTTON_MOUSE_RIGHT].is_down) || player.moved) {
   if (player.aiming)
    world.aim_camera_transition_t = 0;
   player.aiming = 0;
  } else {
   if (!player.aiming)
    world.aim_camera_transition_t = 0;
   player.aiming = 1;
  }

  if (player.shooting) {

   if (game.time - player.last_gun_time > 0.3) {


    v3 dir = normalize(world.player_camera_p + 4 * player_forward
     - player.position);
    push_line(player.position, player.position + dir * 5, V3(0));





   }
  }



  a += -40 * player_up;
  a.xy = a.xy * (player.run ? 50 : 30);
  bool jumped = false;
  if ((input.buttons[BUTTON_SPACE].is_down) && player.can_jump)
  {
   if (!player.pressing_jump)
    play_sound(game, game.loaded_sounds[1]);

   a += 200 * player_up;
   a.xy = {};
   jumped = true;
   player.pressing_jump = true;
  }
  else
   player.pressing_jump = false;



  a -= player.dp * 3;

  {
   v3 delta_p = 0.5f * dt * dt * a + dt * player.dp;

   move_entity(world, player, delta_p);
   player.dp += a * dt;

  }
# 276 "code/world.cpp"
  {


   Animation *next_anim = 0;
   player.anim_time += dt;
   player.blend_time += dt;

   if (!player.curr_anim)
    player.curr_anim = &game.animations[ANIMATION_GUN_IDLE];


   if (!player.on_ground) {
    if (player.curr_anim != &game.animations[ANIMATION_JUMP]
      && player.next_anim != &game.animations[ANIMATION_JUMP]
      && !jumped)
     next_anim = player.next_anim;
    else
     next_anim = &game.animations[ANIMATION_JUMP];
   }
   else if (player.shooting)
    next_anim = &game.animations[ANIMATION_SHOOT];
   else if (player.run)
    next_anim = &game.animations[ANIMATION_RUN];
   else if (walk_backward)
    next_anim = &game.animations[ANIMATION_BACKWARD_GUN_WALK];
   else if (player.moved)
    next_anim = &game.animations[ANIMATION_FORWARD_GUN_WALK];
   else
    next_anim = &game.animations[ANIMATION_GUN_IDLE];

   if (!player.curr_anim)
    player.curr_anim = next_anim;
   else if (!next_anim)
    ;
   else if (!player.next_anim) {
    if (player.curr_anim != next_anim) {
     player.next_anim = next_anim;
     player.blend_time = 0;
    }
   }
   else if (next_anim == player.next_anim)
    ;
   else if (next_anim != player.curr_anim) {






   }
   else {
    player.next_anim = 0;
    player.blend_time = 0;
   }







  }
 }
}

void update_enemies(Game &game, World &world, GameInput &input, float dt)
{
}

Camera update_camera(Game &game, World &world, GameInput &input, float dt)
{
 Camera camera = {};

 Entity *player = get_entity(world, world.player_id);
 if (!player)
  assert(0);





 if (game.in_editor && (ImGui::GetIO().WantCaptureMouse || !(input.buttons[BUTTON_MOUSE_LEFT].is_down)))
  input.mouse_dp = {};


 v3 camera_rot;
 if (game.in_editor) {
  world.editor_camera_rotation.x += -input.mouse_dp.y * dt * 0.2f;
  world.editor_camera_rotation.z += -input.mouse_dp.x * dt * 0.2f;

  if (world.editor_camera_rotation.x > 3.14159265359f / 2 - 0.001f)
   world.editor_camera_rotation.x = 3.14159265359f / 2 - 0.001f;
  if (world.editor_camera_rotation.x < -3.14159265359f / 2 + 0.001f)
   world.editor_camera_rotation.x = -3.14159265359f / 2 + 0.001f;
  camera_rot = world.editor_camera_rotation;
 }
 else {
  v2 mouse_dp = (input.mouse_dp) * 0.1f;
  v3 a = {-24*mouse_dp.y, 0, -20*mouse_dp.x};


  a -= world.player_camera_drotation * 10;
  world.player_camera_rotation += 0.5 * a * dt * dt + world.player_camera_drotation * dt;
  world.player_camera_drotation += a * dt;
  {
   if (world.player_camera_rotation.x >= 3.14159265359f / 2)
    world.player_camera_rotation.x = 3.14159265359f / 2;
   if (world.player_camera_rotation.x <= -3.14159265359f / 2)
    world.player_camera_rotation.x = -3.14159265359f / 2;
  }
  world.player_camera_rotation.z = fmod(world.player_camera_rotation.z, 2*3.14159265359f);

  camera_rot = world.player_camera_rotation;
  camera_rot.z -= 3.14159265359f / 2;
  player->rotation = zrotation_quat(world.player_camera_rotation.z);


  {
   v3 player_forward = normalize(V3(cosf(world.player_camera_rotation.z),
      sinf(world.player_camera_rotation.z), 0));
   v3 player_right = normalize(cross(player_forward, V3(0, 0, 1)));
   float o = camera_rot.x;

   float t[4] = {-3.14159265359f/2, 0, 3.14159265359f/2.5, 3.14159265359f/2};
   assert(player->ellipsoid_collision_shape);

   v3 player_p = get_world_p(world, player->id);

   v3 v[4] = {
    player_p + V3(0, 0, player->ellipsoid_radius.z*3),
    player_p - player_forward * 3 + V3(0, 0, player->ellipsoid_radius.z * 0.5),
    player_p - player_forward * 1.5
     + V3(0, 0, -player->ellipsoid_radius.z +0.2),
    player_p - V3(0, 0, player->ellipsoid_radius.z-0.1),

   };




   mat4 M;
   mat4 V;

   for (int i = 0; i < 4; i++) {
    for (int j = 0; j < 4; j++) {
     M.e[i][j] = 1;
     for (int k = 0; k < 3 - i; k++)
      M.e[i][j] *= t[j];

     if (i == 3)
      V.e[i][j] = 0;
     else
      V.e[i][j] = v[j].e[i];
    }
   }

   M = inverse(M);

   mat4 A = V * M;

   v3 target_camera_p = (A * V4(o*o*o, o*o, o, 1)).xyz;

   if (player->aiming)
    target_camera_p += player_right * 1.f + player_forward * 0.9 + V3(0, 0, 0.7);
   else
    target_camera_p += player_right * 0.3f;
   float transition_time = 1.5f;
   if (world.aim_camera_transition_t < transition_time)
    world.player_camera_p += (15 + 40 * world.aim_camera_transition_t/transition_time) * dt * (target_camera_p - world.player_camera_p);
   else
    world.player_camera_p += (15 + 40) * dt * (target_camera_p - world.player_camera_p);

   world.aim_camera_transition_t = min(transition_time, dt + world.aim_camera_transition_t);
# 462 "code/world.cpp"
  }
 }



 mat4 camera_transform;
 if (game.in_editor)
  camera_transform = translate(world.editor_camera_p) * zrotation(camera_rot.z) * xrotation(camera_rot.x);
 else
  camera_transform = translate(world.player_camera_p) * zrotation(camera_rot.z) * xrotation(camera_rot.x) ;

 v3 camera_x = (camera_transform * v4{1, 0, 0, 0}).xyz;
 v3 camera_y = (camera_transform * v4{0, 0, 1, 0}).xyz;
 v3 camera_z = (camera_transform * v4{0, -1, 0, 0}).xyz;




  if (game.in_editor && !(input.buttons[BUTTON_LEFT_CONTROL].is_down)
    && !ImGui::GetIO().WantCaptureKeyboard)

  {
   v3 camera_dp = {};
   if ((input.buttons[BUTTON_W].is_down))
    camera_dp -= camera_z;
   if ((input.buttons[BUTTON_S].is_down))
    camera_dp += camera_z;
   if ((input.buttons[BUTTON_A].is_down))
    camera_dp -= camera_x;
   if ((input.buttons[BUTTON_D].is_down))
    camera_dp += camera_x;
   if ((input.buttons[BUTTON_Q].is_down))
    camera_dp += camera_y;
   if ((input.buttons[BUTTON_E].is_down))
    camera_dp -= camera_y;
   world.editor_camera_p += normalize(camera_dp) * dt * 8;
  }

 mat4 rotation = {
  camera_x.x, camera_x.y, camera_x.z, 0,
  camera_y.x, camera_y.y, camera_y.z, 0,
  camera_z.x, camera_z.y, camera_z.z, 0,
  0, 0, 0, 1
 };

 v3 p = game.in_editor ? world.editor_camera_p : world.player_camera_p;
 mat4 view = rotation * translate(-p);


 camera = make_perspective_camera(view, 0.1f, 100, 100, (float)g_rc->window_height / g_rc->window_width);
# 527 "code/world.cpp"
 return camera;
}
# 107 "code/game.cpp" 2
# 1 "code/editor.cpp" 1
entity_id raycast_to_entities(Game &game, World &world, v3 ray_origin, v3 ray_dir,
  float &hit_t, int &mesh_index)
{
 entity_id hit_id = 0;

 v3 hit_triangle[3];

 mesh_index = -1;
 float min_t = FLT_MAX;

 for (usize i = 0; i < world.entities.count; i++) {
  Entity &e = world.entities[i];
  if (!e.scene_id)
   continue ;

  Scene &scene = get_scene_by_id(game, e.scene_id);
  mat4 transform = get_entity_transform(world, e) * e.scene_transform;
  for (usize j = 0; j < scene.meshes.count; j++) {
   Mesh &mesh = scene.meshes[j];
   mat4 mesh_transform = transform * mesh.transform;

   {
    v3 x_axis = normalize((mesh_transform * V4(1, 0, 0, 0)).xyz);
    v3 y_axis = normalize((mesh_transform * V4(0, 1, 0, 0)).xyz);
    v3 z_axis = normalize((mesh_transform * V4(0, 0, 1, 0)).xyz);

    v3 a = (mesh_transform * V4(mesh.box_min, 1)).xyz;
    v3 b = (mesh_transform * V4(mesh.box_max, 1)).xyz;

    v3 c = (a + b) * 0.5f;

    x_axis *= fabsf(dot((b - a)*0.5f, x_axis));
    y_axis *= fabsf(dot((b - a)*0.5f, y_axis));
    z_axis *= fabsf(dot((b - a)*0.5f, z_axis));



    float t = ray_hit_box(ray_origin, ray_dir, c, x_axis, y_axis, z_axis);
    if (t < 0)
     continue ;
   }


   for (usize t = 0; t < mesh.indices.count; t += 3) {
    v3 v0 = (mesh_transform * V4(mesh.vertices[(int)mesh.indices[t+0]], 1)).xyz;
    v3 v1 = (mesh_transform * V4(mesh.vertices[(int)mesh.indices[t+1]], 1)).xyz;
    v3 v2 = (mesh_transform * V4(mesh.vertices[(int)mesh.indices[t+2]], 1)).xyz;

    v3 u = v1 - v0;
    v3 v = v2 - v0;
    v3 normal = cross(u, v);

    float hit_t;
    if (ray_hit_plane(ray_origin, ray_dir, normal, v0, &hit_t)
      && hit_t < min_t) {
     float one_over_length_n_sq = 1.f/dot(normal, normal);
     v3 p = ray_origin + hit_t * ray_dir;
     float A = dot(cross(p - v0, v), normal) * one_over_length_n_sq;
     float B = -dot(cross(p - v0, u), normal) * one_over_length_n_sq;
     if (A >= 0 && B >= 0 && A + B <= 1) {
      min_t = hit_t;
      hit_id = e.id;
      hit_triangle[0] = v0;
      hit_triangle[1] = v1;
      hit_triangle[2] = v2;
      mesh_index = (int)j;
     }
    }
   }
  }
 }

 if (hit_id) {
  push_triangle_outline(hit_triangle[0], hit_triangle[1], hit_triangle[2], V3(0));
 }
 hit_t = min_t;
 return hit_id;
}

void do_editor_op(Game &game, World &world, Editor &editor, EditorOp &op)
{
 Entity *e = get_entity(world, op.entity);
 if (e) {
  if (op.type == EDITOR_OP_TRANSLATE_ENTITY)
   e->position = op.translate.new_p;
  else if (op.type == EDITOR_OP_ROTATE_ENTITY)
   e->rotation = op.rotate.new_rot;
  else if (op.type == EDITOR_OP_SCALE_ENTITY)
   e->scale = op.scale.new_scale;
 }
 if (op.type == EDITOR_OP_PASTE_ENTITY) {
  Entity *copy_from = get_entity(world, op.paste.copy_from);
  if (copy_from) {



   Entity *copied;

   if (op.paste.id) {
    Entity p = *copy_from;
    p.id = op.paste.id;
    world.entities.push(p);
    copied = &world.entities[world.entities.count - 1];
    world.entities_id_map[p.id] = world.entities.count - 1;
   }
   else {
    Entity *p = make_entity(world);
    entity_id id = p->id;
    *p = *copy_from;
    p->id = id;
    op.paste.id = p->id;
    copied = p;
   }
   copied->position = op.paste.p;
   if (op.paste.mesh_index >= 0) {
    Scene scene = {};
    scene.id = ++game.next_scene_id;
    Scene &s = get_scene_by_id(game, copied->scene_id);
    assert(op.paste.mesh_index < s.meshes.count);

    scene.meshes = make_array<Mesh>(&world.arena, 1);
    scene.meshes[0] = s.meshes[op.paste.mesh_index];

    copied->scene_transform = identity();

    scene.meshes[0].transform = scene.meshes[0].default_transform;

    game.scenes.push(scene);
    copied->scene_id = scene.id;
   }
  }
 }
 else if (op.type == EDITOR_OP_DELETE_ENTITY)
  remove_entity(world, op.entity);

 editor.ops.push(op);
}

void redo_editor_op(Game &game, World &world, Editor &editor)
{
 if (!editor.undos.count)
  return ;
 EditorOp op = editor.undos[editor.undos.count - 1];
 editor.undos.count--;

 do_editor_op(game, world, editor, op);
}

void undo_editor_op(Game &game, World &world, Editor &editor)
{
 if (!editor.ops.count)
  return ;
 EditorOp op = editor.ops[editor.ops.count - 1];

 editor.undos.push(op);
 editor.ops.count--;
 Entity *e = get_entity(world, op.entity);
 if (e) {
  if (op.type == EDITOR_OP_TRANSLATE_ENTITY)
   e->position = op.translate.prev_p;
  else if (op.type == EDITOR_OP_ROTATE_ENTITY)
   e->rotation = op.rotate.prev_rot;
  else if (op.type == EDITOR_OP_SCALE_ENTITY)
   e->scale = op.scale.prev_scale;
 }
 if (op.type == EDITOR_OP_PASTE_ENTITY)
  remove_entity(world, op.paste.id);
 else if (op.type == EDITOR_OP_DELETE_ENTITY) {
  world.entities.push(op.del.entity_data);
  world.entities_id_map[op.del.entity_data.id] = world.entities.count - 1;
 }
}

void update_editor(Game &game, World &world, Editor &editor, GameInput &input, Camera &camera)
{
 {
  Entity *e = get_entity(world, world.editor_selected_entity);

  if (e) {
   ImGuiIO &io = ImGui::GetIO();

   ImGui::Begin("Entity");

   if (ImGui::Button("Reset scale"))
    e->scale = V3(1);
   if (ImGui::Button("Reset rotation"))
    e->rotation = identity_quat();
   if (e->id != world.player_id && ImGui::Button("delete")) {
    EditorOp op = {};
    op.entity = e->id;
    op.type = EDITOR_OP_DELETE_ENTITY;
    op.del.entity_data = *e;
    do_editor_op(game, world, editor, op);
    e = 0;
   }
   if (e)
    imgui_edit_struct_Entity(*e, "selected entity", false);
# 246 "code/editor.cpp"
   ImGui::End();
  }
 }
 if (!game.in_editor)
  return ;



 v2 mouse_p = (input.mouse_p * V2(1.f / g_rc->window_width, 1.f / g_rc->window_height)) * 2 - V2(1);
 mouse_p.y *= -1;

 v3 ray_origin = camera.position;
 v3 ray_dir = camera.forward * camera.znear
  + mouse_p.x * camera.right * camera.width * 0.5f
  + mouse_p.y * camera.up * camera.height * 0.5f;
 if ((input.buttons[BUTTON_LEFT_CONTROL].is_down)) {
  if ((input.buttons[BUTTON_T].is_down)) editor.gizmo_mode = GIZMO_TRANSLATION;
  else if ((input.buttons[BUTTON_R].is_down)) editor.gizmo_mode = GIZMO_ROTATION;
  else if ((input.buttons[BUTTON_S].is_down)) editor.gizmo_mode = GIZMO_SCALE;

  if (((input.buttons[BUTTON_Q].is_down) && !(input.buttons[BUTTON_Q].was_down))) {

   editor.edit_collision_mesh = !editor.edit_collision_mesh;
   if (editor.edit_collision_mesh)
    editor.in_gizmo = 0;
  }
 }
 float rotation_inner_radius = 1.5;
 float rotation_outer_radius = 2;
 float rotation_circle_radius = 0.5f * (rotation_inner_radius + rotation_outer_radius);
 v3 axis[3] = {
  2*V3(1, 0, 0),
  2*V3(0, 1, 0),
  2*V3(0, 0, 1)
 };

 if (editor.gizmo_mode == GIZMO_SCALE || editor.gizmo_mode == GIZMO_ROTATION) {
  Entity *e = get_entity(world, editor.selected_entity);
  if (e) {
   mat4 transform = get_entity_transform(world, *e);

   for (int i = 0; i < 3; i++)
    axis[i] = V3(transform.e[0][i], transform.e[1][i], transform.e[2][i]);
   for (int i = 0; i < 3; i++)
    axis[i] = 2 * normalize(axis[i]);
  }
 }

 if (!editor.edit_collision_mesh && (input.buttons[BUTTON_MOUSE_RIGHT].is_down)) {
  float min_hit_t;
  int hit_entity_mesh_index;
  entity_id hit_entity = raycast_to_entities(game, world, ray_origin, ray_dir, min_hit_t, hit_entity_mesh_index);

  if (editor.selected_entity && !editor.in_gizmo && !editor.edit_collision_mesh) {
   Entity *e = get_entity(world, editor.selected_entity);
   if (e) {
    float min_axis_t = FLT_MAX;
    int best_axis = -1;
    for (int i = 0; i < 3; i++) {

     float t = -1;
     if (editor.gizmo_mode == GIZMO_ROTATION) {
      if (ray_hit_plane(ray_origin, ray_dir, axis[i], e->position, &t)) {
       v3 p = ray_origin + t * ray_dir;

       if (t >= 0 &&
         length(p - e->position) > rotation_inner_radius
         && length(p - e->position) < rotation_outer_radius) {
       }
       else
        t = -1;
      }
     }
     else {
      t = ray_hit_box(ray_origin, ray_dir, e->position + 0.5f * axis[i],
        axis[0] * (i == 0 ? 0.5f : 0.15f),
        axis[1] * (i == 1 ? 0.5f : 0.15f),
        axis[2] * (i == 2 ? 0.5f : 0.15f));
     }

     if (t >= 0 && t < min_axis_t) {
      min_axis_t = t;
      best_axis = i;
     }
    }
    if (editor.gizmo_mode == GIZMO_SCALE) {


    }
    if (min_axis_t != FLT_MAX) {


     editor.in_gizmo = true;
     editor.did_drag = false;
     editor.dragging_axis = best_axis;
    }
    }
   }

   if (editor.in_gizmo) {

    Entity *e = get_entity(world, editor.selected_entity);
    if (e) {
     if (editor.did_drag && !v3_equal(camera.position, editor.last_camera_p))
      editor.did_drag = false;


     v3 plane_normal = cross(axis[editor.dragging_axis], cross(axis[editor.dragging_axis], camera.forward));
     if (editor.gizmo_mode == GIZMO_ROTATION) {

      plane_normal = axis[editor.dragging_axis];
     }

     push_line(e->position, e->position + normalize(plane_normal) * 2,
       V3(1, 0, 1));

     float hit_t;
     if (ray_hit_plane(ray_origin, ray_dir, plane_normal, e->position, &hit_t)) {
      v3 hit_p = ray_origin + hit_t * ray_dir;

      if (editor.gizmo_mode == GIZMO_TRANSLATION) {


       v3 dp = normalize(axis[editor.dragging_axis]) * dot(hit_p - e->position, normalize(axis[editor.dragging_axis]));

       if (!editor.did_drag) {
        editor.did_drag = true;
        editor.p_init_drag = dp;
       }
       else
        e->position += dp - editor.p_init_drag;
      }
      else if (editor.gizmo_mode == GIZMO_SCALE) {

       float ds = dot(hit_p - e->position, normalize(axis[editor.dragging_axis]));


       if (!editor.did_drag) {
        editor.did_drag = true;
        editor.s_init_drag = ds;
        editor.s_init_scale = e->scale.e[editor.dragging_axis];
       }
       else {
        v3 new_scale = e->scale;
        new_scale.e[editor.dragging_axis] = editor.s_init_scale + ds - editor.s_init_drag;
        if (new_scale.e[editor.dragging_axis] < 0.01f)
         new_scale.e[editor.dragging_axis] = 0.01f;
        e->scale = new_scale;
       }
      }
      else if (editor.gizmo_mode == GIZMO_ROTATION) {

       v3 p = normalize(hit_p - e->position) * rotation_circle_radius;


       push_cube_outline(e->position + p, V3(0.1), V3(0));

       v3 right_axis = axis[(editor.dragging_axis+1)%3];
       v3 up_axis = axis[(editor.dragging_axis+2)%3];

       if (editor.did_drag)
        right_axis = editor.r_right_axis, up_axis = editor.r_up_axis;
       else
        editor.r_axis = axis[editor.dragging_axis];



       mat4 m = inverse(
         mat4_cols(V4(right_axis, 0),
          V4(up_axis, 0), V4(editor.r_axis, 0),
          V4(0, 0, 0, 1)));

       p = (m * V4(p, 0)).xyz;






       push_line(e->position, e->position + right_axis, V3(1));
       push_line(e->position, e->position + up_axis, V3(0.2));
       float a = atan2(p.y, p.x);

       if (!editor.did_drag) {
        editor.did_drag = true;
        editor.r_init_drag = a;
        editor.r_init_rot = e->rotation;
        editor.r_right_axis = right_axis;
        editor.r_up_axis = up_axis;
        editor.r_axis = axis[editor.dragging_axis];
       }
       else {
        e->rotation = rotate_around_axis_quat(editor.r_axis, a - editor.r_init_drag)
         * editor.r_init_rot;
       }
      }
      else
       assert(0);
     }
    }
   }
   else {



    editor.selected_entity = hit_entity;
    editor.selected_entity_mesh = hit_entity_mesh_index;
    Entity *e = get_entity(world, hit_entity);
    if (e)
     editor.init_entity = *e;
   }

 }
 else {
   if (editor.in_gizmo && editor.did_drag) {
    EditorOp op = {};
    Entity *e = get_entity(world, editor.selected_entity);
    if (e) {
     op.entity = editor.init_entity.id;
     bool push = true;
     if (editor.gizmo_mode == GIZMO_TRANSLATION) {
      op.type = EDITOR_OP_TRANSLATE_ENTITY;
      op.translate.prev_p = editor.init_entity.position;
      op.translate.new_p = e->position;
      push &= (!v3_equal(op.translate.prev_p, op.translate.new_p));
     }
     else if (editor.gizmo_mode == GIZMO_SCALE) {
      op.type = EDITOR_OP_SCALE_ENTITY;
      op.scale.prev_scale = editor.init_entity.scale;
      op.scale.new_scale = e->scale;
      push &= (!v3_equal(op.scale.prev_scale, op.scale.new_scale));
     }
     else if (editor.gizmo_mode == GIZMO_ROTATION) {
      op.type = EDITOR_OP_ROTATE_ENTITY;
      op.rotate.prev_rot = editor.init_entity.rotation;
      op.rotate.new_rot = e->rotation;
      push &= (!quat_equal(op.rotate.prev_rot, op.rotate.new_rot));
     }
     if (push)
      do_editor_op(game, world, editor, op);
    }
   }
   editor.in_gizmo = 0;
   if (get_entity(world, editor.selected_entity))
    editor.init_entity = *get_entity(world, editor.selected_entity);
 }
 if (editor.edit_collision_mesh) {

  float min_hit_t;
  int hit_entity_mesh_index;
  entity_id hit_entity = raycast_to_entities(game, world, ray_origin, ray_dir, min_hit_t, hit_entity_mesh_index);

  Entity *e = get_entity(world, hit_entity);

  if (e && e->scene_id) {

   mat4 to_world = get_entity_transform(world, *e) * e->scene_transform;
   mat4 to_object = inverse(to_world);

   if (!world.scene_collision_mesh.count(e->scene_id)) {
    CollisionMesh cmesh = {};

    cmesh.vertices = make_array_max<v3>(&world.arena, 3 * 1000);
    cmesh.scene = e->scene_id;
    world.collision_meshes.push(cmesh);
    world.scene_collision_mesh[e->scene_id] = world.collision_meshes.count - 1;
   }

   CollisionMesh &cmesh = world.collision_meshes[world.scene_collision_mesh[e->scene_id]];

   v3 hit_p = ray_origin + min_hit_t * ray_dir;

   float dist_to_snap = 0.03f * length(hit_p - camera.position);
   float size = dist_to_snap;

   if (((input.buttons[BUTTON_MOUSE_RIGHT].is_down) && !(input.buttons[BUTTON_MOUSE_RIGHT].was_down))) {

    hit_p = (to_object * V4(hit_p, 1)).xyz;

    float closest_dist = FLT_MAX;
    int best_p = 0;
    for (int i = 0; i < cmesh.vertices.count; i++) {
     float dist = length_sq(cmesh.vertices[i] - hit_p);
     if (dist < closest_dist) {
      closest_dist = dist;
      best_p = i;
     }
    }
    if (closest_dist < dist_to_snap * dist_to_snap)
     hit_p = cmesh.vertices[best_p];
    cmesh.vertices.push(hit_p);
    hit_p = (to_world * V4(hit_p, 1)).xyz;
   }
   push_cube_outline(hit_p, V3(size), V3(1, 1, 0));
   for (int i = 0; i < cmesh.vertices.count; i++)
    push_cube_outline((to_world * V4(cmesh.vertices[i], 1)).xyz, V3(size), V3(1, 0, 0));

   for (int i = 0; i + 2 < cmesh.vertices.count; i += 3) {
     push_triangle_outline((to_world * V4(cmesh.vertices[i + 0], 1)).xyz,
            (to_world * V4(cmesh.vertices[i + 1], 1)).xyz,
            (to_world * V4(cmesh.vertices[i + 2], 1)).xyz, V3(1, 0, 0));
   }
  }
 }
 {
  Entity *e = get_entity(world, editor.selected_entity);
  if (e) {

   for (int i = 0; i < 3; i++) {
    v3 color = {};
    color.e[i] = 1;
    if (editor.in_gizmo && editor.dragging_axis == i)
     color = V3(1, 1, 0);

    if (editor.gizmo_mode == GIZMO_SCALE) {
     push_line(e->position, e->position + axis[i], color);
     push_cube_outline(e->position + axis[i], V3(0.1f), color);

    }
    else if (editor.gizmo_mode == GIZMO_TRANSLATION) {
     push_line(e->position, e->position + axis[i], color);
     push_ellipsoid_outline(e->position + axis[i], V3(0.1f), color);
    }
    else {






     push_circle(e->position,
       rotation_circle_radius
       , axis[(i + 1) % 3], axis[(i + 2) % 3], color);


    }




   }
   if (editor.gizmo_mode == GIZMO_SCALE) {
    push_line(e->position, e->position
      + 2*normalize(axis[0] + axis[1] + axis[2]), V3(0, 1, 0));
   }
  }
 }

 world.editor_selected_entity = editor.selected_entity;
 editor.last_camera_p = camera.position;
 if ((input.buttons[BUTTON_LEFT_CONTROL].is_down) &&
  ((input.buttons[BUTTON_C].is_down) && !(input.buttons[BUTTON_C].was_down)) &&
  editor.selected_entity) {
  editor.copied_entity = editor.selected_entity;
  editor.copy_entity_mesh = (input.buttons[BUTTON_LEFT_SHIFT].is_down);
 }
 if ((input.buttons[BUTTON_LEFT_CONTROL].is_down) &&
  ((input.buttons[BUTTON_V].is_down) && !(input.buttons[BUTTON_V].was_down))) {
  Entity *copy_from = get_entity(world, editor.copied_entity);
  if (copy_from) {
   EditorOp op = {};
   op.type = EDITOR_OP_PASTE_ENTITY;
   op.paste.copy_from = copy_from->id;
   if (editor.copy_entity_mesh)
    op.paste.mesh_index = editor.selected_entity_mesh;
   else
    op.paste.mesh_index = -1;

   float min_hit_t;
   int hit_mesh_index;
   entity_id hit_entity = raycast_to_entities(game, world, ray_origin, ray_dir, min_hit_t, hit_mesh_index);
   if (hit_entity) {
    op.paste.p = ray_origin + min_hit_t * ray_dir
     + V3(0, 0, copy_from->scale.z);
   }else
    op.paste.p = camera.position + camera.forward * 2
     * max(copy_from->scale.x, max(copy_from->scale.y, copy_from->scale.z));

   do_editor_op(game, world, editor, op);
  }
 }

 if (!editor.in_gizmo && (input.buttons[BUTTON_LEFT_CONTROL].is_down) &&
  ((input.buttons[BUTTON_Z].is_down) && !(input.buttons[BUTTON_Z].was_down))) {
  undo_editor_op(game, world, editor);
 }
 if (!editor.in_gizmo && (input.buttons[BUTTON_LEFT_CONTROL].is_down) &&
  ((input.buttons[BUTTON_X].is_down) && !(input.buttons[BUTTON_X].was_down))) {
  redo_editor_op(game, world, editor);
 }
}
# 108 "code/game.cpp" 2


ShadowMap create_shadow_map(int texture_width, int texture_height,
  v3 light_p, v3 light_dir, float znear, float zfar, float width, float height, v3 up = V3(0, 0, 1))
{
 ShadowMap shadow_map = {};

 shadow_map.tex_width = texture_width;
 shadow_map.tex_height = texture_height;
 shadow_map.light_p = light_p;
 shadow_map.light_dir = light_dir;

 shadow_map.view = lookat(shadow_map.light_p, shadow_map.light_dir, up);
 shadow_map.znear = znear;
 shadow_map.zfar = zfar;
 shadow_map.width = width;
 shadow_map.height = height;
 shadow_map.projection = orthographic_projection(znear, zfar, width, height);

 shadow_map.depth_texture = create_depth_texture(texture_width, texture_height);

 shadow_map.framebuffer = create_frame_buffer(true);

 bind_framebuffer_depthbuffer(shadow_map.framebuffer, shadow_map.depth_texture);

 if (glCheckFramebufferStatus(GL_FRAMEBUFFER) != GL_FRAMEBUFFER_COMPLETE)
  assert(0);
 return shadow_map;
}

extern "C" void game_update_and_render(Platform &platform, Arena *memory, GameInput &input, float dt)
{
 g_rc = (RenderContext *)platform.render_context;
 g_temp_arena = &platform.temp_arena;
 ImGui::SetCurrentContext((ImGuiContext *)platform.imgui_context);

 Game &game = *((Game *)memory->data);
 if (!game.is_initialized) {
  assert(memory->used == 0);
  arena_alloc_zero(memory, sizeof(game));

  init_render_context(memory, *g_rc, platform);

  usize temp_arena_size = (1024ULL * (1024ULL * 1024));
  g_temp_arena->arena = make_arena(_arena_alloc("code/game.cpp", __func__, 152, memory, temp_arena_size), temp_arena_size);


  game.scenes = make_array_max<Scene>(memory, 1024);





  game.world = new World();
  World &world = *game.world;

  world.arena = make_arena(_arena_alloc("code/game.cpp", __func__, 164, memory, (1024ULL * (1024ULL * 64))), (1024ULL * (1024ULL * 64)));
  world.editor.ops = make_array_max<EditorOp>(&world.arena, 8192);
  world.editor.undos = make_array_max<EditorOp>(&world.arena, 8192);

  game.asset_arena = make_arena(_arena_alloc("code/game.cpp", __func__, 168, memory, (1024ULL * (1024ULL * 2048))), (1024ULL * (1024ULL * 2048)));

  game.default_rasterizer_state = create_rasterizer_state(RASTERIZER_FILL_SOLID, RASTERIZER_CULL_NONE);
  game.default_depth_stencil_state = create_depth_stencil_state(true);
  game.disable_depth_state = create_depth_stencil_state(false);
  game.wireframe_rasterizer_state = create_rasterizer_state(RASTERIZER_FILL_WIREFRAME, RASTERIZER_CULL_NONE);




  VertexInputLayout input_layout = create_vertex_input_layout(g_vertex_input_elements,
    (sizeof(g_vertex_input_elements) / sizeof(*g_vertex_input_elements)), sizeof(Vertex));

  game.mesh_render_pass = create_render_pass(




    load_shader(make_cstring("shaders/vertex.glsl"), SHADER_TYPE_VERTEX),
    load_shader(make_cstring("shaders/fragment.glsl"), SHADER_TYPE_FRAGMENT),

    PRIMITIVE_TRIANGLES, game.default_depth_stencil_state, game.default_rasterizer_state,
    input_layout);

  game.outline_render_pass = create_render_pass(
    load_shader(make_cstring("shaders/outline_vertex.glsl"), SHADER_TYPE_VERTEX),
    load_shader(make_cstring("shaders/outline_fragment.glsl"), SHADER_TYPE_FRAGMENT),
    PRIMITIVE_TRIANGLES, game.default_depth_stencil_state, game.default_rasterizer_state,
    input_layout);

  game.shadow_map_render_pass = create_render_pass(
    load_shader(make_cstring("shaders/vertex.glsl"), SHADER_TYPE_VERTEX),
    load_shader(make_cstring("shaders/shadow_map_fs.glsl"), SHADER_TYPE_FRAGMENT),
    PRIMITIVE_TRIANGLES, game.default_depth_stencil_state, game.default_rasterizer_state,
    input_layout);

  game.shadow_map = create_shadow_map(4096, 4096,
    V3(24, 0, 24), V3(-1, 0, -1),
    1, 75, 50, 40);
  {
   VertexInputElement input_elements[] = {
    {0, 3, INPUT_ELEMENT_FLOAT, "POSITION"},
    {sizeof(v3), 3, INPUT_ELEMENT_FLOAT, "COLOR"},
   };
   VertexInputLayout line_input_layout = create_vertex_input_layout(input_elements, (sizeof(input_elements) / sizeof(*input_elements)),
     sizeof(v3) * 2);

   game.debug_lines_render_pass = create_render_pass(




     load_shader(make_cstring("shaders/debug_lines_vs.glsl"), SHADER_TYPE_VERTEX),
     load_shader(make_cstring("shaders/debug_lines_fs.glsl"), SHADER_TYPE_FRAGMENT),

     PRIMITIVE_LINES, game.default_depth_stencil_state, game.default_rasterizer_state,
     line_input_layout);

   game.debug_lines_vertex_buffer = create_vertex_buffer(VERTEX_BUFFER_DYNAMIC,
     g_rc->debug_lines.capacity * sizeof(v3));

   ConstantBufferElement elems[] = {
    {CONSTANT_BUFFER_ELEMENT_MAT4},
   };
   game.debug_lines_constant_buffer = create_constant_buffer(make_array<ConstantBufferElement>(elems, (sizeof(elems) / sizeof(*elems))));
  }



  {
   StructMetaData constant_metadata = get_struct_Constants_info();
   Arena *temp = begin_temp_memory();

   auto elems = make_array<ConstantBufferElement>(temp, constant_metadata.member_count);


   for (int i = 0; i < constant_metadata.member_count; i++) {

    elems[i] = {};
    bool found = false;
    for (int j = 0; j < CONSTANT_BUFFER_ELEMENT_COUNT; j++) {
     const char *type_name = get_constant_buffer_element_typename((ConstantBufferElementType)j);

     int k = 0;
     while (constant_metadata.members[i].type_name[k]
       == type_name[k] && type_name[k])
      k++;
     if (!constant_metadata.members[i].type_name[k] && !type_name[k]) {
      elems[i].type = (ConstantBufferElementType)j;
      found = true;
      break ;
     }
    }
    if (!found) {
     printf("ERROR: in constant buffer elements, couldn't find type for %s\n", constant_metadata.members[i].type_name);
     assert(0);
    }
    if (constant_metadata.members[i].is_array)
     elems[i].array_size = constant_metadata.members[i].array_size;
   }

   game.constant_buffer = create_constant_buffer(elems);
   end_temp_memory();
  }

  load_scene(&game.asset_arena, game, "data/parking/zma_carpark_b2.obj");
  load_scene(&game.asset_arena, game, "data/Sponza/Sponza.fbx");
  load_scene(&game.asset_arena, game, "data/cube.fbx");
  load_scene(&game.asset_arena, game, "data/sphere.fbx");
  load_scene(&game.asset_arena, game, "data/wood-crates/source/BoxPack1.fbx");
  load_scene(&game.asset_arena, game, "data/PrivacyFencePack/PrivacyFencePack.fbx");


  load_scene(&game.asset_arena, game, "data/Ybot.fbx");


  game.animations[ANIMATION_JUMP] = load_animation(&game.asset_arena, game, "data/jump.fbx");
  game.animations[ANIMATION_SHOOT] = load_animation(&game.asset_arena, game, "data/shoot.fbx");

  game.animations[ANIMATION_SHOOT].duration *= 0.6;
  game.animations[ANIMATION_RUN] = load_animation(&game.asset_arena, game, "data/run.fbx");
  game.animations[ANIMATION_FORWARD_GUN_WALK] = load_animation(&game.asset_arena, game, "data/forward_gun_walk.fbx");
  game.animations[ANIMATION_BACKWARD_GUN_WALK] = load_animation(&game.asset_arena, game, "data/backward_gun_walk.fbx");
  game.animations[ANIMATION_GUN_IDLE] = load_animation(&game.asset_arena, game, "data/gun_idle.fbx");
# 302 "code/game.cpp"
  FILE *fd = fopen("world.bin", "rb");
  if (!fd) {
   world.entities = make_array_max<Entity>(&world.arena, 4096);

   Entity *ground = make_entity(world, EntityType_Static, get_scene_id_by_name(game, make_cstring("cube.fbx")), V3(0, 0, -0.5));
   ground->scale = V3(100, 100, 0.5);
   ground->color = V3(0.3f);

   Entity *player = make_entity(world, EntityType_Player, get_scene_id_by_name(game, make_cstring("Ybot.fbx")),
     V3(0, 0, 4));
   player->ellipsoid_radius = V3(0.55f, 0.55f, 0.95f);
   player->ellipsoid_collision_shape = true;
   player->scene_transform = translate(0, 0, -player->ellipsoid_radius.z) * zrotation(3*3.14159265359f/2) * scale(V3(1.1));
   player->color = V3(0, 1, 1);

   world.player_id = player->id;
   world.editor_camera_p = V3(0, 0, 3);

   world.collision_meshes = make_array_max<CollisionMesh>(&world.arena, game.scenes.capacity);
  }
  else {
   serialize_World(fd, false, world, &world.arena);
   for (int i = 0; i < world.entities.count; i++)
    world.entities_id_map[world.entities[i].id] = i;
   for (int i = 0; i < world.collision_meshes.count; i++)
    world.scene_collision_mesh[world.collision_meshes[i].scene] = i;

   fclose(fd);
  }

  {
   game.debug_asset_fb = create_frame_buffer(false, true);

   Texture texture = create_texture(make_cstring("Debug Asset"), 0, 128, 128,
     true, false);
   Texture depth = create_depth_texture(texture.width, texture.height);
   bind_framebuffer_color(game.debug_asset_fb, texture);
   bind_framebuffer_depthbuffer(game.debug_asset_fb, depth);

   game.debug_asset_tex = create_texture(make_cstring("debug asset temp"),
      0, texture.width, texture.height, 1, 0);

   assert(glCheckFramebufferStatus(GL_FRAMEBUFFER)
     == GL_FRAMEBUFFER_COMPLETE);
  }

  game.sound_state.sample_count = 48000*10;
  game.sound_state.buffer = (float *)arena_alloc_zero(memory, game.sound_state.sample_count * 2 * sizeof(float));


  game.loaded_sounds[0] = load_wav_file(memory, "data/music.wav");
  game.loaded_sounds[1] = load_wav_file(memory, "data/jump.wav");

  game.master_volume = 1;
  game.frustum_culling = true;

  game.is_initialized = 1;
 }
 game.memory = memory;


 if (game.frame == 0)
  play_sound(game, game.loaded_sounds[0], 0);

 World &world = *game.world;

 if (((input.buttons[BUTTON_F1].is_down) && !(input.buttons[BUTTON_F1].was_down)))
  game.in_editor = !game.in_editor;

 if (ImGui::GetIO().WantCaptureKeyboard) {
  for (int i = 0; i < BUTTON_COUNT; i++)
   if ((i != BUTTON_MOUSE_LEFT && i != BUTTON_MOUSE_RIGHT))
    input.buttons[i].is_down = false;
 }

 begin_render_frame();



 if (!game.in_editor) {
  update_player(game, world, input, dt);
  update_enemies(game, world, input, dt);






 }
 Camera game_camera = update_camera(game, world, input, dt);

 if (!game.in_editor)
  world.last_game_camera = game_camera;


 update_editor(game, world, world.editor, input, game_camera);
 if (game.in_editor) {

  Camera c = world.last_game_camera;

  v3 p[4] = {
   c.position + c.forward * c.znear - c.right * c.width * 0.5f - c.up * c.height * 0.5f,
   c.position + c.forward * c.znear + c.right * c.width * 0.5f - c.up * c.height * 0.5f,
   c.position + c.forward * c.znear + c.right * c.width * 0.5f + c.up * c.height * 0.5f,
   c.position + c.forward * c.znear - c.right * c.width * 0.5f + c.up * c.height * 0.5f,
  };
  push_line(c.position, p[0]);
  push_line(c.position, p[1]);
  push_line(c.position, p[2]);
  push_line(c.position, p[3]);
  push_line(p[0], p[1]);
  push_line(p[1], p[2]);
  push_line(p[2], p[3]);
  push_line(p[3], p[0]);
 }
 push_cube_outline(game.shadow_map.light_p, V3(0.3));
 push_line(game.shadow_map.light_p, game.shadow_map.light_p + 0.5 * game.shadow_map.light_dir);

 begin_render_pass(game.shadow_map_render_pass);
 {
  set_viewport(0, 0, game.shadow_map.tex_width, game.shadow_map.tex_height);
  bind_framebuffer(game.shadow_map.framebuffer);
  clear_framebuffer_depth(game.shadow_map.framebuffer, 1);
  render_entities(game, world, make_orthographic_camera(game.shadow_map.view, game.shadow_map.znear,
   game.shadow_map.zfar, game.shadow_map.width, game.shadow_map.height), true);
 }
 end_render_pass();

 begin_render_pass(game.mesh_render_pass);
 {
  set_viewport(0, 0, g_rc->window_width, g_rc->window_height);

  bind_framebuffer(g_rc->window_framebuffer);
  clear_framebuffer_color(g_rc->window_framebuffer, V4(0.392f, 0.584f, 0.929f, 1.f));
  clear_framebuffer_depth(g_rc->window_framebuffer, 1);

  bind_texture(4, game.shadow_map.depth_texture);
  render_entities(game, world, game_camera, false);




 }
 end_render_pass();





 begin_render_pass(game.debug_lines_render_pass);
 {

  clear_framebuffer_depth(g_rc->window_framebuffer, 1);
  update_vertex_buffer(game.debug_lines_vertex_buffer, (int)g_rc->debug_lines.count * sizeof(v3),
    g_rc->debug_lines.data);
  mat4 mvp = game_camera.projection * game_camera.view;
  bind_constant_buffer(game.debug_lines_constant_buffer, 1);
  update_constant_buffer(game.debug_lines_constant_buffer, &mvp);
  bind_vertex_buffer(game.debug_lines_vertex_buffer);
  draw(0, (int)(g_rc->debug_lines.count / 2));
 }
 end_render_pass();


 {
  ImGuiIO &io = ImGui::GetIO();
  ImGui::Begin("debug");
  ImGui::Text("average %.3f ms/frame (%.1f FPS)", 1000.0f / io.Framerate, io.Framerate);
  ImGui::Text("resolution: %dx%d", g_rc->window_width, g_rc->window_height);

  ImGui::Text("entity count: %ld", world.entities.count);
  if (ImGui::Button("new cube")) {
   Entity *entity = make_entity(world, EntityType_Static,
     get_scene_id_by_name(game, make_cstring("cube.fbx")), game_camera.position
     + game_camera.forward * 4);
   world.editor.selected_entity = entity->id;
  }
  if (ImGui::Button("new sphere")) {
   Entity *entity = make_entity(world, EntityType_Static,
     get_scene_id_by_name(game, make_cstring("sphere.fbx")), game_camera.position
     + game_camera.forward * 4);
   entity->ellipsoid_radius = V3(1);
   entity->ellipsoid_collision_shape = true;
   world.editor.selected_entity = entity->id;
  }

  if (ImGui::Button("save world")) {
   FILE *fd = fopen("world.bin", "wb");
   if (!fd)
    assert(0);
   serialize_World(fd, true, world);
   fclose(fd);
  }

  if (get_entity(world, world.editor.copied_entity))
   ImGui::Text("copying entity %ld", world.editor.copied_entity);
  imgui_edit_struct_Game(game, "game");
  imgui_edit_struct_World(world, "world");

  ImGui::End();
 }


 end_render_frame();

 update_sound(game, world);

 game.time += dt;

 if (game.frame == 0 || !game.in_editor) ImGui::SetWindowFocus(
# 511 "code/game.cpp" 3 4
                                                              __null
# 511 "code/game.cpp"
                                                                  );
 game.frame++;
}
