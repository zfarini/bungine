# 1 "code/glfw_main.cpp"
# 1 "<built-in>"
# 1 "<command-line>"
# 1 "/usr/include/stdc-predef.h" 1 3 4
# 1 "<command-line>" 2
# 1 "code/glfw_main.cpp"
# 1 "include/glad/glad.h" 1
# 47 "include/glad/glad.h"
extern "C" {


struct gladGLversionStruct {
    int major;
    int minor;
};

typedef void* (* GLADloadproc)(const char *name);
# 83 "include/glad/glad.h"
extern struct gladGLversionStruct GLVersion;

extern int gladLoadGL(void);

extern int gladLoadGLLoader(GLADloadproc);

# 1 "include/KHR/khrplatform.h" 1
# 149 "include/KHR/khrplatform.h"
# 1 "/usr/lib/gcc/x86_64-linux-gnu/10/include/stdint.h" 1 3 4
# 9 "/usr/lib/gcc/x86_64-linux-gnu/10/include/stdint.h" 3 4
# 1 "/usr/include/stdint.h" 1 3 4
# 26 "/usr/include/stdint.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/libc-header-start.h" 1 3 4
# 33 "/usr/include/x86_64-linux-gnu/bits/libc-header-start.h" 3 4
# 1 "/usr/include/features.h" 1 3 4
# 392 "/usr/include/features.h" 3 4
# 1 "/usr/include/features-time64.h" 1 3 4
# 20 "/usr/include/features-time64.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 21 "/usr/include/features-time64.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/timesize.h" 1 3 4
# 19 "/usr/include/x86_64-linux-gnu/bits/timesize.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 20 "/usr/include/x86_64-linux-gnu/bits/timesize.h" 2 3 4
# 22 "/usr/include/features-time64.h" 2 3 4
# 393 "/usr/include/features.h" 2 3 4
# 486 "/usr/include/features.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/sys/cdefs.h" 1 3 4
# 559 "/usr/include/x86_64-linux-gnu/sys/cdefs.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 560 "/usr/include/x86_64-linux-gnu/sys/cdefs.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/long-double.h" 1 3 4
# 561 "/usr/include/x86_64-linux-gnu/sys/cdefs.h" 2 3 4
# 487 "/usr/include/features.h" 2 3 4
# 510 "/usr/include/features.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/gnu/stubs.h" 1 3 4
# 10 "/usr/include/x86_64-linux-gnu/gnu/stubs.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/gnu/stubs-64.h" 1 3 4
# 11 "/usr/include/x86_64-linux-gnu/gnu/stubs.h" 2 3 4
# 511 "/usr/include/features.h" 2 3 4
# 34 "/usr/include/x86_64-linux-gnu/bits/libc-header-start.h" 2 3 4
# 27 "/usr/include/stdint.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types.h" 1 3 4
# 27 "/usr/include/x86_64-linux-gnu/bits/types.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 28 "/usr/include/x86_64-linux-gnu/bits/types.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/timesize.h" 1 3 4
# 19 "/usr/include/x86_64-linux-gnu/bits/timesize.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 20 "/usr/include/x86_64-linux-gnu/bits/timesize.h" 2 3 4
# 29 "/usr/include/x86_64-linux-gnu/bits/types.h" 2 3 4



# 31 "/usr/include/x86_64-linux-gnu/bits/types.h" 3 4
typedef unsigned char __u_char;
typedef unsigned short int __u_short;
typedef unsigned int __u_int;
typedef unsigned long int __u_long;


typedef signed char __int8_t;
typedef unsigned char __uint8_t;
typedef signed short int __int16_t;
typedef unsigned short int __uint16_t;
typedef signed int __int32_t;
typedef unsigned int __uint32_t;

typedef signed long int __int64_t;
typedef unsigned long int __uint64_t;






typedef __int8_t __int_least8_t;
typedef __uint8_t __uint_least8_t;
typedef __int16_t __int_least16_t;
typedef __uint16_t __uint_least16_t;
typedef __int32_t __int_least32_t;
typedef __uint32_t __uint_least32_t;
typedef __int64_t __int_least64_t;
typedef __uint64_t __uint_least64_t;



typedef long int __quad_t;
typedef unsigned long int __u_quad_t;







typedef long int __intmax_t;
typedef unsigned long int __uintmax_t;
# 141 "/usr/include/x86_64-linux-gnu/bits/types.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/typesizes.h" 1 3 4
# 142 "/usr/include/x86_64-linux-gnu/bits/types.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/time64.h" 1 3 4
# 143 "/usr/include/x86_64-linux-gnu/bits/types.h" 2 3 4


typedef unsigned long int __dev_t;
typedef unsigned int __uid_t;
typedef unsigned int __gid_t;
typedef unsigned long int __ino_t;
typedef unsigned long int __ino64_t;
typedef unsigned int __mode_t;
typedef unsigned long int __nlink_t;
typedef long int __off_t;
typedef long int __off64_t;
typedef int __pid_t;
typedef struct { int __val[2]; } __fsid_t;
typedef long int __clock_t;
typedef unsigned long int __rlim_t;
typedef unsigned long int __rlim64_t;
typedef unsigned int __id_t;
typedef long int __time_t;
typedef unsigned int __useconds_t;
typedef long int __suseconds_t;
typedef long int __suseconds64_t;

typedef int __daddr_t;
typedef int __key_t;


typedef int __clockid_t;


typedef void * __timer_t;


typedef long int __blksize_t;




typedef long int __blkcnt_t;
typedef long int __blkcnt64_t;


typedef unsigned long int __fsblkcnt_t;
typedef unsigned long int __fsblkcnt64_t;


typedef unsigned long int __fsfilcnt_t;
typedef unsigned long int __fsfilcnt64_t;


typedef long int __fsword_t;

typedef long int __ssize_t;


typedef long int __syscall_slong_t;

typedef unsigned long int __syscall_ulong_t;



typedef __off64_t __loff_t;
typedef char *__caddr_t;


typedef long int __intptr_t;


typedef unsigned int __socklen_t;




typedef int __sig_atomic_t;
# 28 "/usr/include/stdint.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wchar.h" 1 3 4
# 29 "/usr/include/stdint.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 30 "/usr/include/stdint.h" 2 3 4




# 1 "/usr/include/x86_64-linux-gnu/bits/stdint-intn.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/stdint-intn.h" 3 4
typedef __int8_t int8_t;
typedef __int16_t int16_t;
typedef __int32_t int32_t;
typedef __int64_t int64_t;
# 35 "/usr/include/stdint.h" 2 3 4


# 1 "/usr/include/x86_64-linux-gnu/bits/stdint-uintn.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/stdint-uintn.h" 3 4
typedef __uint8_t uint8_t;
typedef __uint16_t uint16_t;
typedef __uint32_t uint32_t;
typedef __uint64_t uint64_t;
# 38 "/usr/include/stdint.h" 2 3 4





typedef __int_least8_t int_least8_t;
typedef __int_least16_t int_least16_t;
typedef __int_least32_t int_least32_t;
typedef __int_least64_t int_least64_t;


typedef __uint_least8_t uint_least8_t;
typedef __uint_least16_t uint_least16_t;
typedef __uint_least32_t uint_least32_t;
typedef __uint_least64_t uint_least64_t;





typedef signed char int_fast8_t;

typedef long int int_fast16_t;
typedef long int int_fast32_t;
typedef long int int_fast64_t;
# 71 "/usr/include/stdint.h" 3 4
typedef unsigned char uint_fast8_t;

typedef unsigned long int uint_fast16_t;
typedef unsigned long int uint_fast32_t;
typedef unsigned long int uint_fast64_t;
# 87 "/usr/include/stdint.h" 3 4
typedef long int intptr_t;


typedef unsigned long int uintptr_t;
# 101 "/usr/include/stdint.h" 3 4
typedef __intmax_t intmax_t;
typedef __uintmax_t uintmax_t;
# 10 "/usr/lib/gcc/x86_64-linux-gnu/10/include/stdint.h" 2 3 4
# 150 "include/KHR/khrplatform.h" 2

# 150 "include/KHR/khrplatform.h"
typedef int32_t khronos_int32_t;
typedef uint32_t khronos_uint32_t;
typedef int64_t khronos_int64_t;
typedef uint64_t khronos_uint64_t;
# 242 "include/KHR/khrplatform.h"
typedef signed char khronos_int8_t;
typedef unsigned char khronos_uint8_t;
typedef signed short int khronos_int16_t;
typedef unsigned short int khronos_uint16_t;
# 259 "include/KHR/khrplatform.h"
typedef signed long int khronos_intptr_t;
typedef unsigned long int khronos_uintptr_t;






typedef signed long int khronos_ssize_t;
typedef unsigned long int khronos_usize_t;






typedef float khronos_float_t;
# 288 "include/KHR/khrplatform.h"
typedef khronos_uint64_t khronos_utime_nanoseconds_t;
typedef khronos_int64_t khronos_stime_nanoseconds_t;
# 305 "include/KHR/khrplatform.h"
typedef enum {
    KHRONOS_FALSE = 0,
    KHRONOS_TRUE = 1,
    KHRONOS_BOOLEAN_ENUM_FORCE_SIZE = 0x7FFFFFFF
} khronos_boolean_enum_t;
# 90 "include/glad/glad.h" 2
typedef unsigned int GLenum;
typedef unsigned char GLboolean;
typedef unsigned int GLbitfield;
typedef void GLvoid;
typedef khronos_int8_t GLbyte;
typedef khronos_uint8_t GLubyte;
typedef khronos_int16_t GLshort;
typedef khronos_uint16_t GLushort;
typedef int GLint;
typedef unsigned int GLuint;
typedef khronos_int32_t GLclampx;
typedef int GLsizei;
typedef khronos_float_t GLfloat;
typedef khronos_float_t GLclampf;
typedef double GLdouble;
typedef double GLclampd;
typedef void *GLeglClientBufferEXT;
typedef void *GLeglImageOES;
typedef char GLchar;
typedef char GLcharARB;



typedef unsigned int GLhandleARB;

typedef khronos_uint16_t GLhalf;
typedef khronos_uint16_t GLhalfARB;
typedef khronos_int32_t GLfixed;
typedef khronos_intptr_t GLintptr;
typedef khronos_intptr_t GLintptrARB;
typedef khronos_ssize_t GLsizeiptr;
typedef khronos_ssize_t GLsizeiptrARB;
typedef khronos_int64_t GLint64;
typedef khronos_int64_t GLint64EXT;
typedef khronos_uint64_t GLuint64;
typedef khronos_uint64_t GLuint64EXT;
typedef struct __GLsync *GLsync;
struct _cl_context;
struct _cl_event;
typedef void ( *GLDEBUGPROC)(GLenum source,GLenum type,GLuint id,GLenum severity,GLsizei length,const GLchar *message,const void *userParam);
typedef void ( *GLDEBUGPROCARB)(GLenum source,GLenum type,GLuint id,GLenum severity,GLsizei length,const GLchar *message,const void *userParam);
typedef void ( *GLDEBUGPROCKHR)(GLenum source,GLenum type,GLuint id,GLenum severity,GLsizei length,const GLchar *message,const void *userParam);
typedef void ( *GLDEBUGPROCAMD)(GLuint id,GLenum category,GLenum severity,GLsizei length,const GLchar *message,void *userParam);
typedef unsigned short GLhalfNV;
typedef GLintptr GLvdpauSurfaceNV;
typedef void ( *GLVULKANPROCNV)(void);
# 1496 "include/glad/glad.h"
extern int GLAD_GL_VERSION_1_0;
typedef void ( * PFNGLCULLFACEPROC)(GLenum mode);
extern PFNGLCULLFACEPROC glad_glCullFace;

typedef void ( * PFNGLFRONTFACEPROC)(GLenum mode);
extern PFNGLFRONTFACEPROC glad_glFrontFace;

typedef void ( * PFNGLHINTPROC)(GLenum target, GLenum mode);
extern PFNGLHINTPROC glad_glHint;

typedef void ( * PFNGLLINEWIDTHPROC)(GLfloat width);
extern PFNGLLINEWIDTHPROC glad_glLineWidth;

typedef void ( * PFNGLPOINTSIZEPROC)(GLfloat size);
extern PFNGLPOINTSIZEPROC glad_glPointSize;

typedef void ( * PFNGLPOLYGONMODEPROC)(GLenum face, GLenum mode);
extern PFNGLPOLYGONMODEPROC glad_glPolygonMode;

typedef void ( * PFNGLSCISSORPROC)(GLint x, GLint y, GLsizei width, GLsizei height);
extern PFNGLSCISSORPROC glad_glScissor;

typedef void ( * PFNGLTEXPARAMETERFPROC)(GLenum target, GLenum pname, GLfloat param);
extern PFNGLTEXPARAMETERFPROC glad_glTexParameterf;

typedef void ( * PFNGLTEXPARAMETERFVPROC)(GLenum target, GLenum pname, const GLfloat *params);
extern PFNGLTEXPARAMETERFVPROC glad_glTexParameterfv;

typedef void ( * PFNGLTEXPARAMETERIPROC)(GLenum target, GLenum pname, GLint param);
extern PFNGLTEXPARAMETERIPROC glad_glTexParameteri;

typedef void ( * PFNGLTEXPARAMETERIVPROC)(GLenum target, GLenum pname, const GLint *params);
extern PFNGLTEXPARAMETERIVPROC glad_glTexParameteriv;

typedef void ( * PFNGLTEXIMAGE1DPROC)(GLenum target, GLint level, GLint internalformat, GLsizei width, GLint border, GLenum format, GLenum type, const void *pixels);
extern PFNGLTEXIMAGE1DPROC glad_glTexImage1D;

typedef void ( * PFNGLTEXIMAGE2DPROC)(GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const void *pixels);
extern PFNGLTEXIMAGE2DPROC glad_glTexImage2D;

typedef void ( * PFNGLDRAWBUFFERPROC)(GLenum buf);
extern PFNGLDRAWBUFFERPROC glad_glDrawBuffer;

typedef void ( * PFNGLCLEARPROC)(GLbitfield mask);
extern PFNGLCLEARPROC glad_glClear;

typedef void ( * PFNGLCLEARCOLORPROC)(GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha);
extern PFNGLCLEARCOLORPROC glad_glClearColor;

typedef void ( * PFNGLCLEARSTENCILPROC)(GLint s);
extern PFNGLCLEARSTENCILPROC glad_glClearStencil;

typedef void ( * PFNGLCLEARDEPTHPROC)(GLdouble depth);
extern PFNGLCLEARDEPTHPROC glad_glClearDepth;

typedef void ( * PFNGLSTENCILMASKPROC)(GLuint mask);
extern PFNGLSTENCILMASKPROC glad_glStencilMask;

typedef void ( * PFNGLCOLORMASKPROC)(GLboolean red, GLboolean green, GLboolean blue, GLboolean alpha);
extern PFNGLCOLORMASKPROC glad_glColorMask;

typedef void ( * PFNGLDEPTHMASKPROC)(GLboolean flag);
extern PFNGLDEPTHMASKPROC glad_glDepthMask;

typedef void ( * PFNGLDISABLEPROC)(GLenum cap);
extern PFNGLDISABLEPROC glad_glDisable;

typedef void ( * PFNGLENABLEPROC)(GLenum cap);
extern PFNGLENABLEPROC glad_glEnable;

typedef void ( * PFNGLFINISHPROC)(void);
extern PFNGLFINISHPROC glad_glFinish;

typedef void ( * PFNGLFLUSHPROC)(void);
extern PFNGLFLUSHPROC glad_glFlush;

typedef void ( * PFNGLBLENDFUNCPROC)(GLenum sfactor, GLenum dfactor);
extern PFNGLBLENDFUNCPROC glad_glBlendFunc;

typedef void ( * PFNGLLOGICOPPROC)(GLenum opcode);
extern PFNGLLOGICOPPROC glad_glLogicOp;

typedef void ( * PFNGLSTENCILFUNCPROC)(GLenum func, GLint ref, GLuint mask);
extern PFNGLSTENCILFUNCPROC glad_glStencilFunc;

typedef void ( * PFNGLSTENCILOPPROC)(GLenum fail, GLenum zfail, GLenum zpass);
extern PFNGLSTENCILOPPROC glad_glStencilOp;

typedef void ( * PFNGLDEPTHFUNCPROC)(GLenum func);
extern PFNGLDEPTHFUNCPROC glad_glDepthFunc;

typedef void ( * PFNGLPIXELSTOREFPROC)(GLenum pname, GLfloat param);
extern PFNGLPIXELSTOREFPROC glad_glPixelStoref;

typedef void ( * PFNGLPIXELSTOREIPROC)(GLenum pname, GLint param);
extern PFNGLPIXELSTOREIPROC glad_glPixelStorei;

typedef void ( * PFNGLREADBUFFERPROC)(GLenum src);
extern PFNGLREADBUFFERPROC glad_glReadBuffer;

typedef void ( * PFNGLREADPIXELSPROC)(GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, void *pixels);
extern PFNGLREADPIXELSPROC glad_glReadPixels;

typedef void ( * PFNGLGETBOOLEANVPROC)(GLenum pname, GLboolean *data);
extern PFNGLGETBOOLEANVPROC glad_glGetBooleanv;

typedef void ( * PFNGLGETDOUBLEVPROC)(GLenum pname, GLdouble *data);
extern PFNGLGETDOUBLEVPROC glad_glGetDoublev;

typedef GLenum ( * PFNGLGETERRORPROC)(void);
extern PFNGLGETERRORPROC glad_glGetError;

typedef void ( * PFNGLGETFLOATVPROC)(GLenum pname, GLfloat *data);
extern PFNGLGETFLOATVPROC glad_glGetFloatv;

typedef void ( * PFNGLGETINTEGERVPROC)(GLenum pname, GLint *data);
extern PFNGLGETINTEGERVPROC glad_glGetIntegerv;

typedef const GLubyte * ( * PFNGLGETSTRINGPROC)(GLenum name);
extern PFNGLGETSTRINGPROC glad_glGetString;

typedef void ( * PFNGLGETTEXIMAGEPROC)(GLenum target, GLint level, GLenum format, GLenum type, void *pixels);
extern PFNGLGETTEXIMAGEPROC glad_glGetTexImage;

typedef void ( * PFNGLGETTEXPARAMETERFVPROC)(GLenum target, GLenum pname, GLfloat *params);
extern PFNGLGETTEXPARAMETERFVPROC glad_glGetTexParameterfv;

typedef void ( * PFNGLGETTEXPARAMETERIVPROC)(GLenum target, GLenum pname, GLint *params);
extern PFNGLGETTEXPARAMETERIVPROC glad_glGetTexParameteriv;

typedef void ( * PFNGLGETTEXLEVELPARAMETERFVPROC)(GLenum target, GLint level, GLenum pname, GLfloat *params);
extern PFNGLGETTEXLEVELPARAMETERFVPROC glad_glGetTexLevelParameterfv;

typedef void ( * PFNGLGETTEXLEVELPARAMETERIVPROC)(GLenum target, GLint level, GLenum pname, GLint *params);
extern PFNGLGETTEXLEVELPARAMETERIVPROC glad_glGetTexLevelParameteriv;

typedef GLboolean ( * PFNGLISENABLEDPROC)(GLenum cap);
extern PFNGLISENABLEDPROC glad_glIsEnabled;

typedef void ( * PFNGLDEPTHRANGEPROC)(GLdouble n, GLdouble f);
extern PFNGLDEPTHRANGEPROC glad_glDepthRange;

typedef void ( * PFNGLVIEWPORTPROC)(GLint x, GLint y, GLsizei width, GLsizei height);
extern PFNGLVIEWPORTPROC glad_glViewport;




extern int GLAD_GL_VERSION_1_1;
typedef void ( * PFNGLDRAWARRAYSPROC)(GLenum mode, GLint first, GLsizei count);
extern PFNGLDRAWARRAYSPROC glad_glDrawArrays;

typedef void ( * PFNGLDRAWELEMENTSPROC)(GLenum mode, GLsizei count, GLenum type, const void *indices);
extern PFNGLDRAWELEMENTSPROC glad_glDrawElements;

typedef void ( * PFNGLPOLYGONOFFSETPROC)(GLfloat factor, GLfloat units);
extern PFNGLPOLYGONOFFSETPROC glad_glPolygonOffset;

typedef void ( * PFNGLCOPYTEXIMAGE1DPROC)(GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLint border);
extern PFNGLCOPYTEXIMAGE1DPROC glad_glCopyTexImage1D;

typedef void ( * PFNGLCOPYTEXIMAGE2DPROC)(GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border);
extern PFNGLCOPYTEXIMAGE2DPROC glad_glCopyTexImage2D;

typedef void ( * PFNGLCOPYTEXSUBIMAGE1DPROC)(GLenum target, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width);
extern PFNGLCOPYTEXSUBIMAGE1DPROC glad_glCopyTexSubImage1D;

typedef void ( * PFNGLCOPYTEXSUBIMAGE2DPROC)(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height);
extern PFNGLCOPYTEXSUBIMAGE2DPROC glad_glCopyTexSubImage2D;

typedef void ( * PFNGLTEXSUBIMAGE1DPROC)(GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const void *pixels);
extern PFNGLTEXSUBIMAGE1DPROC glad_glTexSubImage1D;

typedef void ( * PFNGLTEXSUBIMAGE2DPROC)(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const void *pixels);
extern PFNGLTEXSUBIMAGE2DPROC glad_glTexSubImage2D;

typedef void ( * PFNGLBINDTEXTUREPROC)(GLenum target, GLuint texture);
extern PFNGLBINDTEXTUREPROC glad_glBindTexture;

typedef void ( * PFNGLDELETETEXTURESPROC)(GLsizei n, const GLuint *textures);
extern PFNGLDELETETEXTURESPROC glad_glDeleteTextures;

typedef void ( * PFNGLGENTEXTURESPROC)(GLsizei n, GLuint *textures);
extern PFNGLGENTEXTURESPROC glad_glGenTextures;

typedef GLboolean ( * PFNGLISTEXTUREPROC)(GLuint texture);
extern PFNGLISTEXTUREPROC glad_glIsTexture;




extern int GLAD_GL_VERSION_1_2;
typedef void ( * PFNGLDRAWRANGEELEMENTSPROC)(GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const void *indices);
extern PFNGLDRAWRANGEELEMENTSPROC glad_glDrawRangeElements;

typedef void ( * PFNGLTEXIMAGE3DPROC)(GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const void *pixels);
extern PFNGLTEXIMAGE3DPROC glad_glTexImage3D;

typedef void ( * PFNGLTEXSUBIMAGE3DPROC)(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const void *pixels);
extern PFNGLTEXSUBIMAGE3DPROC glad_glTexSubImage3D;

typedef void ( * PFNGLCOPYTEXSUBIMAGE3DPROC)(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height);
extern PFNGLCOPYTEXSUBIMAGE3DPROC glad_glCopyTexSubImage3D;




extern int GLAD_GL_VERSION_1_3;
typedef void ( * PFNGLACTIVETEXTUREPROC)(GLenum texture);
extern PFNGLACTIVETEXTUREPROC glad_glActiveTexture;

typedef void ( * PFNGLSAMPLECOVERAGEPROC)(GLfloat value, GLboolean invert);
extern PFNGLSAMPLECOVERAGEPROC glad_glSampleCoverage;

typedef void ( * PFNGLCOMPRESSEDTEXIMAGE3DPROC)(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const void *data);
extern PFNGLCOMPRESSEDTEXIMAGE3DPROC glad_glCompressedTexImage3D;

typedef void ( * PFNGLCOMPRESSEDTEXIMAGE2DPROC)(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const void *data);
extern PFNGLCOMPRESSEDTEXIMAGE2DPROC glad_glCompressedTexImage2D;

typedef void ( * PFNGLCOMPRESSEDTEXIMAGE1DPROC)(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLint border, GLsizei imageSize, const void *data);
extern PFNGLCOMPRESSEDTEXIMAGE1DPROC glad_glCompressedTexImage1D;

typedef void ( * PFNGLCOMPRESSEDTEXSUBIMAGE3DPROC)(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const void *data);
extern PFNGLCOMPRESSEDTEXSUBIMAGE3DPROC glad_glCompressedTexSubImage3D;

typedef void ( * PFNGLCOMPRESSEDTEXSUBIMAGE2DPROC)(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const void *data);
extern PFNGLCOMPRESSEDTEXSUBIMAGE2DPROC glad_glCompressedTexSubImage2D;

typedef void ( * PFNGLCOMPRESSEDTEXSUBIMAGE1DPROC)(GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const void *data);
extern PFNGLCOMPRESSEDTEXSUBIMAGE1DPROC glad_glCompressedTexSubImage1D;

typedef void ( * PFNGLGETCOMPRESSEDTEXIMAGEPROC)(GLenum target, GLint level, void *img);
extern PFNGLGETCOMPRESSEDTEXIMAGEPROC glad_glGetCompressedTexImage;




extern int GLAD_GL_VERSION_1_4;
typedef void ( * PFNGLBLENDFUNCSEPARATEPROC)(GLenum sfactorRGB, GLenum dfactorRGB, GLenum sfactorAlpha, GLenum dfactorAlpha);
extern PFNGLBLENDFUNCSEPARATEPROC glad_glBlendFuncSeparate;

typedef void ( * PFNGLMULTIDRAWARRAYSPROC)(GLenum mode, const GLint *first, const GLsizei *count, GLsizei drawcount);
extern PFNGLMULTIDRAWARRAYSPROC glad_glMultiDrawArrays;

typedef void ( * PFNGLMULTIDRAWELEMENTSPROC)(GLenum mode, const GLsizei *count, GLenum type, const void *const*indices, GLsizei drawcount);
extern PFNGLMULTIDRAWELEMENTSPROC glad_glMultiDrawElements;

typedef void ( * PFNGLPOINTPARAMETERFPROC)(GLenum pname, GLfloat param);
extern PFNGLPOINTPARAMETERFPROC glad_glPointParameterf;

typedef void ( * PFNGLPOINTPARAMETERFVPROC)(GLenum pname, const GLfloat *params);
extern PFNGLPOINTPARAMETERFVPROC glad_glPointParameterfv;

typedef void ( * PFNGLPOINTPARAMETERIPROC)(GLenum pname, GLint param);
extern PFNGLPOINTPARAMETERIPROC glad_glPointParameteri;

typedef void ( * PFNGLPOINTPARAMETERIVPROC)(GLenum pname, const GLint *params);
extern PFNGLPOINTPARAMETERIVPROC glad_glPointParameteriv;

typedef void ( * PFNGLBLENDCOLORPROC)(GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha);
extern PFNGLBLENDCOLORPROC glad_glBlendColor;

typedef void ( * PFNGLBLENDEQUATIONPROC)(GLenum mode);
extern PFNGLBLENDEQUATIONPROC glad_glBlendEquation;




extern int GLAD_GL_VERSION_1_5;
typedef void ( * PFNGLGENQUERIESPROC)(GLsizei n, GLuint *ids);
extern PFNGLGENQUERIESPROC glad_glGenQueries;

typedef void ( * PFNGLDELETEQUERIESPROC)(GLsizei n, const GLuint *ids);
extern PFNGLDELETEQUERIESPROC glad_glDeleteQueries;

typedef GLboolean ( * PFNGLISQUERYPROC)(GLuint id);
extern PFNGLISQUERYPROC glad_glIsQuery;

typedef void ( * PFNGLBEGINQUERYPROC)(GLenum target, GLuint id);
extern PFNGLBEGINQUERYPROC glad_glBeginQuery;

typedef void ( * PFNGLENDQUERYPROC)(GLenum target);
extern PFNGLENDQUERYPROC glad_glEndQuery;

typedef void ( * PFNGLGETQUERYIVPROC)(GLenum target, GLenum pname, GLint *params);
extern PFNGLGETQUERYIVPROC glad_glGetQueryiv;

typedef void ( * PFNGLGETQUERYOBJECTIVPROC)(GLuint id, GLenum pname, GLint *params);
extern PFNGLGETQUERYOBJECTIVPROC glad_glGetQueryObjectiv;

typedef void ( * PFNGLGETQUERYOBJECTUIVPROC)(GLuint id, GLenum pname, GLuint *params);
extern PFNGLGETQUERYOBJECTUIVPROC glad_glGetQueryObjectuiv;

typedef void ( * PFNGLBINDBUFFERPROC)(GLenum target, GLuint buffer);
extern PFNGLBINDBUFFERPROC glad_glBindBuffer;

typedef void ( * PFNGLDELETEBUFFERSPROC)(GLsizei n, const GLuint *buffers);
extern PFNGLDELETEBUFFERSPROC glad_glDeleteBuffers;

typedef void ( * PFNGLGENBUFFERSPROC)(GLsizei n, GLuint *buffers);
extern PFNGLGENBUFFERSPROC glad_glGenBuffers;

typedef GLboolean ( * PFNGLISBUFFERPROC)(GLuint buffer);
extern PFNGLISBUFFERPROC glad_glIsBuffer;

typedef void ( * PFNGLBUFFERDATAPROC)(GLenum target, GLsizeiptr size, const void *data, GLenum usage);
extern PFNGLBUFFERDATAPROC glad_glBufferData;

typedef void ( * PFNGLBUFFERSUBDATAPROC)(GLenum target, GLintptr offset, GLsizeiptr size, const void *data);
extern PFNGLBUFFERSUBDATAPROC glad_glBufferSubData;

typedef void ( * PFNGLGETBUFFERSUBDATAPROC)(GLenum target, GLintptr offset, GLsizeiptr size, void *data);
extern PFNGLGETBUFFERSUBDATAPROC glad_glGetBufferSubData;

typedef void * ( * PFNGLMAPBUFFERPROC)(GLenum target, GLenum access);
extern PFNGLMAPBUFFERPROC glad_glMapBuffer;

typedef GLboolean ( * PFNGLUNMAPBUFFERPROC)(GLenum target);
extern PFNGLUNMAPBUFFERPROC glad_glUnmapBuffer;

typedef void ( * PFNGLGETBUFFERPARAMETERIVPROC)(GLenum target, GLenum pname, GLint *params);
extern PFNGLGETBUFFERPARAMETERIVPROC glad_glGetBufferParameteriv;

typedef void ( * PFNGLGETBUFFERPOINTERVPROC)(GLenum target, GLenum pname, void **params);
extern PFNGLGETBUFFERPOINTERVPROC glad_glGetBufferPointerv;




extern int GLAD_GL_VERSION_2_0;
typedef void ( * PFNGLBLENDEQUATIONSEPARATEPROC)(GLenum modeRGB, GLenum modeAlpha);
extern PFNGLBLENDEQUATIONSEPARATEPROC glad_glBlendEquationSeparate;

typedef void ( * PFNGLDRAWBUFFERSPROC)(GLsizei n, const GLenum *bufs);
extern PFNGLDRAWBUFFERSPROC glad_glDrawBuffers;

typedef void ( * PFNGLSTENCILOPSEPARATEPROC)(GLenum face, GLenum sfail, GLenum dpfail, GLenum dppass);
extern PFNGLSTENCILOPSEPARATEPROC glad_glStencilOpSeparate;

typedef void ( * PFNGLSTENCILFUNCSEPARATEPROC)(GLenum face, GLenum func, GLint ref, GLuint mask);
extern PFNGLSTENCILFUNCSEPARATEPROC glad_glStencilFuncSeparate;

typedef void ( * PFNGLSTENCILMASKSEPARATEPROC)(GLenum face, GLuint mask);
extern PFNGLSTENCILMASKSEPARATEPROC glad_glStencilMaskSeparate;

typedef void ( * PFNGLATTACHSHADERPROC)(GLuint program, GLuint shader);
extern PFNGLATTACHSHADERPROC glad_glAttachShader;

typedef void ( * PFNGLBINDATTRIBLOCATIONPROC)(GLuint program, GLuint index, const GLchar *name);
extern PFNGLBINDATTRIBLOCATIONPROC glad_glBindAttribLocation;

typedef void ( * PFNGLCOMPILESHADERPROC)(GLuint shader);
extern PFNGLCOMPILESHADERPROC glad_glCompileShader;

typedef GLuint ( * PFNGLCREATEPROGRAMPROC)(void);
extern PFNGLCREATEPROGRAMPROC glad_glCreateProgram;

typedef GLuint ( * PFNGLCREATESHADERPROC)(GLenum type);
extern PFNGLCREATESHADERPROC glad_glCreateShader;

typedef void ( * PFNGLDELETEPROGRAMPROC)(GLuint program);
extern PFNGLDELETEPROGRAMPROC glad_glDeleteProgram;

typedef void ( * PFNGLDELETESHADERPROC)(GLuint shader);
extern PFNGLDELETESHADERPROC glad_glDeleteShader;

typedef void ( * PFNGLDETACHSHADERPROC)(GLuint program, GLuint shader);
extern PFNGLDETACHSHADERPROC glad_glDetachShader;

typedef void ( * PFNGLDISABLEVERTEXATTRIBARRAYPROC)(GLuint index);
extern PFNGLDISABLEVERTEXATTRIBARRAYPROC glad_glDisableVertexAttribArray;

typedef void ( * PFNGLENABLEVERTEXATTRIBARRAYPROC)(GLuint index);
extern PFNGLENABLEVERTEXATTRIBARRAYPROC glad_glEnableVertexAttribArray;

typedef void ( * PFNGLGETACTIVEATTRIBPROC)(GLuint program, GLuint index, GLsizei bufSize, GLsizei *length, GLint *size, GLenum *type, GLchar *name);
extern PFNGLGETACTIVEATTRIBPROC glad_glGetActiveAttrib;

typedef void ( * PFNGLGETACTIVEUNIFORMPROC)(GLuint program, GLuint index, GLsizei bufSize, GLsizei *length, GLint *size, GLenum *type, GLchar *name);
extern PFNGLGETACTIVEUNIFORMPROC glad_glGetActiveUniform;

typedef void ( * PFNGLGETATTACHEDSHADERSPROC)(GLuint program, GLsizei maxCount, GLsizei *count, GLuint *shaders);
extern PFNGLGETATTACHEDSHADERSPROC glad_glGetAttachedShaders;

typedef GLint ( * PFNGLGETATTRIBLOCATIONPROC)(GLuint program, const GLchar *name);
extern PFNGLGETATTRIBLOCATIONPROC glad_glGetAttribLocation;

typedef void ( * PFNGLGETPROGRAMIVPROC)(GLuint program, GLenum pname, GLint *params);
extern PFNGLGETPROGRAMIVPROC glad_glGetProgramiv;

typedef void ( * PFNGLGETPROGRAMINFOLOGPROC)(GLuint program, GLsizei bufSize, GLsizei *length, GLchar *infoLog);
extern PFNGLGETPROGRAMINFOLOGPROC glad_glGetProgramInfoLog;

typedef void ( * PFNGLGETSHADERIVPROC)(GLuint shader, GLenum pname, GLint *params);
extern PFNGLGETSHADERIVPROC glad_glGetShaderiv;

typedef void ( * PFNGLGETSHADERINFOLOGPROC)(GLuint shader, GLsizei bufSize, GLsizei *length, GLchar *infoLog);
extern PFNGLGETSHADERINFOLOGPROC glad_glGetShaderInfoLog;

typedef void ( * PFNGLGETSHADERSOURCEPROC)(GLuint shader, GLsizei bufSize, GLsizei *length, GLchar *source);
extern PFNGLGETSHADERSOURCEPROC glad_glGetShaderSource;

typedef GLint ( * PFNGLGETUNIFORMLOCATIONPROC)(GLuint program, const GLchar *name);
extern PFNGLGETUNIFORMLOCATIONPROC glad_glGetUniformLocation;

typedef void ( * PFNGLGETUNIFORMFVPROC)(GLuint program, GLint location, GLfloat *params);
extern PFNGLGETUNIFORMFVPROC glad_glGetUniformfv;

typedef void ( * PFNGLGETUNIFORMIVPROC)(GLuint program, GLint location, GLint *params);
extern PFNGLGETUNIFORMIVPROC glad_glGetUniformiv;

typedef void ( * PFNGLGETVERTEXATTRIBDVPROC)(GLuint index, GLenum pname, GLdouble *params);
extern PFNGLGETVERTEXATTRIBDVPROC glad_glGetVertexAttribdv;

typedef void ( * PFNGLGETVERTEXATTRIBFVPROC)(GLuint index, GLenum pname, GLfloat *params);
extern PFNGLGETVERTEXATTRIBFVPROC glad_glGetVertexAttribfv;

typedef void ( * PFNGLGETVERTEXATTRIBIVPROC)(GLuint index, GLenum pname, GLint *params);
extern PFNGLGETVERTEXATTRIBIVPROC glad_glGetVertexAttribiv;

typedef void ( * PFNGLGETVERTEXATTRIBPOINTERVPROC)(GLuint index, GLenum pname, void **pointer);
extern PFNGLGETVERTEXATTRIBPOINTERVPROC glad_glGetVertexAttribPointerv;

typedef GLboolean ( * PFNGLISPROGRAMPROC)(GLuint program);
extern PFNGLISPROGRAMPROC glad_glIsProgram;

typedef GLboolean ( * PFNGLISSHADERPROC)(GLuint shader);
extern PFNGLISSHADERPROC glad_glIsShader;

typedef void ( * PFNGLLINKPROGRAMPROC)(GLuint program);
extern PFNGLLINKPROGRAMPROC glad_glLinkProgram;

typedef void ( * PFNGLSHADERSOURCEPROC)(GLuint shader, GLsizei count, const GLchar *const*string, const GLint *length);
extern PFNGLSHADERSOURCEPROC glad_glShaderSource;

typedef void ( * PFNGLUSEPROGRAMPROC)(GLuint program);
extern PFNGLUSEPROGRAMPROC glad_glUseProgram;

typedef void ( * PFNGLUNIFORM1FPROC)(GLint location, GLfloat v0);
extern PFNGLUNIFORM1FPROC glad_glUniform1f;

typedef void ( * PFNGLUNIFORM2FPROC)(GLint location, GLfloat v0, GLfloat v1);
extern PFNGLUNIFORM2FPROC glad_glUniform2f;

typedef void ( * PFNGLUNIFORM3FPROC)(GLint location, GLfloat v0, GLfloat v1, GLfloat v2);
extern PFNGLUNIFORM3FPROC glad_glUniform3f;

typedef void ( * PFNGLUNIFORM4FPROC)(GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3);
extern PFNGLUNIFORM4FPROC glad_glUniform4f;

typedef void ( * PFNGLUNIFORM1IPROC)(GLint location, GLint v0);
extern PFNGLUNIFORM1IPROC glad_glUniform1i;

typedef void ( * PFNGLUNIFORM2IPROC)(GLint location, GLint v0, GLint v1);
extern PFNGLUNIFORM2IPROC glad_glUniform2i;

typedef void ( * PFNGLUNIFORM3IPROC)(GLint location, GLint v0, GLint v1, GLint v2);
extern PFNGLUNIFORM3IPROC glad_glUniform3i;

typedef void ( * PFNGLUNIFORM4IPROC)(GLint location, GLint v0, GLint v1, GLint v2, GLint v3);
extern PFNGLUNIFORM4IPROC glad_glUniform4i;

typedef void ( * PFNGLUNIFORM1FVPROC)(GLint location, GLsizei count, const GLfloat *value);
extern PFNGLUNIFORM1FVPROC glad_glUniform1fv;

typedef void ( * PFNGLUNIFORM2FVPROC)(GLint location, GLsizei count, const GLfloat *value);
extern PFNGLUNIFORM2FVPROC glad_glUniform2fv;

typedef void ( * PFNGLUNIFORM3FVPROC)(GLint location, GLsizei count, const GLfloat *value);
extern PFNGLUNIFORM3FVPROC glad_glUniform3fv;

typedef void ( * PFNGLUNIFORM4FVPROC)(GLint location, GLsizei count, const GLfloat *value);
extern PFNGLUNIFORM4FVPROC glad_glUniform4fv;

typedef void ( * PFNGLUNIFORM1IVPROC)(GLint location, GLsizei count, const GLint *value);
extern PFNGLUNIFORM1IVPROC glad_glUniform1iv;

typedef void ( * PFNGLUNIFORM2IVPROC)(GLint location, GLsizei count, const GLint *value);
extern PFNGLUNIFORM2IVPROC glad_glUniform2iv;

typedef void ( * PFNGLUNIFORM3IVPROC)(GLint location, GLsizei count, const GLint *value);
extern PFNGLUNIFORM3IVPROC glad_glUniform3iv;

typedef void ( * PFNGLUNIFORM4IVPROC)(GLint location, GLsizei count, const GLint *value);
extern PFNGLUNIFORM4IVPROC glad_glUniform4iv;

typedef void ( * PFNGLUNIFORMMATRIX2FVPROC)(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
extern PFNGLUNIFORMMATRIX2FVPROC glad_glUniformMatrix2fv;

typedef void ( * PFNGLUNIFORMMATRIX3FVPROC)(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
extern PFNGLUNIFORMMATRIX3FVPROC glad_glUniformMatrix3fv;

typedef void ( * PFNGLUNIFORMMATRIX4FVPROC)(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
extern PFNGLUNIFORMMATRIX4FVPROC glad_glUniformMatrix4fv;

typedef void ( * PFNGLVALIDATEPROGRAMPROC)(GLuint program);
extern PFNGLVALIDATEPROGRAMPROC glad_glValidateProgram;

typedef void ( * PFNGLVERTEXATTRIB1DPROC)(GLuint index, GLdouble x);
extern PFNGLVERTEXATTRIB1DPROC glad_glVertexAttrib1d;

typedef void ( * PFNGLVERTEXATTRIB1DVPROC)(GLuint index, const GLdouble *v);
extern PFNGLVERTEXATTRIB1DVPROC glad_glVertexAttrib1dv;

typedef void ( * PFNGLVERTEXATTRIB1FPROC)(GLuint index, GLfloat x);
extern PFNGLVERTEXATTRIB1FPROC glad_glVertexAttrib1f;

typedef void ( * PFNGLVERTEXATTRIB1FVPROC)(GLuint index, const GLfloat *v);
extern PFNGLVERTEXATTRIB1FVPROC glad_glVertexAttrib1fv;

typedef void ( * PFNGLVERTEXATTRIB1SPROC)(GLuint index, GLshort x);
extern PFNGLVERTEXATTRIB1SPROC glad_glVertexAttrib1s;

typedef void ( * PFNGLVERTEXATTRIB1SVPROC)(GLuint index, const GLshort *v);
extern PFNGLVERTEXATTRIB1SVPROC glad_glVertexAttrib1sv;

typedef void ( * PFNGLVERTEXATTRIB2DPROC)(GLuint index, GLdouble x, GLdouble y);
extern PFNGLVERTEXATTRIB2DPROC glad_glVertexAttrib2d;

typedef void ( * PFNGLVERTEXATTRIB2DVPROC)(GLuint index, const GLdouble *v);
extern PFNGLVERTEXATTRIB2DVPROC glad_glVertexAttrib2dv;

typedef void ( * PFNGLVERTEXATTRIB2FPROC)(GLuint index, GLfloat x, GLfloat y);
extern PFNGLVERTEXATTRIB2FPROC glad_glVertexAttrib2f;

typedef void ( * PFNGLVERTEXATTRIB2FVPROC)(GLuint index, const GLfloat *v);
extern PFNGLVERTEXATTRIB2FVPROC glad_glVertexAttrib2fv;

typedef void ( * PFNGLVERTEXATTRIB2SPROC)(GLuint index, GLshort x, GLshort y);
extern PFNGLVERTEXATTRIB2SPROC glad_glVertexAttrib2s;

typedef void ( * PFNGLVERTEXATTRIB2SVPROC)(GLuint index, const GLshort *v);
extern PFNGLVERTEXATTRIB2SVPROC glad_glVertexAttrib2sv;

typedef void ( * PFNGLVERTEXATTRIB3DPROC)(GLuint index, GLdouble x, GLdouble y, GLdouble z);
extern PFNGLVERTEXATTRIB3DPROC glad_glVertexAttrib3d;

typedef void ( * PFNGLVERTEXATTRIB3DVPROC)(GLuint index, const GLdouble *v);
extern PFNGLVERTEXATTRIB3DVPROC glad_glVertexAttrib3dv;

typedef void ( * PFNGLVERTEXATTRIB3FPROC)(GLuint index, GLfloat x, GLfloat y, GLfloat z);
extern PFNGLVERTEXATTRIB3FPROC glad_glVertexAttrib3f;

typedef void ( * PFNGLVERTEXATTRIB3FVPROC)(GLuint index, const GLfloat *v);
extern PFNGLVERTEXATTRIB3FVPROC glad_glVertexAttrib3fv;

typedef void ( * PFNGLVERTEXATTRIB3SPROC)(GLuint index, GLshort x, GLshort y, GLshort z);
extern PFNGLVERTEXATTRIB3SPROC glad_glVertexAttrib3s;

typedef void ( * PFNGLVERTEXATTRIB3SVPROC)(GLuint index, const GLshort *v);
extern PFNGLVERTEXATTRIB3SVPROC glad_glVertexAttrib3sv;

typedef void ( * PFNGLVERTEXATTRIB4NBVPROC)(GLuint index, const GLbyte *v);
extern PFNGLVERTEXATTRIB4NBVPROC glad_glVertexAttrib4Nbv;

typedef void ( * PFNGLVERTEXATTRIB4NIVPROC)(GLuint index, const GLint *v);
extern PFNGLVERTEXATTRIB4NIVPROC glad_glVertexAttrib4Niv;

typedef void ( * PFNGLVERTEXATTRIB4NSVPROC)(GLuint index, const GLshort *v);
extern PFNGLVERTEXATTRIB4NSVPROC glad_glVertexAttrib4Nsv;

typedef void ( * PFNGLVERTEXATTRIB4NUBPROC)(GLuint index, GLubyte x, GLubyte y, GLubyte z, GLubyte w);
extern PFNGLVERTEXATTRIB4NUBPROC glad_glVertexAttrib4Nub;

typedef void ( * PFNGLVERTEXATTRIB4NUBVPROC)(GLuint index, const GLubyte *v);
extern PFNGLVERTEXATTRIB4NUBVPROC glad_glVertexAttrib4Nubv;

typedef void ( * PFNGLVERTEXATTRIB4NUIVPROC)(GLuint index, const GLuint *v);
extern PFNGLVERTEXATTRIB4NUIVPROC glad_glVertexAttrib4Nuiv;

typedef void ( * PFNGLVERTEXATTRIB4NUSVPROC)(GLuint index, const GLushort *v);
extern PFNGLVERTEXATTRIB4NUSVPROC glad_glVertexAttrib4Nusv;

typedef void ( * PFNGLVERTEXATTRIB4BVPROC)(GLuint index, const GLbyte *v);
extern PFNGLVERTEXATTRIB4BVPROC glad_glVertexAttrib4bv;

typedef void ( * PFNGLVERTEXATTRIB4DPROC)(GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
extern PFNGLVERTEXATTRIB4DPROC glad_glVertexAttrib4d;

typedef void ( * PFNGLVERTEXATTRIB4DVPROC)(GLuint index, const GLdouble *v);
extern PFNGLVERTEXATTRIB4DVPROC glad_glVertexAttrib4dv;

typedef void ( * PFNGLVERTEXATTRIB4FPROC)(GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
extern PFNGLVERTEXATTRIB4FPROC glad_glVertexAttrib4f;

typedef void ( * PFNGLVERTEXATTRIB4FVPROC)(GLuint index, const GLfloat *v);
extern PFNGLVERTEXATTRIB4FVPROC glad_glVertexAttrib4fv;

typedef void ( * PFNGLVERTEXATTRIB4IVPROC)(GLuint index, const GLint *v);
extern PFNGLVERTEXATTRIB4IVPROC glad_glVertexAttrib4iv;

typedef void ( * PFNGLVERTEXATTRIB4SPROC)(GLuint index, GLshort x, GLshort y, GLshort z, GLshort w);
extern PFNGLVERTEXATTRIB4SPROC glad_glVertexAttrib4s;

typedef void ( * PFNGLVERTEXATTRIB4SVPROC)(GLuint index, const GLshort *v);
extern PFNGLVERTEXATTRIB4SVPROC glad_glVertexAttrib4sv;

typedef void ( * PFNGLVERTEXATTRIB4UBVPROC)(GLuint index, const GLubyte *v);
extern PFNGLVERTEXATTRIB4UBVPROC glad_glVertexAttrib4ubv;

typedef void ( * PFNGLVERTEXATTRIB4UIVPROC)(GLuint index, const GLuint *v);
extern PFNGLVERTEXATTRIB4UIVPROC glad_glVertexAttrib4uiv;

typedef void ( * PFNGLVERTEXATTRIB4USVPROC)(GLuint index, const GLushort *v);
extern PFNGLVERTEXATTRIB4USVPROC glad_glVertexAttrib4usv;

typedef void ( * PFNGLVERTEXATTRIBPOINTERPROC)(GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, const void *pointer);
extern PFNGLVERTEXATTRIBPOINTERPROC glad_glVertexAttribPointer;




extern int GLAD_GL_VERSION_2_1;
typedef void ( * PFNGLUNIFORMMATRIX2X3FVPROC)(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
extern PFNGLUNIFORMMATRIX2X3FVPROC glad_glUniformMatrix2x3fv;

typedef void ( * PFNGLUNIFORMMATRIX3X2FVPROC)(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
extern PFNGLUNIFORMMATRIX3X2FVPROC glad_glUniformMatrix3x2fv;

typedef void ( * PFNGLUNIFORMMATRIX2X4FVPROC)(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
extern PFNGLUNIFORMMATRIX2X4FVPROC glad_glUniformMatrix2x4fv;

typedef void ( * PFNGLUNIFORMMATRIX4X2FVPROC)(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
extern PFNGLUNIFORMMATRIX4X2FVPROC glad_glUniformMatrix4x2fv;

typedef void ( * PFNGLUNIFORMMATRIX3X4FVPROC)(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
extern PFNGLUNIFORMMATRIX3X4FVPROC glad_glUniformMatrix3x4fv;

typedef void ( * PFNGLUNIFORMMATRIX4X3FVPROC)(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
extern PFNGLUNIFORMMATRIX4X3FVPROC glad_glUniformMatrix4x3fv;




extern int GLAD_GL_VERSION_3_0;
typedef void ( * PFNGLCOLORMASKIPROC)(GLuint index, GLboolean r, GLboolean g, GLboolean b, GLboolean a);
extern PFNGLCOLORMASKIPROC glad_glColorMaski;

typedef void ( * PFNGLGETBOOLEANI_VPROC)(GLenum target, GLuint index, GLboolean *data);
extern PFNGLGETBOOLEANI_VPROC glad_glGetBooleani_v;

typedef void ( * PFNGLGETINTEGERI_VPROC)(GLenum target, GLuint index, GLint *data);
extern PFNGLGETINTEGERI_VPROC glad_glGetIntegeri_v;

typedef void ( * PFNGLENABLEIPROC)(GLenum target, GLuint index);
extern PFNGLENABLEIPROC glad_glEnablei;

typedef void ( * PFNGLDISABLEIPROC)(GLenum target, GLuint index);
extern PFNGLDISABLEIPROC glad_glDisablei;

typedef GLboolean ( * PFNGLISENABLEDIPROC)(GLenum target, GLuint index);
extern PFNGLISENABLEDIPROC glad_glIsEnabledi;

typedef void ( * PFNGLBEGINTRANSFORMFEEDBACKPROC)(GLenum primitiveMode);
extern PFNGLBEGINTRANSFORMFEEDBACKPROC glad_glBeginTransformFeedback;

typedef void ( * PFNGLENDTRANSFORMFEEDBACKPROC)(void);
extern PFNGLENDTRANSFORMFEEDBACKPROC glad_glEndTransformFeedback;

typedef void ( * PFNGLBINDBUFFERRANGEPROC)(GLenum target, GLuint index, GLuint buffer, GLintptr offset, GLsizeiptr size);
extern PFNGLBINDBUFFERRANGEPROC glad_glBindBufferRange;

typedef void ( * PFNGLBINDBUFFERBASEPROC)(GLenum target, GLuint index, GLuint buffer);
extern PFNGLBINDBUFFERBASEPROC glad_glBindBufferBase;

typedef void ( * PFNGLTRANSFORMFEEDBACKVARYINGSPROC)(GLuint program, GLsizei count, const GLchar *const*varyings, GLenum bufferMode);
extern PFNGLTRANSFORMFEEDBACKVARYINGSPROC glad_glTransformFeedbackVaryings;

typedef void ( * PFNGLGETTRANSFORMFEEDBACKVARYINGPROC)(GLuint program, GLuint index, GLsizei bufSize, GLsizei *length, GLsizei *size, GLenum *type, GLchar *name);
extern PFNGLGETTRANSFORMFEEDBACKVARYINGPROC glad_glGetTransformFeedbackVarying;

typedef void ( * PFNGLCLAMPCOLORPROC)(GLenum target, GLenum clamp);
extern PFNGLCLAMPCOLORPROC glad_glClampColor;

typedef void ( * PFNGLBEGINCONDITIONALRENDERPROC)(GLuint id, GLenum mode);
extern PFNGLBEGINCONDITIONALRENDERPROC glad_glBeginConditionalRender;

typedef void ( * PFNGLENDCONDITIONALRENDERPROC)(void);
extern PFNGLENDCONDITIONALRENDERPROC glad_glEndConditionalRender;

typedef void ( * PFNGLVERTEXATTRIBIPOINTERPROC)(GLuint index, GLint size, GLenum type, GLsizei stride, const void *pointer);
extern PFNGLVERTEXATTRIBIPOINTERPROC glad_glVertexAttribIPointer;

typedef void ( * PFNGLGETVERTEXATTRIBIIVPROC)(GLuint index, GLenum pname, GLint *params);
extern PFNGLGETVERTEXATTRIBIIVPROC glad_glGetVertexAttribIiv;

typedef void ( * PFNGLGETVERTEXATTRIBIUIVPROC)(GLuint index, GLenum pname, GLuint *params);
extern PFNGLGETVERTEXATTRIBIUIVPROC glad_glGetVertexAttribIuiv;

typedef void ( * PFNGLVERTEXATTRIBI1IPROC)(GLuint index, GLint x);
extern PFNGLVERTEXATTRIBI1IPROC glad_glVertexAttribI1i;

typedef void ( * PFNGLVERTEXATTRIBI2IPROC)(GLuint index, GLint x, GLint y);
extern PFNGLVERTEXATTRIBI2IPROC glad_glVertexAttribI2i;

typedef void ( * PFNGLVERTEXATTRIBI3IPROC)(GLuint index, GLint x, GLint y, GLint z);
extern PFNGLVERTEXATTRIBI3IPROC glad_glVertexAttribI3i;

typedef void ( * PFNGLVERTEXATTRIBI4IPROC)(GLuint index, GLint x, GLint y, GLint z, GLint w);
extern PFNGLVERTEXATTRIBI4IPROC glad_glVertexAttribI4i;

typedef void ( * PFNGLVERTEXATTRIBI1UIPROC)(GLuint index, GLuint x);
extern PFNGLVERTEXATTRIBI1UIPROC glad_glVertexAttribI1ui;

typedef void ( * PFNGLVERTEXATTRIBI2UIPROC)(GLuint index, GLuint x, GLuint y);
extern PFNGLVERTEXATTRIBI2UIPROC glad_glVertexAttribI2ui;

typedef void ( * PFNGLVERTEXATTRIBI3UIPROC)(GLuint index, GLuint x, GLuint y, GLuint z);
extern PFNGLVERTEXATTRIBI3UIPROC glad_glVertexAttribI3ui;

typedef void ( * PFNGLVERTEXATTRIBI4UIPROC)(GLuint index, GLuint x, GLuint y, GLuint z, GLuint w);
extern PFNGLVERTEXATTRIBI4UIPROC glad_glVertexAttribI4ui;

typedef void ( * PFNGLVERTEXATTRIBI1IVPROC)(GLuint index, const GLint *v);
extern PFNGLVERTEXATTRIBI1IVPROC glad_glVertexAttribI1iv;

typedef void ( * PFNGLVERTEXATTRIBI2IVPROC)(GLuint index, const GLint *v);
extern PFNGLVERTEXATTRIBI2IVPROC glad_glVertexAttribI2iv;

typedef void ( * PFNGLVERTEXATTRIBI3IVPROC)(GLuint index, const GLint *v);
extern PFNGLVERTEXATTRIBI3IVPROC glad_glVertexAttribI3iv;

typedef void ( * PFNGLVERTEXATTRIBI4IVPROC)(GLuint index, const GLint *v);
extern PFNGLVERTEXATTRIBI4IVPROC glad_glVertexAttribI4iv;

typedef void ( * PFNGLVERTEXATTRIBI1UIVPROC)(GLuint index, const GLuint *v);
extern PFNGLVERTEXATTRIBI1UIVPROC glad_glVertexAttribI1uiv;

typedef void ( * PFNGLVERTEXATTRIBI2UIVPROC)(GLuint index, const GLuint *v);
extern PFNGLVERTEXATTRIBI2UIVPROC glad_glVertexAttribI2uiv;

typedef void ( * PFNGLVERTEXATTRIBI3UIVPROC)(GLuint index, const GLuint *v);
extern PFNGLVERTEXATTRIBI3UIVPROC glad_glVertexAttribI3uiv;

typedef void ( * PFNGLVERTEXATTRIBI4UIVPROC)(GLuint index, const GLuint *v);
extern PFNGLVERTEXATTRIBI4UIVPROC glad_glVertexAttribI4uiv;

typedef void ( * PFNGLVERTEXATTRIBI4BVPROC)(GLuint index, const GLbyte *v);
extern PFNGLVERTEXATTRIBI4BVPROC glad_glVertexAttribI4bv;

typedef void ( * PFNGLVERTEXATTRIBI4SVPROC)(GLuint index, const GLshort *v);
extern PFNGLVERTEXATTRIBI4SVPROC glad_glVertexAttribI4sv;

typedef void ( * PFNGLVERTEXATTRIBI4UBVPROC)(GLuint index, const GLubyte *v);
extern PFNGLVERTEXATTRIBI4UBVPROC glad_glVertexAttribI4ubv;

typedef void ( * PFNGLVERTEXATTRIBI4USVPROC)(GLuint index, const GLushort *v);
extern PFNGLVERTEXATTRIBI4USVPROC glad_glVertexAttribI4usv;

typedef void ( * PFNGLGETUNIFORMUIVPROC)(GLuint program, GLint location, GLuint *params);
extern PFNGLGETUNIFORMUIVPROC glad_glGetUniformuiv;

typedef void ( * PFNGLBINDFRAGDATALOCATIONPROC)(GLuint program, GLuint color, const GLchar *name);
extern PFNGLBINDFRAGDATALOCATIONPROC glad_glBindFragDataLocation;

typedef GLint ( * PFNGLGETFRAGDATALOCATIONPROC)(GLuint program, const GLchar *name);
extern PFNGLGETFRAGDATALOCATIONPROC glad_glGetFragDataLocation;

typedef void ( * PFNGLUNIFORM1UIPROC)(GLint location, GLuint v0);
extern PFNGLUNIFORM1UIPROC glad_glUniform1ui;

typedef void ( * PFNGLUNIFORM2UIPROC)(GLint location, GLuint v0, GLuint v1);
extern PFNGLUNIFORM2UIPROC glad_glUniform2ui;

typedef void ( * PFNGLUNIFORM3UIPROC)(GLint location, GLuint v0, GLuint v1, GLuint v2);
extern PFNGLUNIFORM3UIPROC glad_glUniform3ui;

typedef void ( * PFNGLUNIFORM4UIPROC)(GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3);
extern PFNGLUNIFORM4UIPROC glad_glUniform4ui;

typedef void ( * PFNGLUNIFORM1UIVPROC)(GLint location, GLsizei count, const GLuint *value);
extern PFNGLUNIFORM1UIVPROC glad_glUniform1uiv;

typedef void ( * PFNGLUNIFORM2UIVPROC)(GLint location, GLsizei count, const GLuint *value);
extern PFNGLUNIFORM2UIVPROC glad_glUniform2uiv;

typedef void ( * PFNGLUNIFORM3UIVPROC)(GLint location, GLsizei count, const GLuint *value);
extern PFNGLUNIFORM3UIVPROC glad_glUniform3uiv;

typedef void ( * PFNGLUNIFORM4UIVPROC)(GLint location, GLsizei count, const GLuint *value);
extern PFNGLUNIFORM4UIVPROC glad_glUniform4uiv;

typedef void ( * PFNGLTEXPARAMETERIIVPROC)(GLenum target, GLenum pname, const GLint *params);
extern PFNGLTEXPARAMETERIIVPROC glad_glTexParameterIiv;

typedef void ( * PFNGLTEXPARAMETERIUIVPROC)(GLenum target, GLenum pname, const GLuint *params);
extern PFNGLTEXPARAMETERIUIVPROC glad_glTexParameterIuiv;

typedef void ( * PFNGLGETTEXPARAMETERIIVPROC)(GLenum target, GLenum pname, GLint *params);
extern PFNGLGETTEXPARAMETERIIVPROC glad_glGetTexParameterIiv;

typedef void ( * PFNGLGETTEXPARAMETERIUIVPROC)(GLenum target, GLenum pname, GLuint *params);
extern PFNGLGETTEXPARAMETERIUIVPROC glad_glGetTexParameterIuiv;

typedef void ( * PFNGLCLEARBUFFERIVPROC)(GLenum buffer, GLint drawbuffer, const GLint *value);
extern PFNGLCLEARBUFFERIVPROC glad_glClearBufferiv;

typedef void ( * PFNGLCLEARBUFFERUIVPROC)(GLenum buffer, GLint drawbuffer, const GLuint *value);
extern PFNGLCLEARBUFFERUIVPROC glad_glClearBufferuiv;

typedef void ( * PFNGLCLEARBUFFERFVPROC)(GLenum buffer, GLint drawbuffer, const GLfloat *value);
extern PFNGLCLEARBUFFERFVPROC glad_glClearBufferfv;

typedef void ( * PFNGLCLEARBUFFERFIPROC)(GLenum buffer, GLint drawbuffer, GLfloat depth, GLint stencil);
extern PFNGLCLEARBUFFERFIPROC glad_glClearBufferfi;

typedef const GLubyte * ( * PFNGLGETSTRINGIPROC)(GLenum name, GLuint index);
extern PFNGLGETSTRINGIPROC glad_glGetStringi;

typedef GLboolean ( * PFNGLISRENDERBUFFERPROC)(GLuint renderbuffer);
extern PFNGLISRENDERBUFFERPROC glad_glIsRenderbuffer;

typedef void ( * PFNGLBINDRENDERBUFFERPROC)(GLenum target, GLuint renderbuffer);
extern PFNGLBINDRENDERBUFFERPROC glad_glBindRenderbuffer;

typedef void ( * PFNGLDELETERENDERBUFFERSPROC)(GLsizei n, const GLuint *renderbuffers);
extern PFNGLDELETERENDERBUFFERSPROC glad_glDeleteRenderbuffers;

typedef void ( * PFNGLGENRENDERBUFFERSPROC)(GLsizei n, GLuint *renderbuffers);
extern PFNGLGENRENDERBUFFERSPROC glad_glGenRenderbuffers;

typedef void ( * PFNGLRENDERBUFFERSTORAGEPROC)(GLenum target, GLenum internalformat, GLsizei width, GLsizei height);
extern PFNGLRENDERBUFFERSTORAGEPROC glad_glRenderbufferStorage;

typedef void ( * PFNGLGETRENDERBUFFERPARAMETERIVPROC)(GLenum target, GLenum pname, GLint *params);
extern PFNGLGETRENDERBUFFERPARAMETERIVPROC glad_glGetRenderbufferParameteriv;

typedef GLboolean ( * PFNGLISFRAMEBUFFERPROC)(GLuint framebuffer);
extern PFNGLISFRAMEBUFFERPROC glad_glIsFramebuffer;

typedef void ( * PFNGLBINDFRAMEBUFFERPROC)(GLenum target, GLuint framebuffer);
extern PFNGLBINDFRAMEBUFFERPROC glad_glBindFramebuffer;

typedef void ( * PFNGLDELETEFRAMEBUFFERSPROC)(GLsizei n, const GLuint *framebuffers);
extern PFNGLDELETEFRAMEBUFFERSPROC glad_glDeleteFramebuffers;

typedef void ( * PFNGLGENFRAMEBUFFERSPROC)(GLsizei n, GLuint *framebuffers);
extern PFNGLGENFRAMEBUFFERSPROC glad_glGenFramebuffers;

typedef GLenum ( * PFNGLCHECKFRAMEBUFFERSTATUSPROC)(GLenum target);
extern PFNGLCHECKFRAMEBUFFERSTATUSPROC glad_glCheckFramebufferStatus;

typedef void ( * PFNGLFRAMEBUFFERTEXTURE1DPROC)(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level);
extern PFNGLFRAMEBUFFERTEXTURE1DPROC glad_glFramebufferTexture1D;

typedef void ( * PFNGLFRAMEBUFFERTEXTURE2DPROC)(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level);
extern PFNGLFRAMEBUFFERTEXTURE2DPROC glad_glFramebufferTexture2D;

typedef void ( * PFNGLFRAMEBUFFERTEXTURE3DPROC)(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLint zoffset);
extern PFNGLFRAMEBUFFERTEXTURE3DPROC glad_glFramebufferTexture3D;

typedef void ( * PFNGLFRAMEBUFFERRENDERBUFFERPROC)(GLenum target, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer);
extern PFNGLFRAMEBUFFERRENDERBUFFERPROC glad_glFramebufferRenderbuffer;

typedef void ( * PFNGLGETFRAMEBUFFERATTACHMENTPARAMETERIVPROC)(GLenum target, GLenum attachment, GLenum pname, GLint *params);
extern PFNGLGETFRAMEBUFFERATTACHMENTPARAMETERIVPROC glad_glGetFramebufferAttachmentParameteriv;

typedef void ( * PFNGLGENERATEMIPMAPPROC)(GLenum target);
extern PFNGLGENERATEMIPMAPPROC glad_glGenerateMipmap;

typedef void ( * PFNGLBLITFRAMEBUFFERPROC)(GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter);
extern PFNGLBLITFRAMEBUFFERPROC glad_glBlitFramebuffer;

typedef void ( * PFNGLRENDERBUFFERSTORAGEMULTISAMPLEPROC)(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height);
extern PFNGLRENDERBUFFERSTORAGEMULTISAMPLEPROC glad_glRenderbufferStorageMultisample;

typedef void ( * PFNGLFRAMEBUFFERTEXTURELAYERPROC)(GLenum target, GLenum attachment, GLuint texture, GLint level, GLint layer);
extern PFNGLFRAMEBUFFERTEXTURELAYERPROC glad_glFramebufferTextureLayer;

typedef void * ( * PFNGLMAPBUFFERRANGEPROC)(GLenum target, GLintptr offset, GLsizeiptr length, GLbitfield access);
extern PFNGLMAPBUFFERRANGEPROC glad_glMapBufferRange;

typedef void ( * PFNGLFLUSHMAPPEDBUFFERRANGEPROC)(GLenum target, GLintptr offset, GLsizeiptr length);
extern PFNGLFLUSHMAPPEDBUFFERRANGEPROC glad_glFlushMappedBufferRange;

typedef void ( * PFNGLBINDVERTEXARRAYPROC)(GLuint array);
extern PFNGLBINDVERTEXARRAYPROC glad_glBindVertexArray;

typedef void ( * PFNGLDELETEVERTEXARRAYSPROC)(GLsizei n, const GLuint *arrays);
extern PFNGLDELETEVERTEXARRAYSPROC glad_glDeleteVertexArrays;

typedef void ( * PFNGLGENVERTEXARRAYSPROC)(GLsizei n, GLuint *arrays);
extern PFNGLGENVERTEXARRAYSPROC glad_glGenVertexArrays;

typedef GLboolean ( * PFNGLISVERTEXARRAYPROC)(GLuint array);
extern PFNGLISVERTEXARRAYPROC glad_glIsVertexArray;




extern int GLAD_GL_VERSION_3_1;
typedef void ( * PFNGLDRAWARRAYSINSTANCEDPROC)(GLenum mode, GLint first, GLsizei count, GLsizei instancecount);
extern PFNGLDRAWARRAYSINSTANCEDPROC glad_glDrawArraysInstanced;

typedef void ( * PFNGLDRAWELEMENTSINSTANCEDPROC)(GLenum mode, GLsizei count, GLenum type, const void *indices, GLsizei instancecount);
extern PFNGLDRAWELEMENTSINSTANCEDPROC glad_glDrawElementsInstanced;

typedef void ( * PFNGLTEXBUFFERPROC)(GLenum target, GLenum internalformat, GLuint buffer);
extern PFNGLTEXBUFFERPROC glad_glTexBuffer;

typedef void ( * PFNGLPRIMITIVERESTARTINDEXPROC)(GLuint index);
extern PFNGLPRIMITIVERESTARTINDEXPROC glad_glPrimitiveRestartIndex;

typedef void ( * PFNGLCOPYBUFFERSUBDATAPROC)(GLenum readTarget, GLenum writeTarget, GLintptr readOffset, GLintptr writeOffset, GLsizeiptr size);
extern PFNGLCOPYBUFFERSUBDATAPROC glad_glCopyBufferSubData;

typedef void ( * PFNGLGETUNIFORMINDICESPROC)(GLuint program, GLsizei uniformCount, const GLchar *const*uniformNames, GLuint *uniformIndices);
extern PFNGLGETUNIFORMINDICESPROC glad_glGetUniformIndices;

typedef void ( * PFNGLGETACTIVEUNIFORMSIVPROC)(GLuint program, GLsizei uniformCount, const GLuint *uniformIndices, GLenum pname, GLint *params);
extern PFNGLGETACTIVEUNIFORMSIVPROC glad_glGetActiveUniformsiv;

typedef void ( * PFNGLGETACTIVEUNIFORMNAMEPROC)(GLuint program, GLuint uniformIndex, GLsizei bufSize, GLsizei *length, GLchar *uniformName);
extern PFNGLGETACTIVEUNIFORMNAMEPROC glad_glGetActiveUniformName;

typedef GLuint ( * PFNGLGETUNIFORMBLOCKINDEXPROC)(GLuint program, const GLchar *uniformBlockName);
extern PFNGLGETUNIFORMBLOCKINDEXPROC glad_glGetUniformBlockIndex;

typedef void ( * PFNGLGETACTIVEUNIFORMBLOCKIVPROC)(GLuint program, GLuint uniformBlockIndex, GLenum pname, GLint *params);
extern PFNGLGETACTIVEUNIFORMBLOCKIVPROC glad_glGetActiveUniformBlockiv;

typedef void ( * PFNGLGETACTIVEUNIFORMBLOCKNAMEPROC)(GLuint program, GLuint uniformBlockIndex, GLsizei bufSize, GLsizei *length, GLchar *uniformBlockName);
extern PFNGLGETACTIVEUNIFORMBLOCKNAMEPROC glad_glGetActiveUniformBlockName;

typedef void ( * PFNGLUNIFORMBLOCKBINDINGPROC)(GLuint program, GLuint uniformBlockIndex, GLuint uniformBlockBinding);
extern PFNGLUNIFORMBLOCKBINDINGPROC glad_glUniformBlockBinding;




extern int GLAD_GL_VERSION_3_2;
typedef void ( * PFNGLDRAWELEMENTSBASEVERTEXPROC)(GLenum mode, GLsizei count, GLenum type, const void *indices, GLint basevertex);
extern PFNGLDRAWELEMENTSBASEVERTEXPROC glad_glDrawElementsBaseVertex;

typedef void ( * PFNGLDRAWRANGEELEMENTSBASEVERTEXPROC)(GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const void *indices, GLint basevertex);
extern PFNGLDRAWRANGEELEMENTSBASEVERTEXPROC glad_glDrawRangeElementsBaseVertex;

typedef void ( * PFNGLDRAWELEMENTSINSTANCEDBASEVERTEXPROC)(GLenum mode, GLsizei count, GLenum type, const void *indices, GLsizei instancecount, GLint basevertex);
extern PFNGLDRAWELEMENTSINSTANCEDBASEVERTEXPROC glad_glDrawElementsInstancedBaseVertex;

typedef void ( * PFNGLMULTIDRAWELEMENTSBASEVERTEXPROC)(GLenum mode, const GLsizei *count, GLenum type, const void *const*indices, GLsizei drawcount, const GLint *basevertex);
extern PFNGLMULTIDRAWELEMENTSBASEVERTEXPROC glad_glMultiDrawElementsBaseVertex;

typedef void ( * PFNGLPROVOKINGVERTEXPROC)(GLenum mode);
extern PFNGLPROVOKINGVERTEXPROC glad_glProvokingVertex;

typedef GLsync ( * PFNGLFENCESYNCPROC)(GLenum condition, GLbitfield flags);
extern PFNGLFENCESYNCPROC glad_glFenceSync;

typedef GLboolean ( * PFNGLISSYNCPROC)(GLsync sync);
extern PFNGLISSYNCPROC glad_glIsSync;

typedef void ( * PFNGLDELETESYNCPROC)(GLsync sync);
extern PFNGLDELETESYNCPROC glad_glDeleteSync;

typedef GLenum ( * PFNGLCLIENTWAITSYNCPROC)(GLsync sync, GLbitfield flags, GLuint64 timeout);
extern PFNGLCLIENTWAITSYNCPROC glad_glClientWaitSync;

typedef void ( * PFNGLWAITSYNCPROC)(GLsync sync, GLbitfield flags, GLuint64 timeout);
extern PFNGLWAITSYNCPROC glad_glWaitSync;

typedef void ( * PFNGLGETINTEGER64VPROC)(GLenum pname, GLint64 *data);
extern PFNGLGETINTEGER64VPROC glad_glGetInteger64v;

typedef void ( * PFNGLGETSYNCIVPROC)(GLsync sync, GLenum pname, GLsizei count, GLsizei *length, GLint *values);
extern PFNGLGETSYNCIVPROC glad_glGetSynciv;

typedef void ( * PFNGLGETINTEGER64I_VPROC)(GLenum target, GLuint index, GLint64 *data);
extern PFNGLGETINTEGER64I_VPROC glad_glGetInteger64i_v;

typedef void ( * PFNGLGETBUFFERPARAMETERI64VPROC)(GLenum target, GLenum pname, GLint64 *params);
extern PFNGLGETBUFFERPARAMETERI64VPROC glad_glGetBufferParameteri64v;

typedef void ( * PFNGLFRAMEBUFFERTEXTUREPROC)(GLenum target, GLenum attachment, GLuint texture, GLint level);
extern PFNGLFRAMEBUFFERTEXTUREPROC glad_glFramebufferTexture;

typedef void ( * PFNGLTEXIMAGE2DMULTISAMPLEPROC)(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLboolean fixedsamplelocations);
extern PFNGLTEXIMAGE2DMULTISAMPLEPROC glad_glTexImage2DMultisample;

typedef void ( * PFNGLTEXIMAGE3DMULTISAMPLEPROC)(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedsamplelocations);
extern PFNGLTEXIMAGE3DMULTISAMPLEPROC glad_glTexImage3DMultisample;

typedef void ( * PFNGLGETMULTISAMPLEFVPROC)(GLenum pname, GLuint index, GLfloat *val);
extern PFNGLGETMULTISAMPLEFVPROC glad_glGetMultisamplefv;

typedef void ( * PFNGLSAMPLEMASKIPROC)(GLuint maskNumber, GLbitfield mask);
extern PFNGLSAMPLEMASKIPROC glad_glSampleMaski;




extern int GLAD_GL_VERSION_3_3;
typedef void ( * PFNGLBINDFRAGDATALOCATIONINDEXEDPROC)(GLuint program, GLuint colorNumber, GLuint index, const GLchar *name);
extern PFNGLBINDFRAGDATALOCATIONINDEXEDPROC glad_glBindFragDataLocationIndexed;

typedef GLint ( * PFNGLGETFRAGDATAINDEXPROC)(GLuint program, const GLchar *name);
extern PFNGLGETFRAGDATAINDEXPROC glad_glGetFragDataIndex;

typedef void ( * PFNGLGENSAMPLERSPROC)(GLsizei count, GLuint *samplers);
extern PFNGLGENSAMPLERSPROC glad_glGenSamplers;

typedef void ( * PFNGLDELETESAMPLERSPROC)(GLsizei count, const GLuint *samplers);
extern PFNGLDELETESAMPLERSPROC glad_glDeleteSamplers;

typedef GLboolean ( * PFNGLISSAMPLERPROC)(GLuint sampler);
extern PFNGLISSAMPLERPROC glad_glIsSampler;

typedef void ( * PFNGLBINDSAMPLERPROC)(GLuint unit, GLuint sampler);
extern PFNGLBINDSAMPLERPROC glad_glBindSampler;

typedef void ( * PFNGLSAMPLERPARAMETERIPROC)(GLuint sampler, GLenum pname, GLint param);
extern PFNGLSAMPLERPARAMETERIPROC glad_glSamplerParameteri;

typedef void ( * PFNGLSAMPLERPARAMETERIVPROC)(GLuint sampler, GLenum pname, const GLint *param);
extern PFNGLSAMPLERPARAMETERIVPROC glad_glSamplerParameteriv;

typedef void ( * PFNGLSAMPLERPARAMETERFPROC)(GLuint sampler, GLenum pname, GLfloat param);
extern PFNGLSAMPLERPARAMETERFPROC glad_glSamplerParameterf;

typedef void ( * PFNGLSAMPLERPARAMETERFVPROC)(GLuint sampler, GLenum pname, const GLfloat *param);
extern PFNGLSAMPLERPARAMETERFVPROC glad_glSamplerParameterfv;

typedef void ( * PFNGLSAMPLERPARAMETERIIVPROC)(GLuint sampler, GLenum pname, const GLint *param);
extern PFNGLSAMPLERPARAMETERIIVPROC glad_glSamplerParameterIiv;

typedef void ( * PFNGLSAMPLERPARAMETERIUIVPROC)(GLuint sampler, GLenum pname, const GLuint *param);
extern PFNGLSAMPLERPARAMETERIUIVPROC glad_glSamplerParameterIuiv;

typedef void ( * PFNGLGETSAMPLERPARAMETERIVPROC)(GLuint sampler, GLenum pname, GLint *params);
extern PFNGLGETSAMPLERPARAMETERIVPROC glad_glGetSamplerParameteriv;

typedef void ( * PFNGLGETSAMPLERPARAMETERIIVPROC)(GLuint sampler, GLenum pname, GLint *params);
extern PFNGLGETSAMPLERPARAMETERIIVPROC glad_glGetSamplerParameterIiv;

typedef void ( * PFNGLGETSAMPLERPARAMETERFVPROC)(GLuint sampler, GLenum pname, GLfloat *params);
extern PFNGLGETSAMPLERPARAMETERFVPROC glad_glGetSamplerParameterfv;

typedef void ( * PFNGLGETSAMPLERPARAMETERIUIVPROC)(GLuint sampler, GLenum pname, GLuint *params);
extern PFNGLGETSAMPLERPARAMETERIUIVPROC glad_glGetSamplerParameterIuiv;

typedef void ( * PFNGLQUERYCOUNTERPROC)(GLuint id, GLenum target);
extern PFNGLQUERYCOUNTERPROC glad_glQueryCounter;

typedef void ( * PFNGLGETQUERYOBJECTI64VPROC)(GLuint id, GLenum pname, GLint64 *params);
extern PFNGLGETQUERYOBJECTI64VPROC glad_glGetQueryObjecti64v;

typedef void ( * PFNGLGETQUERYOBJECTUI64VPROC)(GLuint id, GLenum pname, GLuint64 *params);
extern PFNGLGETQUERYOBJECTUI64VPROC glad_glGetQueryObjectui64v;

typedef void ( * PFNGLVERTEXATTRIBDIVISORPROC)(GLuint index, GLuint divisor);
extern PFNGLVERTEXATTRIBDIVISORPROC glad_glVertexAttribDivisor;

typedef void ( * PFNGLVERTEXATTRIBP1UIPROC)(GLuint index, GLenum type, GLboolean normalized, GLuint value);
extern PFNGLVERTEXATTRIBP1UIPROC glad_glVertexAttribP1ui;

typedef void ( * PFNGLVERTEXATTRIBP1UIVPROC)(GLuint index, GLenum type, GLboolean normalized, const GLuint *value);
extern PFNGLVERTEXATTRIBP1UIVPROC glad_glVertexAttribP1uiv;

typedef void ( * PFNGLVERTEXATTRIBP2UIPROC)(GLuint index, GLenum type, GLboolean normalized, GLuint value);
extern PFNGLVERTEXATTRIBP2UIPROC glad_glVertexAttribP2ui;

typedef void ( * PFNGLVERTEXATTRIBP2UIVPROC)(GLuint index, GLenum type, GLboolean normalized, const GLuint *value);
extern PFNGLVERTEXATTRIBP2UIVPROC glad_glVertexAttribP2uiv;

typedef void ( * PFNGLVERTEXATTRIBP3UIPROC)(GLuint index, GLenum type, GLboolean normalized, GLuint value);
extern PFNGLVERTEXATTRIBP3UIPROC glad_glVertexAttribP3ui;

typedef void ( * PFNGLVERTEXATTRIBP3UIVPROC)(GLuint index, GLenum type, GLboolean normalized, const GLuint *value);
extern PFNGLVERTEXATTRIBP3UIVPROC glad_glVertexAttribP3uiv;

typedef void ( * PFNGLVERTEXATTRIBP4UIPROC)(GLuint index, GLenum type, GLboolean normalized, GLuint value);
extern PFNGLVERTEXATTRIBP4UIPROC glad_glVertexAttribP4ui;

typedef void ( * PFNGLVERTEXATTRIBP4UIVPROC)(GLuint index, GLenum type, GLboolean normalized, const GLuint *value);
extern PFNGLVERTEXATTRIBP4UIVPROC glad_glVertexAttribP4uiv;

typedef void ( * PFNGLVERTEXP2UIPROC)(GLenum type, GLuint value);
extern PFNGLVERTEXP2UIPROC glad_glVertexP2ui;

typedef void ( * PFNGLVERTEXP2UIVPROC)(GLenum type, const GLuint *value);
extern PFNGLVERTEXP2UIVPROC glad_glVertexP2uiv;

typedef void ( * PFNGLVERTEXP3UIPROC)(GLenum type, GLuint value);
extern PFNGLVERTEXP3UIPROC glad_glVertexP3ui;

typedef void ( * PFNGLVERTEXP3UIVPROC)(GLenum type, const GLuint *value);
extern PFNGLVERTEXP3UIVPROC glad_glVertexP3uiv;

typedef void ( * PFNGLVERTEXP4UIPROC)(GLenum type, GLuint value);
extern PFNGLVERTEXP4UIPROC glad_glVertexP4ui;

typedef void ( * PFNGLVERTEXP4UIVPROC)(GLenum type, const GLuint *value);
extern PFNGLVERTEXP4UIVPROC glad_glVertexP4uiv;

typedef void ( * PFNGLTEXCOORDP1UIPROC)(GLenum type, GLuint coords);
extern PFNGLTEXCOORDP1UIPROC glad_glTexCoordP1ui;

typedef void ( * PFNGLTEXCOORDP1UIVPROC)(GLenum type, const GLuint *coords);
extern PFNGLTEXCOORDP1UIVPROC glad_glTexCoordP1uiv;

typedef void ( * PFNGLTEXCOORDP2UIPROC)(GLenum type, GLuint coords);
extern PFNGLTEXCOORDP2UIPROC glad_glTexCoordP2ui;

typedef void ( * PFNGLTEXCOORDP2UIVPROC)(GLenum type, const GLuint *coords);
extern PFNGLTEXCOORDP2UIVPROC glad_glTexCoordP2uiv;

typedef void ( * PFNGLTEXCOORDP3UIPROC)(GLenum type, GLuint coords);
extern PFNGLTEXCOORDP3UIPROC glad_glTexCoordP3ui;

typedef void ( * PFNGLTEXCOORDP3UIVPROC)(GLenum type, const GLuint *coords);
extern PFNGLTEXCOORDP3UIVPROC glad_glTexCoordP3uiv;

typedef void ( * PFNGLTEXCOORDP4UIPROC)(GLenum type, GLuint coords);
extern PFNGLTEXCOORDP4UIPROC glad_glTexCoordP4ui;

typedef void ( * PFNGLTEXCOORDP4UIVPROC)(GLenum type, const GLuint *coords);
extern PFNGLTEXCOORDP4UIVPROC glad_glTexCoordP4uiv;

typedef void ( * PFNGLMULTITEXCOORDP1UIPROC)(GLenum texture, GLenum type, GLuint coords);
extern PFNGLMULTITEXCOORDP1UIPROC glad_glMultiTexCoordP1ui;

typedef void ( * PFNGLMULTITEXCOORDP1UIVPROC)(GLenum texture, GLenum type, const GLuint *coords);
extern PFNGLMULTITEXCOORDP1UIVPROC glad_glMultiTexCoordP1uiv;

typedef void ( * PFNGLMULTITEXCOORDP2UIPROC)(GLenum texture, GLenum type, GLuint coords);
extern PFNGLMULTITEXCOORDP2UIPROC glad_glMultiTexCoordP2ui;

typedef void ( * PFNGLMULTITEXCOORDP2UIVPROC)(GLenum texture, GLenum type, const GLuint *coords);
extern PFNGLMULTITEXCOORDP2UIVPROC glad_glMultiTexCoordP2uiv;

typedef void ( * PFNGLMULTITEXCOORDP3UIPROC)(GLenum texture, GLenum type, GLuint coords);
extern PFNGLMULTITEXCOORDP3UIPROC glad_glMultiTexCoordP3ui;

typedef void ( * PFNGLMULTITEXCOORDP3UIVPROC)(GLenum texture, GLenum type, const GLuint *coords);
extern PFNGLMULTITEXCOORDP3UIVPROC glad_glMultiTexCoordP3uiv;

typedef void ( * PFNGLMULTITEXCOORDP4UIPROC)(GLenum texture, GLenum type, GLuint coords);
extern PFNGLMULTITEXCOORDP4UIPROC glad_glMultiTexCoordP4ui;

typedef void ( * PFNGLMULTITEXCOORDP4UIVPROC)(GLenum texture, GLenum type, const GLuint *coords);
extern PFNGLMULTITEXCOORDP4UIVPROC glad_glMultiTexCoordP4uiv;

typedef void ( * PFNGLNORMALP3UIPROC)(GLenum type, GLuint coords);
extern PFNGLNORMALP3UIPROC glad_glNormalP3ui;

typedef void ( * PFNGLNORMALP3UIVPROC)(GLenum type, const GLuint *coords);
extern PFNGLNORMALP3UIVPROC glad_glNormalP3uiv;

typedef void ( * PFNGLCOLORP3UIPROC)(GLenum type, GLuint color);
extern PFNGLCOLORP3UIPROC glad_glColorP3ui;

typedef void ( * PFNGLCOLORP3UIVPROC)(GLenum type, const GLuint *color);
extern PFNGLCOLORP3UIVPROC glad_glColorP3uiv;

typedef void ( * PFNGLCOLORP4UIPROC)(GLenum type, GLuint color);
extern PFNGLCOLORP4UIPROC glad_glColorP4ui;

typedef void ( * PFNGLCOLORP4UIVPROC)(GLenum type, const GLuint *color);
extern PFNGLCOLORP4UIVPROC glad_glColorP4uiv;

typedef void ( * PFNGLSECONDARYCOLORP3UIPROC)(GLenum type, GLuint color);
extern PFNGLSECONDARYCOLORP3UIPROC glad_glSecondaryColorP3ui;

typedef void ( * PFNGLSECONDARYCOLORP3UIVPROC)(GLenum type, const GLuint *color);
extern PFNGLSECONDARYCOLORP3UIVPROC glad_glSecondaryColorP3uiv;




extern int GLAD_GL_VERSION_4_0;
typedef void ( * PFNGLMINSAMPLESHADINGPROC)(GLfloat value);
extern PFNGLMINSAMPLESHADINGPROC glad_glMinSampleShading;

typedef void ( * PFNGLBLENDEQUATIONIPROC)(GLuint buf, GLenum mode);
extern PFNGLBLENDEQUATIONIPROC glad_glBlendEquationi;

typedef void ( * PFNGLBLENDEQUATIONSEPARATEIPROC)(GLuint buf, GLenum modeRGB, GLenum modeAlpha);
extern PFNGLBLENDEQUATIONSEPARATEIPROC glad_glBlendEquationSeparatei;

typedef void ( * PFNGLBLENDFUNCIPROC)(GLuint buf, GLenum src, GLenum dst);
extern PFNGLBLENDFUNCIPROC glad_glBlendFunci;

typedef void ( * PFNGLBLENDFUNCSEPARATEIPROC)(GLuint buf, GLenum srcRGB, GLenum dstRGB, GLenum srcAlpha, GLenum dstAlpha);
extern PFNGLBLENDFUNCSEPARATEIPROC glad_glBlendFuncSeparatei;

typedef void ( * PFNGLDRAWARRAYSINDIRECTPROC)(GLenum mode, const void *indirect);
extern PFNGLDRAWARRAYSINDIRECTPROC glad_glDrawArraysIndirect;

typedef void ( * PFNGLDRAWELEMENTSINDIRECTPROC)(GLenum mode, GLenum type, const void *indirect);
extern PFNGLDRAWELEMENTSINDIRECTPROC glad_glDrawElementsIndirect;

typedef void ( * PFNGLUNIFORM1DPROC)(GLint location, GLdouble x);
extern PFNGLUNIFORM1DPROC glad_glUniform1d;

typedef void ( * PFNGLUNIFORM2DPROC)(GLint location, GLdouble x, GLdouble y);
extern PFNGLUNIFORM2DPROC glad_glUniform2d;

typedef void ( * PFNGLUNIFORM3DPROC)(GLint location, GLdouble x, GLdouble y, GLdouble z);
extern PFNGLUNIFORM3DPROC glad_glUniform3d;

typedef void ( * PFNGLUNIFORM4DPROC)(GLint location, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
extern PFNGLUNIFORM4DPROC glad_glUniform4d;

typedef void ( * PFNGLUNIFORM1DVPROC)(GLint location, GLsizei count, const GLdouble *value);
extern PFNGLUNIFORM1DVPROC glad_glUniform1dv;

typedef void ( * PFNGLUNIFORM2DVPROC)(GLint location, GLsizei count, const GLdouble *value);
extern PFNGLUNIFORM2DVPROC glad_glUniform2dv;

typedef void ( * PFNGLUNIFORM3DVPROC)(GLint location, GLsizei count, const GLdouble *value);
extern PFNGLUNIFORM3DVPROC glad_glUniform3dv;

typedef void ( * PFNGLUNIFORM4DVPROC)(GLint location, GLsizei count, const GLdouble *value);
extern PFNGLUNIFORM4DVPROC glad_glUniform4dv;

typedef void ( * PFNGLUNIFORMMATRIX2DVPROC)(GLint location, GLsizei count, GLboolean transpose, const GLdouble *value);
extern PFNGLUNIFORMMATRIX2DVPROC glad_glUniformMatrix2dv;

typedef void ( * PFNGLUNIFORMMATRIX3DVPROC)(GLint location, GLsizei count, GLboolean transpose, const GLdouble *value);
extern PFNGLUNIFORMMATRIX3DVPROC glad_glUniformMatrix3dv;

typedef void ( * PFNGLUNIFORMMATRIX4DVPROC)(GLint location, GLsizei count, GLboolean transpose, const GLdouble *value);
extern PFNGLUNIFORMMATRIX4DVPROC glad_glUniformMatrix4dv;

typedef void ( * PFNGLUNIFORMMATRIX2X3DVPROC)(GLint location, GLsizei count, GLboolean transpose, const GLdouble *value);
extern PFNGLUNIFORMMATRIX2X3DVPROC glad_glUniformMatrix2x3dv;

typedef void ( * PFNGLUNIFORMMATRIX2X4DVPROC)(GLint location, GLsizei count, GLboolean transpose, const GLdouble *value);
extern PFNGLUNIFORMMATRIX2X4DVPROC glad_glUniformMatrix2x4dv;

typedef void ( * PFNGLUNIFORMMATRIX3X2DVPROC)(GLint location, GLsizei count, GLboolean transpose, const GLdouble *value);
extern PFNGLUNIFORMMATRIX3X2DVPROC glad_glUniformMatrix3x2dv;

typedef void ( * PFNGLUNIFORMMATRIX3X4DVPROC)(GLint location, GLsizei count, GLboolean transpose, const GLdouble *value);
extern PFNGLUNIFORMMATRIX3X4DVPROC glad_glUniformMatrix3x4dv;

typedef void ( * PFNGLUNIFORMMATRIX4X2DVPROC)(GLint location, GLsizei count, GLboolean transpose, const GLdouble *value);
extern PFNGLUNIFORMMATRIX4X2DVPROC glad_glUniformMatrix4x2dv;

typedef void ( * PFNGLUNIFORMMATRIX4X3DVPROC)(GLint location, GLsizei count, GLboolean transpose, const GLdouble *value);
extern PFNGLUNIFORMMATRIX4X3DVPROC glad_glUniformMatrix4x3dv;

typedef void ( * PFNGLGETUNIFORMDVPROC)(GLuint program, GLint location, GLdouble *params);
extern PFNGLGETUNIFORMDVPROC glad_glGetUniformdv;

typedef GLint ( * PFNGLGETSUBROUTINEUNIFORMLOCATIONPROC)(GLuint program, GLenum shadertype, const GLchar *name);
extern PFNGLGETSUBROUTINEUNIFORMLOCATIONPROC glad_glGetSubroutineUniformLocation;

typedef GLuint ( * PFNGLGETSUBROUTINEINDEXPROC)(GLuint program, GLenum shadertype, const GLchar *name);
extern PFNGLGETSUBROUTINEINDEXPROC glad_glGetSubroutineIndex;

typedef void ( * PFNGLGETACTIVESUBROUTINEUNIFORMIVPROC)(GLuint program, GLenum shadertype, GLuint index, GLenum pname, GLint *values);
extern PFNGLGETACTIVESUBROUTINEUNIFORMIVPROC glad_glGetActiveSubroutineUniformiv;

typedef void ( * PFNGLGETACTIVESUBROUTINEUNIFORMNAMEPROC)(GLuint program, GLenum shadertype, GLuint index, GLsizei bufSize, GLsizei *length, GLchar *name);
extern PFNGLGETACTIVESUBROUTINEUNIFORMNAMEPROC glad_glGetActiveSubroutineUniformName;

typedef void ( * PFNGLGETACTIVESUBROUTINENAMEPROC)(GLuint program, GLenum shadertype, GLuint index, GLsizei bufSize, GLsizei *length, GLchar *name);
extern PFNGLGETACTIVESUBROUTINENAMEPROC glad_glGetActiveSubroutineName;

typedef void ( * PFNGLUNIFORMSUBROUTINESUIVPROC)(GLenum shadertype, GLsizei count, const GLuint *indices);
extern PFNGLUNIFORMSUBROUTINESUIVPROC glad_glUniformSubroutinesuiv;

typedef void ( * PFNGLGETUNIFORMSUBROUTINEUIVPROC)(GLenum shadertype, GLint location, GLuint *params);
extern PFNGLGETUNIFORMSUBROUTINEUIVPROC glad_glGetUniformSubroutineuiv;

typedef void ( * PFNGLGETPROGRAMSTAGEIVPROC)(GLuint program, GLenum shadertype, GLenum pname, GLint *values);
extern PFNGLGETPROGRAMSTAGEIVPROC glad_glGetProgramStageiv;

typedef void ( * PFNGLPATCHPARAMETERIPROC)(GLenum pname, GLint value);
extern PFNGLPATCHPARAMETERIPROC glad_glPatchParameteri;

typedef void ( * PFNGLPATCHPARAMETERFVPROC)(GLenum pname, const GLfloat *values);
extern PFNGLPATCHPARAMETERFVPROC glad_glPatchParameterfv;

typedef void ( * PFNGLBINDTRANSFORMFEEDBACKPROC)(GLenum target, GLuint id);
extern PFNGLBINDTRANSFORMFEEDBACKPROC glad_glBindTransformFeedback;

typedef void ( * PFNGLDELETETRANSFORMFEEDBACKSPROC)(GLsizei n, const GLuint *ids);
extern PFNGLDELETETRANSFORMFEEDBACKSPROC glad_glDeleteTransformFeedbacks;

typedef void ( * PFNGLGENTRANSFORMFEEDBACKSPROC)(GLsizei n, GLuint *ids);
extern PFNGLGENTRANSFORMFEEDBACKSPROC glad_glGenTransformFeedbacks;

typedef GLboolean ( * PFNGLISTRANSFORMFEEDBACKPROC)(GLuint id);
extern PFNGLISTRANSFORMFEEDBACKPROC glad_glIsTransformFeedback;

typedef void ( * PFNGLPAUSETRANSFORMFEEDBACKPROC)(void);
extern PFNGLPAUSETRANSFORMFEEDBACKPROC glad_glPauseTransformFeedback;

typedef void ( * PFNGLRESUMETRANSFORMFEEDBACKPROC)(void);
extern PFNGLRESUMETRANSFORMFEEDBACKPROC glad_glResumeTransformFeedback;

typedef void ( * PFNGLDRAWTRANSFORMFEEDBACKPROC)(GLenum mode, GLuint id);
extern PFNGLDRAWTRANSFORMFEEDBACKPROC glad_glDrawTransformFeedback;

typedef void ( * PFNGLDRAWTRANSFORMFEEDBACKSTREAMPROC)(GLenum mode, GLuint id, GLuint stream);
extern PFNGLDRAWTRANSFORMFEEDBACKSTREAMPROC glad_glDrawTransformFeedbackStream;

typedef void ( * PFNGLBEGINQUERYINDEXEDPROC)(GLenum target, GLuint index, GLuint id);
extern PFNGLBEGINQUERYINDEXEDPROC glad_glBeginQueryIndexed;

typedef void ( * PFNGLENDQUERYINDEXEDPROC)(GLenum target, GLuint index);
extern PFNGLENDQUERYINDEXEDPROC glad_glEndQueryIndexed;

typedef void ( * PFNGLGETQUERYINDEXEDIVPROC)(GLenum target, GLuint index, GLenum pname, GLint *params);
extern PFNGLGETQUERYINDEXEDIVPROC glad_glGetQueryIndexediv;




extern int GLAD_GL_VERSION_4_1;
typedef void ( * PFNGLRELEASESHADERCOMPILERPROC)(void);
extern PFNGLRELEASESHADERCOMPILERPROC glad_glReleaseShaderCompiler;

typedef void ( * PFNGLSHADERBINARYPROC)(GLsizei count, const GLuint *shaders, GLenum binaryFormat, const void *binary, GLsizei length);
extern PFNGLSHADERBINARYPROC glad_glShaderBinary;

typedef void ( * PFNGLGETSHADERPRECISIONFORMATPROC)(GLenum shadertype, GLenum precisiontype, GLint *range, GLint *precision);
extern PFNGLGETSHADERPRECISIONFORMATPROC glad_glGetShaderPrecisionFormat;

typedef void ( * PFNGLDEPTHRANGEFPROC)(GLfloat n, GLfloat f);
extern PFNGLDEPTHRANGEFPROC glad_glDepthRangef;

typedef void ( * PFNGLCLEARDEPTHFPROC)(GLfloat d);
extern PFNGLCLEARDEPTHFPROC glad_glClearDepthf;

typedef void ( * PFNGLGETPROGRAMBINARYPROC)(GLuint program, GLsizei bufSize, GLsizei *length, GLenum *binaryFormat, void *binary);
extern PFNGLGETPROGRAMBINARYPROC glad_glGetProgramBinary;

typedef void ( * PFNGLPROGRAMBINARYPROC)(GLuint program, GLenum binaryFormat, const void *binary, GLsizei length);
extern PFNGLPROGRAMBINARYPROC glad_glProgramBinary;

typedef void ( * PFNGLPROGRAMPARAMETERIPROC)(GLuint program, GLenum pname, GLint value);
extern PFNGLPROGRAMPARAMETERIPROC glad_glProgramParameteri;

typedef void ( * PFNGLUSEPROGRAMSTAGESPROC)(GLuint pipeline, GLbitfield stages, GLuint program);
extern PFNGLUSEPROGRAMSTAGESPROC glad_glUseProgramStages;

typedef void ( * PFNGLACTIVESHADERPROGRAMPROC)(GLuint pipeline, GLuint program);
extern PFNGLACTIVESHADERPROGRAMPROC glad_glActiveShaderProgram;

typedef GLuint ( * PFNGLCREATESHADERPROGRAMVPROC)(GLenum type, GLsizei count, const GLchar *const*strings);
extern PFNGLCREATESHADERPROGRAMVPROC glad_glCreateShaderProgramv;

typedef void ( * PFNGLBINDPROGRAMPIPELINEPROC)(GLuint pipeline);
extern PFNGLBINDPROGRAMPIPELINEPROC glad_glBindProgramPipeline;

typedef void ( * PFNGLDELETEPROGRAMPIPELINESPROC)(GLsizei n, const GLuint *pipelines);
extern PFNGLDELETEPROGRAMPIPELINESPROC glad_glDeleteProgramPipelines;

typedef void ( * PFNGLGENPROGRAMPIPELINESPROC)(GLsizei n, GLuint *pipelines);
extern PFNGLGENPROGRAMPIPELINESPROC glad_glGenProgramPipelines;

typedef GLboolean ( * PFNGLISPROGRAMPIPELINEPROC)(GLuint pipeline);
extern PFNGLISPROGRAMPIPELINEPROC glad_glIsProgramPipeline;

typedef void ( * PFNGLGETPROGRAMPIPELINEIVPROC)(GLuint pipeline, GLenum pname, GLint *params);
extern PFNGLGETPROGRAMPIPELINEIVPROC glad_glGetProgramPipelineiv;

typedef void ( * PFNGLPROGRAMUNIFORM1IPROC)(GLuint program, GLint location, GLint v0);
extern PFNGLPROGRAMUNIFORM1IPROC glad_glProgramUniform1i;

typedef void ( * PFNGLPROGRAMUNIFORM1IVPROC)(GLuint program, GLint location, GLsizei count, const GLint *value);
extern PFNGLPROGRAMUNIFORM1IVPROC glad_glProgramUniform1iv;

typedef void ( * PFNGLPROGRAMUNIFORM1FPROC)(GLuint program, GLint location, GLfloat v0);
extern PFNGLPROGRAMUNIFORM1FPROC glad_glProgramUniform1f;

typedef void ( * PFNGLPROGRAMUNIFORM1FVPROC)(GLuint program, GLint location, GLsizei count, const GLfloat *value);
extern PFNGLPROGRAMUNIFORM1FVPROC glad_glProgramUniform1fv;

typedef void ( * PFNGLPROGRAMUNIFORM1DPROC)(GLuint program, GLint location, GLdouble v0);
extern PFNGLPROGRAMUNIFORM1DPROC glad_glProgramUniform1d;

typedef void ( * PFNGLPROGRAMUNIFORM1DVPROC)(GLuint program, GLint location, GLsizei count, const GLdouble *value);
extern PFNGLPROGRAMUNIFORM1DVPROC glad_glProgramUniform1dv;

typedef void ( * PFNGLPROGRAMUNIFORM1UIPROC)(GLuint program, GLint location, GLuint v0);
extern PFNGLPROGRAMUNIFORM1UIPROC glad_glProgramUniform1ui;

typedef void ( * PFNGLPROGRAMUNIFORM1UIVPROC)(GLuint program, GLint location, GLsizei count, const GLuint *value);
extern PFNGLPROGRAMUNIFORM1UIVPROC glad_glProgramUniform1uiv;

typedef void ( * PFNGLPROGRAMUNIFORM2IPROC)(GLuint program, GLint location, GLint v0, GLint v1);
extern PFNGLPROGRAMUNIFORM2IPROC glad_glProgramUniform2i;

typedef void ( * PFNGLPROGRAMUNIFORM2IVPROC)(GLuint program, GLint location, GLsizei count, const GLint *value);
extern PFNGLPROGRAMUNIFORM2IVPROC glad_glProgramUniform2iv;

typedef void ( * PFNGLPROGRAMUNIFORM2FPROC)(GLuint program, GLint location, GLfloat v0, GLfloat v1);
extern PFNGLPROGRAMUNIFORM2FPROC glad_glProgramUniform2f;

typedef void ( * PFNGLPROGRAMUNIFORM2FVPROC)(GLuint program, GLint location, GLsizei count, const GLfloat *value);
extern PFNGLPROGRAMUNIFORM2FVPROC glad_glProgramUniform2fv;

typedef void ( * PFNGLPROGRAMUNIFORM2DPROC)(GLuint program, GLint location, GLdouble v0, GLdouble v1);
extern PFNGLPROGRAMUNIFORM2DPROC glad_glProgramUniform2d;

typedef void ( * PFNGLPROGRAMUNIFORM2DVPROC)(GLuint program, GLint location, GLsizei count, const GLdouble *value);
extern PFNGLPROGRAMUNIFORM2DVPROC glad_glProgramUniform2dv;

typedef void ( * PFNGLPROGRAMUNIFORM2UIPROC)(GLuint program, GLint location, GLuint v0, GLuint v1);
extern PFNGLPROGRAMUNIFORM2UIPROC glad_glProgramUniform2ui;

typedef void ( * PFNGLPROGRAMUNIFORM2UIVPROC)(GLuint program, GLint location, GLsizei count, const GLuint *value);
extern PFNGLPROGRAMUNIFORM2UIVPROC glad_glProgramUniform2uiv;

typedef void ( * PFNGLPROGRAMUNIFORM3IPROC)(GLuint program, GLint location, GLint v0, GLint v1, GLint v2);
extern PFNGLPROGRAMUNIFORM3IPROC glad_glProgramUniform3i;

typedef void ( * PFNGLPROGRAMUNIFORM3IVPROC)(GLuint program, GLint location, GLsizei count, const GLint *value);
extern PFNGLPROGRAMUNIFORM3IVPROC glad_glProgramUniform3iv;

typedef void ( * PFNGLPROGRAMUNIFORM3FPROC)(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2);
extern PFNGLPROGRAMUNIFORM3FPROC glad_glProgramUniform3f;

typedef void ( * PFNGLPROGRAMUNIFORM3FVPROC)(GLuint program, GLint location, GLsizei count, const GLfloat *value);
extern PFNGLPROGRAMUNIFORM3FVPROC glad_glProgramUniform3fv;

typedef void ( * PFNGLPROGRAMUNIFORM3DPROC)(GLuint program, GLint location, GLdouble v0, GLdouble v1, GLdouble v2);
extern PFNGLPROGRAMUNIFORM3DPROC glad_glProgramUniform3d;

typedef void ( * PFNGLPROGRAMUNIFORM3DVPROC)(GLuint program, GLint location, GLsizei count, const GLdouble *value);
extern PFNGLPROGRAMUNIFORM3DVPROC glad_glProgramUniform3dv;

typedef void ( * PFNGLPROGRAMUNIFORM3UIPROC)(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2);
extern PFNGLPROGRAMUNIFORM3UIPROC glad_glProgramUniform3ui;

typedef void ( * PFNGLPROGRAMUNIFORM3UIVPROC)(GLuint program, GLint location, GLsizei count, const GLuint *value);
extern PFNGLPROGRAMUNIFORM3UIVPROC glad_glProgramUniform3uiv;

typedef void ( * PFNGLPROGRAMUNIFORM4IPROC)(GLuint program, GLint location, GLint v0, GLint v1, GLint v2, GLint v3);
extern PFNGLPROGRAMUNIFORM4IPROC glad_glProgramUniform4i;

typedef void ( * PFNGLPROGRAMUNIFORM4IVPROC)(GLuint program, GLint location, GLsizei count, const GLint *value);
extern PFNGLPROGRAMUNIFORM4IVPROC glad_glProgramUniform4iv;

typedef void ( * PFNGLPROGRAMUNIFORM4FPROC)(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3);
extern PFNGLPROGRAMUNIFORM4FPROC glad_glProgramUniform4f;

typedef void ( * PFNGLPROGRAMUNIFORM4FVPROC)(GLuint program, GLint location, GLsizei count, const GLfloat *value);
extern PFNGLPROGRAMUNIFORM4FVPROC glad_glProgramUniform4fv;

typedef void ( * PFNGLPROGRAMUNIFORM4DPROC)(GLuint program, GLint location, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3);
extern PFNGLPROGRAMUNIFORM4DPROC glad_glProgramUniform4d;

typedef void ( * PFNGLPROGRAMUNIFORM4DVPROC)(GLuint program, GLint location, GLsizei count, const GLdouble *value);
extern PFNGLPROGRAMUNIFORM4DVPROC glad_glProgramUniform4dv;

typedef void ( * PFNGLPROGRAMUNIFORM4UIPROC)(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3);
extern PFNGLPROGRAMUNIFORM4UIPROC glad_glProgramUniform4ui;

typedef void ( * PFNGLPROGRAMUNIFORM4UIVPROC)(GLuint program, GLint location, GLsizei count, const GLuint *value);
extern PFNGLPROGRAMUNIFORM4UIVPROC glad_glProgramUniform4uiv;

typedef void ( * PFNGLPROGRAMUNIFORMMATRIX2FVPROC)(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
extern PFNGLPROGRAMUNIFORMMATRIX2FVPROC glad_glProgramUniformMatrix2fv;

typedef void ( * PFNGLPROGRAMUNIFORMMATRIX3FVPROC)(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
extern PFNGLPROGRAMUNIFORMMATRIX3FVPROC glad_glProgramUniformMatrix3fv;

typedef void ( * PFNGLPROGRAMUNIFORMMATRIX4FVPROC)(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
extern PFNGLPROGRAMUNIFORMMATRIX4FVPROC glad_glProgramUniformMatrix4fv;

typedef void ( * PFNGLPROGRAMUNIFORMMATRIX2DVPROC)(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value);
extern PFNGLPROGRAMUNIFORMMATRIX2DVPROC glad_glProgramUniformMatrix2dv;

typedef void ( * PFNGLPROGRAMUNIFORMMATRIX3DVPROC)(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value);
extern PFNGLPROGRAMUNIFORMMATRIX3DVPROC glad_glProgramUniformMatrix3dv;

typedef void ( * PFNGLPROGRAMUNIFORMMATRIX4DVPROC)(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value);
extern PFNGLPROGRAMUNIFORMMATRIX4DVPROC glad_glProgramUniformMatrix4dv;

typedef void ( * PFNGLPROGRAMUNIFORMMATRIX2X3FVPROC)(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
extern PFNGLPROGRAMUNIFORMMATRIX2X3FVPROC glad_glProgramUniformMatrix2x3fv;

typedef void ( * PFNGLPROGRAMUNIFORMMATRIX3X2FVPROC)(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
extern PFNGLPROGRAMUNIFORMMATRIX3X2FVPROC glad_glProgramUniformMatrix3x2fv;

typedef void ( * PFNGLPROGRAMUNIFORMMATRIX2X4FVPROC)(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
extern PFNGLPROGRAMUNIFORMMATRIX2X4FVPROC glad_glProgramUniformMatrix2x4fv;

typedef void ( * PFNGLPROGRAMUNIFORMMATRIX4X2FVPROC)(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
extern PFNGLPROGRAMUNIFORMMATRIX4X2FVPROC glad_glProgramUniformMatrix4x2fv;

typedef void ( * PFNGLPROGRAMUNIFORMMATRIX3X4FVPROC)(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
extern PFNGLPROGRAMUNIFORMMATRIX3X4FVPROC glad_glProgramUniformMatrix3x4fv;

typedef void ( * PFNGLPROGRAMUNIFORMMATRIX4X3FVPROC)(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
extern PFNGLPROGRAMUNIFORMMATRIX4X3FVPROC glad_glProgramUniformMatrix4x3fv;

typedef void ( * PFNGLPROGRAMUNIFORMMATRIX2X3DVPROC)(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value);
extern PFNGLPROGRAMUNIFORMMATRIX2X3DVPROC glad_glProgramUniformMatrix2x3dv;

typedef void ( * PFNGLPROGRAMUNIFORMMATRIX3X2DVPROC)(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value);
extern PFNGLPROGRAMUNIFORMMATRIX3X2DVPROC glad_glProgramUniformMatrix3x2dv;

typedef void ( * PFNGLPROGRAMUNIFORMMATRIX2X4DVPROC)(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value);
extern PFNGLPROGRAMUNIFORMMATRIX2X4DVPROC glad_glProgramUniformMatrix2x4dv;

typedef void ( * PFNGLPROGRAMUNIFORMMATRIX4X2DVPROC)(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value);
extern PFNGLPROGRAMUNIFORMMATRIX4X2DVPROC glad_glProgramUniformMatrix4x2dv;

typedef void ( * PFNGLPROGRAMUNIFORMMATRIX3X4DVPROC)(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value);
extern PFNGLPROGRAMUNIFORMMATRIX3X4DVPROC glad_glProgramUniformMatrix3x4dv;

typedef void ( * PFNGLPROGRAMUNIFORMMATRIX4X3DVPROC)(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value);
extern PFNGLPROGRAMUNIFORMMATRIX4X3DVPROC glad_glProgramUniformMatrix4x3dv;

typedef void ( * PFNGLVALIDATEPROGRAMPIPELINEPROC)(GLuint pipeline);
extern PFNGLVALIDATEPROGRAMPIPELINEPROC glad_glValidateProgramPipeline;

typedef void ( * PFNGLGETPROGRAMPIPELINEINFOLOGPROC)(GLuint pipeline, GLsizei bufSize, GLsizei *length, GLchar *infoLog);
extern PFNGLGETPROGRAMPIPELINEINFOLOGPROC glad_glGetProgramPipelineInfoLog;

typedef void ( * PFNGLVERTEXATTRIBL1DPROC)(GLuint index, GLdouble x);
extern PFNGLVERTEXATTRIBL1DPROC glad_glVertexAttribL1d;

typedef void ( * PFNGLVERTEXATTRIBL2DPROC)(GLuint index, GLdouble x, GLdouble y);
extern PFNGLVERTEXATTRIBL2DPROC glad_glVertexAttribL2d;

typedef void ( * PFNGLVERTEXATTRIBL3DPROC)(GLuint index, GLdouble x, GLdouble y, GLdouble z);
extern PFNGLVERTEXATTRIBL3DPROC glad_glVertexAttribL3d;

typedef void ( * PFNGLVERTEXATTRIBL4DPROC)(GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
extern PFNGLVERTEXATTRIBL4DPROC glad_glVertexAttribL4d;

typedef void ( * PFNGLVERTEXATTRIBL1DVPROC)(GLuint index, const GLdouble *v);
extern PFNGLVERTEXATTRIBL1DVPROC glad_glVertexAttribL1dv;

typedef void ( * PFNGLVERTEXATTRIBL2DVPROC)(GLuint index, const GLdouble *v);
extern PFNGLVERTEXATTRIBL2DVPROC glad_glVertexAttribL2dv;

typedef void ( * PFNGLVERTEXATTRIBL3DVPROC)(GLuint index, const GLdouble *v);
extern PFNGLVERTEXATTRIBL3DVPROC glad_glVertexAttribL3dv;

typedef void ( * PFNGLVERTEXATTRIBL4DVPROC)(GLuint index, const GLdouble *v);
extern PFNGLVERTEXATTRIBL4DVPROC glad_glVertexAttribL4dv;

typedef void ( * PFNGLVERTEXATTRIBLPOINTERPROC)(GLuint index, GLint size, GLenum type, GLsizei stride, const void *pointer);
extern PFNGLVERTEXATTRIBLPOINTERPROC glad_glVertexAttribLPointer;

typedef void ( * PFNGLGETVERTEXATTRIBLDVPROC)(GLuint index, GLenum pname, GLdouble *params);
extern PFNGLGETVERTEXATTRIBLDVPROC glad_glGetVertexAttribLdv;

typedef void ( * PFNGLVIEWPORTARRAYVPROC)(GLuint first, GLsizei count, const GLfloat *v);
extern PFNGLVIEWPORTARRAYVPROC glad_glViewportArrayv;

typedef void ( * PFNGLVIEWPORTINDEXEDFPROC)(GLuint index, GLfloat x, GLfloat y, GLfloat w, GLfloat h);
extern PFNGLVIEWPORTINDEXEDFPROC glad_glViewportIndexedf;

typedef void ( * PFNGLVIEWPORTINDEXEDFVPROC)(GLuint index, const GLfloat *v);
extern PFNGLVIEWPORTINDEXEDFVPROC glad_glViewportIndexedfv;

typedef void ( * PFNGLSCISSORARRAYVPROC)(GLuint first, GLsizei count, const GLint *v);
extern PFNGLSCISSORARRAYVPROC glad_glScissorArrayv;

typedef void ( * PFNGLSCISSORINDEXEDPROC)(GLuint index, GLint left, GLint bottom, GLsizei width, GLsizei height);
extern PFNGLSCISSORINDEXEDPROC glad_glScissorIndexed;

typedef void ( * PFNGLSCISSORINDEXEDVPROC)(GLuint index, const GLint *v);
extern PFNGLSCISSORINDEXEDVPROC glad_glScissorIndexedv;

typedef void ( * PFNGLDEPTHRANGEARRAYVPROC)(GLuint first, GLsizei count, const GLdouble *v);
extern PFNGLDEPTHRANGEARRAYVPROC glad_glDepthRangeArrayv;

typedef void ( * PFNGLDEPTHRANGEINDEXEDPROC)(GLuint index, GLdouble n, GLdouble f);
extern PFNGLDEPTHRANGEINDEXEDPROC glad_glDepthRangeIndexed;

typedef void ( * PFNGLGETFLOATI_VPROC)(GLenum target, GLuint index, GLfloat *data);
extern PFNGLGETFLOATI_VPROC glad_glGetFloati_v;

typedef void ( * PFNGLGETDOUBLEI_VPROC)(GLenum target, GLuint index, GLdouble *data);
extern PFNGLGETDOUBLEI_VPROC glad_glGetDoublei_v;




extern int GLAD_GL_VERSION_4_2;
typedef void ( * PFNGLDRAWARRAYSINSTANCEDBASEINSTANCEPROC)(GLenum mode, GLint first, GLsizei count, GLsizei instancecount, GLuint baseinstance);
extern PFNGLDRAWARRAYSINSTANCEDBASEINSTANCEPROC glad_glDrawArraysInstancedBaseInstance;

typedef void ( * PFNGLDRAWELEMENTSINSTANCEDBASEINSTANCEPROC)(GLenum mode, GLsizei count, GLenum type, const void *indices, GLsizei instancecount, GLuint baseinstance);
extern PFNGLDRAWELEMENTSINSTANCEDBASEINSTANCEPROC glad_glDrawElementsInstancedBaseInstance;

typedef void ( * PFNGLDRAWELEMENTSINSTANCEDBASEVERTEXBASEINSTANCEPROC)(GLenum mode, GLsizei count, GLenum type, const void *indices, GLsizei instancecount, GLint basevertex, GLuint baseinstance);
extern PFNGLDRAWELEMENTSINSTANCEDBASEVERTEXBASEINSTANCEPROC glad_glDrawElementsInstancedBaseVertexBaseInstance;

typedef void ( * PFNGLGETINTERNALFORMATIVPROC)(GLenum target, GLenum internalformat, GLenum pname, GLsizei count, GLint *params);
extern PFNGLGETINTERNALFORMATIVPROC glad_glGetInternalformativ;

typedef void ( * PFNGLGETACTIVEATOMICCOUNTERBUFFERIVPROC)(GLuint program, GLuint bufferIndex, GLenum pname, GLint *params);
extern PFNGLGETACTIVEATOMICCOUNTERBUFFERIVPROC glad_glGetActiveAtomicCounterBufferiv;

typedef void ( * PFNGLBINDIMAGETEXTUREPROC)(GLuint unit, GLuint texture, GLint level, GLboolean layered, GLint layer, GLenum access, GLenum format);
extern PFNGLBINDIMAGETEXTUREPROC glad_glBindImageTexture;

typedef void ( * PFNGLMEMORYBARRIERPROC)(GLbitfield barriers);
extern PFNGLMEMORYBARRIERPROC glad_glMemoryBarrier;

typedef void ( * PFNGLTEXSTORAGE1DPROC)(GLenum target, GLsizei levels, GLenum internalformat, GLsizei width);
extern PFNGLTEXSTORAGE1DPROC glad_glTexStorage1D;

typedef void ( * PFNGLTEXSTORAGE2DPROC)(GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height);
extern PFNGLTEXSTORAGE2DPROC glad_glTexStorage2D;

typedef void ( * PFNGLTEXSTORAGE3DPROC)(GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth);
extern PFNGLTEXSTORAGE3DPROC glad_glTexStorage3D;

typedef void ( * PFNGLDRAWTRANSFORMFEEDBACKINSTANCEDPROC)(GLenum mode, GLuint id, GLsizei instancecount);
extern PFNGLDRAWTRANSFORMFEEDBACKINSTANCEDPROC glad_glDrawTransformFeedbackInstanced;

typedef void ( * PFNGLDRAWTRANSFORMFEEDBACKSTREAMINSTANCEDPROC)(GLenum mode, GLuint id, GLuint stream, GLsizei instancecount);
extern PFNGLDRAWTRANSFORMFEEDBACKSTREAMINSTANCEDPROC glad_glDrawTransformFeedbackStreamInstanced;




extern int GLAD_GL_VERSION_4_3;
typedef void ( * PFNGLCLEARBUFFERDATAPROC)(GLenum target, GLenum internalformat, GLenum format, GLenum type, const void *data);
extern PFNGLCLEARBUFFERDATAPROC glad_glClearBufferData;

typedef void ( * PFNGLCLEARBUFFERSUBDATAPROC)(GLenum target, GLenum internalformat, GLintptr offset, GLsizeiptr size, GLenum format, GLenum type, const void *data);
extern PFNGLCLEARBUFFERSUBDATAPROC glad_glClearBufferSubData;

typedef void ( * PFNGLDISPATCHCOMPUTEPROC)(GLuint num_groups_x, GLuint num_groups_y, GLuint num_groups_z);
extern PFNGLDISPATCHCOMPUTEPROC glad_glDispatchCompute;

typedef void ( * PFNGLDISPATCHCOMPUTEINDIRECTPROC)(GLintptr indirect);
extern PFNGLDISPATCHCOMPUTEINDIRECTPROC glad_glDispatchComputeIndirect;

typedef void ( * PFNGLCOPYIMAGESUBDATAPROC)(GLuint srcName, GLenum srcTarget, GLint srcLevel, GLint srcX, GLint srcY, GLint srcZ, GLuint dstName, GLenum dstTarget, GLint dstLevel, GLint dstX, GLint dstY, GLint dstZ, GLsizei srcWidth, GLsizei srcHeight, GLsizei srcDepth);
extern PFNGLCOPYIMAGESUBDATAPROC glad_glCopyImageSubData;

typedef void ( * PFNGLFRAMEBUFFERPARAMETERIPROC)(GLenum target, GLenum pname, GLint param);
extern PFNGLFRAMEBUFFERPARAMETERIPROC glad_glFramebufferParameteri;

typedef void ( * PFNGLGETFRAMEBUFFERPARAMETERIVPROC)(GLenum target, GLenum pname, GLint *params);
extern PFNGLGETFRAMEBUFFERPARAMETERIVPROC glad_glGetFramebufferParameteriv;

typedef void ( * PFNGLGETINTERNALFORMATI64VPROC)(GLenum target, GLenum internalformat, GLenum pname, GLsizei count, GLint64 *params);
extern PFNGLGETINTERNALFORMATI64VPROC glad_glGetInternalformati64v;

typedef void ( * PFNGLINVALIDATETEXSUBIMAGEPROC)(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth);
extern PFNGLINVALIDATETEXSUBIMAGEPROC glad_glInvalidateTexSubImage;

typedef void ( * PFNGLINVALIDATETEXIMAGEPROC)(GLuint texture, GLint level);
extern PFNGLINVALIDATETEXIMAGEPROC glad_glInvalidateTexImage;

typedef void ( * PFNGLINVALIDATEBUFFERSUBDATAPROC)(GLuint buffer, GLintptr offset, GLsizeiptr length);
extern PFNGLINVALIDATEBUFFERSUBDATAPROC glad_glInvalidateBufferSubData;

typedef void ( * PFNGLINVALIDATEBUFFERDATAPROC)(GLuint buffer);
extern PFNGLINVALIDATEBUFFERDATAPROC glad_glInvalidateBufferData;

typedef void ( * PFNGLINVALIDATEFRAMEBUFFERPROC)(GLenum target, GLsizei numAttachments, const GLenum *attachments);
extern PFNGLINVALIDATEFRAMEBUFFERPROC glad_glInvalidateFramebuffer;

typedef void ( * PFNGLINVALIDATESUBFRAMEBUFFERPROC)(GLenum target, GLsizei numAttachments, const GLenum *attachments, GLint x, GLint y, GLsizei width, GLsizei height);
extern PFNGLINVALIDATESUBFRAMEBUFFERPROC glad_glInvalidateSubFramebuffer;

typedef void ( * PFNGLMULTIDRAWARRAYSINDIRECTPROC)(GLenum mode, const void *indirect, GLsizei drawcount, GLsizei stride);
extern PFNGLMULTIDRAWARRAYSINDIRECTPROC glad_glMultiDrawArraysIndirect;

typedef void ( * PFNGLMULTIDRAWELEMENTSINDIRECTPROC)(GLenum mode, GLenum type, const void *indirect, GLsizei drawcount, GLsizei stride);
extern PFNGLMULTIDRAWELEMENTSINDIRECTPROC glad_glMultiDrawElementsIndirect;

typedef void ( * PFNGLGETPROGRAMINTERFACEIVPROC)(GLuint program, GLenum programInterface, GLenum pname, GLint *params);
extern PFNGLGETPROGRAMINTERFACEIVPROC glad_glGetProgramInterfaceiv;

typedef GLuint ( * PFNGLGETPROGRAMRESOURCEINDEXPROC)(GLuint program, GLenum programInterface, const GLchar *name);
extern PFNGLGETPROGRAMRESOURCEINDEXPROC glad_glGetProgramResourceIndex;

typedef void ( * PFNGLGETPROGRAMRESOURCENAMEPROC)(GLuint program, GLenum programInterface, GLuint index, GLsizei bufSize, GLsizei *length, GLchar *name);
extern PFNGLGETPROGRAMRESOURCENAMEPROC glad_glGetProgramResourceName;

typedef void ( * PFNGLGETPROGRAMRESOURCEIVPROC)(GLuint program, GLenum programInterface, GLuint index, GLsizei propCount, const GLenum *props, GLsizei count, GLsizei *length, GLint *params);
extern PFNGLGETPROGRAMRESOURCEIVPROC glad_glGetProgramResourceiv;

typedef GLint ( * PFNGLGETPROGRAMRESOURCELOCATIONPROC)(GLuint program, GLenum programInterface, const GLchar *name);
extern PFNGLGETPROGRAMRESOURCELOCATIONPROC glad_glGetProgramResourceLocation;

typedef GLint ( * PFNGLGETPROGRAMRESOURCELOCATIONINDEXPROC)(GLuint program, GLenum programInterface, const GLchar *name);
extern PFNGLGETPROGRAMRESOURCELOCATIONINDEXPROC glad_glGetProgramResourceLocationIndex;

typedef void ( * PFNGLSHADERSTORAGEBLOCKBINDINGPROC)(GLuint program, GLuint storageBlockIndex, GLuint storageBlockBinding);
extern PFNGLSHADERSTORAGEBLOCKBINDINGPROC glad_glShaderStorageBlockBinding;

typedef void ( * PFNGLTEXBUFFERRANGEPROC)(GLenum target, GLenum internalformat, GLuint buffer, GLintptr offset, GLsizeiptr size);
extern PFNGLTEXBUFFERRANGEPROC glad_glTexBufferRange;

typedef void ( * PFNGLTEXSTORAGE2DMULTISAMPLEPROC)(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLboolean fixedsamplelocations);
extern PFNGLTEXSTORAGE2DMULTISAMPLEPROC glad_glTexStorage2DMultisample;

typedef void ( * PFNGLTEXSTORAGE3DMULTISAMPLEPROC)(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedsamplelocations);
extern PFNGLTEXSTORAGE3DMULTISAMPLEPROC glad_glTexStorage3DMultisample;

typedef void ( * PFNGLTEXTUREVIEWPROC)(GLuint texture, GLenum target, GLuint origtexture, GLenum internalformat, GLuint minlevel, GLuint numlevels, GLuint minlayer, GLuint numlayers);
extern PFNGLTEXTUREVIEWPROC glad_glTextureView;

typedef void ( * PFNGLBINDVERTEXBUFFERPROC)(GLuint bindingindex, GLuint buffer, GLintptr offset, GLsizei stride);
extern PFNGLBINDVERTEXBUFFERPROC glad_glBindVertexBuffer;

typedef void ( * PFNGLVERTEXATTRIBFORMATPROC)(GLuint attribindex, GLint size, GLenum type, GLboolean normalized, GLuint relativeoffset);
extern PFNGLVERTEXATTRIBFORMATPROC glad_glVertexAttribFormat;

typedef void ( * PFNGLVERTEXATTRIBIFORMATPROC)(GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset);
extern PFNGLVERTEXATTRIBIFORMATPROC glad_glVertexAttribIFormat;

typedef void ( * PFNGLVERTEXATTRIBLFORMATPROC)(GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset);
extern PFNGLVERTEXATTRIBLFORMATPROC glad_glVertexAttribLFormat;

typedef void ( * PFNGLVERTEXATTRIBBINDINGPROC)(GLuint attribindex, GLuint bindingindex);
extern PFNGLVERTEXATTRIBBINDINGPROC glad_glVertexAttribBinding;

typedef void ( * PFNGLVERTEXBINDINGDIVISORPROC)(GLuint bindingindex, GLuint divisor);
extern PFNGLVERTEXBINDINGDIVISORPROC glad_glVertexBindingDivisor;

typedef void ( * PFNGLDEBUGMESSAGECONTROLPROC)(GLenum source, GLenum type, GLenum severity, GLsizei count, const GLuint *ids, GLboolean enabled);
extern PFNGLDEBUGMESSAGECONTROLPROC glad_glDebugMessageControl;

typedef void ( * PFNGLDEBUGMESSAGEINSERTPROC)(GLenum source, GLenum type, GLuint id, GLenum severity, GLsizei length, const GLchar *buf);
extern PFNGLDEBUGMESSAGEINSERTPROC glad_glDebugMessageInsert;

typedef void ( * PFNGLDEBUGMESSAGECALLBACKPROC)(GLDEBUGPROC callback, const void *userParam);
extern PFNGLDEBUGMESSAGECALLBACKPROC glad_glDebugMessageCallback;

typedef GLuint ( * PFNGLGETDEBUGMESSAGELOGPROC)(GLuint count, GLsizei bufSize, GLenum *sources, GLenum *types, GLuint *ids, GLenum *severities, GLsizei *lengths, GLchar *messageLog);
extern PFNGLGETDEBUGMESSAGELOGPROC glad_glGetDebugMessageLog;

typedef void ( * PFNGLPUSHDEBUGGROUPPROC)(GLenum source, GLuint id, GLsizei length, const GLchar *message);
extern PFNGLPUSHDEBUGGROUPPROC glad_glPushDebugGroup;

typedef void ( * PFNGLPOPDEBUGGROUPPROC)(void);
extern PFNGLPOPDEBUGGROUPPROC glad_glPopDebugGroup;

typedef void ( * PFNGLOBJECTLABELPROC)(GLenum identifier, GLuint name, GLsizei length, const GLchar *label);
extern PFNGLOBJECTLABELPROC glad_glObjectLabel;

typedef void ( * PFNGLGETOBJECTLABELPROC)(GLenum identifier, GLuint name, GLsizei bufSize, GLsizei *length, GLchar *label);
extern PFNGLGETOBJECTLABELPROC glad_glGetObjectLabel;

typedef void ( * PFNGLOBJECTPTRLABELPROC)(const void *ptr, GLsizei length, const GLchar *label);
extern PFNGLOBJECTPTRLABELPROC glad_glObjectPtrLabel;

typedef void ( * PFNGLGETOBJECTPTRLABELPROC)(const void *ptr, GLsizei bufSize, GLsizei *length, GLchar *label);
extern PFNGLGETOBJECTPTRLABELPROC glad_glGetObjectPtrLabel;

typedef void ( * PFNGLGETPOINTERVPROC)(GLenum pname, void **params);
extern PFNGLGETPOINTERVPROC glad_glGetPointerv;




extern int GLAD_GL_VERSION_4_4;
typedef void ( * PFNGLBUFFERSTORAGEPROC)(GLenum target, GLsizeiptr size, const void *data, GLbitfield flags);
extern PFNGLBUFFERSTORAGEPROC glad_glBufferStorage;

typedef void ( * PFNGLCLEARTEXIMAGEPROC)(GLuint texture, GLint level, GLenum format, GLenum type, const void *data);
extern PFNGLCLEARTEXIMAGEPROC glad_glClearTexImage;

typedef void ( * PFNGLCLEARTEXSUBIMAGEPROC)(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const void *data);
extern PFNGLCLEARTEXSUBIMAGEPROC glad_glClearTexSubImage;

typedef void ( * PFNGLBINDBUFFERSBASEPROC)(GLenum target, GLuint first, GLsizei count, const GLuint *buffers);
extern PFNGLBINDBUFFERSBASEPROC glad_glBindBuffersBase;

typedef void ( * PFNGLBINDBUFFERSRANGEPROC)(GLenum target, GLuint first, GLsizei count, const GLuint *buffers, const GLintptr *offsets, const GLsizeiptr *sizes);
extern PFNGLBINDBUFFERSRANGEPROC glad_glBindBuffersRange;

typedef void ( * PFNGLBINDTEXTURESPROC)(GLuint first, GLsizei count, const GLuint *textures);
extern PFNGLBINDTEXTURESPROC glad_glBindTextures;

typedef void ( * PFNGLBINDSAMPLERSPROC)(GLuint first, GLsizei count, const GLuint *samplers);
extern PFNGLBINDSAMPLERSPROC glad_glBindSamplers;

typedef void ( * PFNGLBINDIMAGETEXTURESPROC)(GLuint first, GLsizei count, const GLuint *textures);
extern PFNGLBINDIMAGETEXTURESPROC glad_glBindImageTextures;

typedef void ( * PFNGLBINDVERTEXBUFFERSPROC)(GLuint first, GLsizei count, const GLuint *buffers, const GLintptr *offsets, const GLsizei *strides);
extern PFNGLBINDVERTEXBUFFERSPROC glad_glBindVertexBuffers;




extern int GLAD_GL_VERSION_4_5;
typedef void ( * PFNGLCLIPCONTROLPROC)(GLenum origin, GLenum depth);
extern PFNGLCLIPCONTROLPROC glad_glClipControl;

typedef void ( * PFNGLCREATETRANSFORMFEEDBACKSPROC)(GLsizei n, GLuint *ids);
extern PFNGLCREATETRANSFORMFEEDBACKSPROC glad_glCreateTransformFeedbacks;

typedef void ( * PFNGLTRANSFORMFEEDBACKBUFFERBASEPROC)(GLuint xfb, GLuint index, GLuint buffer);
extern PFNGLTRANSFORMFEEDBACKBUFFERBASEPROC glad_glTransformFeedbackBufferBase;

typedef void ( * PFNGLTRANSFORMFEEDBACKBUFFERRANGEPROC)(GLuint xfb, GLuint index, GLuint buffer, GLintptr offset, GLsizeiptr size);
extern PFNGLTRANSFORMFEEDBACKBUFFERRANGEPROC glad_glTransformFeedbackBufferRange;

typedef void ( * PFNGLGETTRANSFORMFEEDBACKIVPROC)(GLuint xfb, GLenum pname, GLint *param);
extern PFNGLGETTRANSFORMFEEDBACKIVPROC glad_glGetTransformFeedbackiv;

typedef void ( * PFNGLGETTRANSFORMFEEDBACKI_VPROC)(GLuint xfb, GLenum pname, GLuint index, GLint *param);
extern PFNGLGETTRANSFORMFEEDBACKI_VPROC glad_glGetTransformFeedbacki_v;

typedef void ( * PFNGLGETTRANSFORMFEEDBACKI64_VPROC)(GLuint xfb, GLenum pname, GLuint index, GLint64 *param);
extern PFNGLGETTRANSFORMFEEDBACKI64_VPROC glad_glGetTransformFeedbacki64_v;

typedef void ( * PFNGLCREATEBUFFERSPROC)(GLsizei n, GLuint *buffers);
extern PFNGLCREATEBUFFERSPROC glad_glCreateBuffers;

typedef void ( * PFNGLNAMEDBUFFERSTORAGEPROC)(GLuint buffer, GLsizeiptr size, const void *data, GLbitfield flags);
extern PFNGLNAMEDBUFFERSTORAGEPROC glad_glNamedBufferStorage;

typedef void ( * PFNGLNAMEDBUFFERDATAPROC)(GLuint buffer, GLsizeiptr size, const void *data, GLenum usage);
extern PFNGLNAMEDBUFFERDATAPROC glad_glNamedBufferData;

typedef void ( * PFNGLNAMEDBUFFERSUBDATAPROC)(GLuint buffer, GLintptr offset, GLsizeiptr size, const void *data);
extern PFNGLNAMEDBUFFERSUBDATAPROC glad_glNamedBufferSubData;

typedef void ( * PFNGLCOPYNAMEDBUFFERSUBDATAPROC)(GLuint readBuffer, GLuint writeBuffer, GLintptr readOffset, GLintptr writeOffset, GLsizeiptr size);
extern PFNGLCOPYNAMEDBUFFERSUBDATAPROC glad_glCopyNamedBufferSubData;

typedef void ( * PFNGLCLEARNAMEDBUFFERDATAPROC)(GLuint buffer, GLenum internalformat, GLenum format, GLenum type, const void *data);
extern PFNGLCLEARNAMEDBUFFERDATAPROC glad_glClearNamedBufferData;

typedef void ( * PFNGLCLEARNAMEDBUFFERSUBDATAPROC)(GLuint buffer, GLenum internalformat, GLintptr offset, GLsizeiptr size, GLenum format, GLenum type, const void *data);
extern PFNGLCLEARNAMEDBUFFERSUBDATAPROC glad_glClearNamedBufferSubData;

typedef void * ( * PFNGLMAPNAMEDBUFFERPROC)(GLuint buffer, GLenum access);
extern PFNGLMAPNAMEDBUFFERPROC glad_glMapNamedBuffer;

typedef void * ( * PFNGLMAPNAMEDBUFFERRANGEPROC)(GLuint buffer, GLintptr offset, GLsizeiptr length, GLbitfield access);
extern PFNGLMAPNAMEDBUFFERRANGEPROC glad_glMapNamedBufferRange;

typedef GLboolean ( * PFNGLUNMAPNAMEDBUFFERPROC)(GLuint buffer);
extern PFNGLUNMAPNAMEDBUFFERPROC glad_glUnmapNamedBuffer;

typedef void ( * PFNGLFLUSHMAPPEDNAMEDBUFFERRANGEPROC)(GLuint buffer, GLintptr offset, GLsizeiptr length);
extern PFNGLFLUSHMAPPEDNAMEDBUFFERRANGEPROC glad_glFlushMappedNamedBufferRange;

typedef void ( * PFNGLGETNAMEDBUFFERPARAMETERIVPROC)(GLuint buffer, GLenum pname, GLint *params);
extern PFNGLGETNAMEDBUFFERPARAMETERIVPROC glad_glGetNamedBufferParameteriv;

typedef void ( * PFNGLGETNAMEDBUFFERPARAMETERI64VPROC)(GLuint buffer, GLenum pname, GLint64 *params);
extern PFNGLGETNAMEDBUFFERPARAMETERI64VPROC glad_glGetNamedBufferParameteri64v;

typedef void ( * PFNGLGETNAMEDBUFFERPOINTERVPROC)(GLuint buffer, GLenum pname, void **params);
extern PFNGLGETNAMEDBUFFERPOINTERVPROC glad_glGetNamedBufferPointerv;

typedef void ( * PFNGLGETNAMEDBUFFERSUBDATAPROC)(GLuint buffer, GLintptr offset, GLsizeiptr size, void *data);
extern PFNGLGETNAMEDBUFFERSUBDATAPROC glad_glGetNamedBufferSubData;

typedef void ( * PFNGLCREATEFRAMEBUFFERSPROC)(GLsizei n, GLuint *framebuffers);
extern PFNGLCREATEFRAMEBUFFERSPROC glad_glCreateFramebuffers;

typedef void ( * PFNGLNAMEDFRAMEBUFFERRENDERBUFFERPROC)(GLuint framebuffer, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer);
extern PFNGLNAMEDFRAMEBUFFERRENDERBUFFERPROC glad_glNamedFramebufferRenderbuffer;

typedef void ( * PFNGLNAMEDFRAMEBUFFERPARAMETERIPROC)(GLuint framebuffer, GLenum pname, GLint param);
extern PFNGLNAMEDFRAMEBUFFERPARAMETERIPROC glad_glNamedFramebufferParameteri;

typedef void ( * PFNGLNAMEDFRAMEBUFFERTEXTUREPROC)(GLuint framebuffer, GLenum attachment, GLuint texture, GLint level);
extern PFNGLNAMEDFRAMEBUFFERTEXTUREPROC glad_glNamedFramebufferTexture;

typedef void ( * PFNGLNAMEDFRAMEBUFFERTEXTURELAYERPROC)(GLuint framebuffer, GLenum attachment, GLuint texture, GLint level, GLint layer);
extern PFNGLNAMEDFRAMEBUFFERTEXTURELAYERPROC glad_glNamedFramebufferTextureLayer;

typedef void ( * PFNGLNAMEDFRAMEBUFFERDRAWBUFFERPROC)(GLuint framebuffer, GLenum buf);
extern PFNGLNAMEDFRAMEBUFFERDRAWBUFFERPROC glad_glNamedFramebufferDrawBuffer;

typedef void ( * PFNGLNAMEDFRAMEBUFFERDRAWBUFFERSPROC)(GLuint framebuffer, GLsizei n, const GLenum *bufs);
extern PFNGLNAMEDFRAMEBUFFERDRAWBUFFERSPROC glad_glNamedFramebufferDrawBuffers;

typedef void ( * PFNGLNAMEDFRAMEBUFFERREADBUFFERPROC)(GLuint framebuffer, GLenum src);
extern PFNGLNAMEDFRAMEBUFFERREADBUFFERPROC glad_glNamedFramebufferReadBuffer;

typedef void ( * PFNGLINVALIDATENAMEDFRAMEBUFFERDATAPROC)(GLuint framebuffer, GLsizei numAttachments, const GLenum *attachments);
extern PFNGLINVALIDATENAMEDFRAMEBUFFERDATAPROC glad_glInvalidateNamedFramebufferData;

typedef void ( * PFNGLINVALIDATENAMEDFRAMEBUFFERSUBDATAPROC)(GLuint framebuffer, GLsizei numAttachments, const GLenum *attachments, GLint x, GLint y, GLsizei width, GLsizei height);
extern PFNGLINVALIDATENAMEDFRAMEBUFFERSUBDATAPROC glad_glInvalidateNamedFramebufferSubData;

typedef void ( * PFNGLCLEARNAMEDFRAMEBUFFERIVPROC)(GLuint framebuffer, GLenum buffer, GLint drawbuffer, const GLint *value);
extern PFNGLCLEARNAMEDFRAMEBUFFERIVPROC glad_glClearNamedFramebufferiv;

typedef void ( * PFNGLCLEARNAMEDFRAMEBUFFERUIVPROC)(GLuint framebuffer, GLenum buffer, GLint drawbuffer, const GLuint *value);
extern PFNGLCLEARNAMEDFRAMEBUFFERUIVPROC glad_glClearNamedFramebufferuiv;

typedef void ( * PFNGLCLEARNAMEDFRAMEBUFFERFVPROC)(GLuint framebuffer, GLenum buffer, GLint drawbuffer, const GLfloat *value);
extern PFNGLCLEARNAMEDFRAMEBUFFERFVPROC glad_glClearNamedFramebufferfv;

typedef void ( * PFNGLCLEARNAMEDFRAMEBUFFERFIPROC)(GLuint framebuffer, GLenum buffer, GLint drawbuffer, GLfloat depth, GLint stencil);
extern PFNGLCLEARNAMEDFRAMEBUFFERFIPROC glad_glClearNamedFramebufferfi;

typedef void ( * PFNGLBLITNAMEDFRAMEBUFFERPROC)(GLuint readFramebuffer, GLuint drawFramebuffer, GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter);
extern PFNGLBLITNAMEDFRAMEBUFFERPROC glad_glBlitNamedFramebuffer;

typedef GLenum ( * PFNGLCHECKNAMEDFRAMEBUFFERSTATUSPROC)(GLuint framebuffer, GLenum target);
extern PFNGLCHECKNAMEDFRAMEBUFFERSTATUSPROC glad_glCheckNamedFramebufferStatus;

typedef void ( * PFNGLGETNAMEDFRAMEBUFFERPARAMETERIVPROC)(GLuint framebuffer, GLenum pname, GLint *param);
extern PFNGLGETNAMEDFRAMEBUFFERPARAMETERIVPROC glad_glGetNamedFramebufferParameteriv;

typedef void ( * PFNGLGETNAMEDFRAMEBUFFERATTACHMENTPARAMETERIVPROC)(GLuint framebuffer, GLenum attachment, GLenum pname, GLint *params);
extern PFNGLGETNAMEDFRAMEBUFFERATTACHMENTPARAMETERIVPROC glad_glGetNamedFramebufferAttachmentParameteriv;

typedef void ( * PFNGLCREATERENDERBUFFERSPROC)(GLsizei n, GLuint *renderbuffers);
extern PFNGLCREATERENDERBUFFERSPROC glad_glCreateRenderbuffers;

typedef void ( * PFNGLNAMEDRENDERBUFFERSTORAGEPROC)(GLuint renderbuffer, GLenum internalformat, GLsizei width, GLsizei height);
extern PFNGLNAMEDRENDERBUFFERSTORAGEPROC glad_glNamedRenderbufferStorage;

typedef void ( * PFNGLNAMEDRENDERBUFFERSTORAGEMULTISAMPLEPROC)(GLuint renderbuffer, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height);
extern PFNGLNAMEDRENDERBUFFERSTORAGEMULTISAMPLEPROC glad_glNamedRenderbufferStorageMultisample;

typedef void ( * PFNGLGETNAMEDRENDERBUFFERPARAMETERIVPROC)(GLuint renderbuffer, GLenum pname, GLint *params);
extern PFNGLGETNAMEDRENDERBUFFERPARAMETERIVPROC glad_glGetNamedRenderbufferParameteriv;

typedef void ( * PFNGLCREATETEXTURESPROC)(GLenum target, GLsizei n, GLuint *textures);
extern PFNGLCREATETEXTURESPROC glad_glCreateTextures;

typedef void ( * PFNGLTEXTUREBUFFERPROC)(GLuint texture, GLenum internalformat, GLuint buffer);
extern PFNGLTEXTUREBUFFERPROC glad_glTextureBuffer;

typedef void ( * PFNGLTEXTUREBUFFERRANGEPROC)(GLuint texture, GLenum internalformat, GLuint buffer, GLintptr offset, GLsizeiptr size);
extern PFNGLTEXTUREBUFFERRANGEPROC glad_glTextureBufferRange;

typedef void ( * PFNGLTEXTURESTORAGE1DPROC)(GLuint texture, GLsizei levels, GLenum internalformat, GLsizei width);
extern PFNGLTEXTURESTORAGE1DPROC glad_glTextureStorage1D;

typedef void ( * PFNGLTEXTURESTORAGE2DPROC)(GLuint texture, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height);
extern PFNGLTEXTURESTORAGE2DPROC glad_glTextureStorage2D;

typedef void ( * PFNGLTEXTURESTORAGE3DPROC)(GLuint texture, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth);
extern PFNGLTEXTURESTORAGE3DPROC glad_glTextureStorage3D;

typedef void ( * PFNGLTEXTURESTORAGE2DMULTISAMPLEPROC)(GLuint texture, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLboolean fixedsamplelocations);
extern PFNGLTEXTURESTORAGE2DMULTISAMPLEPROC glad_glTextureStorage2DMultisample;

typedef void ( * PFNGLTEXTURESTORAGE3DMULTISAMPLEPROC)(GLuint texture, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedsamplelocations);
extern PFNGLTEXTURESTORAGE3DMULTISAMPLEPROC glad_glTextureStorage3DMultisample;

typedef void ( * PFNGLTEXTURESUBIMAGE1DPROC)(GLuint texture, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const void *pixels);
extern PFNGLTEXTURESUBIMAGE1DPROC glad_glTextureSubImage1D;

typedef void ( * PFNGLTEXTURESUBIMAGE2DPROC)(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const void *pixels);
extern PFNGLTEXTURESUBIMAGE2DPROC glad_glTextureSubImage2D;

typedef void ( * PFNGLTEXTURESUBIMAGE3DPROC)(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const void *pixels);
extern PFNGLTEXTURESUBIMAGE3DPROC glad_glTextureSubImage3D;

typedef void ( * PFNGLCOMPRESSEDTEXTURESUBIMAGE1DPROC)(GLuint texture, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const void *data);
extern PFNGLCOMPRESSEDTEXTURESUBIMAGE1DPROC glad_glCompressedTextureSubImage1D;

typedef void ( * PFNGLCOMPRESSEDTEXTURESUBIMAGE2DPROC)(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const void *data);
extern PFNGLCOMPRESSEDTEXTURESUBIMAGE2DPROC glad_glCompressedTextureSubImage2D;

typedef void ( * PFNGLCOMPRESSEDTEXTURESUBIMAGE3DPROC)(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const void *data);
extern PFNGLCOMPRESSEDTEXTURESUBIMAGE3DPROC glad_glCompressedTextureSubImage3D;

typedef void ( * PFNGLCOPYTEXTURESUBIMAGE1DPROC)(GLuint texture, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width);
extern PFNGLCOPYTEXTURESUBIMAGE1DPROC glad_glCopyTextureSubImage1D;

typedef void ( * PFNGLCOPYTEXTURESUBIMAGE2DPROC)(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height);
extern PFNGLCOPYTEXTURESUBIMAGE2DPROC glad_glCopyTextureSubImage2D;

typedef void ( * PFNGLCOPYTEXTURESUBIMAGE3DPROC)(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height);
extern PFNGLCOPYTEXTURESUBIMAGE3DPROC glad_glCopyTextureSubImage3D;

typedef void ( * PFNGLTEXTUREPARAMETERFPROC)(GLuint texture, GLenum pname, GLfloat param);
extern PFNGLTEXTUREPARAMETERFPROC glad_glTextureParameterf;

typedef void ( * PFNGLTEXTUREPARAMETERFVPROC)(GLuint texture, GLenum pname, const GLfloat *param);
extern PFNGLTEXTUREPARAMETERFVPROC glad_glTextureParameterfv;

typedef void ( * PFNGLTEXTUREPARAMETERIPROC)(GLuint texture, GLenum pname, GLint param);
extern PFNGLTEXTUREPARAMETERIPROC glad_glTextureParameteri;

typedef void ( * PFNGLTEXTUREPARAMETERIIVPROC)(GLuint texture, GLenum pname, const GLint *params);
extern PFNGLTEXTUREPARAMETERIIVPROC glad_glTextureParameterIiv;

typedef void ( * PFNGLTEXTUREPARAMETERIUIVPROC)(GLuint texture, GLenum pname, const GLuint *params);
extern PFNGLTEXTUREPARAMETERIUIVPROC glad_glTextureParameterIuiv;

typedef void ( * PFNGLTEXTUREPARAMETERIVPROC)(GLuint texture, GLenum pname, const GLint *param);
extern PFNGLTEXTUREPARAMETERIVPROC glad_glTextureParameteriv;

typedef void ( * PFNGLGENERATETEXTUREMIPMAPPROC)(GLuint texture);
extern PFNGLGENERATETEXTUREMIPMAPPROC glad_glGenerateTextureMipmap;

typedef void ( * PFNGLBINDTEXTUREUNITPROC)(GLuint unit, GLuint texture);
extern PFNGLBINDTEXTUREUNITPROC glad_glBindTextureUnit;

typedef void ( * PFNGLGETTEXTUREIMAGEPROC)(GLuint texture, GLint level, GLenum format, GLenum type, GLsizei bufSize, void *pixels);
extern PFNGLGETTEXTUREIMAGEPROC glad_glGetTextureImage;

typedef void ( * PFNGLGETCOMPRESSEDTEXTUREIMAGEPROC)(GLuint texture, GLint level, GLsizei bufSize, void *pixels);
extern PFNGLGETCOMPRESSEDTEXTUREIMAGEPROC glad_glGetCompressedTextureImage;

typedef void ( * PFNGLGETTEXTURELEVELPARAMETERFVPROC)(GLuint texture, GLint level, GLenum pname, GLfloat *params);
extern PFNGLGETTEXTURELEVELPARAMETERFVPROC glad_glGetTextureLevelParameterfv;

typedef void ( * PFNGLGETTEXTURELEVELPARAMETERIVPROC)(GLuint texture, GLint level, GLenum pname, GLint *params);
extern PFNGLGETTEXTURELEVELPARAMETERIVPROC glad_glGetTextureLevelParameteriv;

typedef void ( * PFNGLGETTEXTUREPARAMETERFVPROC)(GLuint texture, GLenum pname, GLfloat *params);
extern PFNGLGETTEXTUREPARAMETERFVPROC glad_glGetTextureParameterfv;

typedef void ( * PFNGLGETTEXTUREPARAMETERIIVPROC)(GLuint texture, GLenum pname, GLint *params);
extern PFNGLGETTEXTUREPARAMETERIIVPROC glad_glGetTextureParameterIiv;

typedef void ( * PFNGLGETTEXTUREPARAMETERIUIVPROC)(GLuint texture, GLenum pname, GLuint *params);
extern PFNGLGETTEXTUREPARAMETERIUIVPROC glad_glGetTextureParameterIuiv;

typedef void ( * PFNGLGETTEXTUREPARAMETERIVPROC)(GLuint texture, GLenum pname, GLint *params);
extern PFNGLGETTEXTUREPARAMETERIVPROC glad_glGetTextureParameteriv;

typedef void ( * PFNGLCREATEVERTEXARRAYSPROC)(GLsizei n, GLuint *arrays);
extern PFNGLCREATEVERTEXARRAYSPROC glad_glCreateVertexArrays;

typedef void ( * PFNGLDISABLEVERTEXARRAYATTRIBPROC)(GLuint vaobj, GLuint index);
extern PFNGLDISABLEVERTEXARRAYATTRIBPROC glad_glDisableVertexArrayAttrib;

typedef void ( * PFNGLENABLEVERTEXARRAYATTRIBPROC)(GLuint vaobj, GLuint index);
extern PFNGLENABLEVERTEXARRAYATTRIBPROC glad_glEnableVertexArrayAttrib;

typedef void ( * PFNGLVERTEXARRAYELEMENTBUFFERPROC)(GLuint vaobj, GLuint buffer);
extern PFNGLVERTEXARRAYELEMENTBUFFERPROC glad_glVertexArrayElementBuffer;

typedef void ( * PFNGLVERTEXARRAYVERTEXBUFFERPROC)(GLuint vaobj, GLuint bindingindex, GLuint buffer, GLintptr offset, GLsizei stride);
extern PFNGLVERTEXARRAYVERTEXBUFFERPROC glad_glVertexArrayVertexBuffer;

typedef void ( * PFNGLVERTEXARRAYVERTEXBUFFERSPROC)(GLuint vaobj, GLuint first, GLsizei count, const GLuint *buffers, const GLintptr *offsets, const GLsizei *strides);
extern PFNGLVERTEXARRAYVERTEXBUFFERSPROC glad_glVertexArrayVertexBuffers;

typedef void ( * PFNGLVERTEXARRAYATTRIBBINDINGPROC)(GLuint vaobj, GLuint attribindex, GLuint bindingindex);
extern PFNGLVERTEXARRAYATTRIBBINDINGPROC glad_glVertexArrayAttribBinding;

typedef void ( * PFNGLVERTEXARRAYATTRIBFORMATPROC)(GLuint vaobj, GLuint attribindex, GLint size, GLenum type, GLboolean normalized, GLuint relativeoffset);
extern PFNGLVERTEXARRAYATTRIBFORMATPROC glad_glVertexArrayAttribFormat;

typedef void ( * PFNGLVERTEXARRAYATTRIBIFORMATPROC)(GLuint vaobj, GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset);
extern PFNGLVERTEXARRAYATTRIBIFORMATPROC glad_glVertexArrayAttribIFormat;

typedef void ( * PFNGLVERTEXARRAYATTRIBLFORMATPROC)(GLuint vaobj, GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset);
extern PFNGLVERTEXARRAYATTRIBLFORMATPROC glad_glVertexArrayAttribLFormat;

typedef void ( * PFNGLVERTEXARRAYBINDINGDIVISORPROC)(GLuint vaobj, GLuint bindingindex, GLuint divisor);
extern PFNGLVERTEXARRAYBINDINGDIVISORPROC glad_glVertexArrayBindingDivisor;

typedef void ( * PFNGLGETVERTEXARRAYIVPROC)(GLuint vaobj, GLenum pname, GLint *param);
extern PFNGLGETVERTEXARRAYIVPROC glad_glGetVertexArrayiv;

typedef void ( * PFNGLGETVERTEXARRAYINDEXEDIVPROC)(GLuint vaobj, GLuint index, GLenum pname, GLint *param);
extern PFNGLGETVERTEXARRAYINDEXEDIVPROC glad_glGetVertexArrayIndexediv;

typedef void ( * PFNGLGETVERTEXARRAYINDEXED64IVPROC)(GLuint vaobj, GLuint index, GLenum pname, GLint64 *param);
extern PFNGLGETVERTEXARRAYINDEXED64IVPROC glad_glGetVertexArrayIndexed64iv;

typedef void ( * PFNGLCREATESAMPLERSPROC)(GLsizei n, GLuint *samplers);
extern PFNGLCREATESAMPLERSPROC glad_glCreateSamplers;

typedef void ( * PFNGLCREATEPROGRAMPIPELINESPROC)(GLsizei n, GLuint *pipelines);
extern PFNGLCREATEPROGRAMPIPELINESPROC glad_glCreateProgramPipelines;

typedef void ( * PFNGLCREATEQUERIESPROC)(GLenum target, GLsizei n, GLuint *ids);
extern PFNGLCREATEQUERIESPROC glad_glCreateQueries;

typedef void ( * PFNGLGETQUERYBUFFEROBJECTI64VPROC)(GLuint id, GLuint buffer, GLenum pname, GLintptr offset);
extern PFNGLGETQUERYBUFFEROBJECTI64VPROC glad_glGetQueryBufferObjecti64v;

typedef void ( * PFNGLGETQUERYBUFFEROBJECTIVPROC)(GLuint id, GLuint buffer, GLenum pname, GLintptr offset);
extern PFNGLGETQUERYBUFFEROBJECTIVPROC glad_glGetQueryBufferObjectiv;

typedef void ( * PFNGLGETQUERYBUFFEROBJECTUI64VPROC)(GLuint id, GLuint buffer, GLenum pname, GLintptr offset);
extern PFNGLGETQUERYBUFFEROBJECTUI64VPROC glad_glGetQueryBufferObjectui64v;

typedef void ( * PFNGLGETQUERYBUFFEROBJECTUIVPROC)(GLuint id, GLuint buffer, GLenum pname, GLintptr offset);
extern PFNGLGETQUERYBUFFEROBJECTUIVPROC glad_glGetQueryBufferObjectuiv;

typedef void ( * PFNGLMEMORYBARRIERBYREGIONPROC)(GLbitfield barriers);
extern PFNGLMEMORYBARRIERBYREGIONPROC glad_glMemoryBarrierByRegion;

typedef void ( * PFNGLGETTEXTURESUBIMAGEPROC)(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, GLsizei bufSize, void *pixels);
extern PFNGLGETTEXTURESUBIMAGEPROC glad_glGetTextureSubImage;

typedef void ( * PFNGLGETCOMPRESSEDTEXTURESUBIMAGEPROC)(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLsizei bufSize, void *pixels);
extern PFNGLGETCOMPRESSEDTEXTURESUBIMAGEPROC glad_glGetCompressedTextureSubImage;

typedef GLenum ( * PFNGLGETGRAPHICSRESETSTATUSPROC)(void);
extern PFNGLGETGRAPHICSRESETSTATUSPROC glad_glGetGraphicsResetStatus;

typedef void ( * PFNGLGETNCOMPRESSEDTEXIMAGEPROC)(GLenum target, GLint lod, GLsizei bufSize, void *pixels);
extern PFNGLGETNCOMPRESSEDTEXIMAGEPROC glad_glGetnCompressedTexImage;

typedef void ( * PFNGLGETNTEXIMAGEPROC)(GLenum target, GLint level, GLenum format, GLenum type, GLsizei bufSize, void *pixels);
extern PFNGLGETNTEXIMAGEPROC glad_glGetnTexImage;

typedef void ( * PFNGLGETNUNIFORMDVPROC)(GLuint program, GLint location, GLsizei bufSize, GLdouble *params);
extern PFNGLGETNUNIFORMDVPROC glad_glGetnUniformdv;

typedef void ( * PFNGLGETNUNIFORMFVPROC)(GLuint program, GLint location, GLsizei bufSize, GLfloat *params);
extern PFNGLGETNUNIFORMFVPROC glad_glGetnUniformfv;

typedef void ( * PFNGLGETNUNIFORMIVPROC)(GLuint program, GLint location, GLsizei bufSize, GLint *params);
extern PFNGLGETNUNIFORMIVPROC glad_glGetnUniformiv;

typedef void ( * PFNGLGETNUNIFORMUIVPROC)(GLuint program, GLint location, GLsizei bufSize, GLuint *params);
extern PFNGLGETNUNIFORMUIVPROC glad_glGetnUniformuiv;

typedef void ( * PFNGLREADNPIXELSPROC)(GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLsizei bufSize, void *data);
extern PFNGLREADNPIXELSPROC glad_glReadnPixels;

typedef void ( * PFNGLGETNMAPDVPROC)(GLenum target, GLenum query, GLsizei bufSize, GLdouble *v);
extern PFNGLGETNMAPDVPROC glad_glGetnMapdv;

typedef void ( * PFNGLGETNMAPFVPROC)(GLenum target, GLenum query, GLsizei bufSize, GLfloat *v);
extern PFNGLGETNMAPFVPROC glad_glGetnMapfv;

typedef void ( * PFNGLGETNMAPIVPROC)(GLenum target, GLenum query, GLsizei bufSize, GLint *v);
extern PFNGLGETNMAPIVPROC glad_glGetnMapiv;

typedef void ( * PFNGLGETNPIXELMAPFVPROC)(GLenum map, GLsizei bufSize, GLfloat *values);
extern PFNGLGETNPIXELMAPFVPROC glad_glGetnPixelMapfv;

typedef void ( * PFNGLGETNPIXELMAPUIVPROC)(GLenum map, GLsizei bufSize, GLuint *values);
extern PFNGLGETNPIXELMAPUIVPROC glad_glGetnPixelMapuiv;

typedef void ( * PFNGLGETNPIXELMAPUSVPROC)(GLenum map, GLsizei bufSize, GLushort *values);
extern PFNGLGETNPIXELMAPUSVPROC glad_glGetnPixelMapusv;

typedef void ( * PFNGLGETNPOLYGONSTIPPLEPROC)(GLsizei bufSize, GLubyte *pattern);
extern PFNGLGETNPOLYGONSTIPPLEPROC glad_glGetnPolygonStipple;

typedef void ( * PFNGLGETNCOLORTABLEPROC)(GLenum target, GLenum format, GLenum type, GLsizei bufSize, void *table);
extern PFNGLGETNCOLORTABLEPROC glad_glGetnColorTable;

typedef void ( * PFNGLGETNCONVOLUTIONFILTERPROC)(GLenum target, GLenum format, GLenum type, GLsizei bufSize, void *image);
extern PFNGLGETNCONVOLUTIONFILTERPROC glad_glGetnConvolutionFilter;

typedef void ( * PFNGLGETNSEPARABLEFILTERPROC)(GLenum target, GLenum format, GLenum type, GLsizei rowBufSize, void *row, GLsizei columnBufSize, void *column, void *span);
extern PFNGLGETNSEPARABLEFILTERPROC glad_glGetnSeparableFilter;

typedef void ( * PFNGLGETNHISTOGRAMPROC)(GLenum target, GLboolean reset, GLenum format, GLenum type, GLsizei bufSize, void *values);
extern PFNGLGETNHISTOGRAMPROC glad_glGetnHistogram;

typedef void ( * PFNGLGETNMINMAXPROC)(GLenum target, GLboolean reset, GLenum format, GLenum type, GLsizei bufSize, void *values);
extern PFNGLGETNMINMAXPROC glad_glGetnMinmax;

typedef void ( * PFNGLTEXTUREBARRIERPROC)(void);
extern PFNGLTEXTUREBARRIERPROC glad_glTextureBarrier;




}
# 2 "code/glfw_main.cpp" 2
# 1 "include/GLFW/glfw3.h" 1
# 33 "include/GLFW/glfw3.h"
extern "C" {
# 103 "include/GLFW/glfw3.h"
# 1 "/usr/lib/gcc/x86_64-linux-gnu/10/include/stddef.h" 1 3 4
# 143 "/usr/lib/gcc/x86_64-linux-gnu/10/include/stddef.h" 3 4

# 143 "/usr/lib/gcc/x86_64-linux-gnu/10/include/stddef.h" 3 4
typedef long int ptrdiff_t;
# 209 "/usr/lib/gcc/x86_64-linux-gnu/10/include/stddef.h" 3 4
typedef long unsigned int size_t;
# 415 "/usr/lib/gcc/x86_64-linux-gnu/10/include/stddef.h" 3 4
typedef struct {
  long long __max_align_ll __attribute__((__aligned__(__alignof__(long long))));
  long double __max_align_ld __attribute__((__aligned__(__alignof__(long double))));
# 426 "/usr/lib/gcc/x86_64-linux-gnu/10/include/stddef.h" 3 4
} max_align_t;






  typedef decltype(nullptr) nullptr_t;
# 104 "include/GLFW/glfw3.h" 2
# 210 "include/GLFW/glfw3.h"
# 1 "/usr/include/GL/gl.h" 1 3 4
# 211 "include/GLFW/glfw3.h" 2
# 1197 "include/GLFW/glfw3.h"

# 1197 "include/GLFW/glfw3.h"
typedef void (*GLFWglproc)(void);
# 1211 "include/GLFW/glfw3.h"
typedef void (*GLFWvkproc)(void);
# 1223 "include/GLFW/glfw3.h"
typedef struct GLFWmonitor GLFWmonitor;
# 1235 "include/GLFW/glfw3.h"
typedef struct GLFWwindow GLFWwindow;
# 1247 "include/GLFW/glfw3.h"
typedef struct GLFWcursor GLFWcursor;
# 1271 "include/GLFW/glfw3.h"
typedef void (* GLFWerrorfun)(int,const char*);
# 1294 "include/GLFW/glfw3.h"
typedef void (* GLFWwindowposfun)(GLFWwindow*,int,int);
# 1316 "include/GLFW/glfw3.h"
typedef void (* GLFWwindowsizefun)(GLFWwindow*,int,int);
# 1336 "include/GLFW/glfw3.h"
typedef void (* GLFWwindowclosefun)(GLFWwindow*);
# 1356 "include/GLFW/glfw3.h"
typedef void (* GLFWwindowrefreshfun)(GLFWwindow*);
# 1377 "include/GLFW/glfw3.h"
typedef void (* GLFWwindowfocusfun)(GLFWwindow*,int);
# 1398 "include/GLFW/glfw3.h"
typedef void (* GLFWwindowiconifyfun)(GLFWwindow*,int);
# 1419 "include/GLFW/glfw3.h"
typedef void (* GLFWwindowmaximizefun)(GLFWwindow*,int);
# 1440 "include/GLFW/glfw3.h"
typedef void (* GLFWframebuffersizefun)(GLFWwindow*,int,int);
# 1461 "include/GLFW/glfw3.h"
typedef void (* GLFWwindowcontentscalefun)(GLFWwindow*,float,float);
# 1487 "include/GLFW/glfw3.h"
typedef void (* GLFWmousebuttonfun)(GLFWwindow*,int,int,int);
# 1510 "include/GLFW/glfw3.h"
typedef void (* GLFWcursorposfun)(GLFWwindow*,double,double);
# 1531 "include/GLFW/glfw3.h"
typedef void (* GLFWcursorenterfun)(GLFWwindow*,int);
# 1552 "include/GLFW/glfw3.h"
typedef void (* GLFWscrollfun)(GLFWwindow*,double,double);
# 1578 "include/GLFW/glfw3.h"
typedef void (* GLFWkeyfun)(GLFWwindow*,int,int,int,int);
# 1599 "include/GLFW/glfw3.h"
typedef void (* GLFWcharfun)(GLFWwindow*,unsigned int);
# 1626 "include/GLFW/glfw3.h"
typedef void (* GLFWcharmodsfun)(GLFWwindow*,unsigned int,int);
# 1650 "include/GLFW/glfw3.h"
typedef void (* GLFWdropfun)(GLFWwindow*,int,const char*[]);
# 1671 "include/GLFW/glfw3.h"
typedef void (* GLFWmonitorfun)(GLFWmonitor*,int);
# 1692 "include/GLFW/glfw3.h"
typedef void (* GLFWjoystickfun)(int,int);
# 1707 "include/GLFW/glfw3.h"
typedef struct GLFWvidmode
{


    int width;


    int height;


    int redBits;


    int greenBits;


    int blueBits;


    int refreshRate;
} GLFWvidmode;
# 1741 "include/GLFW/glfw3.h"
typedef struct GLFWgammaramp
{


    unsigned short* red;


    unsigned short* green;


    unsigned short* blue;


    unsigned int size;
} GLFWgammaramp;
# 1770 "include/GLFW/glfw3.h"
typedef struct GLFWimage
{


    int width;


    int height;


    unsigned char* pixels;
} GLFWimage;
# 1794 "include/GLFW/glfw3.h"
typedef struct GLFWgamepadstate
{



    unsigned char buttons[15];



    float axes[6];
} GLFWgamepadstate;
# 1843 "include/GLFW/glfw3.h"
 int glfwInit(void);
# 1875 "include/GLFW/glfw3.h"
 void glfwTerminate(void);
# 1907 "include/GLFW/glfw3.h"
 void glfwInitHint(int hint, int value);
# 1934 "include/GLFW/glfw3.h"
 void glfwGetVersion(int* major, int* minor, int* rev);
# 1965 "include/GLFW/glfw3.h"
 const char* glfwGetVersionString(void);
# 1996 "include/GLFW/glfw3.h"
 int glfwGetError(const char** description);
# 2042 "include/GLFW/glfw3.h"
 GLFWerrorfun glfwSetErrorCallback(GLFWerrorfun callback);
# 2071 "include/GLFW/glfw3.h"
 GLFWmonitor** glfwGetMonitors(int* count);
# 2095 "include/GLFW/glfw3.h"
 GLFWmonitor* glfwGetPrimaryMonitor(void);
# 2120 "include/GLFW/glfw3.h"
 void glfwGetMonitorPos(GLFWmonitor* monitor, int* xpos, int* ypos);
# 2151 "include/GLFW/glfw3.h"
 void glfwGetMonitorWorkarea(GLFWmonitor* monitor, int* xpos, int* ypos, int* width, int* height);
# 2185 "include/GLFW/glfw3.h"
 void glfwGetMonitorPhysicalSize(GLFWmonitor* monitor, int* widthMM, int* heightMM);
# 2217 "include/GLFW/glfw3.h"
 void glfwGetMonitorContentScale(GLFWmonitor* monitor, float* xscale, float* yscale);
# 2243 "include/GLFW/glfw3.h"
 const char* glfwGetMonitorName(GLFWmonitor* monitor);
# 2269 "include/GLFW/glfw3.h"
 void glfwSetMonitorUserPointer(GLFWmonitor* monitor, void* pointer);
# 2293 "include/GLFW/glfw3.h"
 void* glfwGetMonitorUserPointer(GLFWmonitor* monitor);
# 2323 "include/GLFW/glfw3.h"
 GLFWmonitorfun glfwSetMonitorCallback(GLFWmonitorfun callback);
# 2356 "include/GLFW/glfw3.h"
 const GLFWvidmode* glfwGetVideoModes(GLFWmonitor* monitor, int* count);
# 2384 "include/GLFW/glfw3.h"
 const GLFWvidmode* glfwGetVideoMode(GLFWmonitor* monitor);
# 2417 "include/GLFW/glfw3.h"
 void glfwSetGamma(GLFWmonitor* monitor, float gamma);
# 2447 "include/GLFW/glfw3.h"
 const GLFWgammaramp* glfwGetGammaRamp(GLFWmonitor* monitor);
# 2488 "include/GLFW/glfw3.h"
 void glfwSetGammaRamp(GLFWmonitor* monitor, const GLFWgammaramp* ramp);
# 2507 "include/GLFW/glfw3.h"
 void glfwDefaultWindowHints(void);
# 2542 "include/GLFW/glfw3.h"
 void glfwWindowHint(int hint, int value);
# 2580 "include/GLFW/glfw3.h"
 void glfwWindowHintString(int hint, const char* value);
# 2733 "include/GLFW/glfw3.h"
 GLFWwindow* glfwCreateWindow(int width, int height, const char* title, GLFWmonitor* monitor, GLFWwindow* share);
# 2762 "include/GLFW/glfw3.h"
 void glfwDestroyWindow(GLFWwindow* window);
# 2782 "include/GLFW/glfw3.h"
 int glfwWindowShouldClose(GLFWwindow* window);
# 2804 "include/GLFW/glfw3.h"
 void glfwSetWindowShouldClose(GLFWwindow* window, int value);
# 2829 "include/GLFW/glfw3.h"
 void glfwSetWindowTitle(GLFWwindow* window, const char* title);
# 2876 "include/GLFW/glfw3.h"
 void glfwSetWindowIcon(GLFWwindow* window, int count, const GLFWimage* images);
# 2908 "include/GLFW/glfw3.h"
 void glfwGetWindowPos(GLFWwindow* window, int* xpos, int* ypos);
# 2943 "include/GLFW/glfw3.h"
 void glfwSetWindowPos(GLFWwindow* window, int xpos, int ypos);
# 2973 "include/GLFW/glfw3.h"
 void glfwGetWindowSize(GLFWwindow* window, int* width, int* height);
# 3016 "include/GLFW/glfw3.h"
 void glfwSetWindowSizeLimits(GLFWwindow* window, int minwidth, int minheight, int maxwidth, int maxheight);
# 3059 "include/GLFW/glfw3.h"
 void glfwSetWindowAspectRatio(GLFWwindow* window, int numer, int denom);
# 3100 "include/GLFW/glfw3.h"
 void glfwSetWindowSize(GLFWwindow* window, int width, int height);
# 3129 "include/GLFW/glfw3.h"
 void glfwGetFramebufferSize(GLFWwindow* window, int* width, int* height);
# 3166 "include/GLFW/glfw3.h"
 void glfwGetWindowFrameSize(GLFWwindow* window, int* left, int* top, int* right, int* bottom);
# 3199 "include/GLFW/glfw3.h"
 void glfwGetWindowContentScale(GLFWwindow* window, float* xscale, float* yscale);
# 3226 "include/GLFW/glfw3.h"
 float glfwGetWindowOpacity(GLFWwindow* window);
# 3255 "include/GLFW/glfw3.h"
 void glfwSetWindowOpacity(GLFWwindow* window, float opacity);
# 3286 "include/GLFW/glfw3.h"
 void glfwIconifyWindow(GLFWwindow* window);
# 3313 "include/GLFW/glfw3.h"
 void glfwRestoreWindow(GLFWwindow* window);
# 3338 "include/GLFW/glfw3.h"
 void glfwMaximizeWindow(GLFWwindow* window);
# 3365 "include/GLFW/glfw3.h"
 void glfwShowWindow(GLFWwindow* window);
# 3387 "include/GLFW/glfw3.h"
 void glfwHideWindow(GLFWwindow* window);
# 3426 "include/GLFW/glfw3.h"
 void glfwFocusWindow(GLFWwindow* window);
# 3453 "include/GLFW/glfw3.h"
 void glfwRequestWindowAttention(GLFWwindow* window);
# 3475 "include/GLFW/glfw3.h"
 GLFWmonitor* glfwGetWindowMonitor(GLFWwindow* window);
# 3534 "include/GLFW/glfw3.h"
 void glfwSetWindowMonitor(GLFWwindow* window, GLFWmonitor* monitor, int xpos, int ypos, int width, int height, int refreshRate);
# 3568 "include/GLFW/glfw3.h"
 int glfwGetWindowAttrib(GLFWwindow* window, int attrib);
# 3605 "include/GLFW/glfw3.h"
 void glfwSetWindowAttrib(GLFWwindow* window, int attrib, int value);
# 3628 "include/GLFW/glfw3.h"
 void glfwSetWindowUserPointer(GLFWwindow* window, void* pointer);
# 3649 "include/GLFW/glfw3.h"
 void* glfwGetWindowUserPointer(GLFWwindow* window);
# 3684 "include/GLFW/glfw3.h"
 GLFWwindowposfun glfwSetWindowPosCallback(GLFWwindow* window, GLFWwindowposfun callback);
# 3716 "include/GLFW/glfw3.h"
 GLFWwindowsizefun glfwSetWindowSizeCallback(GLFWwindow* window, GLFWwindowsizefun callback);
# 3756 "include/GLFW/glfw3.h"
 GLFWwindowclosefun glfwSetWindowCloseCallback(GLFWwindow* window, GLFWwindowclosefun callback);
# 3792 "include/GLFW/glfw3.h"
 GLFWwindowrefreshfun glfwSetWindowRefreshCallback(GLFWwindow* window, GLFWwindowrefreshfun callback);
# 3827 "include/GLFW/glfw3.h"
 GLFWwindowfocusfun glfwSetWindowFocusCallback(GLFWwindow* window, GLFWwindowfocusfun callback);
# 3857 "include/GLFW/glfw3.h"
 GLFWwindowiconifyfun glfwSetWindowIconifyCallback(GLFWwindow* window, GLFWwindowiconifyfun callback);
# 3887 "include/GLFW/glfw3.h"
 GLFWwindowmaximizefun glfwSetWindowMaximizeCallback(GLFWwindow* window, GLFWwindowmaximizefun callback);
# 3917 "include/GLFW/glfw3.h"
 GLFWframebuffersizefun glfwSetFramebufferSizeCallback(GLFWwindow* window, GLFWframebuffersizefun callback);
# 3948 "include/GLFW/glfw3.h"
 GLFWwindowcontentscalefun glfwSetWindowContentScaleCallback(GLFWwindow* window, GLFWwindowcontentscalefun callback);
# 3986 "include/GLFW/glfw3.h"
 void glfwPollEvents(void);
# 4031 "include/GLFW/glfw3.h"
 void glfwWaitEvents(void);
# 4080 "include/GLFW/glfw3.h"
 void glfwWaitEventsTimeout(double timeout);
# 4100 "include/GLFW/glfw3.h"
 void glfwPostEmptyEvent(void);
# 4125 "include/GLFW/glfw3.h"
 int glfwGetInputMode(GLFWwindow* window, int mode);
# 4187 "include/GLFW/glfw3.h"
 void glfwSetInputMode(GLFWwindow* window, int mode, int value);
# 4216 "include/GLFW/glfw3.h"
 int glfwRawMouseMotionSupported(void);
# 4284 "include/GLFW/glfw3.h"
 const char* glfwGetKeyName(int key, int scancode);
# 4308 "include/GLFW/glfw3.h"
 int glfwGetKeyScancode(int key);
# 4348 "include/GLFW/glfw3.h"
 int glfwGetKey(GLFWwindow* window, int key);
# 4377 "include/GLFW/glfw3.h"
 int glfwGetMouseButton(GLFWwindow* window, int button);
# 4415 "include/GLFW/glfw3.h"
 void glfwGetCursorPos(GLFWwindow* window, double* xpos, double* ypos);
# 4455 "include/GLFW/glfw3.h"
 void glfwSetCursorPos(GLFWwindow* window, double xpos, double ypos);
# 4493 "include/GLFW/glfw3.h"
 GLFWcursor* glfwCreateCursor(const GLFWimage* image, int xhot, int yhot);
# 4541 "include/GLFW/glfw3.h"
 GLFWcursor* glfwCreateStandardCursor(int shape);
# 4568 "include/GLFW/glfw3.h"
 void glfwDestroyCursor(GLFWcursor* cursor);
# 4595 "include/GLFW/glfw3.h"
 void glfwSetCursor(GLFWwindow* window, GLFWcursor* cursor);
# 4645 "include/GLFW/glfw3.h"
 GLFWkeyfun glfwSetKeyCallback(GLFWwindow* window, GLFWkeyfun callback);
# 4688 "include/GLFW/glfw3.h"
 GLFWcharfun glfwSetCharCallback(GLFWwindow* window, GLFWcharfun callback);
# 4730 "include/GLFW/glfw3.h"
 GLFWcharmodsfun glfwSetCharModsCallback(GLFWwindow* window, GLFWcharmodsfun callback);
# 4767 "include/GLFW/glfw3.h"
 GLFWmousebuttonfun glfwSetMouseButtonCallback(GLFWwindow* window, GLFWmousebuttonfun callback);
# 4799 "include/GLFW/glfw3.h"
 GLFWcursorposfun glfwSetCursorPosCallback(GLFWwindow* window, GLFWcursorposfun callback);
# 4830 "include/GLFW/glfw3.h"
 GLFWcursorenterfun glfwSetCursorEnterCallback(GLFWwindow* window, GLFWcursorenterfun callback);
# 4864 "include/GLFW/glfw3.h"
 GLFWscrollfun glfwSetScrollCallback(GLFWwindow* window, GLFWscrollfun callback);
# 4901 "include/GLFW/glfw3.h"
 GLFWdropfun glfwSetDropCallback(GLFWwindow* window, GLFWdropfun callback);
# 4925 "include/GLFW/glfw3.h"
 int glfwJoystickPresent(int jid);
# 4958 "include/GLFW/glfw3.h"
 const float* glfwGetJoystickAxes(int jid, int* count);
# 4999 "include/GLFW/glfw3.h"
 const unsigned char* glfwGetJoystickButtons(int jid, int* count);
# 5056 "include/GLFW/glfw3.h"
 const unsigned char* glfwGetJoystickHats(int jid, int* count);
# 5087 "include/GLFW/glfw3.h"
 const char* glfwGetJoystickName(int jid);
# 5128 "include/GLFW/glfw3.h"
 const char* glfwGetJoystickGUID(int jid);
# 5154 "include/GLFW/glfw3.h"
 void glfwSetJoystickUserPointer(int jid, void* pointer);
# 5178 "include/GLFW/glfw3.h"
 void* glfwGetJoystickUserPointer(int jid);
# 5206 "include/GLFW/glfw3.h"
 int glfwJoystickIsGamepad(int jid);
# 5242 "include/GLFW/glfw3.h"
 GLFWjoystickfun glfwSetJoystickCallback(GLFWjoystickfun callback);
# 5276 "include/GLFW/glfw3.h"
 int glfwUpdateGamepadMappings(const char* string);
# 5306 "include/GLFW/glfw3.h"
 const char* glfwGetGamepadName(int jid);
# 5344 "include/GLFW/glfw3.h"
 int glfwGetGamepadState(int jid, GLFWgamepadstate* state);
# 5369 "include/GLFW/glfw3.h"
 void glfwSetClipboardString(GLFWwindow* window, const char* string);
# 5399 "include/GLFW/glfw3.h"
 const char* glfwGetClipboardString(GLFWwindow* window);
# 5429 "include/GLFW/glfw3.h"
 double glfwGetTime(void);
# 5459 "include/GLFW/glfw3.h"
 void glfwSetTime(double time);
# 5481 "include/GLFW/glfw3.h"
 uint64_t glfwGetTimerValue(void);
# 5501 "include/GLFW/glfw3.h"
 uint64_t glfwGetTimerFrequency(void);
# 5539 "include/GLFW/glfw3.h"
 void glfwMakeContextCurrent(GLFWwindow* window);
# 5560 "include/GLFW/glfw3.h"
 GLFWwindow* glfwGetCurrentContext(void);
# 5594 "include/GLFW/glfw3.h"
 void glfwSwapBuffers(GLFWwindow* window);
# 5640 "include/GLFW/glfw3.h"
 void glfwSwapInterval(int interval);
# 5678 "include/GLFW/glfw3.h"
 int glfwExtensionSupported(const char* extension);
# 5720 "include/GLFW/glfw3.h"
 GLFWglproc glfwGetProcAddress(const char* procname);
# 5748 "include/GLFW/glfw3.h"
 int glfwVulkanSupported(void);
# 5796 "include/GLFW/glfw3.h"
 const char** glfwGetRequiredInstanceExtensions(uint32_t* count);
# 5969 "include/GLFW/glfw3.h"
}
# 3 "code/glfw_main.cpp" 2
# 1 "/usr/include/c++/10/cassert" 1 3
# 41 "/usr/include/c++/10/cassert" 3
       
# 42 "/usr/include/c++/10/cassert" 3

# 1 "/usr/include/x86_64-linux-gnu/c++/10/bits/c++config.h" 1 3
# 262 "/usr/include/x86_64-linux-gnu/c++/10/bits/c++config.h" 3

# 262 "/usr/include/x86_64-linux-gnu/c++/10/bits/c++config.h" 3
namespace std
{
  typedef long unsigned int size_t;
  typedef long int ptrdiff_t;


  typedef decltype(nullptr) nullptr_t;

}
# 284 "/usr/include/x86_64-linux-gnu/c++/10/bits/c++config.h" 3
namespace std
{
  inline namespace __cxx11 __attribute__((__abi_tag__ ("cxx11"))) { }
}
namespace __gnu_cxx
{
  inline namespace __cxx11 __attribute__((__abi_tag__ ("cxx11"))) { }
}
# 522 "/usr/include/x86_64-linux-gnu/c++/10/bits/c++config.h" 3
# 1 "/usr/include/x86_64-linux-gnu/c++/10/bits/os_defines.h" 1 3
# 523 "/usr/include/x86_64-linux-gnu/c++/10/bits/c++config.h" 2 3


# 1 "/usr/include/x86_64-linux-gnu/c++/10/bits/cpu_defines.h" 1 3
# 526 "/usr/include/x86_64-linux-gnu/c++/10/bits/c++config.h" 2 3
# 44 "/usr/include/c++/10/cassert" 2 3
# 1 "/usr/include/assert.h" 1 3 4
# 66 "/usr/include/assert.h" 3 4
extern "C" {


extern void __assert_fail (const char *__assertion, const char *__file,
      unsigned int __line, const char *__function)
     noexcept (true) __attribute__ ((__noreturn__));


extern void __assert_perror_fail (int __errnum, const char *__file,
      unsigned int __line, const char *__function)
     noexcept (true) __attribute__ ((__noreturn__));




extern void __assert (const char *__assertion, const char *__file, int __line)
     noexcept (true) __attribute__ ((__noreturn__));


}
# 45 "/usr/include/c++/10/cassert" 2 3
# 4 "code/glfw_main.cpp" 2
# 1 "/usr/include/c++/10/cstdint" 1 3
# 32 "/usr/include/c++/10/cstdint" 3
       
# 33 "/usr/include/c++/10/cstdint" 3
# 44 "/usr/include/c++/10/cstdint" 3
namespace std
{

  using ::int8_t;
  using ::int16_t;
  using ::int32_t;
  using ::int64_t;

  using ::int_fast8_t;
  using ::int_fast16_t;
  using ::int_fast32_t;
  using ::int_fast64_t;

  using ::int_least8_t;
  using ::int_least16_t;
  using ::int_least32_t;
  using ::int_least64_t;

  using ::intmax_t;
  using ::intptr_t;

  using ::uint8_t;
  using ::uint16_t;
  using ::uint32_t;
  using ::uint64_t;

  using ::uint_fast8_t;
  using ::uint_fast16_t;
  using ::uint_fast32_t;
  using ::uint_fast64_t;

  using ::uint_least8_t;
  using ::uint_least16_t;
  using ::uint_least32_t;
  using ::uint_least64_t;

  using ::uintmax_t;
  using ::uintptr_t;





}
# 5 "code/glfw_main.cpp" 2
# 1 "/usr/include/c++/10/cstdlib" 1 3
# 39 "/usr/include/c++/10/cstdlib" 3
       
# 40 "/usr/include/c++/10/cstdlib" 3
# 75 "/usr/include/c++/10/cstdlib" 3
# 1 "/usr/include/stdlib.h" 1 3 4
# 26 "/usr/include/stdlib.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/libc-header-start.h" 1 3 4
# 27 "/usr/include/stdlib.h" 2 3 4





# 1 "/usr/lib/gcc/x86_64-linux-gnu/10/include/stddef.h" 1 3 4
# 33 "/usr/include/stdlib.h" 2 3 4

extern "C" {





# 1 "/usr/include/x86_64-linux-gnu/bits/waitflags.h" 1 3 4
# 41 "/usr/include/stdlib.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/waitstatus.h" 1 3 4
# 42 "/usr/include/stdlib.h" 2 3 4
# 56 "/usr/include/stdlib.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/floatn.h" 1 3 4
# 74 "/usr/include/x86_64-linux-gnu/bits/floatn.h" 3 4
typedef _Complex float __cfloat128 __attribute__ ((__mode__ (__TC__)));
# 86 "/usr/include/x86_64-linux-gnu/bits/floatn.h" 3 4
typedef __float128 _Float128;
# 119 "/usr/include/x86_64-linux-gnu/bits/floatn.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/floatn-common.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/floatn-common.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/long-double.h" 1 3 4
# 25 "/usr/include/x86_64-linux-gnu/bits/floatn-common.h" 2 3 4
# 214 "/usr/include/x86_64-linux-gnu/bits/floatn-common.h" 3 4
typedef float _Float32;
# 251 "/usr/include/x86_64-linux-gnu/bits/floatn-common.h" 3 4
typedef double _Float64;
# 268 "/usr/include/x86_64-linux-gnu/bits/floatn-common.h" 3 4
typedef double _Float32x;
# 285 "/usr/include/x86_64-linux-gnu/bits/floatn-common.h" 3 4
typedef long double _Float64x;
# 120 "/usr/include/x86_64-linux-gnu/bits/floatn.h" 2 3 4
# 57 "/usr/include/stdlib.h" 2 3 4


typedef struct
  {
    int quot;
    int rem;
  } div_t;



typedef struct
  {
    long int quot;
    long int rem;
  } ldiv_t;





__extension__ typedef struct
  {
    long long int quot;
    long long int rem;
  } lldiv_t;
# 98 "/usr/include/stdlib.h" 3 4
extern size_t __ctype_get_mb_cur_max (void) noexcept (true) ;



extern double atof (const char *__nptr)
     noexcept (true) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;

extern int atoi (const char *__nptr)
     noexcept (true) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;

extern long int atol (const char *__nptr)
     noexcept (true) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;



__extension__ extern long long int atoll (const char *__nptr)
     noexcept (true) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;



extern double strtod (const char *__restrict __nptr,
        char **__restrict __endptr)
     noexcept (true) __attribute__ ((__nonnull__ (1)));



extern float strtof (const char *__restrict __nptr,
       char **__restrict __endptr) noexcept (true) __attribute__ ((__nonnull__ (1)));

extern long double strtold (const char *__restrict __nptr,
       char **__restrict __endptr)
     noexcept (true) __attribute__ ((__nonnull__ (1)));
# 141 "/usr/include/stdlib.h" 3 4
extern _Float32 strtof32 (const char *__restrict __nptr,
     char **__restrict __endptr)
     noexcept (true) __attribute__ ((__nonnull__ (1)));



extern _Float64 strtof64 (const char *__restrict __nptr,
     char **__restrict __endptr)
     noexcept (true) __attribute__ ((__nonnull__ (1)));



extern _Float128 strtof128 (const char *__restrict __nptr,
       char **__restrict __endptr)
     noexcept (true) __attribute__ ((__nonnull__ (1)));



extern _Float32x strtof32x (const char *__restrict __nptr,
       char **__restrict __endptr)
     noexcept (true) __attribute__ ((__nonnull__ (1)));



extern _Float64x strtof64x (const char *__restrict __nptr,
       char **__restrict __endptr)
     noexcept (true) __attribute__ ((__nonnull__ (1)));
# 177 "/usr/include/stdlib.h" 3 4
extern long int strtol (const char *__restrict __nptr,
   char **__restrict __endptr, int __base)
     noexcept (true) __attribute__ ((__nonnull__ (1)));

extern unsigned long int strtoul (const char *__restrict __nptr,
      char **__restrict __endptr, int __base)
     noexcept (true) __attribute__ ((__nonnull__ (1)));



__extension__
extern long long int strtoq (const char *__restrict __nptr,
        char **__restrict __endptr, int __base)
     noexcept (true) __attribute__ ((__nonnull__ (1)));

__extension__
extern unsigned long long int strtouq (const char *__restrict __nptr,
           char **__restrict __endptr, int __base)
     noexcept (true) __attribute__ ((__nonnull__ (1)));




__extension__
extern long long int strtoll (const char *__restrict __nptr,
         char **__restrict __endptr, int __base)
     noexcept (true) __attribute__ ((__nonnull__ (1)));

__extension__
extern unsigned long long int strtoull (const char *__restrict __nptr,
     char **__restrict __endptr, int __base)
     noexcept (true) __attribute__ ((__nonnull__ (1)));




extern int strfromd (char *__dest, size_t __size, const char *__format,
       double __f)
     noexcept (true) __attribute__ ((__nonnull__ (3)));

extern int strfromf (char *__dest, size_t __size, const char *__format,
       float __f)
     noexcept (true) __attribute__ ((__nonnull__ (3)));

extern int strfroml (char *__dest, size_t __size, const char *__format,
       long double __f)
     noexcept (true) __attribute__ ((__nonnull__ (3)));
# 233 "/usr/include/stdlib.h" 3 4
extern int strfromf32 (char *__dest, size_t __size, const char * __format,
         _Float32 __f)
     noexcept (true) __attribute__ ((__nonnull__ (3)));



extern int strfromf64 (char *__dest, size_t __size, const char * __format,
         _Float64 __f)
     noexcept (true) __attribute__ ((__nonnull__ (3)));



extern int strfromf128 (char *__dest, size_t __size, const char * __format,
   _Float128 __f)
     noexcept (true) __attribute__ ((__nonnull__ (3)));



extern int strfromf32x (char *__dest, size_t __size, const char * __format,
   _Float32x __f)
     noexcept (true) __attribute__ ((__nonnull__ (3)));



extern int strfromf64x (char *__dest, size_t __size, const char * __format,
   _Float64x __f)
     noexcept (true) __attribute__ ((__nonnull__ (3)));
# 273 "/usr/include/stdlib.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/locale_t.h" 1 3 4
# 22 "/usr/include/x86_64-linux-gnu/bits/types/locale_t.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/__locale_t.h" 1 3 4
# 27 "/usr/include/x86_64-linux-gnu/bits/types/__locale_t.h" 3 4
struct __locale_struct
{

  struct __locale_data *__locales[13];


  const unsigned short int *__ctype_b;
  const int *__ctype_tolower;
  const int *__ctype_toupper;


  const char *__names[13];
};

typedef struct __locale_struct *__locale_t;
# 23 "/usr/include/x86_64-linux-gnu/bits/types/locale_t.h" 2 3 4

typedef __locale_t locale_t;
# 274 "/usr/include/stdlib.h" 2 3 4

extern long int strtol_l (const char *__restrict __nptr,
     char **__restrict __endptr, int __base,
     locale_t __loc) noexcept (true) __attribute__ ((__nonnull__ (1, 4)));

extern unsigned long int strtoul_l (const char *__restrict __nptr,
        char **__restrict __endptr,
        int __base, locale_t __loc)
     noexcept (true) __attribute__ ((__nonnull__ (1, 4)));

__extension__
extern long long int strtoll_l (const char *__restrict __nptr,
    char **__restrict __endptr, int __base,
    locale_t __loc)
     noexcept (true) __attribute__ ((__nonnull__ (1, 4)));

__extension__
extern unsigned long long int strtoull_l (const char *__restrict __nptr,
       char **__restrict __endptr,
       int __base, locale_t __loc)
     noexcept (true) __attribute__ ((__nonnull__ (1, 4)));

extern double strtod_l (const char *__restrict __nptr,
   char **__restrict __endptr, locale_t __loc)
     noexcept (true) __attribute__ ((__nonnull__ (1, 3)));

extern float strtof_l (const char *__restrict __nptr,
         char **__restrict __endptr, locale_t __loc)
     noexcept (true) __attribute__ ((__nonnull__ (1, 3)));

extern long double strtold_l (const char *__restrict __nptr,
         char **__restrict __endptr,
         locale_t __loc)
     noexcept (true) __attribute__ ((__nonnull__ (1, 3)));
# 317 "/usr/include/stdlib.h" 3 4
extern _Float32 strtof32_l (const char *__restrict __nptr,
       char **__restrict __endptr,
       locale_t __loc)
     noexcept (true) __attribute__ ((__nonnull__ (1, 3)));



extern _Float64 strtof64_l (const char *__restrict __nptr,
       char **__restrict __endptr,
       locale_t __loc)
     noexcept (true) __attribute__ ((__nonnull__ (1, 3)));



extern _Float128 strtof128_l (const char *__restrict __nptr,
         char **__restrict __endptr,
         locale_t __loc)
     noexcept (true) __attribute__ ((__nonnull__ (1, 3)));



extern _Float32x strtof32x_l (const char *__restrict __nptr,
         char **__restrict __endptr,
         locale_t __loc)
     noexcept (true) __attribute__ ((__nonnull__ (1, 3)));



extern _Float64x strtof64x_l (const char *__restrict __nptr,
         char **__restrict __endptr,
         locale_t __loc)
     noexcept (true) __attribute__ ((__nonnull__ (1, 3)));
# 386 "/usr/include/stdlib.h" 3 4
extern char *l64a (long int __n) noexcept (true) ;


extern long int a64l (const char *__s)
     noexcept (true) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;




# 1 "/usr/include/x86_64-linux-gnu/sys/types.h" 1 3 4
# 27 "/usr/include/x86_64-linux-gnu/sys/types.h" 3 4
extern "C" {





typedef __u_char u_char;
typedef __u_short u_short;
typedef __u_int u_int;
typedef __u_long u_long;
typedef __quad_t quad_t;
typedef __u_quad_t u_quad_t;
typedef __fsid_t fsid_t;


typedef __loff_t loff_t;




typedef __ino_t ino_t;






typedef __ino64_t ino64_t;




typedef __dev_t dev_t;




typedef __gid_t gid_t;




typedef __mode_t mode_t;




typedef __nlink_t nlink_t;




typedef __uid_t uid_t;





typedef __off_t off_t;






typedef __off64_t off64_t;




typedef __pid_t pid_t;





typedef __id_t id_t;




typedef __ssize_t ssize_t;





typedef __daddr_t daddr_t;
typedef __caddr_t caddr_t;





typedef __key_t key_t;




# 1 "/usr/include/x86_64-linux-gnu/bits/types/clock_t.h" 1 3 4






typedef __clock_t clock_t;
# 127 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4

# 1 "/usr/include/x86_64-linux-gnu/bits/types/clockid_t.h" 1 3 4






typedef __clockid_t clockid_t;
# 129 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/time_t.h" 1 3 4
# 10 "/usr/include/x86_64-linux-gnu/bits/types/time_t.h" 3 4
typedef __time_t time_t;
# 130 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/timer_t.h" 1 3 4






typedef __timer_t timer_t;
# 131 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4



typedef __useconds_t useconds_t;



typedef __suseconds_t suseconds_t;





# 1 "/usr/lib/gcc/x86_64-linux-gnu/10/include/stddef.h" 1 3 4
# 145 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4



typedef unsigned long int ulong;
typedef unsigned short int ushort;
typedef unsigned int uint;







typedef __uint8_t u_int8_t;
typedef __uint16_t u_int16_t;
typedef __uint32_t u_int32_t;
typedef __uint64_t u_int64_t;


typedef int register_t __attribute__ ((__mode__ (__word__)));
# 176 "/usr/include/x86_64-linux-gnu/sys/types.h" 3 4
# 1 "/usr/include/endian.h" 1 3 4
# 24 "/usr/include/endian.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/endian.h" 1 3 4
# 35 "/usr/include/x86_64-linux-gnu/bits/endian.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/endianness.h" 1 3 4
# 36 "/usr/include/x86_64-linux-gnu/bits/endian.h" 2 3 4
# 25 "/usr/include/endian.h" 2 3 4
# 35 "/usr/include/endian.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/byteswap.h" 1 3 4
# 33 "/usr/include/x86_64-linux-gnu/bits/byteswap.h" 3 4
static __inline __uint16_t
__bswap_16 (__uint16_t __bsx)
{

  return __builtin_bswap16 (__bsx);



}






static __inline __uint32_t
__bswap_32 (__uint32_t __bsx)
{

  return __builtin_bswap32 (__bsx);



}
# 69 "/usr/include/x86_64-linux-gnu/bits/byteswap.h" 3 4
__extension__ static __inline __uint64_t
__bswap_64 (__uint64_t __bsx)
{

  return __builtin_bswap64 (__bsx);



}
# 36 "/usr/include/endian.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/uintn-identity.h" 1 3 4
# 32 "/usr/include/x86_64-linux-gnu/bits/uintn-identity.h" 3 4
static __inline __uint16_t
__uint16_identity (__uint16_t __x)
{
  return __x;
}

static __inline __uint32_t
__uint32_identity (__uint32_t __x)
{
  return __x;
}

static __inline __uint64_t
__uint64_identity (__uint64_t __x)
{
  return __x;
}
# 37 "/usr/include/endian.h" 2 3 4
# 177 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4


# 1 "/usr/include/x86_64-linux-gnu/sys/select.h" 1 3 4
# 30 "/usr/include/x86_64-linux-gnu/sys/select.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/select.h" 1 3 4
# 31 "/usr/include/x86_64-linux-gnu/sys/select.h" 2 3 4


# 1 "/usr/include/x86_64-linux-gnu/bits/types/sigset_t.h" 1 3 4



# 1 "/usr/include/x86_64-linux-gnu/bits/types/__sigset_t.h" 1 3 4




typedef struct
{
  unsigned long int __val[(1024 / (8 * sizeof (unsigned long int)))];
} __sigset_t;
# 5 "/usr/include/x86_64-linux-gnu/bits/types/sigset_t.h" 2 3 4


typedef __sigset_t sigset_t;
# 34 "/usr/include/x86_64-linux-gnu/sys/select.h" 2 3 4



# 1 "/usr/include/x86_64-linux-gnu/bits/types/struct_timeval.h" 1 3 4







struct timeval
{




  __time_t tv_sec;
  __suseconds_t tv_usec;

};
# 38 "/usr/include/x86_64-linux-gnu/sys/select.h" 2 3 4

# 1 "/usr/include/x86_64-linux-gnu/bits/types/struct_timespec.h" 1 3 4
# 11 "/usr/include/x86_64-linux-gnu/bits/types/struct_timespec.h" 3 4
struct timespec
{



  __time_t tv_sec;




  __syscall_slong_t tv_nsec;
# 31 "/usr/include/x86_64-linux-gnu/bits/types/struct_timespec.h" 3 4
};
# 40 "/usr/include/x86_64-linux-gnu/sys/select.h" 2 3 4
# 49 "/usr/include/x86_64-linux-gnu/sys/select.h" 3 4
typedef long int __fd_mask;
# 59 "/usr/include/x86_64-linux-gnu/sys/select.h" 3 4
typedef struct
  {



    __fd_mask fds_bits[1024 / (8 * (int) sizeof (__fd_mask))];





  } fd_set;






typedef __fd_mask fd_mask;
# 91 "/usr/include/x86_64-linux-gnu/sys/select.h" 3 4
extern "C" {
# 102 "/usr/include/x86_64-linux-gnu/sys/select.h" 3 4
extern int select (int __nfds, fd_set *__restrict __readfds,
     fd_set *__restrict __writefds,
     fd_set *__restrict __exceptfds,
     struct timeval *__restrict __timeout);
# 127 "/usr/include/x86_64-linux-gnu/sys/select.h" 3 4
extern int pselect (int __nfds, fd_set *__restrict __readfds,
      fd_set *__restrict __writefds,
      fd_set *__restrict __exceptfds,
      const struct timespec *__restrict __timeout,
      const __sigset_t *__restrict __sigmask);
# 153 "/usr/include/x86_64-linux-gnu/sys/select.h" 3 4
}
# 180 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4





typedef __blksize_t blksize_t;






typedef __blkcnt_t blkcnt_t;



typedef __fsblkcnt_t fsblkcnt_t;



typedef __fsfilcnt_t fsfilcnt_t;
# 219 "/usr/include/x86_64-linux-gnu/sys/types.h" 3 4
typedef __blkcnt64_t blkcnt64_t;
typedef __fsblkcnt64_t fsblkcnt64_t;
typedef __fsfilcnt64_t fsfilcnt64_t;





# 1 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h" 1 3 4
# 23 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h" 1 3 4
# 44 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes-arch.h" 1 3 4
# 21 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes-arch.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 22 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes-arch.h" 2 3 4
# 45 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h" 2 3 4

# 1 "/usr/include/x86_64-linux-gnu/bits/atomic_wide_counter.h" 1 3 4
# 25 "/usr/include/x86_64-linux-gnu/bits/atomic_wide_counter.h" 3 4
typedef union
{
  __extension__ unsigned long long int __value64;
  struct
  {
    unsigned int __low;
    unsigned int __high;
  } __value32;
} __atomic_wide_counter;
# 47 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h" 2 3 4




typedef struct __pthread_internal_list
{
  struct __pthread_internal_list *__prev;
  struct __pthread_internal_list *__next;
} __pthread_list_t;

typedef struct __pthread_internal_slist
{
  struct __pthread_internal_slist *__next;
} __pthread_slist_t;
# 76 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/struct_mutex.h" 1 3 4
# 22 "/usr/include/x86_64-linux-gnu/bits/struct_mutex.h" 3 4
struct __pthread_mutex_s
{
  int __lock;
  unsigned int __count;
  int __owner;

  unsigned int __nusers;



  int __kind;

  short __spins;
  short __elision;
  __pthread_list_t __list;
# 53 "/usr/include/x86_64-linux-gnu/bits/struct_mutex.h" 3 4
};
# 77 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h" 2 3 4
# 89 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/struct_rwlock.h" 1 3 4
# 23 "/usr/include/x86_64-linux-gnu/bits/struct_rwlock.h" 3 4
struct __pthread_rwlock_arch_t
{
  unsigned int __readers;
  unsigned int __writers;
  unsigned int __wrphase_futex;
  unsigned int __writers_futex;
  unsigned int __pad3;
  unsigned int __pad4;

  int __cur_writer;
  int __shared;
  signed char __rwelision;




  unsigned char __pad1[7];


  unsigned long int __pad2;


  unsigned int __flags;
# 55 "/usr/include/x86_64-linux-gnu/bits/struct_rwlock.h" 3 4
};
# 90 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h" 2 3 4




struct __pthread_cond_s
{
  __atomic_wide_counter __wseq;
  __atomic_wide_counter __g1_start;
  unsigned int __g_refs[2] ;
  unsigned int __g_size[2];
  unsigned int __g1_orig_size;
  unsigned int __wrefs;
  unsigned int __g_signals[2];
};

typedef unsigned int __tss_t;
typedef unsigned long int __thrd_t;

typedef struct
{
  int __data ;
} __once_flag;
# 24 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h" 2 3 4



typedef unsigned long int pthread_t;




typedef union
{
  char __size[4];
  int __align;
} pthread_mutexattr_t;




typedef union
{
  char __size[4];
  int __align;
} pthread_condattr_t;



typedef unsigned int pthread_key_t;



typedef int pthread_once_t;


union pthread_attr_t
{
  char __size[56];
  long int __align;
};

typedef union pthread_attr_t pthread_attr_t;




typedef union
{
  struct __pthread_mutex_s __data;
  char __size[40];
  long int __align;
} pthread_mutex_t;


typedef union
{
  struct __pthread_cond_s __data;
  char __size[48];
  __extension__ long long int __align;
} pthread_cond_t;





typedef union
{
  struct __pthread_rwlock_arch_t __data;
  char __size[56];
  long int __align;
} pthread_rwlock_t;

typedef union
{
  char __size[8];
  long int __align;
} pthread_rwlockattr_t;





typedef volatile int pthread_spinlock_t;




typedef union
{
  char __size[32];
  long int __align;
} pthread_barrier_t;

typedef union
{
  char __size[4];
  int __align;
} pthread_barrierattr_t;
# 228 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4


}
# 396 "/usr/include/stdlib.h" 2 3 4






extern long int random (void) noexcept (true);


extern void srandom (unsigned int __seed) noexcept (true);





extern char *initstate (unsigned int __seed, char *__statebuf,
   size_t __statelen) noexcept (true) __attribute__ ((__nonnull__ (2)));



extern char *setstate (char *__statebuf) noexcept (true) __attribute__ ((__nonnull__ (1)));







struct random_data
  {
    int32_t *fptr;
    int32_t *rptr;
    int32_t *state;
    int rand_type;
    int rand_deg;
    int rand_sep;
    int32_t *end_ptr;
  };

extern int random_r (struct random_data *__restrict __buf,
       int32_t *__restrict __result) noexcept (true) __attribute__ ((__nonnull__ (1, 2)));

extern int srandom_r (unsigned int __seed, struct random_data *__buf)
     noexcept (true) __attribute__ ((__nonnull__ (2)));

extern int initstate_r (unsigned int __seed, char *__restrict __statebuf,
   size_t __statelen,
   struct random_data *__restrict __buf)
     noexcept (true) __attribute__ ((__nonnull__ (2, 4)));

extern int setstate_r (char *__restrict __statebuf,
         struct random_data *__restrict __buf)
     noexcept (true) __attribute__ ((__nonnull__ (1, 2)));





extern int rand (void) noexcept (true);

extern void srand (unsigned int __seed) noexcept (true);



extern int rand_r (unsigned int *__seed) noexcept (true);







extern double drand48 (void) noexcept (true);
extern double erand48 (unsigned short int __xsubi[3]) noexcept (true) __attribute__ ((__nonnull__ (1)));


extern long int lrand48 (void) noexcept (true);
extern long int nrand48 (unsigned short int __xsubi[3])
     noexcept (true) __attribute__ ((__nonnull__ (1)));


extern long int mrand48 (void) noexcept (true);
extern long int jrand48 (unsigned short int __xsubi[3])
     noexcept (true) __attribute__ ((__nonnull__ (1)));


extern void srand48 (long int __seedval) noexcept (true);
extern unsigned short int *seed48 (unsigned short int __seed16v[3])
     noexcept (true) __attribute__ ((__nonnull__ (1)));
extern void lcong48 (unsigned short int __param[7]) noexcept (true) __attribute__ ((__nonnull__ (1)));





struct drand48_data
  {
    unsigned short int __x[3];
    unsigned short int __old_x[3];
    unsigned short int __c;
    unsigned short int __init;
    __extension__ unsigned long long int __a;

  };


extern int drand48_r (struct drand48_data *__restrict __buffer,
        double *__restrict __result) noexcept (true) __attribute__ ((__nonnull__ (1, 2)));
extern int erand48_r (unsigned short int __xsubi[3],
        struct drand48_data *__restrict __buffer,
        double *__restrict __result) noexcept (true) __attribute__ ((__nonnull__ (1, 2)));


extern int lrand48_r (struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     noexcept (true) __attribute__ ((__nonnull__ (1, 2)));
extern int nrand48_r (unsigned short int __xsubi[3],
        struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     noexcept (true) __attribute__ ((__nonnull__ (1, 2)));


extern int mrand48_r (struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     noexcept (true) __attribute__ ((__nonnull__ (1, 2)));
extern int jrand48_r (unsigned short int __xsubi[3],
        struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     noexcept (true) __attribute__ ((__nonnull__ (1, 2)));


extern int srand48_r (long int __seedval, struct drand48_data *__buffer)
     noexcept (true) __attribute__ ((__nonnull__ (2)));

extern int seed48_r (unsigned short int __seed16v[3],
       struct drand48_data *__buffer) noexcept (true) __attribute__ ((__nonnull__ (1, 2)));

extern int lcong48_r (unsigned short int __param[7],
        struct drand48_data *__buffer)
     noexcept (true) __attribute__ ((__nonnull__ (1, 2)));




extern void *malloc (size_t __size) noexcept (true) __attribute__ ((__malloc__))
     __attribute__ ((__alloc_size__ (1))) ;

extern void *calloc (size_t __nmemb, size_t __size)
     noexcept (true) __attribute__ ((__malloc__)) __attribute__ ((__alloc_size__ (1, 2))) ;






extern void *realloc (void *__ptr, size_t __size)
     noexcept (true) __attribute__ ((__warn_unused_result__)) __attribute__ ((__alloc_size__ (2)));


extern void free (void *__ptr) noexcept (true);







extern void *reallocarray (void *__ptr, size_t __nmemb, size_t __size)
     noexcept (true) __attribute__ ((__warn_unused_result__))
     __attribute__ ((__alloc_size__ (2, 3)))
    ;


extern void *reallocarray (void *__ptr, size_t __nmemb, size_t __size)
     noexcept (true) ;



# 1 "/usr/include/alloca.h" 1 3 4
# 24 "/usr/include/alloca.h" 3 4
# 1 "/usr/lib/gcc/x86_64-linux-gnu/10/include/stddef.h" 1 3 4
# 25 "/usr/include/alloca.h" 2 3 4

extern "C" {





extern void *alloca (size_t __size) noexcept (true);





}
# 575 "/usr/include/stdlib.h" 2 3 4





extern void *valloc (size_t __size) noexcept (true) __attribute__ ((__malloc__))
     __attribute__ ((__alloc_size__ (1))) ;




extern int posix_memalign (void **__memptr, size_t __alignment, size_t __size)
     noexcept (true) __attribute__ ((__nonnull__ (1))) ;




extern void *aligned_alloc (size_t __alignment, size_t __size)
     noexcept (true) __attribute__ ((__malloc__)) __attribute__ ((__alloc_align__ (1)))
     __attribute__ ((__alloc_size__ (2))) ;



extern void abort (void) noexcept (true) __attribute__ ((__noreturn__));



extern int atexit (void (*__func) (void)) noexcept (true) __attribute__ ((__nonnull__ (1)));




extern "C++" int at_quick_exit (void (*__func) (void))
     noexcept (true) __asm ("at_quick_exit") __attribute__ ((__nonnull__ (1)));
# 617 "/usr/include/stdlib.h" 3 4
extern int on_exit (void (*__func) (int __status, void *__arg), void *__arg)
     noexcept (true) __attribute__ ((__nonnull__ (1)));





extern void exit (int __status) noexcept (true) __attribute__ ((__noreturn__));





extern void quick_exit (int __status) noexcept (true) __attribute__ ((__noreturn__));





extern void _Exit (int __status) noexcept (true) __attribute__ ((__noreturn__));




extern char *getenv (const char *__name) noexcept (true) __attribute__ ((__nonnull__ (1))) ;




extern char *secure_getenv (const char *__name)
     noexcept (true) __attribute__ ((__nonnull__ (1))) ;






extern int putenv (char *__string) noexcept (true) __attribute__ ((__nonnull__ (1)));





extern int setenv (const char *__name, const char *__value, int __replace)
     noexcept (true) __attribute__ ((__nonnull__ (2)));


extern int unsetenv (const char *__name) noexcept (true) __attribute__ ((__nonnull__ (1)));






extern int clearenv (void) noexcept (true);
# 682 "/usr/include/stdlib.h" 3 4
extern char *mktemp (char *__template) noexcept (true) __attribute__ ((__nonnull__ (1)));
# 695 "/usr/include/stdlib.h" 3 4
extern int mkstemp (char *__template) __attribute__ ((__nonnull__ (1))) ;
# 705 "/usr/include/stdlib.h" 3 4
extern int mkstemp64 (char *__template) __attribute__ ((__nonnull__ (1))) ;
# 717 "/usr/include/stdlib.h" 3 4
extern int mkstemps (char *__template, int __suffixlen) __attribute__ ((__nonnull__ (1))) ;
# 727 "/usr/include/stdlib.h" 3 4
extern int mkstemps64 (char *__template, int __suffixlen)
     __attribute__ ((__nonnull__ (1))) ;
# 738 "/usr/include/stdlib.h" 3 4
extern char *mkdtemp (char *__template) noexcept (true) __attribute__ ((__nonnull__ (1))) ;
# 749 "/usr/include/stdlib.h" 3 4
extern int mkostemp (char *__template, int __flags) __attribute__ ((__nonnull__ (1))) ;
# 759 "/usr/include/stdlib.h" 3 4
extern int mkostemp64 (char *__template, int __flags) __attribute__ ((__nonnull__ (1))) ;
# 769 "/usr/include/stdlib.h" 3 4
extern int mkostemps (char *__template, int __suffixlen, int __flags)
     __attribute__ ((__nonnull__ (1))) ;
# 781 "/usr/include/stdlib.h" 3 4
extern int mkostemps64 (char *__template, int __suffixlen, int __flags)
     __attribute__ ((__nonnull__ (1))) ;
# 791 "/usr/include/stdlib.h" 3 4
extern int system (const char *__command) ;





extern char *canonicalize_file_name (const char *__name)
     noexcept (true) __attribute__ ((__nonnull__ (1))) __attribute__ ((__malloc__))
     ;
# 808 "/usr/include/stdlib.h" 3 4
extern char *realpath (const char *__restrict __name,
         char *__restrict __resolved) noexcept (true) ;






typedef int (*__compar_fn_t) (const void *, const void *);


typedef __compar_fn_t comparison_fn_t;



typedef int (*__compar_d_fn_t) (const void *, const void *, void *);




extern void *bsearch (const void *__key, const void *__base,
        size_t __nmemb, size_t __size, __compar_fn_t __compar)
     __attribute__ ((__nonnull__ (1, 2, 5))) ;







extern void qsort (void *__base, size_t __nmemb, size_t __size,
     __compar_fn_t __compar) __attribute__ ((__nonnull__ (1, 4)));

extern void qsort_r (void *__base, size_t __nmemb, size_t __size,
       __compar_d_fn_t __compar, void *__arg)
  __attribute__ ((__nonnull__ (1, 4)));




extern int abs (int __x) noexcept (true) __attribute__ ((__const__)) ;
extern long int labs (long int __x) noexcept (true) __attribute__ ((__const__)) ;


__extension__ extern long long int llabs (long long int __x)
     noexcept (true) __attribute__ ((__const__)) ;






extern div_t div (int __numer, int __denom)
     noexcept (true) __attribute__ ((__const__)) ;
extern ldiv_t ldiv (long int __numer, long int __denom)
     noexcept (true) __attribute__ ((__const__)) ;


__extension__ extern lldiv_t lldiv (long long int __numer,
        long long int __denom)
     noexcept (true) __attribute__ ((__const__)) ;
# 880 "/usr/include/stdlib.h" 3 4
extern char *ecvt (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign) noexcept (true) __attribute__ ((__nonnull__ (3, 4))) ;




extern char *fcvt (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign) noexcept (true) __attribute__ ((__nonnull__ (3, 4))) ;




extern char *gcvt (double __value, int __ndigit, char *__buf)
     noexcept (true) __attribute__ ((__nonnull__ (3))) ;




extern char *qecvt (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign)
     noexcept (true) __attribute__ ((__nonnull__ (3, 4))) ;
extern char *qfcvt (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign)
     noexcept (true) __attribute__ ((__nonnull__ (3, 4))) ;
extern char *qgcvt (long double __value, int __ndigit, char *__buf)
     noexcept (true) __attribute__ ((__nonnull__ (3))) ;




extern int ecvt_r (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign, char *__restrict __buf,
     size_t __len) noexcept (true) __attribute__ ((__nonnull__ (3, 4, 5)));
extern int fcvt_r (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign, char *__restrict __buf,
     size_t __len) noexcept (true) __attribute__ ((__nonnull__ (3, 4, 5)));

extern int qecvt_r (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign,
      char *__restrict __buf, size_t __len)
     noexcept (true) __attribute__ ((__nonnull__ (3, 4, 5)));
extern int qfcvt_r (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign,
      char *__restrict __buf, size_t __len)
     noexcept (true) __attribute__ ((__nonnull__ (3, 4, 5)));





extern int mblen (const char *__s, size_t __n) noexcept (true);


extern int mbtowc (wchar_t *__restrict __pwc,
     const char *__restrict __s, size_t __n) noexcept (true);


extern int wctomb (char *__s, wchar_t __wchar) noexcept (true);



extern size_t mbstowcs (wchar_t *__restrict __pwcs,
   const char *__restrict __s, size_t __n) noexcept (true)
    __attribute__ ((__access__ (__read_only__, 2)));

extern size_t wcstombs (char *__restrict __s,
   const wchar_t *__restrict __pwcs, size_t __n)
     noexcept (true)
  __attribute__ ((__access__ (__write_only__, 1, 3)))
  __attribute__ ((__access__ (__read_only__, 2)));






extern int rpmatch (const char *__response) noexcept (true) __attribute__ ((__nonnull__ (1))) ;
# 967 "/usr/include/stdlib.h" 3 4
extern int getsubopt (char **__restrict __optionp,
        char *const *__restrict __tokens,
        char **__restrict __valuep)
     noexcept (true) __attribute__ ((__nonnull__ (1, 2, 3))) ;







extern int posix_openpt (int __oflag) ;







extern int grantpt (int __fd) noexcept (true);



extern int unlockpt (int __fd) noexcept (true);




extern char *ptsname (int __fd) noexcept (true) ;






extern int ptsname_r (int __fd, char *__buf, size_t __buflen)
     noexcept (true) __attribute__ ((__nonnull__ (2))) __attribute__ ((__access__ (__write_only__, 2, 3)));


extern int getpt (void);






extern int getloadavg (double __loadavg[], int __nelem)
     noexcept (true) __attribute__ ((__nonnull__ (1)));
# 1023 "/usr/include/stdlib.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/stdlib-float.h" 1 3 4
# 1024 "/usr/include/stdlib.h" 2 3 4
# 1035 "/usr/include/stdlib.h" 3 4
}
# 76 "/usr/include/c++/10/cstdlib" 2 3

# 1 "/usr/include/c++/10/bits/std_abs.h" 1 3
# 33 "/usr/include/c++/10/bits/std_abs.h" 3
       
# 34 "/usr/include/c++/10/bits/std_abs.h" 3
# 46 "/usr/include/c++/10/bits/std_abs.h" 3
extern "C++"
{
namespace std __attribute__ ((__visibility__ ("default")))
{


  using ::abs;


  inline long
  abs(long __i) { return __builtin_labs(__i); }



  inline long long
  abs(long long __x) { return __builtin_llabs (__x); }
# 70 "/usr/include/c++/10/bits/std_abs.h" 3
  inline constexpr double
  abs(double __x)
  { return __builtin_fabs(__x); }

  inline constexpr float
  abs(float __x)
  { return __builtin_fabsf(__x); }

  inline constexpr long double
  abs(long double __x)
  { return __builtin_fabsl(__x); }



  inline constexpr __int128
  abs(__int128 __x) { return __x >= 0 ? __x : -__x; }
# 101 "/usr/include/c++/10/bits/std_abs.h" 3
  inline constexpr
  __float128
  abs(__float128 __x)
  { return __x < 0 ? -__x : __x; }



}
}
# 78 "/usr/include/c++/10/cstdlib" 2 3
# 121 "/usr/include/c++/10/cstdlib" 3
extern "C++"
{
namespace std __attribute__ ((__visibility__ ("default")))
{


  using ::div_t;
  using ::ldiv_t;

  using ::abort;



  using ::atexit;


  using ::at_quick_exit;


  using ::atof;
  using ::atoi;
  using ::atol;
  using ::bsearch;
  using ::calloc;
  using ::div;
  using ::exit;
  using ::free;
  using ::getenv;
  using ::labs;
  using ::ldiv;
  using ::malloc;

  using ::mblen;
  using ::mbstowcs;
  using ::mbtowc;

  using ::qsort;


  using ::quick_exit;


  using ::rand;
  using ::realloc;
  using ::srand;
  using ::strtod;
  using ::strtol;
  using ::strtoul;
  using ::system;

  using ::wcstombs;
  using ::wctomb;



  inline ldiv_t
  div(long __i, long __j) { return ldiv(__i, __j); }




}
# 195 "/usr/include/c++/10/cstdlib" 3
namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{



  using ::lldiv_t;





  using ::_Exit;



  using ::llabs;

  inline lldiv_t
  div(long long __n, long long __d)
  { lldiv_t __q; __q.quot = __n / __d; __q.rem = __n % __d; return __q; }

  using ::lldiv;
# 227 "/usr/include/c++/10/cstdlib" 3
  using ::atoll;
  using ::strtoll;
  using ::strtoull;

  using ::strtof;
  using ::strtold;


}

namespace std
{

  using ::__gnu_cxx::lldiv_t;

  using ::__gnu_cxx::_Exit;

  using ::__gnu_cxx::llabs;
  using ::__gnu_cxx::div;
  using ::__gnu_cxx::lldiv;

  using ::__gnu_cxx::atoll;
  using ::__gnu_cxx::strtof;
  using ::__gnu_cxx::strtoll;
  using ::__gnu_cxx::strtoull;
  using ::__gnu_cxx::strtold;
}



}
# 6 "code/glfw_main.cpp" 2
# 1 "/usr/include/fcntl.h" 1 3 4
# 28 "/usr/include/fcntl.h" 3 4
extern "C" {






# 1 "/usr/include/x86_64-linux-gnu/bits/fcntl.h" 1 3 4
# 35 "/usr/include/x86_64-linux-gnu/bits/fcntl.h" 3 4
struct flock
  {
    short int l_type;
    short int l_whence;

    __off_t l_start;
    __off_t l_len;




    __pid_t l_pid;
  };


struct flock64
  {
    short int l_type;
    short int l_whence;
    __off64_t l_start;
    __off64_t l_len;
    __pid_t l_pid;
  };



# 1 "/usr/include/x86_64-linux-gnu/bits/fcntl-linux.h" 1 3 4
# 38 "/usr/include/x86_64-linux-gnu/bits/fcntl-linux.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/struct_iovec.h" 1 3 4
# 23 "/usr/include/x86_64-linux-gnu/bits/types/struct_iovec.h" 3 4
# 1 "/usr/lib/gcc/x86_64-linux-gnu/10/include/stddef.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/types/struct_iovec.h" 2 3 4


struct iovec
  {
    void *iov_base;
    size_t iov_len;
  };
# 39 "/usr/include/x86_64-linux-gnu/bits/fcntl-linux.h" 2 3 4
# 265 "/usr/include/x86_64-linux-gnu/bits/fcntl-linux.h" 3 4
enum __pid_type
  {
    F_OWNER_TID = 0,
    F_OWNER_PID,
    F_OWNER_PGRP,
    F_OWNER_GID = F_OWNER_PGRP
  };


struct f_owner_ex
  {
    enum __pid_type type;
    __pid_t pid;
  };
# 354 "/usr/include/x86_64-linux-gnu/bits/fcntl-linux.h" 3 4
# 1 "/usr/include/linux/falloc.h" 1 3 4
# 355 "/usr/include/x86_64-linux-gnu/bits/fcntl-linux.h" 2 3 4



struct file_handle
{
  unsigned int handle_bytes;
  int handle_type;

  unsigned char f_handle[0];
};
# 393 "/usr/include/x86_64-linux-gnu/bits/fcntl-linux.h" 3 4
extern "C" {




extern __ssize_t readahead (int __fd, __off64_t __offset, size_t __count)
    noexcept (true);






extern int sync_file_range (int __fd, __off64_t __offset, __off64_t __count,
       unsigned int __flags);






extern __ssize_t vmsplice (int __fdout, const struct iovec *__iov,
      size_t __count, unsigned int __flags);





extern __ssize_t splice (int __fdin, __off64_t *__offin, int __fdout,
    __off64_t *__offout, size_t __len,
    unsigned int __flags);





extern __ssize_t tee (int __fdin, int __fdout, size_t __len,
        unsigned int __flags);






extern int fallocate (int __fd, int __mode, __off_t __offset, __off_t __len);
# 448 "/usr/include/x86_64-linux-gnu/bits/fcntl-linux.h" 3 4
extern int fallocate64 (int __fd, int __mode, __off64_t __offset,
   __off64_t __len);




extern int name_to_handle_at (int __dfd, const char *__name,
         struct file_handle *__handle, int *__mnt_id,
         int __flags) noexcept (true);





extern int open_by_handle_at (int __mountdirfd, struct file_handle *__handle,
         int __flags);



}
# 62 "/usr/include/x86_64-linux-gnu/bits/fcntl.h" 2 3 4
# 36 "/usr/include/fcntl.h" 2 3 4
# 78 "/usr/include/fcntl.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/stat.h" 1 3 4
# 25 "/usr/include/x86_64-linux-gnu/bits/stat.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/struct_stat.h" 1 3 4
# 26 "/usr/include/x86_64-linux-gnu/bits/struct_stat.h" 3 4
struct stat
  {



    __dev_t st_dev;




    __ino_t st_ino;







    __nlink_t st_nlink;
    __mode_t st_mode;

    __uid_t st_uid;
    __gid_t st_gid;

    int __pad0;

    __dev_t st_rdev;




    __off_t st_size;



    __blksize_t st_blksize;

    __blkcnt_t st_blocks;
# 74 "/usr/include/x86_64-linux-gnu/bits/struct_stat.h" 3 4
    struct timespec st_atim;
    struct timespec st_mtim;
    struct timespec st_ctim;
# 89 "/usr/include/x86_64-linux-gnu/bits/struct_stat.h" 3 4
    __syscall_slong_t __glibc_reserved[3];
# 99 "/usr/include/x86_64-linux-gnu/bits/struct_stat.h" 3 4
  };



struct stat64
  {



    __dev_t st_dev;

    __ino64_t st_ino;
    __nlink_t st_nlink;
    __mode_t st_mode;






    __uid_t st_uid;
    __gid_t st_gid;

    int __pad0;
    __dev_t st_rdev;
    __off_t st_size;





    __blksize_t st_blksize;
    __blkcnt64_t st_blocks;







    struct timespec st_atim;
    struct timespec st_mtim;
    struct timespec st_ctim;
# 151 "/usr/include/x86_64-linux-gnu/bits/struct_stat.h" 3 4
    __syscall_slong_t __glibc_reserved[3];




  };
# 26 "/usr/include/x86_64-linux-gnu/bits/stat.h" 2 3 4
# 79 "/usr/include/fcntl.h" 2 3 4
# 149 "/usr/include/fcntl.h" 3 4
extern int fcntl (int __fd, int __cmd, ...);
# 158 "/usr/include/fcntl.h" 3 4
extern int fcntl64 (int __fd, int __cmd, ...);
# 181 "/usr/include/fcntl.h" 3 4
extern int open (const char *__file, int __oflag, ...) __attribute__ ((__nonnull__ (1)));
# 191 "/usr/include/fcntl.h" 3 4
extern int open64 (const char *__file, int __oflag, ...) __attribute__ ((__nonnull__ (1)));
# 205 "/usr/include/fcntl.h" 3 4
extern int openat (int __fd, const char *__file, int __oflag, ...)
     __attribute__ ((__nonnull__ (2)));
# 216 "/usr/include/fcntl.h" 3 4
extern int openat64 (int __fd, const char *__file, int __oflag, ...)
     __attribute__ ((__nonnull__ (2)));
# 227 "/usr/include/fcntl.h" 3 4
extern int creat (const char *__file, mode_t __mode) __attribute__ ((__nonnull__ (1)));
# 237 "/usr/include/fcntl.h" 3 4
extern int creat64 (const char *__file, mode_t __mode) __attribute__ ((__nonnull__ (1)));
# 256 "/usr/include/fcntl.h" 3 4
extern int lockf (int __fd, int __cmd, off_t __len);
# 265 "/usr/include/fcntl.h" 3 4
extern int lockf64 (int __fd, int __cmd, off64_t __len);







extern int posix_fadvise (int __fd, off_t __offset, off_t __len,
     int __advise) noexcept (true);
# 285 "/usr/include/fcntl.h" 3 4
extern int posix_fadvise64 (int __fd, off64_t __offset, off64_t __len,
       int __advise) noexcept (true);
# 295 "/usr/include/fcntl.h" 3 4
extern int posix_fallocate (int __fd, off_t __offset, off_t __len);
# 306 "/usr/include/fcntl.h" 3 4
extern int posix_fallocate64 (int __fd, off64_t __offset, off64_t __len);
# 317 "/usr/include/fcntl.h" 3 4
}
# 7 "code/glfw_main.cpp" 2

# 1 "/usr/include/x86_64-linux-gnu/sys/stat.h" 1 3 4
# 99 "/usr/include/x86_64-linux-gnu/sys/stat.h" 3 4
extern "C" {

# 1 "/usr/include/x86_64-linux-gnu/bits/stat.h" 1 3 4
# 102 "/usr/include/x86_64-linux-gnu/sys/stat.h" 2 3 4
# 205 "/usr/include/x86_64-linux-gnu/sys/stat.h" 3 4
extern int stat (const char *__restrict __file,
   struct stat *__restrict __buf) noexcept (true) __attribute__ ((__nonnull__ (1, 2)));



extern int fstat (int __fd, struct stat *__buf) noexcept (true) __attribute__ ((__nonnull__ (2)));
# 240 "/usr/include/x86_64-linux-gnu/sys/stat.h" 3 4
extern int stat64 (const char *__restrict __file,
     struct stat64 *__restrict __buf) noexcept (true) __attribute__ ((__nonnull__ (1, 2)));
extern int fstat64 (int __fd, struct stat64 *__buf) noexcept (true) __attribute__ ((__nonnull__ (2)));
# 264 "/usr/include/x86_64-linux-gnu/sys/stat.h" 3 4
extern int fstatat (int __fd, const char *__restrict __file,
      struct stat *__restrict __buf, int __flag)
     noexcept (true) __attribute__ ((__nonnull__ (2, 3)));
# 291 "/usr/include/x86_64-linux-gnu/sys/stat.h" 3 4
extern int fstatat64 (int __fd, const char *__restrict __file,
        struct stat64 *__restrict __buf, int __flag)
     noexcept (true) __attribute__ ((__nonnull__ (2, 3)));
# 313 "/usr/include/x86_64-linux-gnu/sys/stat.h" 3 4
extern int lstat (const char *__restrict __file,
    struct stat *__restrict __buf) noexcept (true) __attribute__ ((__nonnull__ (1, 2)));
# 338 "/usr/include/x86_64-linux-gnu/sys/stat.h" 3 4
extern int lstat64 (const char *__restrict __file,
      struct stat64 *__restrict __buf)
     noexcept (true) __attribute__ ((__nonnull__ (1, 2)));
# 352 "/usr/include/x86_64-linux-gnu/sys/stat.h" 3 4
extern int chmod (const char *__file, __mode_t __mode)
     noexcept (true) __attribute__ ((__nonnull__ (1)));





extern int lchmod (const char *__file, __mode_t __mode)
     noexcept (true) __attribute__ ((__nonnull__ (1)));




extern int fchmod (int __fd, __mode_t __mode) noexcept (true);





extern int fchmodat (int __fd, const char *__file, __mode_t __mode,
       int __flag)
     noexcept (true) __attribute__ ((__nonnull__ (2))) ;






extern __mode_t umask (__mode_t __mask) noexcept (true);




extern __mode_t getumask (void) noexcept (true);



extern int mkdir (const char *__path, __mode_t __mode)
     noexcept (true) __attribute__ ((__nonnull__ (1)));





extern int mkdirat (int __fd, const char *__path, __mode_t __mode)
     noexcept (true) __attribute__ ((__nonnull__ (2)));






extern int mknod (const char *__path, __mode_t __mode, __dev_t __dev)
     noexcept (true) __attribute__ ((__nonnull__ (1)));





extern int mknodat (int __fd, const char *__path, __mode_t __mode,
      __dev_t __dev) noexcept (true) __attribute__ ((__nonnull__ (2)));





extern int mkfifo (const char *__path, __mode_t __mode)
     noexcept (true) __attribute__ ((__nonnull__ (1)));





extern int mkfifoat (int __fd, const char *__path, __mode_t __mode)
     noexcept (true) __attribute__ ((__nonnull__ (2)));






extern int utimensat (int __fd, const char *__path,
        const struct timespec __times[2],
        int __flags)
     noexcept (true) __attribute__ ((__nonnull__ (2)));
# 452 "/usr/include/x86_64-linux-gnu/sys/stat.h" 3 4
extern int futimens (int __fd, const struct timespec __times[2]) noexcept (true);
# 465 "/usr/include/x86_64-linux-gnu/sys/stat.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/statx.h" 1 3 4
# 31 "/usr/include/x86_64-linux-gnu/bits/statx.h" 3 4
# 1 "/usr/include/linux/stat.h" 1 3 4




# 1 "/usr/include/linux/types.h" 1 3 4




# 1 "/usr/include/x86_64-linux-gnu/asm/types.h" 1 3 4
# 1 "/usr/include/asm-generic/types.h" 1 3 4






# 1 "/usr/include/asm-generic/int-ll64.h" 1 3 4
# 12 "/usr/include/asm-generic/int-ll64.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/asm/bitsperlong.h" 1 3 4
# 11 "/usr/include/x86_64-linux-gnu/asm/bitsperlong.h" 3 4
# 1 "/usr/include/asm-generic/bitsperlong.h" 1 3 4
# 12 "/usr/include/x86_64-linux-gnu/asm/bitsperlong.h" 2 3 4
# 13 "/usr/include/asm-generic/int-ll64.h" 2 3 4







typedef __signed__ char __s8;
typedef unsigned char __u8;

typedef __signed__ short __s16;
typedef unsigned short __u16;

typedef __signed__ int __s32;
typedef unsigned int __u32;


__extension__ typedef __signed__ long long __s64;
__extension__ typedef unsigned long long __u64;
# 8 "/usr/include/asm-generic/types.h" 2 3 4
# 2 "/usr/include/x86_64-linux-gnu/asm/types.h" 2 3 4
# 6 "/usr/include/linux/types.h" 2 3 4



# 1 "/usr/include/linux/posix_types.h" 1 3 4




# 1 "/usr/include/linux/stddef.h" 1 3 4
# 6 "/usr/include/linux/posix_types.h" 2 3 4
# 25 "/usr/include/linux/posix_types.h" 3 4
typedef struct {
 unsigned long fds_bits[1024 / (8 * sizeof(long))];
} __kernel_fd_set;


typedef void (*__kernel_sighandler_t)(int);


typedef int __kernel_key_t;
typedef int __kernel_mqd_t;

# 1 "/usr/include/x86_64-linux-gnu/asm/posix_types.h" 1 3 4






# 1 "/usr/include/x86_64-linux-gnu/asm/posix_types_64.h" 1 3 4
# 11 "/usr/include/x86_64-linux-gnu/asm/posix_types_64.h" 3 4
typedef unsigned short __kernel_old_uid_t;
typedef unsigned short __kernel_old_gid_t;


typedef unsigned long __kernel_old_dev_t;


# 1 "/usr/include/asm-generic/posix_types.h" 1 3 4
# 15 "/usr/include/asm-generic/posix_types.h" 3 4
typedef long __kernel_long_t;
typedef unsigned long __kernel_ulong_t;



typedef __kernel_ulong_t __kernel_ino_t;



typedef unsigned int __kernel_mode_t;



typedef int __kernel_pid_t;



typedef int __kernel_ipc_pid_t;



typedef unsigned int __kernel_uid_t;
typedef unsigned int __kernel_gid_t;



typedef __kernel_long_t __kernel_suseconds_t;



typedef int __kernel_daddr_t;



typedef unsigned int __kernel_uid32_t;
typedef unsigned int __kernel_gid32_t;
# 72 "/usr/include/asm-generic/posix_types.h" 3 4
typedef __kernel_ulong_t __kernel_size_t;
typedef __kernel_long_t __kernel_ssize_t;
typedef __kernel_long_t __kernel_ptrdiff_t;




typedef struct {
 int val[2];
} __kernel_fsid_t;





typedef __kernel_long_t __kernel_off_t;
typedef long long __kernel_loff_t;
typedef __kernel_long_t __kernel_old_time_t;
typedef __kernel_long_t __kernel_time_t;
typedef long long __kernel_time64_t;
typedef __kernel_long_t __kernel_clock_t;
typedef int __kernel_timer_t;
typedef int __kernel_clockid_t;
typedef char * __kernel_caddr_t;
typedef unsigned short __kernel_uid16_t;
typedef unsigned short __kernel_gid16_t;
# 19 "/usr/include/x86_64-linux-gnu/asm/posix_types_64.h" 2 3 4
# 8 "/usr/include/x86_64-linux-gnu/asm/posix_types.h" 2 3 4
# 37 "/usr/include/linux/posix_types.h" 2 3 4
# 10 "/usr/include/linux/types.h" 2 3 4
# 24 "/usr/include/linux/types.h" 3 4
typedef __u16 __le16;
typedef __u16 __be16;
typedef __u32 __le32;
typedef __u32 __be32;
typedef __u64 __le64;
typedef __u64 __be64;

typedef __u16 __sum16;
typedef __u32 __wsum;
# 47 "/usr/include/linux/types.h" 3 4
typedef unsigned __poll_t;
# 6 "/usr/include/linux/stat.h" 2 3 4
# 56 "/usr/include/linux/stat.h" 3 4
struct statx_timestamp {
 __s64 tv_sec;
 __u32 tv_nsec;
 __s32 __reserved;
};
# 99 "/usr/include/linux/stat.h" 3 4
struct statx {

 __u32 stx_mask;
 __u32 stx_blksize;
 __u64 stx_attributes;

 __u32 stx_nlink;
 __u32 stx_uid;
 __u32 stx_gid;
 __u16 stx_mode;
 __u16 __spare0[1];

 __u64 stx_ino;
 __u64 stx_size;
 __u64 stx_blocks;
 __u64 stx_attributes_mask;

 struct statx_timestamp stx_atime;
 struct statx_timestamp stx_btime;
 struct statx_timestamp stx_ctime;
 struct statx_timestamp stx_mtime;

 __u32 stx_rdev_major;
 __u32 stx_rdev_minor;
 __u32 stx_dev_major;
 __u32 stx_dev_minor;

 __u64 stx_mnt_id;
 __u64 __spare2;

 __u64 __spare3[12];

};
# 32 "/usr/include/x86_64-linux-gnu/bits/statx.h" 2 3 4







# 1 "/usr/include/x86_64-linux-gnu/bits/statx-generic.h" 1 3 4
# 25 "/usr/include/x86_64-linux-gnu/bits/statx-generic.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/struct_statx_timestamp.h" 1 3 4
# 26 "/usr/include/x86_64-linux-gnu/bits/statx-generic.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/struct_statx.h" 1 3 4
# 27 "/usr/include/x86_64-linux-gnu/bits/statx-generic.h" 2 3 4
# 57 "/usr/include/x86_64-linux-gnu/bits/statx-generic.h" 3 4
extern "C" {


int statx (int __dirfd, const char *__restrict __path, int __flags,
           unsigned int __mask, struct statx *__restrict __buf)
  noexcept (true) __attribute__ ((__nonnull__ (2, 5)));

}
# 40 "/usr/include/x86_64-linux-gnu/bits/statx.h" 2 3 4
# 466 "/usr/include/x86_64-linux-gnu/sys/stat.h" 2 3 4


}
# 9 "code/glfw_main.cpp" 2
# 1 "/usr/include/unistd.h" 1 3 4
# 27 "/usr/include/unistd.h" 3 4
extern "C" {
# 202 "/usr/include/unistd.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/posix_opt.h" 1 3 4
# 203 "/usr/include/unistd.h" 2 3 4



# 1 "/usr/include/x86_64-linux-gnu/bits/environments.h" 1 3 4
# 22 "/usr/include/x86_64-linux-gnu/bits/environments.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 23 "/usr/include/x86_64-linux-gnu/bits/environments.h" 2 3 4
# 207 "/usr/include/unistd.h" 2 3 4
# 226 "/usr/include/unistd.h" 3 4
# 1 "/usr/lib/gcc/x86_64-linux-gnu/10/include/stddef.h" 1 3 4
# 227 "/usr/include/unistd.h" 2 3 4
# 274 "/usr/include/unistd.h" 3 4
typedef __socklen_t socklen_t;
# 287 "/usr/include/unistd.h" 3 4
extern int access (const char *__name, int __type) noexcept (true) __attribute__ ((__nonnull__ (1)));




extern int euidaccess (const char *__name, int __type)
     noexcept (true) __attribute__ ((__nonnull__ (1)));


extern int eaccess (const char *__name, int __type)
     noexcept (true) __attribute__ ((__nonnull__ (1)));


extern int execveat (int __fd, const char *__path, char *const __argv[],
                     char *const __envp[], int __flags)
    noexcept (true) __attribute__ ((__nonnull__ (2, 3)));






extern int faccessat (int __fd, const char *__file, int __type, int __flag)
     noexcept (true) __attribute__ ((__nonnull__ (2))) ;
# 339 "/usr/include/unistd.h" 3 4
extern __off_t lseek (int __fd, __off_t __offset, int __whence) noexcept (true);
# 350 "/usr/include/unistd.h" 3 4
extern __off64_t lseek64 (int __fd, __off64_t __offset, int __whence)
     noexcept (true);






extern int close (int __fd);




extern void closefrom (int __lowfd) noexcept (true);







extern ssize_t read (int __fd, void *__buf, size_t __nbytes)
    __attribute__ ((__access__ (__write_only__, 2, 3)));





extern ssize_t write (int __fd, const void *__buf, size_t __n)
    __attribute__ ((__access__ (__read_only__, 2, 3)));
# 389 "/usr/include/unistd.h" 3 4
extern ssize_t pread (int __fd, void *__buf, size_t __nbytes,
        __off_t __offset)
    __attribute__ ((__access__ (__write_only__, 2, 3)));






extern ssize_t pwrite (int __fd, const void *__buf, size_t __n,
         __off_t __offset)
    __attribute__ ((__access__ (__read_only__, 2, 3)));
# 422 "/usr/include/unistd.h" 3 4
extern ssize_t pread64 (int __fd, void *__buf, size_t __nbytes,
   __off64_t __offset)
    __attribute__ ((__access__ (__write_only__, 2, 3)));


extern ssize_t pwrite64 (int __fd, const void *__buf, size_t __n,
    __off64_t __offset)
    __attribute__ ((__access__ (__read_only__, 2, 3)));







extern int pipe (int __pipedes[2]) noexcept (true) ;




extern int pipe2 (int __pipedes[2], int __flags) noexcept (true) ;
# 452 "/usr/include/unistd.h" 3 4
extern unsigned int alarm (unsigned int __seconds) noexcept (true);
# 464 "/usr/include/unistd.h" 3 4
extern unsigned int sleep (unsigned int __seconds);







extern __useconds_t ualarm (__useconds_t __value, __useconds_t __interval)
     noexcept (true);






extern int usleep (__useconds_t __useconds);
# 489 "/usr/include/unistd.h" 3 4
extern int pause (void);



extern int chown (const char *__file, __uid_t __owner, __gid_t __group)
     noexcept (true) __attribute__ ((__nonnull__ (1))) ;



extern int fchown (int __fd, __uid_t __owner, __gid_t __group) noexcept (true) ;




extern int lchown (const char *__file, __uid_t __owner, __gid_t __group)
     noexcept (true) __attribute__ ((__nonnull__ (1))) ;






extern int fchownat (int __fd, const char *__file, __uid_t __owner,
       __gid_t __group, int __flag)
     noexcept (true) __attribute__ ((__nonnull__ (2))) ;



extern int chdir (const char *__path) noexcept (true) __attribute__ ((__nonnull__ (1))) ;



extern int fchdir (int __fd) noexcept (true) ;
# 531 "/usr/include/unistd.h" 3 4
extern char *getcwd (char *__buf, size_t __size) noexcept (true) ;





extern char *get_current_dir_name (void) noexcept (true);







extern char *getwd (char *__buf)
     noexcept (true) __attribute__ ((__nonnull__ (1))) __attribute__ ((__deprecated__))
    __attribute__ ((__access__ (__write_only__, 1)));




extern int dup (int __fd) noexcept (true) ;


extern int dup2 (int __fd, int __fd2) noexcept (true);




extern int dup3 (int __fd, int __fd2, int __flags) noexcept (true);



extern char **__environ;

extern char **environ;





extern int execve (const char *__path, char *const __argv[],
     char *const __envp[]) noexcept (true) __attribute__ ((__nonnull__ (1, 2)));




extern int fexecve (int __fd, char *const __argv[], char *const __envp[])
     noexcept (true) __attribute__ ((__nonnull__ (2)));




extern int execv (const char *__path, char *const __argv[])
     noexcept (true) __attribute__ ((__nonnull__ (1, 2)));



extern int execle (const char *__path, const char *__arg, ...)
     noexcept (true) __attribute__ ((__nonnull__ (1, 2)));



extern int execl (const char *__path, const char *__arg, ...)
     noexcept (true) __attribute__ ((__nonnull__ (1, 2)));



extern int execvp (const char *__file, char *const __argv[])
     noexcept (true) __attribute__ ((__nonnull__ (1, 2)));




extern int execlp (const char *__file, const char *__arg, ...)
     noexcept (true) __attribute__ ((__nonnull__ (1, 2)));




extern int execvpe (const char *__file, char *const __argv[],
      char *const __envp[])
     noexcept (true) __attribute__ ((__nonnull__ (1, 2)));





extern int nice (int __inc) noexcept (true) ;




extern void _exit (int __status) __attribute__ ((__noreturn__));





# 1 "/usr/include/x86_64-linux-gnu/bits/confname.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/confname.h" 3 4
enum
  {
    _PC_LINK_MAX,

    _PC_MAX_CANON,

    _PC_MAX_INPUT,

    _PC_NAME_MAX,

    _PC_PATH_MAX,

    _PC_PIPE_BUF,

    _PC_CHOWN_RESTRICTED,

    _PC_NO_TRUNC,

    _PC_VDISABLE,

    _PC_SYNC_IO,

    _PC_ASYNC_IO,

    _PC_PRIO_IO,

    _PC_SOCK_MAXBUF,

    _PC_FILESIZEBITS,

    _PC_REC_INCR_XFER_SIZE,

    _PC_REC_MAX_XFER_SIZE,

    _PC_REC_MIN_XFER_SIZE,

    _PC_REC_XFER_ALIGN,

    _PC_ALLOC_SIZE_MIN,

    _PC_SYMLINK_MAX,

    _PC_2_SYMLINKS

  };


enum
  {
    _SC_ARG_MAX,

    _SC_CHILD_MAX,

    _SC_CLK_TCK,

    _SC_NGROUPS_MAX,

    _SC_OPEN_MAX,

    _SC_STREAM_MAX,

    _SC_TZNAME_MAX,

    _SC_JOB_CONTROL,

    _SC_SAVED_IDS,

    _SC_REALTIME_SIGNALS,

    _SC_PRIORITY_SCHEDULING,

    _SC_TIMERS,

    _SC_ASYNCHRONOUS_IO,

    _SC_PRIORITIZED_IO,

    _SC_SYNCHRONIZED_IO,

    _SC_FSYNC,

    _SC_MAPPED_FILES,

    _SC_MEMLOCK,

    _SC_MEMLOCK_RANGE,

    _SC_MEMORY_PROTECTION,

    _SC_MESSAGE_PASSING,

    _SC_SEMAPHORES,

    _SC_SHARED_MEMORY_OBJECTS,

    _SC_AIO_LISTIO_MAX,

    _SC_AIO_MAX,

    _SC_AIO_PRIO_DELTA_MAX,

    _SC_DELAYTIMER_MAX,

    _SC_MQ_OPEN_MAX,

    _SC_MQ_PRIO_MAX,

    _SC_VERSION,

    _SC_PAGESIZE,


    _SC_RTSIG_MAX,

    _SC_SEM_NSEMS_MAX,

    _SC_SEM_VALUE_MAX,

    _SC_SIGQUEUE_MAX,

    _SC_TIMER_MAX,




    _SC_BC_BASE_MAX,

    _SC_BC_DIM_MAX,

    _SC_BC_SCALE_MAX,

    _SC_BC_STRING_MAX,

    _SC_COLL_WEIGHTS_MAX,

    _SC_EQUIV_CLASS_MAX,

    _SC_EXPR_NEST_MAX,

    _SC_LINE_MAX,

    _SC_RE_DUP_MAX,

    _SC_CHARCLASS_NAME_MAX,


    _SC_2_VERSION,

    _SC_2_C_BIND,

    _SC_2_C_DEV,

    _SC_2_FORT_DEV,

    _SC_2_FORT_RUN,

    _SC_2_SW_DEV,

    _SC_2_LOCALEDEF,


    _SC_PII,

    _SC_PII_XTI,

    _SC_PII_SOCKET,

    _SC_PII_INTERNET,

    _SC_PII_OSI,

    _SC_POLL,

    _SC_SELECT,

    _SC_UIO_MAXIOV,

    _SC_IOV_MAX = _SC_UIO_MAXIOV,

    _SC_PII_INTERNET_STREAM,

    _SC_PII_INTERNET_DGRAM,

    _SC_PII_OSI_COTS,

    _SC_PII_OSI_CLTS,

    _SC_PII_OSI_M,

    _SC_T_IOV_MAX,



    _SC_THREADS,

    _SC_THREAD_SAFE_FUNCTIONS,

    _SC_GETGR_R_SIZE_MAX,

    _SC_GETPW_R_SIZE_MAX,

    _SC_LOGIN_NAME_MAX,

    _SC_TTY_NAME_MAX,

    _SC_THREAD_DESTRUCTOR_ITERATIONS,

    _SC_THREAD_KEYS_MAX,

    _SC_THREAD_STACK_MIN,

    _SC_THREAD_THREADS_MAX,

    _SC_THREAD_ATTR_STACKADDR,

    _SC_THREAD_ATTR_STACKSIZE,

    _SC_THREAD_PRIORITY_SCHEDULING,

    _SC_THREAD_PRIO_INHERIT,

    _SC_THREAD_PRIO_PROTECT,

    _SC_THREAD_PROCESS_SHARED,


    _SC_NPROCESSORS_CONF,

    _SC_NPROCESSORS_ONLN,

    _SC_PHYS_PAGES,

    _SC_AVPHYS_PAGES,

    _SC_ATEXIT_MAX,

    _SC_PASS_MAX,


    _SC_XOPEN_VERSION,

    _SC_XOPEN_XCU_VERSION,

    _SC_XOPEN_UNIX,

    _SC_XOPEN_CRYPT,

    _SC_XOPEN_ENH_I18N,

    _SC_XOPEN_SHM,


    _SC_2_CHAR_TERM,

    _SC_2_C_VERSION,

    _SC_2_UPE,


    _SC_XOPEN_XPG2,

    _SC_XOPEN_XPG3,

    _SC_XOPEN_XPG4,


    _SC_CHAR_BIT,

    _SC_CHAR_MAX,

    _SC_CHAR_MIN,

    _SC_INT_MAX,

    _SC_INT_MIN,

    _SC_LONG_BIT,

    _SC_WORD_BIT,

    _SC_MB_LEN_MAX,

    _SC_NZERO,

    _SC_SSIZE_MAX,

    _SC_SCHAR_MAX,

    _SC_SCHAR_MIN,

    _SC_SHRT_MAX,

    _SC_SHRT_MIN,

    _SC_UCHAR_MAX,

    _SC_UINT_MAX,

    _SC_ULONG_MAX,

    _SC_USHRT_MAX,


    _SC_NL_ARGMAX,

    _SC_NL_LANGMAX,

    _SC_NL_MSGMAX,

    _SC_NL_NMAX,

    _SC_NL_SETMAX,

    _SC_NL_TEXTMAX,


    _SC_XBS5_ILP32_OFF32,

    _SC_XBS5_ILP32_OFFBIG,

    _SC_XBS5_LP64_OFF64,

    _SC_XBS5_LPBIG_OFFBIG,


    _SC_XOPEN_LEGACY,

    _SC_XOPEN_REALTIME,

    _SC_XOPEN_REALTIME_THREADS,


    _SC_ADVISORY_INFO,

    _SC_BARRIERS,

    _SC_BASE,

    _SC_C_LANG_SUPPORT,

    _SC_C_LANG_SUPPORT_R,

    _SC_CLOCK_SELECTION,

    _SC_CPUTIME,

    _SC_THREAD_CPUTIME,

    _SC_DEVICE_IO,

    _SC_DEVICE_SPECIFIC,

    _SC_DEVICE_SPECIFIC_R,

    _SC_FD_MGMT,

    _SC_FIFO,

    _SC_PIPE,

    _SC_FILE_ATTRIBUTES,

    _SC_FILE_LOCKING,

    _SC_FILE_SYSTEM,

    _SC_MONOTONIC_CLOCK,

    _SC_MULTI_PROCESS,

    _SC_SINGLE_PROCESS,

    _SC_NETWORKING,

    _SC_READER_WRITER_LOCKS,

    _SC_SPIN_LOCKS,

    _SC_REGEXP,

    _SC_REGEX_VERSION,

    _SC_SHELL,

    _SC_SIGNALS,

    _SC_SPAWN,

    _SC_SPORADIC_SERVER,

    _SC_THREAD_SPORADIC_SERVER,

    _SC_SYSTEM_DATABASE,

    _SC_SYSTEM_DATABASE_R,

    _SC_TIMEOUTS,

    _SC_TYPED_MEMORY_OBJECTS,

    _SC_USER_GROUPS,

    _SC_USER_GROUPS_R,

    _SC_2_PBS,

    _SC_2_PBS_ACCOUNTING,

    _SC_2_PBS_LOCATE,

    _SC_2_PBS_MESSAGE,

    _SC_2_PBS_TRACK,

    _SC_SYMLOOP_MAX,

    _SC_STREAMS,

    _SC_2_PBS_CHECKPOINT,


    _SC_V6_ILP32_OFF32,

    _SC_V6_ILP32_OFFBIG,

    _SC_V6_LP64_OFF64,

    _SC_V6_LPBIG_OFFBIG,


    _SC_HOST_NAME_MAX,

    _SC_TRACE,

    _SC_TRACE_EVENT_FILTER,

    _SC_TRACE_INHERIT,

    _SC_TRACE_LOG,


    _SC_LEVEL1_ICACHE_SIZE,

    _SC_LEVEL1_ICACHE_ASSOC,

    _SC_LEVEL1_ICACHE_LINESIZE,

    _SC_LEVEL1_DCACHE_SIZE,

    _SC_LEVEL1_DCACHE_ASSOC,

    _SC_LEVEL1_DCACHE_LINESIZE,

    _SC_LEVEL2_CACHE_SIZE,

    _SC_LEVEL2_CACHE_ASSOC,

    _SC_LEVEL2_CACHE_LINESIZE,

    _SC_LEVEL3_CACHE_SIZE,

    _SC_LEVEL3_CACHE_ASSOC,

    _SC_LEVEL3_CACHE_LINESIZE,

    _SC_LEVEL4_CACHE_SIZE,

    _SC_LEVEL4_CACHE_ASSOC,

    _SC_LEVEL4_CACHE_LINESIZE,



    _SC_IPV6 = _SC_LEVEL1_ICACHE_SIZE + 50,

    _SC_RAW_SOCKETS,


    _SC_V7_ILP32_OFF32,

    _SC_V7_ILP32_OFFBIG,

    _SC_V7_LP64_OFF64,

    _SC_V7_LPBIG_OFFBIG,


    _SC_SS_REPL_MAX,


    _SC_TRACE_EVENT_NAME_MAX,

    _SC_TRACE_NAME_MAX,

    _SC_TRACE_SYS_MAX,

    _SC_TRACE_USER_EVENT_MAX,


    _SC_XOPEN_STREAMS,


    _SC_THREAD_ROBUST_PRIO_INHERIT,

    _SC_THREAD_ROBUST_PRIO_PROTECT,


    _SC_MINSIGSTKSZ,


    _SC_SIGSTKSZ

  };


enum
  {
    _CS_PATH,


    _CS_V6_WIDTH_RESTRICTED_ENVS,



    _CS_GNU_LIBC_VERSION,

    _CS_GNU_LIBPTHREAD_VERSION,


    _CS_V5_WIDTH_RESTRICTED_ENVS,



    _CS_V7_WIDTH_RESTRICTED_ENVS,



    _CS_LFS_CFLAGS = 1000,

    _CS_LFS_LDFLAGS,

    _CS_LFS_LIBS,

    _CS_LFS_LINTFLAGS,

    _CS_LFS64_CFLAGS,

    _CS_LFS64_LDFLAGS,

    _CS_LFS64_LIBS,

    _CS_LFS64_LINTFLAGS,


    _CS_XBS5_ILP32_OFF32_CFLAGS = 1100,

    _CS_XBS5_ILP32_OFF32_LDFLAGS,

    _CS_XBS5_ILP32_OFF32_LIBS,

    _CS_XBS5_ILP32_OFF32_LINTFLAGS,

    _CS_XBS5_ILP32_OFFBIG_CFLAGS,

    _CS_XBS5_ILP32_OFFBIG_LDFLAGS,

    _CS_XBS5_ILP32_OFFBIG_LIBS,

    _CS_XBS5_ILP32_OFFBIG_LINTFLAGS,

    _CS_XBS5_LP64_OFF64_CFLAGS,

    _CS_XBS5_LP64_OFF64_LDFLAGS,

    _CS_XBS5_LP64_OFF64_LIBS,

    _CS_XBS5_LP64_OFF64_LINTFLAGS,

    _CS_XBS5_LPBIG_OFFBIG_CFLAGS,

    _CS_XBS5_LPBIG_OFFBIG_LDFLAGS,

    _CS_XBS5_LPBIG_OFFBIG_LIBS,

    _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS,


    _CS_POSIX_V6_ILP32_OFF32_CFLAGS,

    _CS_POSIX_V6_ILP32_OFF32_LDFLAGS,

    _CS_POSIX_V6_ILP32_OFF32_LIBS,

    _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS,

    _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS,

    _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS,

    _CS_POSIX_V6_ILP32_OFFBIG_LIBS,

    _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS,

    _CS_POSIX_V6_LP64_OFF64_CFLAGS,

    _CS_POSIX_V6_LP64_OFF64_LDFLAGS,

    _CS_POSIX_V6_LP64_OFF64_LIBS,

    _CS_POSIX_V6_LP64_OFF64_LINTFLAGS,

    _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS,

    _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS,

    _CS_POSIX_V6_LPBIG_OFFBIG_LIBS,

    _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS,


    _CS_POSIX_V7_ILP32_OFF32_CFLAGS,

    _CS_POSIX_V7_ILP32_OFF32_LDFLAGS,

    _CS_POSIX_V7_ILP32_OFF32_LIBS,

    _CS_POSIX_V7_ILP32_OFF32_LINTFLAGS,

    _CS_POSIX_V7_ILP32_OFFBIG_CFLAGS,

    _CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS,

    _CS_POSIX_V7_ILP32_OFFBIG_LIBS,

    _CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS,

    _CS_POSIX_V7_LP64_OFF64_CFLAGS,

    _CS_POSIX_V7_LP64_OFF64_LDFLAGS,

    _CS_POSIX_V7_LP64_OFF64_LIBS,

    _CS_POSIX_V7_LP64_OFF64_LINTFLAGS,

    _CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS,

    _CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS,

    _CS_POSIX_V7_LPBIG_OFFBIG_LIBS,

    _CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS,


    _CS_V6_ENV,

    _CS_V7_ENV

  };
# 631 "/usr/include/unistd.h" 2 3 4


extern long int pathconf (const char *__path, int __name)
     noexcept (true) __attribute__ ((__nonnull__ (1)));


extern long int fpathconf (int __fd, int __name) noexcept (true);


extern long int sysconf (int __name) noexcept (true);



extern size_t confstr (int __name, char *__buf, size_t __len) noexcept (true)
    __attribute__ ((__access__ (__write_only__, 2, 3)));




extern __pid_t getpid (void) noexcept (true);


extern __pid_t getppid (void) noexcept (true);


extern __pid_t getpgrp (void) noexcept (true);


extern __pid_t __getpgid (__pid_t __pid) noexcept (true);

extern __pid_t getpgid (__pid_t __pid) noexcept (true);






extern int setpgid (__pid_t __pid, __pid_t __pgid) noexcept (true);
# 682 "/usr/include/unistd.h" 3 4
extern int setpgrp (void) noexcept (true);






extern __pid_t setsid (void) noexcept (true);



extern __pid_t getsid (__pid_t __pid) noexcept (true);



extern __uid_t getuid (void) noexcept (true);


extern __uid_t geteuid (void) noexcept (true);


extern __gid_t getgid (void) noexcept (true);


extern __gid_t getegid (void) noexcept (true);




extern int getgroups (int __size, __gid_t __list[]) noexcept (true)
    __attribute__ ((__access__ (__write_only__, 2, 1)));


extern int group_member (__gid_t __gid) noexcept (true);






extern int setuid (__uid_t __uid) noexcept (true) ;




extern int setreuid (__uid_t __ruid, __uid_t __euid) noexcept (true) ;




extern int seteuid (__uid_t __uid) noexcept (true) ;






extern int setgid (__gid_t __gid) noexcept (true) ;




extern int setregid (__gid_t __rgid, __gid_t __egid) noexcept (true) ;




extern int setegid (__gid_t __gid) noexcept (true) ;





extern int getresuid (__uid_t *__ruid, __uid_t *__euid, __uid_t *__suid)
     noexcept (true);



extern int getresgid (__gid_t *__rgid, __gid_t *__egid, __gid_t *__sgid)
     noexcept (true);



extern int setresuid (__uid_t __ruid, __uid_t __euid, __uid_t __suid)
     noexcept (true) ;



extern int setresgid (__gid_t __rgid, __gid_t __egid, __gid_t __sgid)
     noexcept (true) ;






extern __pid_t fork (void) noexcept (true);







extern __pid_t vfork (void) noexcept (true);






extern __pid_t _Fork (void) noexcept (true);





extern char *ttyname (int __fd) noexcept (true);



extern int ttyname_r (int __fd, char *__buf, size_t __buflen)
     noexcept (true) __attribute__ ((__nonnull__ (2)))
     __attribute__ ((__access__ (__write_only__, 2, 3)));



extern int isatty (int __fd) noexcept (true);




extern int ttyslot (void) noexcept (true);




extern int link (const char *__from, const char *__to)
     noexcept (true) __attribute__ ((__nonnull__ (1, 2))) ;




extern int linkat (int __fromfd, const char *__from, int __tofd,
     const char *__to, int __flags)
     noexcept (true) __attribute__ ((__nonnull__ (2, 4))) ;




extern int symlink (const char *__from, const char *__to)
     noexcept (true) __attribute__ ((__nonnull__ (1, 2))) ;




extern ssize_t readlink (const char *__restrict __path,
    char *__restrict __buf, size_t __len)
     noexcept (true) __attribute__ ((__nonnull__ (1, 2)))
     __attribute__ ((__access__ (__write_only__, 2, 3)));





extern int symlinkat (const char *__from, int __tofd,
        const char *__to) noexcept (true) __attribute__ ((__nonnull__ (1, 3))) ;


extern ssize_t readlinkat (int __fd, const char *__restrict __path,
      char *__restrict __buf, size_t __len)
     noexcept (true) __attribute__ ((__nonnull__ (2, 3)))
     __attribute__ ((__access__ (__write_only__, 3, 4)));



extern int unlink (const char *__name) noexcept (true) __attribute__ ((__nonnull__ (1)));



extern int unlinkat (int __fd, const char *__name, int __flag)
     noexcept (true) __attribute__ ((__nonnull__ (2)));



extern int rmdir (const char *__path) noexcept (true) __attribute__ ((__nonnull__ (1)));



extern __pid_t tcgetpgrp (int __fd) noexcept (true);


extern int tcsetpgrp (int __fd, __pid_t __pgrp_id) noexcept (true);






extern char *getlogin (void);







extern int getlogin_r (char *__name, size_t __name_len) __attribute__ ((__nonnull__ (1)))
    __attribute__ ((__access__ (__write_only__, 1, 2)));




extern int setlogin (const char *__name) noexcept (true) __attribute__ ((__nonnull__ (1)));







# 1 "/usr/include/x86_64-linux-gnu/bits/getopt_posix.h" 1 3 4
# 27 "/usr/include/x86_64-linux-gnu/bits/getopt_posix.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/getopt_core.h" 1 3 4
# 28 "/usr/include/x86_64-linux-gnu/bits/getopt_core.h" 3 4
extern "C" {







extern char *optarg;
# 50 "/usr/include/x86_64-linux-gnu/bits/getopt_core.h" 3 4
extern int optind;




extern int opterr;



extern int optopt;
# 91 "/usr/include/x86_64-linux-gnu/bits/getopt_core.h" 3 4
extern int getopt (int ___argc, char *const *___argv, const char *__shortopts)
       noexcept (true) __attribute__ ((__nonnull__ (2, 3)));

}
# 28 "/usr/include/x86_64-linux-gnu/bits/getopt_posix.h" 2 3 4

extern "C" {
# 49 "/usr/include/x86_64-linux-gnu/bits/getopt_posix.h" 3 4
}
# 904 "/usr/include/unistd.h" 2 3 4







extern int gethostname (char *__name, size_t __len) noexcept (true) __attribute__ ((__nonnull__ (1)))
    __attribute__ ((__access__ (__write_only__, 1, 2)));






extern int sethostname (const char *__name, size_t __len)
     noexcept (true) __attribute__ ((__nonnull__ (1))) __attribute__ ((__access__ (__read_only__, 1, 2)));



extern int sethostid (long int __id) noexcept (true) ;





extern int getdomainname (char *__name, size_t __len)
     noexcept (true) __attribute__ ((__nonnull__ (1)))
     __attribute__ ((__access__ (__write_only__, 1, 2)));
extern int setdomainname (const char *__name, size_t __len)
     noexcept (true) __attribute__ ((__nonnull__ (1))) __attribute__ ((__access__ (__read_only__, 1, 2)));




extern int vhangup (void) noexcept (true);


extern int revoke (const char *__file) noexcept (true) __attribute__ ((__nonnull__ (1))) ;







extern int profil (unsigned short int *__sample_buffer, size_t __size,
     size_t __offset, unsigned int __scale)
     noexcept (true) __attribute__ ((__nonnull__ (1)));





extern int acct (const char *__name) noexcept (true);



extern char *getusershell (void) noexcept (true);
extern void endusershell (void) noexcept (true);
extern void setusershell (void) noexcept (true);





extern int daemon (int __nochdir, int __noclose) noexcept (true) ;






extern int chroot (const char *__path) noexcept (true) __attribute__ ((__nonnull__ (1))) ;



extern char *getpass (const char *__prompt) __attribute__ ((__nonnull__ (1)));







extern int fsync (int __fd);





extern int syncfs (int __fd) noexcept (true);






extern long int gethostid (void);


extern void sync (void) noexcept (true);





extern int getpagesize (void) noexcept (true) __attribute__ ((__const__));




extern int getdtablesize (void) noexcept (true);
# 1026 "/usr/include/unistd.h" 3 4
extern int truncate (const char *__file, __off_t __length)
     noexcept (true) __attribute__ ((__nonnull__ (1))) ;
# 1038 "/usr/include/unistd.h" 3 4
extern int truncate64 (const char *__file, __off64_t __length)
     noexcept (true) __attribute__ ((__nonnull__ (1))) ;
# 1049 "/usr/include/unistd.h" 3 4
extern int ftruncate (int __fd, __off_t __length) noexcept (true) ;
# 1059 "/usr/include/unistd.h" 3 4
extern int ftruncate64 (int __fd, __off64_t __length) noexcept (true) ;
# 1070 "/usr/include/unistd.h" 3 4
extern int brk (void *__addr) noexcept (true) ;





extern void *sbrk (intptr_t __delta) noexcept (true);
# 1091 "/usr/include/unistd.h" 3 4
extern long int syscall (long int __sysno, ...) noexcept (true);
# 1142 "/usr/include/unistd.h" 3 4
ssize_t copy_file_range (int __infd, __off64_t *__pinoff,
    int __outfd, __off64_t *__poutoff,
    size_t __length, unsigned int __flags);





extern int fdatasync (int __fildes);
# 1159 "/usr/include/unistd.h" 3 4
extern char *crypt (const char *__key, const char *__salt)
     noexcept (true) __attribute__ ((__nonnull__ (1, 2)));







extern void swab (const void *__restrict __from, void *__restrict __to,
    ssize_t __n) noexcept (true) __attribute__ ((__nonnull__ (1, 2)))
    __attribute__ ((__access__ (__read_only__, 1, 3)))
    __attribute__ ((__access__ (__write_only__, 2, 3)));
# 1198 "/usr/include/unistd.h" 3 4
int getentropy (void *__buffer, size_t __length)
    __attribute__ ((__access__ (__write_only__, 1, 2)));
# 1208 "/usr/include/unistd.h" 3 4
extern int close_range (unsigned int __fd, unsigned int __max_fd,
   int __flags) noexcept (true);
# 1218 "/usr/include/unistd.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/unistd_ext.h" 1 3 4
# 34 "/usr/include/x86_64-linux-gnu/bits/unistd_ext.h" 3 4
extern __pid_t gettid (void) noexcept (true);



# 1 "/usr/include/linux/close_range.h" 1 3 4
# 39 "/usr/include/x86_64-linux-gnu/bits/unistd_ext.h" 2 3 4
# 1219 "/usr/include/unistd.h" 2 3 4

}
# 10 "code/glfw_main.cpp" 2
# 1 "include/glad.c" 1
# 22 "include/glad.c"
# 1 "/usr/include/stdio.h" 1 3 4
# 27 "/usr/include/stdio.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/libc-header-start.h" 1 3 4
# 28 "/usr/include/stdio.h" 2 3 4

extern "C" {



# 1 "/usr/lib/gcc/x86_64-linux-gnu/10/include/stddef.h" 1 3 4
# 34 "/usr/include/stdio.h" 2 3 4


# 1 "/usr/lib/gcc/x86_64-linux-gnu/10/include/stdarg.h" 1 3 4
# 40 "/usr/lib/gcc/x86_64-linux-gnu/10/include/stdarg.h" 3 4
typedef __builtin_va_list __gnuc_va_list;
# 37 "/usr/include/stdio.h" 2 3 4


# 1 "/usr/include/x86_64-linux-gnu/bits/types/__fpos_t.h" 1 3 4




# 1 "/usr/include/x86_64-linux-gnu/bits/types/__mbstate_t.h" 1 3 4
# 13 "/usr/include/x86_64-linux-gnu/bits/types/__mbstate_t.h" 3 4
typedef struct
{
  int __count;
  union
  {
    unsigned int __wch;
    char __wchb[4];
  } __value;
} __mbstate_t;
# 6 "/usr/include/x86_64-linux-gnu/bits/types/__fpos_t.h" 2 3 4




typedef struct _G_fpos_t
{
  __off_t __pos;
  __mbstate_t __state;
} __fpos_t;
# 40 "/usr/include/stdio.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/__fpos64_t.h" 1 3 4
# 10 "/usr/include/x86_64-linux-gnu/bits/types/__fpos64_t.h" 3 4
typedef struct _G_fpos64_t
{
  __off64_t __pos;
  __mbstate_t __state;
} __fpos64_t;
# 41 "/usr/include/stdio.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/__FILE.h" 1 3 4



struct _IO_FILE;
typedef struct _IO_FILE __FILE;
# 42 "/usr/include/stdio.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/FILE.h" 1 3 4



struct _IO_FILE;


typedef struct _IO_FILE FILE;
# 43 "/usr/include/stdio.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/struct_FILE.h" 1 3 4
# 35 "/usr/include/x86_64-linux-gnu/bits/types/struct_FILE.h" 3 4
struct _IO_FILE;
struct _IO_marker;
struct _IO_codecvt;
struct _IO_wide_data;




typedef void _IO_lock_t;





struct _IO_FILE
{
  int _flags;


  char *_IO_read_ptr;
  char *_IO_read_end;
  char *_IO_read_base;
  char *_IO_write_base;
  char *_IO_write_ptr;
  char *_IO_write_end;
  char *_IO_buf_base;
  char *_IO_buf_end;


  char *_IO_save_base;
  char *_IO_backup_base;
  char *_IO_save_end;

  struct _IO_marker *_markers;

  struct _IO_FILE *_chain;

  int _fileno;
  int _flags2;
  __off_t _old_offset;


  unsigned short _cur_column;
  signed char _vtable_offset;
  char _shortbuf[1];

  _IO_lock_t *_lock;







  __off64_t _offset;

  struct _IO_codecvt *_codecvt;
  struct _IO_wide_data *_wide_data;
  struct _IO_FILE *_freeres_list;
  void *_freeres_buf;
  size_t __pad5;
  int _mode;

  char _unused2[15 * sizeof (int) - 4 * sizeof (void *) - sizeof (size_t)];
};
# 44 "/usr/include/stdio.h" 2 3 4


# 1 "/usr/include/x86_64-linux-gnu/bits/types/cookie_io_functions_t.h" 1 3 4
# 27 "/usr/include/x86_64-linux-gnu/bits/types/cookie_io_functions_t.h" 3 4
typedef __ssize_t cookie_read_function_t (void *__cookie, char *__buf,
                                          size_t __nbytes);







typedef __ssize_t cookie_write_function_t (void *__cookie, const char *__buf,
                                           size_t __nbytes);







typedef int cookie_seek_function_t (void *__cookie, __off64_t *__pos, int __w);


typedef int cookie_close_function_t (void *__cookie);






typedef struct _IO_cookie_io_functions_t
{
  cookie_read_function_t *read;
  cookie_write_function_t *write;
  cookie_seek_function_t *seek;
  cookie_close_function_t *close;
} cookie_io_functions_t;
# 47 "/usr/include/stdio.h" 2 3 4





typedef __gnuc_va_list va_list;
# 84 "/usr/include/stdio.h" 3 4
typedef __fpos_t fpos_t;




typedef __fpos64_t fpos64_t;
# 133 "/usr/include/stdio.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/stdio_lim.h" 1 3 4
# 134 "/usr/include/stdio.h" 2 3 4
# 143 "/usr/include/stdio.h" 3 4
extern FILE *stdin;
extern FILE *stdout;
extern FILE *stderr;






extern int remove (const char *__filename) noexcept (true);

extern int rename (const char *__old, const char *__new) noexcept (true);



extern int renameat (int __oldfd, const char *__old, int __newfd,
       const char *__new) noexcept (true);
# 170 "/usr/include/stdio.h" 3 4
extern int renameat2 (int __oldfd, const char *__old, int __newfd,
        const char *__new, unsigned int __flags) noexcept (true);






extern int fclose (FILE *__stream);
# 188 "/usr/include/stdio.h" 3 4
extern FILE *tmpfile (void)
  __attribute__ ((__malloc__)) ;
# 200 "/usr/include/stdio.h" 3 4
extern FILE *tmpfile64 (void)
   __attribute__ ((__malloc__)) ;



extern char *tmpnam (char[20]) noexcept (true) ;




extern char *tmpnam_r (char __s[20]) noexcept (true) ;
# 222 "/usr/include/stdio.h" 3 4
extern char *tempnam (const char *__dir, const char *__pfx)
   noexcept (true) __attribute__ ((__malloc__)) ;






extern int fflush (FILE *__stream);
# 239 "/usr/include/stdio.h" 3 4
extern int fflush_unlocked (FILE *__stream);
# 249 "/usr/include/stdio.h" 3 4
extern int fcloseall (void);
# 258 "/usr/include/stdio.h" 3 4
extern FILE *fopen (const char *__restrict __filename,
      const char *__restrict __modes)
  __attribute__ ((__malloc__)) ;




extern FILE *freopen (const char *__restrict __filename,
        const char *__restrict __modes,
        FILE *__restrict __stream) ;
# 283 "/usr/include/stdio.h" 3 4
extern FILE *fopen64 (const char *__restrict __filename,
        const char *__restrict __modes)
  __attribute__ ((__malloc__)) ;
extern FILE *freopen64 (const char *__restrict __filename,
   const char *__restrict __modes,
   FILE *__restrict __stream) ;




extern FILE *fdopen (int __fd, const char *__modes) noexcept (true)
  __attribute__ ((__malloc__)) ;





extern FILE *fopencookie (void *__restrict __magic_cookie,
     const char *__restrict __modes,
     cookie_io_functions_t __io_funcs) noexcept (true)
  __attribute__ ((__malloc__)) ;




extern FILE *fmemopen (void *__s, size_t __len, const char *__modes)
  noexcept (true) __attribute__ ((__malloc__)) ;




extern FILE *open_memstream (char **__bufloc, size_t *__sizeloc) noexcept (true)
  __attribute__ ((__malloc__)) ;
# 328 "/usr/include/stdio.h" 3 4
extern void setbuf (FILE *__restrict __stream, char *__restrict __buf) noexcept (true);



extern int setvbuf (FILE *__restrict __stream, char *__restrict __buf,
      int __modes, size_t __n) noexcept (true);




extern void setbuffer (FILE *__restrict __stream, char *__restrict __buf,
         size_t __size) noexcept (true);


extern void setlinebuf (FILE *__stream) noexcept (true);







extern int fprintf (FILE *__restrict __stream,
      const char *__restrict __format, ...);




extern int printf (const char *__restrict __format, ...);

extern int sprintf (char *__restrict __s,
      const char *__restrict __format, ...) noexcept (true);





extern int vfprintf (FILE *__restrict __s, const char *__restrict __format,
       __gnuc_va_list __arg);




extern int vprintf (const char *__restrict __format, __gnuc_va_list __arg);

extern int vsprintf (char *__restrict __s, const char *__restrict __format,
       __gnuc_va_list __arg) noexcept (true);



extern int snprintf (char *__restrict __s, size_t __maxlen,
       const char *__restrict __format, ...)
     noexcept (true) __attribute__ ((__format__ (__printf__, 3, 4)));

extern int vsnprintf (char *__restrict __s, size_t __maxlen,
        const char *__restrict __format, __gnuc_va_list __arg)
     noexcept (true) __attribute__ ((__format__ (__printf__, 3, 0)));





extern int vasprintf (char **__restrict __ptr, const char *__restrict __f,
        __gnuc_va_list __arg)
     noexcept (true) __attribute__ ((__format__ (__printf__, 2, 0))) ;
extern int __asprintf (char **__restrict __ptr,
         const char *__restrict __fmt, ...)
     noexcept (true) __attribute__ ((__format__ (__printf__, 2, 3))) ;
extern int asprintf (char **__restrict __ptr,
       const char *__restrict __fmt, ...)
     noexcept (true) __attribute__ ((__format__ (__printf__, 2, 3))) ;




extern int vdprintf (int __fd, const char *__restrict __fmt,
       __gnuc_va_list __arg)
     __attribute__ ((__format__ (__printf__, 2, 0)));
extern int dprintf (int __fd, const char *__restrict __fmt, ...)
     __attribute__ ((__format__ (__printf__, 2, 3)));







extern int fscanf (FILE *__restrict __stream,
     const char *__restrict __format, ...) ;




extern int scanf (const char *__restrict __format, ...) ;

extern int sscanf (const char *__restrict __s,
     const char *__restrict __format, ...) noexcept (true);
# 434 "/usr/include/stdio.h" 3 4
extern int fscanf (FILE *__restrict __stream, const char *__restrict __format, ...) __asm__ ("" "__isoc99_fscanf")

                               ;
extern int scanf (const char *__restrict __format, ...) __asm__ ("" "__isoc99_scanf")
                              ;
extern int sscanf (const char *__restrict __s, const char *__restrict __format, ...) noexcept (true) __asm__ ("" "__isoc99_sscanf")

                      ;
# 459 "/usr/include/stdio.h" 3 4
extern int vfscanf (FILE *__restrict __s, const char *__restrict __format,
      __gnuc_va_list __arg)
     __attribute__ ((__format__ (__scanf__, 2, 0))) ;





extern int vscanf (const char *__restrict __format, __gnuc_va_list __arg)
     __attribute__ ((__format__ (__scanf__, 1, 0))) ;


extern int vsscanf (const char *__restrict __s,
      const char *__restrict __format, __gnuc_va_list __arg)
     noexcept (true) __attribute__ ((__format__ (__scanf__, 2, 0)));





extern int vfscanf (FILE *__restrict __s, const char *__restrict __format, __gnuc_va_list __arg) __asm__ ("" "__isoc99_vfscanf")



     __attribute__ ((__format__ (__scanf__, 2, 0))) ;
extern int vscanf (const char *__restrict __format, __gnuc_va_list __arg) __asm__ ("" "__isoc99_vscanf")

     __attribute__ ((__format__ (__scanf__, 1, 0))) ;
extern int vsscanf (const char *__restrict __s, const char *__restrict __format, __gnuc_va_list __arg) noexcept (true) __asm__ ("" "__isoc99_vsscanf")



     __attribute__ ((__format__ (__scanf__, 2, 0)));
# 513 "/usr/include/stdio.h" 3 4
extern int fgetc (FILE *__stream);
extern int getc (FILE *__stream);





extern int getchar (void);






extern int getc_unlocked (FILE *__stream);
extern int getchar_unlocked (void);
# 538 "/usr/include/stdio.h" 3 4
extern int fgetc_unlocked (FILE *__stream);
# 549 "/usr/include/stdio.h" 3 4
extern int fputc (int __c, FILE *__stream);
extern int putc (int __c, FILE *__stream);





extern int putchar (int __c);
# 565 "/usr/include/stdio.h" 3 4
extern int fputc_unlocked (int __c, FILE *__stream);







extern int putc_unlocked (int __c, FILE *__stream);
extern int putchar_unlocked (int __c);






extern int getw (FILE *__stream);


extern int putw (int __w, FILE *__stream);







extern char *fgets (char *__restrict __s, int __n, FILE *__restrict __stream)
     __attribute__ ((__access__ (__write_only__, 1, 2)));
# 615 "/usr/include/stdio.h" 3 4
extern char *fgets_unlocked (char *__restrict __s, int __n,
        FILE *__restrict __stream)
    __attribute__ ((__access__ (__write_only__, 1, 2)));
# 632 "/usr/include/stdio.h" 3 4
extern __ssize_t __getdelim (char **__restrict __lineptr,
                             size_t *__restrict __n, int __delimiter,
                             FILE *__restrict __stream) ;
extern __ssize_t getdelim (char **__restrict __lineptr,
                           size_t *__restrict __n, int __delimiter,
                           FILE *__restrict __stream) ;







extern __ssize_t getline (char **__restrict __lineptr,
                          size_t *__restrict __n,
                          FILE *__restrict __stream) ;







extern int fputs (const char *__restrict __s, FILE *__restrict __stream);





extern int puts (const char *__s);






extern int ungetc (int __c, FILE *__stream);






extern size_t fread (void *__restrict __ptr, size_t __size,
       size_t __n, FILE *__restrict __stream) ;




extern size_t fwrite (const void *__restrict __ptr, size_t __size,
        size_t __n, FILE *__restrict __s);
# 691 "/usr/include/stdio.h" 3 4
extern int fputs_unlocked (const char *__restrict __s,
      FILE *__restrict __stream);
# 702 "/usr/include/stdio.h" 3 4
extern size_t fread_unlocked (void *__restrict __ptr, size_t __size,
         size_t __n, FILE *__restrict __stream) ;
extern size_t fwrite_unlocked (const void *__restrict __ptr, size_t __size,
          size_t __n, FILE *__restrict __stream);







extern int fseek (FILE *__stream, long int __off, int __whence);




extern long int ftell (FILE *__stream) ;




extern void rewind (FILE *__stream);
# 736 "/usr/include/stdio.h" 3 4
extern int fseeko (FILE *__stream, __off_t __off, int __whence);




extern __off_t ftello (FILE *__stream) ;
# 760 "/usr/include/stdio.h" 3 4
extern int fgetpos (FILE *__restrict __stream, fpos_t *__restrict __pos);




extern int fsetpos (FILE *__stream, const fpos_t *__pos);
# 779 "/usr/include/stdio.h" 3 4
extern int fseeko64 (FILE *__stream, __off64_t __off, int __whence);
extern __off64_t ftello64 (FILE *__stream) ;
extern int fgetpos64 (FILE *__restrict __stream, fpos64_t *__restrict __pos);
extern int fsetpos64 (FILE *__stream, const fpos64_t *__pos);



extern void clearerr (FILE *__stream) noexcept (true);

extern int feof (FILE *__stream) noexcept (true) ;

extern int ferror (FILE *__stream) noexcept (true) ;



extern void clearerr_unlocked (FILE *__stream) noexcept (true);
extern int feof_unlocked (FILE *__stream) noexcept (true) ;
extern int ferror_unlocked (FILE *__stream) noexcept (true) ;







extern void perror (const char *__s);




extern int fileno (FILE *__stream) noexcept (true) ;




extern int fileno_unlocked (FILE *__stream) noexcept (true) ;
# 823 "/usr/include/stdio.h" 3 4
extern int pclose (FILE *__stream);





extern FILE *popen (const char *__command, const char *__modes)
  __attribute__ ((__malloc__)) ;






extern char *ctermid (char *__s) noexcept (true)
  __attribute__ ((__access__ (__write_only__, 1)));





extern char *cuserid (char *__s)
  __attribute__ ((__access__ (__write_only__, 1)));




struct obstack;


extern int obstack_printf (struct obstack *__restrict __obstack,
      const char *__restrict __format, ...)
     noexcept (true) __attribute__ ((__format__ (__printf__, 2, 3)));
extern int obstack_vprintf (struct obstack *__restrict __obstack,
       const char *__restrict __format,
       __gnuc_va_list __args)
     noexcept (true) __attribute__ ((__format__ (__printf__, 2, 0)));







extern void flockfile (FILE *__stream) noexcept (true);



extern int ftrylockfile (FILE *__stream) noexcept (true) ;


extern void funlockfile (FILE *__stream) noexcept (true);
# 885 "/usr/include/stdio.h" 3 4
extern int __uflow (FILE *);
extern int __overflow (FILE *, int);
# 902 "/usr/include/stdio.h" 3 4
}
# 23 "include/glad.c" 2
# 1 "/usr/include/c++/10/stdlib.h" 1 3
# 36 "/usr/include/c++/10/stdlib.h" 3
# 1 "/usr/include/c++/10/cstdlib" 1 3
# 39 "/usr/include/c++/10/cstdlib" 3
       
# 40 "/usr/include/c++/10/cstdlib" 3
# 37 "/usr/include/c++/10/stdlib.h" 2 3

using std::abort;
using std::atexit;
using std::exit;


  using std::at_quick_exit;


  using std::quick_exit;




using std::div_t;
using std::ldiv_t;

using std::abs;
using std::atof;
using std::atoi;
using std::atol;
using std::bsearch;
using std::calloc;
using std::div;
using std::free;
using std::getenv;
using std::labs;
using std::ldiv;
using std::malloc;

using std::mblen;
using std::mbstowcs;
using std::mbtowc;

using std::qsort;
using std::rand;
using std::realloc;
using std::srand;
using std::strtod;
using std::strtol;
using std::strtoul;
using std::system;

using std::wcstombs;
using std::wctomb;
# 24 "include/glad.c" 2
# 1 "/usr/include/string.h" 1 3 4
# 26 "/usr/include/string.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/libc-header-start.h" 1 3 4
# 27 "/usr/include/string.h" 2 3 4

extern "C" {




# 1 "/usr/lib/gcc/x86_64-linux-gnu/10/include/stddef.h" 1 3 4
# 34 "/usr/include/string.h" 2 3 4
# 43 "/usr/include/string.h" 3 4
extern void *memcpy (void *__restrict __dest, const void *__restrict __src,
       size_t __n) noexcept (true) __attribute__ ((__nonnull__ (1, 2)));


extern void *memmove (void *__dest, const void *__src, size_t __n)
     noexcept (true) __attribute__ ((__nonnull__ (1, 2)));





extern void *memccpy (void *__restrict __dest, const void *__restrict __src,
        int __c, size_t __n)
    noexcept (true) __attribute__ ((__nonnull__ (1, 2))) __attribute__ ((__access__ (__write_only__, 1, 4)));




extern void *memset (void *__s, int __c, size_t __n) noexcept (true) __attribute__ ((__nonnull__ (1)));


extern int memcmp (const void *__s1, const void *__s2, size_t __n)
     noexcept (true) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
# 80 "/usr/include/string.h" 3 4
extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
     noexcept (true) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));



extern "C++"
{
extern void *memchr (void *__s, int __c, size_t __n)
      noexcept (true) __asm ("memchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
extern const void *memchr (const void *__s, int __c, size_t __n)
      noexcept (true) __asm ("memchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 105 "/usr/include/string.h" 3 4
}
# 115 "/usr/include/string.h" 3 4
extern "C++" void *rawmemchr (void *__s, int __c)
     noexcept (true) __asm ("rawmemchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
extern "C++" const void *rawmemchr (const void *__s, int __c)
     noexcept (true) __asm ("rawmemchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));







extern "C++" void *memrchr (void *__s, int __c, size_t __n)
      noexcept (true) __asm ("memrchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)))
      __attribute__ ((__access__ (__read_only__, 1, 3)));
extern "C++" const void *memrchr (const void *__s, int __c, size_t __n)
      noexcept (true) __asm ("memrchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)))
      __attribute__ ((__access__ (__read_only__, 1, 3)));
# 141 "/usr/include/string.h" 3 4
extern char *strcpy (char *__restrict __dest, const char *__restrict __src)
     noexcept (true) __attribute__ ((__nonnull__ (1, 2)));

extern char *strncpy (char *__restrict __dest,
        const char *__restrict __src, size_t __n)
     noexcept (true) __attribute__ ((__nonnull__ (1, 2)));


extern char *strcat (char *__restrict __dest, const char *__restrict __src)
     noexcept (true) __attribute__ ((__nonnull__ (1, 2)));

extern char *strncat (char *__restrict __dest, const char *__restrict __src,
        size_t __n) noexcept (true) __attribute__ ((__nonnull__ (1, 2)));


extern int strcmp (const char *__s1, const char *__s2)
     noexcept (true) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));

extern int strncmp (const char *__s1, const char *__s2, size_t __n)
     noexcept (true) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern int strcoll (const char *__s1, const char *__s2)
     noexcept (true) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));

extern size_t strxfrm (char *__restrict __dest,
         const char *__restrict __src, size_t __n)
    noexcept (true) __attribute__ ((__nonnull__ (2))) __attribute__ ((__access__ (__write_only__, 1, 3)));






extern int strcoll_l (const char *__s1, const char *__s2, locale_t __l)
     noexcept (true) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2, 3)));


extern size_t strxfrm_l (char *__dest, const char *__src, size_t __n,
    locale_t __l) noexcept (true) __attribute__ ((__nonnull__ (2, 4)))
     __attribute__ ((__access__ (__write_only__, 1, 3)));





extern char *strdup (const char *__s)
     noexcept (true) __attribute__ ((__malloc__)) __attribute__ ((__nonnull__ (1)));






extern char *strndup (const char *__string, size_t __n)
     noexcept (true) __attribute__ ((__malloc__)) __attribute__ ((__nonnull__ (1)));
# 224 "/usr/include/string.h" 3 4
extern "C++"
{
extern char *strchr (char *__s, int __c)
     noexcept (true) __asm ("strchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
extern const char *strchr (const char *__s, int __c)
     noexcept (true) __asm ("strchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 244 "/usr/include/string.h" 3 4
}






extern "C++"
{
extern char *strrchr (char *__s, int __c)
     noexcept (true) __asm ("strrchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
extern const char *strrchr (const char *__s, int __c)
     noexcept (true) __asm ("strrchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 271 "/usr/include/string.h" 3 4
}
# 281 "/usr/include/string.h" 3 4
extern "C++" char *strchrnul (char *__s, int __c)
     noexcept (true) __asm ("strchrnul") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
extern "C++" const char *strchrnul (const char *__s, int __c)
     noexcept (true) __asm ("strchrnul") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 293 "/usr/include/string.h" 3 4
extern size_t strcspn (const char *__s, const char *__reject)
     noexcept (true) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern size_t strspn (const char *__s, const char *__accept)
     noexcept (true) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern "C++"
{
extern char *strpbrk (char *__s, const char *__accept)
     noexcept (true) __asm ("strpbrk") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
extern const char *strpbrk (const char *__s, const char *__accept)
     noexcept (true) __asm ("strpbrk") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
# 321 "/usr/include/string.h" 3 4
}






extern "C++"
{
extern char *strstr (char *__haystack, const char *__needle)
     noexcept (true) __asm ("strstr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
extern const char *strstr (const char *__haystack, const char *__needle)
     noexcept (true) __asm ("strstr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
# 348 "/usr/include/string.h" 3 4
}







extern char *strtok (char *__restrict __s, const char *__restrict __delim)
     noexcept (true) __attribute__ ((__nonnull__ (2)));



extern char *__strtok_r (char *__restrict __s,
    const char *__restrict __delim,
    char **__restrict __save_ptr)
     noexcept (true) __attribute__ ((__nonnull__ (2, 3)));

extern char *strtok_r (char *__restrict __s, const char *__restrict __delim,
         char **__restrict __save_ptr)
     noexcept (true) __attribute__ ((__nonnull__ (2, 3)));





extern "C++" char *strcasestr (char *__haystack, const char *__needle)
     noexcept (true) __asm ("strcasestr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
extern "C++" const char *strcasestr (const char *__haystack,
         const char *__needle)
     noexcept (true) __asm ("strcasestr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
# 389 "/usr/include/string.h" 3 4
extern void *memmem (const void *__haystack, size_t __haystacklen,
       const void *__needle, size_t __needlelen)
     noexcept (true) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 3)))
    __attribute__ ((__access__ (__read_only__, 1, 2)))
    __attribute__ ((__access__ (__read_only__, 3, 4)));



extern void *__mempcpy (void *__restrict __dest,
   const void *__restrict __src, size_t __n)
     noexcept (true) __attribute__ ((__nonnull__ (1, 2)));
extern void *mempcpy (void *__restrict __dest,
        const void *__restrict __src, size_t __n)
     noexcept (true) __attribute__ ((__nonnull__ (1, 2)));




extern size_t strlen (const char *__s)
     noexcept (true) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));




extern size_t strnlen (const char *__string, size_t __maxlen)
     noexcept (true) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));




extern char *strerror (int __errnum) noexcept (true);
# 444 "/usr/include/string.h" 3 4
extern char *strerror_r (int __errnum, char *__buf, size_t __buflen)
     noexcept (true) __attribute__ ((__nonnull__ (2))) __attribute__ ((__access__ (__write_only__, 2, 3)));




extern const char *strerrordesc_np (int __err) noexcept (true);

extern const char *strerrorname_np (int __err) noexcept (true);





extern char *strerror_l (int __errnum, locale_t __l) noexcept (true);



# 1 "/usr/include/strings.h" 1 3 4
# 23 "/usr/include/strings.h" 3 4
# 1 "/usr/lib/gcc/x86_64-linux-gnu/10/include/stddef.h" 1 3 4
# 24 "/usr/include/strings.h" 2 3 4






extern "C" {



extern int bcmp (const void *__s1, const void *__s2, size_t __n)
     noexcept (true) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern void bcopy (const void *__src, void *__dest, size_t __n)
  noexcept (true) __attribute__ ((__nonnull__ (1, 2)));


extern void bzero (void *__s, size_t __n) noexcept (true) __attribute__ ((__nonnull__ (1)));



extern "C++"
{
extern char *index (char *__s, int __c)
     noexcept (true) __asm ("index") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
extern const char *index (const char *__s, int __c)
     noexcept (true) __asm ("index") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 66 "/usr/include/strings.h" 3 4
}







extern "C++"
{
extern char *rindex (char *__s, int __c)
     noexcept (true) __asm ("rindex") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
extern const char *rindex (const char *__s, int __c)
     noexcept (true) __asm ("rindex") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 94 "/usr/include/strings.h" 3 4
}
# 104 "/usr/include/strings.h" 3 4
extern int ffs (int __i) noexcept (true) __attribute__ ((__const__));





extern int ffsl (long int __l) noexcept (true) __attribute__ ((__const__));
__extension__ extern int ffsll (long long int __ll)
     noexcept (true) __attribute__ ((__const__));



extern int strcasecmp (const char *__s1, const char *__s2)
     noexcept (true) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern int strncasecmp (const char *__s1, const char *__s2, size_t __n)
     noexcept (true) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));






extern int strcasecmp_l (const char *__s1, const char *__s2, locale_t __loc)
     noexcept (true) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2, 3)));



extern int strncasecmp_l (const char *__s1, const char *__s2,
     size_t __n, locale_t __loc)
     noexcept (true) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2, 4)));


}
# 463 "/usr/include/string.h" 2 3 4



extern void explicit_bzero (void *__s, size_t __n) noexcept (true) __attribute__ ((__nonnull__ (1)))
    __attribute__ ((__access__ (__write_only__, 1, 2)));



extern char *strsep (char **__restrict __stringp,
       const char *__restrict __delim)
     noexcept (true) __attribute__ ((__nonnull__ (1, 2)));




extern char *strsignal (int __sig) noexcept (true);



extern const char *sigabbrev_np (int __sig) noexcept (true);


extern const char *sigdescr_np (int __sig) noexcept (true);



extern char *__stpcpy (char *__restrict __dest, const char *__restrict __src)
     noexcept (true) __attribute__ ((__nonnull__ (1, 2)));
extern char *stpcpy (char *__restrict __dest, const char *__restrict __src)
     noexcept (true) __attribute__ ((__nonnull__ (1, 2)));



extern char *__stpncpy (char *__restrict __dest,
   const char *__restrict __src, size_t __n)
     noexcept (true) __attribute__ ((__nonnull__ (1, 2)));
extern char *stpncpy (char *__restrict __dest,
        const char *__restrict __src, size_t __n)
     noexcept (true) __attribute__ ((__nonnull__ (1, 2)));




extern int strverscmp (const char *__s1, const char *__s2)
     noexcept (true) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern char *strfry (char *__string) noexcept (true) __attribute__ ((__nonnull__ (1)));


extern void *memfrob (void *__s, size_t __n) noexcept (true) __attribute__ ((__nonnull__ (1)))
    __attribute__ ((__access__ (__read_write__, 1, 2)));







extern "C++" char *basename (char *__filename)
     noexcept (true) __asm ("basename") __attribute__ ((__nonnull__ (1)));
extern "C++" const char *basename (const char *__filename)
     noexcept (true) __asm ("basename") __attribute__ ((__nonnull__ (1)));
# 539 "/usr/include/string.h" 3 4
}
# 25 "include/glad.c" 2



# 27 "include/glad.c"
static void* get_proc(const char *namez);
# 79 "include/glad.c"
# 1 "/usr/include/dlfcn.h" 1 3 4
# 24 "/usr/include/dlfcn.h" 3 4
# 1 "/usr/lib/gcc/x86_64-linux-gnu/10/include/stddef.h" 1 3 4
# 25 "/usr/include/dlfcn.h" 2 3 4


# 1 "/usr/include/x86_64-linux-gnu/bits/dlfcn.h" 1 3 4
# 57 "/usr/include/x86_64-linux-gnu/bits/dlfcn.h" 3 4

# 57 "/usr/include/x86_64-linux-gnu/bits/dlfcn.h" 3 4
extern "C" {


extern void _dl_mcount_wrapper_check (void *__selfpc) noexcept (true);

}
# 28 "/usr/include/dlfcn.h" 2 3 4



# 1 "/usr/include/x86_64-linux-gnu/bits/dl_find_object.h" 1 3 4
# 32 "/usr/include/dlfcn.h" 2 3 4
# 46 "/usr/include/dlfcn.h" 3 4
typedef long int Lmid_t;







extern "C" {



extern void *dlopen (const char *__file, int __mode) noexcept (true);



extern int dlclose (void *__handle) noexcept (true) __attribute__ ((__nonnull__ (1)));



extern void *dlsym (void *__restrict __handle,
      const char *__restrict __name) noexcept (true) __attribute__ ((__nonnull__ (2)));



extern void *dlmopen (Lmid_t __nsid, const char *__file, int __mode) noexcept (true);



extern void *dlvsym (void *__restrict __handle,
       const char *__restrict __name,
       const char *__restrict __version)
     noexcept (true) __attribute__ ((__nonnull__ (2, 3)));





extern char *dlerror (void) noexcept (true);





typedef struct
{
  const char *dli_fname;
  void *dli_fbase;
  const char *dli_sname;
  void *dli_saddr;
} Dl_info;



extern int dladdr (const void *__address, Dl_info *__info)
     noexcept (true) __attribute__ ((__nonnull__ (2)));


extern int dladdr1 (const void *__address, Dl_info *__info,
      void **__extra_info, int __flags) noexcept (true) __attribute__ ((__nonnull__ (2)));




enum
  {

    RTLD_DL_SYMENT = 1,


    RTLD_DL_LINKMAP = 2
  };







extern int dlinfo (void *__restrict __handle,
     int __request, void *__restrict __arg)
     noexcept (true) __attribute__ ((__nonnull__ (1, 3)));


enum
  {

    RTLD_DI_LMID = 1,



    RTLD_DI_LINKMAP = 2,

    RTLD_DI_CONFIGADDR = 3,






    RTLD_DI_SERINFO = 4,
    RTLD_DI_SERINFOSIZE = 5,



    RTLD_DI_ORIGIN = 6,

    RTLD_DI_PROFILENAME = 7,
    RTLD_DI_PROFILEOUT = 8,




    RTLD_DI_TLS_MODID = 9,





    RTLD_DI_TLS_DATA = 10,

    RTLD_DI_MAX = 10
  };




typedef struct
{
  char *dls_name;
  unsigned int dls_flags;
} Dl_serpath;



typedef struct
{
  size_t dls_size;
  unsigned int dls_cnt;





  __extension__ union
  {
    Dl_serpath dls_serpath[0];
    Dl_serpath __dls_serpath_pad[1];
  };



} Dl_serinfo;

struct dl_find_object
{
  __extension__ unsigned long long int dlfo_flags;
  void *dlfo_map_start;
  void *dlfo_map_end;
  struct link_map *dlfo_link_map;
  void *dlfo_eh_frame;
# 217 "/usr/include/dlfcn.h" 3 4
  __extension__ unsigned long long int __dflo_reserved[7];
};



int _dl_find_object (void *__address, struct dl_find_object *__result) noexcept (true);




}
# 80 "include/glad.c" 2

# 80 "include/glad.c"
static void* libGL;


typedef void* ( * PFNGLXGETPROCADDRESSPROC_PRIVATE)(const char*);
static PFNGLXGETPROCADDRESSPROC_PRIVATE gladGetProcAddressPtr;


static
int open_gl(void) {
# 97 "include/glad.c"
    static const char *NAMES[] = {"libGL.so.1", "libGL.so"};


    unsigned int index = 0;
    for(index = 0; index < (sizeof(NAMES) / sizeof(NAMES[0])); index++) {
        libGL = dlopen(NAMES[index], 
# 102 "include/glad.c" 3 4
                                    0x00002 
# 102 "include/glad.c"
                                             | 
# 102 "include/glad.c" 3 4
                                               0x00100
# 102 "include/glad.c"
                                                          );

        if(libGL != 
# 104 "include/glad.c" 3 4
                   __null
# 104 "include/glad.c"
                       ) {



            gladGetProcAddressPtr = (PFNGLXGETPROCADDRESSPROC_PRIVATE)dlsym(libGL,
                "glXGetProcAddressARB");
            return gladGetProcAddressPtr != 
# 110 "include/glad.c" 3 4
                                           __null
# 110 "include/glad.c"
                                               ;

        }
    }

    return 0;
}

static
void close_gl(void) {
    if(libGL != 
# 120 "include/glad.c" 3 4
               __null
# 120 "include/glad.c"
                   ) {
        dlclose(libGL);
        libGL = 
# 122 "include/glad.c" 3 4
               __null
# 122 "include/glad.c"
                   ;
    }
}


static
void* get_proc(const char *namez) {
    void* result = 
# 129 "include/glad.c" 3 4
                  __null
# 129 "include/glad.c"
                      ;
    if(libGL == 
# 130 "include/glad.c" 3 4
               __null
# 130 "include/glad.c"
                   ) return 
# 130 "include/glad.c" 3 4
                            __null
# 130 "include/glad.c"
                                ;


    if(gladGetProcAddressPtr != 
# 133 "include/glad.c" 3 4
                               __null
# 133 "include/glad.c"
                                   ) {
        result = gladGetProcAddressPtr(namez);
    }

    if(result == 
# 137 "include/glad.c" 3 4
                __null
# 137 "include/glad.c"
                    ) {



        result = dlsym(libGL, namez);

    }

    return result;
}

int gladLoadGL(void) {
    int status = 0;

    if(open_gl()) {
        status = gladLoadGLLoader(&get_proc);
        close_gl();
    }

    return status;
}

struct gladGLversionStruct GLVersion = { 0, 0 };





static int max_loaded_major;
static int max_loaded_minor;

static const char *exts = 
# 168 "include/glad.c" 3 4
                         __null
# 168 "include/glad.c"
                             ;
static int num_exts_i = 0;
static char **exts_i = 
# 170 "include/glad.c" 3 4
                      __null
# 170 "include/glad.c"
                          ;

static int get_exts(void) {

    if(max_loaded_major < 3) {

        exts = (const char *)glad_glGetString(0x1F03);

    } else {
        int index;

        num_exts_i = 0;
        glad_glGetIntegerv(0x821D, &num_exts_i);
        if (num_exts_i > 0) {
            exts_i = (char **)malloc((size_t)num_exts_i * (sizeof *exts_i));
        }

        if (exts_i == 
# 187 "include/glad.c" 3 4
                     __null
# 187 "include/glad.c"
                         ) {
            return 0;
        }

        for(index = 0; index < num_exts_i; index++) {
            const char *gl_str_tmp = (const char*)glad_glGetStringi(0x1F03, index);
            size_t len = strlen(gl_str_tmp);

            char *local_str = (char*)malloc((len+1) * sizeof(char));
            if(local_str != 
# 196 "include/glad.c" 3 4
                           __null
# 196 "include/glad.c"
                               ) {
                memcpy(local_str, gl_str_tmp, (len+1) * sizeof(char));
            }
            exts_i[index] = local_str;
        }
    }

    return 1;
}

static void free_exts(void) {
    if (exts_i != 
# 207 "include/glad.c" 3 4
                 __null
# 207 "include/glad.c"
                     ) {
        int index;
        for(index = 0; index < num_exts_i; index++) {
            free((char *)exts_i[index]);
        }
        free((void *)exts_i);
        exts_i = 
# 213 "include/glad.c" 3 4
                __null
# 213 "include/glad.c"
                    ;
    }
}

static int has_ext(const char *ext) {

    if(max_loaded_major < 3) {

        const char *extensions;
        const char *loc;
        const char *terminator;
        extensions = exts;
        if(extensions == 
# 225 "include/glad.c" 3 4
                        __null 
# 225 "include/glad.c"
                             || ext == 
# 225 "include/glad.c" 3 4
                                       __null
# 225 "include/glad.c"
                                           ) {
            return 0;
        }

        while(1) {
            loc = strstr(extensions, ext);
            if(loc == 
# 231 "include/glad.c" 3 4
                     __null
# 231 "include/glad.c"
                         ) {
                return 0;
            }

            terminator = loc + strlen(ext);
            if((loc == extensions || *(loc - 1) == ' ') &&
                (*terminator == ' ' || *terminator == '\0')) {
                return 1;
            }
            extensions = terminator;
        }

    } else {
        int index;
        if(exts_i == 
# 245 "include/glad.c" 3 4
                    __null
# 245 "include/glad.c"
                        ) return 0;
        for(index = 0; index < num_exts_i; index++) {
            const char *e = exts_i[index];

            if(exts_i[index] != 
# 249 "include/glad.c" 3 4
                               __null 
# 249 "include/glad.c"
                                    && strcmp(e, ext) == 0) {
                return 1;
            }
        }
    }


    return 0;
}
int GLAD_GL_VERSION_1_0 = 0;
int GLAD_GL_VERSION_1_1 = 0;
int GLAD_GL_VERSION_1_2 = 0;
int GLAD_GL_VERSION_1_3 = 0;
int GLAD_GL_VERSION_1_4 = 0;
int GLAD_GL_VERSION_1_5 = 0;
int GLAD_GL_VERSION_2_0 = 0;
int GLAD_GL_VERSION_2_1 = 0;
int GLAD_GL_VERSION_3_0 = 0;
int GLAD_GL_VERSION_3_1 = 0;
int GLAD_GL_VERSION_3_2 = 0;
int GLAD_GL_VERSION_3_3 = 0;
int GLAD_GL_VERSION_4_0 = 0;
int GLAD_GL_VERSION_4_1 = 0;
int GLAD_GL_VERSION_4_2 = 0;
int GLAD_GL_VERSION_4_3 = 0;
int GLAD_GL_VERSION_4_4 = 0;
int GLAD_GL_VERSION_4_5 = 0;
PFNGLACTIVESHADERPROGRAMPROC glad_glActiveShaderProgram = 
# 276 "include/glad.c" 3 4
                                                         __null
# 276 "include/glad.c"
                                                             ;
PFNGLACTIVETEXTUREPROC glad_glActiveTexture = 
# 277 "include/glad.c" 3 4
                                             __null
# 277 "include/glad.c"
                                                 ;
PFNGLATTACHSHADERPROC glad_glAttachShader = 
# 278 "include/glad.c" 3 4
                                           __null
# 278 "include/glad.c"
                                               ;
PFNGLBEGINCONDITIONALRENDERPROC glad_glBeginConditionalRender = 
# 279 "include/glad.c" 3 4
                                                               __null
# 279 "include/glad.c"
                                                                   ;
PFNGLBEGINQUERYPROC glad_glBeginQuery = 
# 280 "include/glad.c" 3 4
                                       __null
# 280 "include/glad.c"
                                           ;
PFNGLBEGINQUERYINDEXEDPROC glad_glBeginQueryIndexed = 
# 281 "include/glad.c" 3 4
                                                     __null
# 281 "include/glad.c"
                                                         ;
PFNGLBEGINTRANSFORMFEEDBACKPROC glad_glBeginTransformFeedback = 
# 282 "include/glad.c" 3 4
                                                               __null
# 282 "include/glad.c"
                                                                   ;
PFNGLBINDATTRIBLOCATIONPROC glad_glBindAttribLocation = 
# 283 "include/glad.c" 3 4
                                                       __null
# 283 "include/glad.c"
                                                           ;
PFNGLBINDBUFFERPROC glad_glBindBuffer = 
# 284 "include/glad.c" 3 4
                                       __null
# 284 "include/glad.c"
                                           ;
PFNGLBINDBUFFERBASEPROC glad_glBindBufferBase = 
# 285 "include/glad.c" 3 4
                                               __null
# 285 "include/glad.c"
                                                   ;
PFNGLBINDBUFFERRANGEPROC glad_glBindBufferRange = 
# 286 "include/glad.c" 3 4
                                                 __null
# 286 "include/glad.c"
                                                     ;
PFNGLBINDBUFFERSBASEPROC glad_glBindBuffersBase = 
# 287 "include/glad.c" 3 4
                                                 __null
# 287 "include/glad.c"
                                                     ;
PFNGLBINDBUFFERSRANGEPROC glad_glBindBuffersRange = 
# 288 "include/glad.c" 3 4
                                                   __null
# 288 "include/glad.c"
                                                       ;
PFNGLBINDFRAGDATALOCATIONPROC glad_glBindFragDataLocation = 
# 289 "include/glad.c" 3 4
                                                           __null
# 289 "include/glad.c"
                                                               ;
PFNGLBINDFRAGDATALOCATIONINDEXEDPROC glad_glBindFragDataLocationIndexed = 
# 290 "include/glad.c" 3 4
                                                                         __null
# 290 "include/glad.c"
                                                                             ;
PFNGLBINDFRAMEBUFFERPROC glad_glBindFramebuffer = 
# 291 "include/glad.c" 3 4
                                                 __null
# 291 "include/glad.c"
                                                     ;
PFNGLBINDIMAGETEXTUREPROC glad_glBindImageTexture = 
# 292 "include/glad.c" 3 4
                                                   __null
# 292 "include/glad.c"
                                                       ;
PFNGLBINDIMAGETEXTURESPROC glad_glBindImageTextures = 
# 293 "include/glad.c" 3 4
                                                     __null
# 293 "include/glad.c"
                                                         ;
PFNGLBINDPROGRAMPIPELINEPROC glad_glBindProgramPipeline = 
# 294 "include/glad.c" 3 4
                                                         __null
# 294 "include/glad.c"
                                                             ;
PFNGLBINDRENDERBUFFERPROC glad_glBindRenderbuffer = 
# 295 "include/glad.c" 3 4
                                                   __null
# 295 "include/glad.c"
                                                       ;
PFNGLBINDSAMPLERPROC glad_glBindSampler = 
# 296 "include/glad.c" 3 4
                                         __null
# 296 "include/glad.c"
                                             ;
PFNGLBINDSAMPLERSPROC glad_glBindSamplers = 
# 297 "include/glad.c" 3 4
                                           __null
# 297 "include/glad.c"
                                               ;
PFNGLBINDTEXTUREPROC glad_glBindTexture = 
# 298 "include/glad.c" 3 4
                                         __null
# 298 "include/glad.c"
                                             ;
PFNGLBINDTEXTUREUNITPROC glad_glBindTextureUnit = 
# 299 "include/glad.c" 3 4
                                                 __null
# 299 "include/glad.c"
                                                     ;
PFNGLBINDTEXTURESPROC glad_glBindTextures = 
# 300 "include/glad.c" 3 4
                                           __null
# 300 "include/glad.c"
                                               ;
PFNGLBINDTRANSFORMFEEDBACKPROC glad_glBindTransformFeedback = 
# 301 "include/glad.c" 3 4
                                                             __null
# 301 "include/glad.c"
                                                                 ;
PFNGLBINDVERTEXARRAYPROC glad_glBindVertexArray = 
# 302 "include/glad.c" 3 4
                                                 __null
# 302 "include/glad.c"
                                                     ;
PFNGLBINDVERTEXBUFFERPROC glad_glBindVertexBuffer = 
# 303 "include/glad.c" 3 4
                                                   __null
# 303 "include/glad.c"
                                                       ;
PFNGLBINDVERTEXBUFFERSPROC glad_glBindVertexBuffers = 
# 304 "include/glad.c" 3 4
                                                     __null
# 304 "include/glad.c"
                                                         ;
PFNGLBLENDCOLORPROC glad_glBlendColor = 
# 305 "include/glad.c" 3 4
                                       __null
# 305 "include/glad.c"
                                           ;
PFNGLBLENDEQUATIONPROC glad_glBlendEquation = 
# 306 "include/glad.c" 3 4
                                             __null
# 306 "include/glad.c"
                                                 ;
PFNGLBLENDEQUATIONSEPARATEPROC glad_glBlendEquationSeparate = 
# 307 "include/glad.c" 3 4
                                                             __null
# 307 "include/glad.c"
                                                                 ;
PFNGLBLENDEQUATIONSEPARATEIPROC glad_glBlendEquationSeparatei = 
# 308 "include/glad.c" 3 4
                                                               __null
# 308 "include/glad.c"
                                                                   ;
PFNGLBLENDEQUATIONIPROC glad_glBlendEquationi = 
# 309 "include/glad.c" 3 4
                                               __null
# 309 "include/glad.c"
                                                   ;
PFNGLBLENDFUNCPROC glad_glBlendFunc = 
# 310 "include/glad.c" 3 4
                                     __null
# 310 "include/glad.c"
                                         ;
PFNGLBLENDFUNCSEPARATEPROC glad_glBlendFuncSeparate = 
# 311 "include/glad.c" 3 4
                                                     __null
# 311 "include/glad.c"
                                                         ;
PFNGLBLENDFUNCSEPARATEIPROC glad_glBlendFuncSeparatei = 
# 312 "include/glad.c" 3 4
                                                       __null
# 312 "include/glad.c"
                                                           ;
PFNGLBLENDFUNCIPROC glad_glBlendFunci = 
# 313 "include/glad.c" 3 4
                                       __null
# 313 "include/glad.c"
                                           ;
PFNGLBLITFRAMEBUFFERPROC glad_glBlitFramebuffer = 
# 314 "include/glad.c" 3 4
                                                 __null
# 314 "include/glad.c"
                                                     ;
PFNGLBLITNAMEDFRAMEBUFFERPROC glad_glBlitNamedFramebuffer = 
# 315 "include/glad.c" 3 4
                                                           __null
# 315 "include/glad.c"
                                                               ;
PFNGLBUFFERDATAPROC glad_glBufferData = 
# 316 "include/glad.c" 3 4
                                       __null
# 316 "include/glad.c"
                                           ;
PFNGLBUFFERSTORAGEPROC glad_glBufferStorage = 
# 317 "include/glad.c" 3 4
                                             __null
# 317 "include/glad.c"
                                                 ;
PFNGLBUFFERSUBDATAPROC glad_glBufferSubData = 
# 318 "include/glad.c" 3 4
                                             __null
# 318 "include/glad.c"
                                                 ;
PFNGLCHECKFRAMEBUFFERSTATUSPROC glad_glCheckFramebufferStatus = 
# 319 "include/glad.c" 3 4
                                                               __null
# 319 "include/glad.c"
                                                                   ;
PFNGLCHECKNAMEDFRAMEBUFFERSTATUSPROC glad_glCheckNamedFramebufferStatus = 
# 320 "include/glad.c" 3 4
                                                                         __null
# 320 "include/glad.c"
                                                                             ;
PFNGLCLAMPCOLORPROC glad_glClampColor = 
# 321 "include/glad.c" 3 4
                                       __null
# 321 "include/glad.c"
                                           ;
PFNGLCLEARPROC glad_glClear = 
# 322 "include/glad.c" 3 4
                             __null
# 322 "include/glad.c"
                                 ;
PFNGLCLEARBUFFERDATAPROC glad_glClearBufferData = 
# 323 "include/glad.c" 3 4
                                                 __null
# 323 "include/glad.c"
                                                     ;
PFNGLCLEARBUFFERSUBDATAPROC glad_glClearBufferSubData = 
# 324 "include/glad.c" 3 4
                                                       __null
# 324 "include/glad.c"
                                                           ;
PFNGLCLEARBUFFERFIPROC glad_glClearBufferfi = 
# 325 "include/glad.c" 3 4
                                             __null
# 325 "include/glad.c"
                                                 ;
PFNGLCLEARBUFFERFVPROC glad_glClearBufferfv = 
# 326 "include/glad.c" 3 4
                                             __null
# 326 "include/glad.c"
                                                 ;
PFNGLCLEARBUFFERIVPROC glad_glClearBufferiv = 
# 327 "include/glad.c" 3 4
                                             __null
# 327 "include/glad.c"
                                                 ;
PFNGLCLEARBUFFERUIVPROC glad_glClearBufferuiv = 
# 328 "include/glad.c" 3 4
                                               __null
# 328 "include/glad.c"
                                                   ;
PFNGLCLEARCOLORPROC glad_glClearColor = 
# 329 "include/glad.c" 3 4
                                       __null
# 329 "include/glad.c"
                                           ;
PFNGLCLEARDEPTHPROC glad_glClearDepth = 
# 330 "include/glad.c" 3 4
                                       __null
# 330 "include/glad.c"
                                           ;
PFNGLCLEARDEPTHFPROC glad_glClearDepthf = 
# 331 "include/glad.c" 3 4
                                         __null
# 331 "include/glad.c"
                                             ;
PFNGLCLEARNAMEDBUFFERDATAPROC glad_glClearNamedBufferData = 
# 332 "include/glad.c" 3 4
                                                           __null
# 332 "include/glad.c"
                                                               ;
PFNGLCLEARNAMEDBUFFERSUBDATAPROC glad_glClearNamedBufferSubData = 
# 333 "include/glad.c" 3 4
                                                                 __null
# 333 "include/glad.c"
                                                                     ;
PFNGLCLEARNAMEDFRAMEBUFFERFIPROC glad_glClearNamedFramebufferfi = 
# 334 "include/glad.c" 3 4
                                                                 __null
# 334 "include/glad.c"
                                                                     ;
PFNGLCLEARNAMEDFRAMEBUFFERFVPROC glad_glClearNamedFramebufferfv = 
# 335 "include/glad.c" 3 4
                                                                 __null
# 335 "include/glad.c"
                                                                     ;
PFNGLCLEARNAMEDFRAMEBUFFERIVPROC glad_glClearNamedFramebufferiv = 
# 336 "include/glad.c" 3 4
                                                                 __null
# 336 "include/glad.c"
                                                                     ;
PFNGLCLEARNAMEDFRAMEBUFFERUIVPROC glad_glClearNamedFramebufferuiv = 
# 337 "include/glad.c" 3 4
                                                                   __null
# 337 "include/glad.c"
                                                                       ;
PFNGLCLEARSTENCILPROC glad_glClearStencil = 
# 338 "include/glad.c" 3 4
                                           __null
# 338 "include/glad.c"
                                               ;
PFNGLCLEARTEXIMAGEPROC glad_glClearTexImage = 
# 339 "include/glad.c" 3 4
                                             __null
# 339 "include/glad.c"
                                                 ;
PFNGLCLEARTEXSUBIMAGEPROC glad_glClearTexSubImage = 
# 340 "include/glad.c" 3 4
                                                   __null
# 340 "include/glad.c"
                                                       ;
PFNGLCLIENTWAITSYNCPROC glad_glClientWaitSync = 
# 341 "include/glad.c" 3 4
                                               __null
# 341 "include/glad.c"
                                                   ;
PFNGLCLIPCONTROLPROC glad_glClipControl = 
# 342 "include/glad.c" 3 4
                                         __null
# 342 "include/glad.c"
                                             ;
PFNGLCOLORMASKPROC glad_glColorMask = 
# 343 "include/glad.c" 3 4
                                     __null
# 343 "include/glad.c"
                                         ;
PFNGLCOLORMASKIPROC glad_glColorMaski = 
# 344 "include/glad.c" 3 4
                                       __null
# 344 "include/glad.c"
                                           ;
PFNGLCOLORP3UIPROC glad_glColorP3ui = 
# 345 "include/glad.c" 3 4
                                     __null
# 345 "include/glad.c"
                                         ;
PFNGLCOLORP3UIVPROC glad_glColorP3uiv = 
# 346 "include/glad.c" 3 4
                                       __null
# 346 "include/glad.c"
                                           ;
PFNGLCOLORP4UIPROC glad_glColorP4ui = 
# 347 "include/glad.c" 3 4
                                     __null
# 347 "include/glad.c"
                                         ;
PFNGLCOLORP4UIVPROC glad_glColorP4uiv = 
# 348 "include/glad.c" 3 4
                                       __null
# 348 "include/glad.c"
                                           ;
PFNGLCOMPILESHADERPROC glad_glCompileShader = 
# 349 "include/glad.c" 3 4
                                             __null
# 349 "include/glad.c"
                                                 ;
PFNGLCOMPRESSEDTEXIMAGE1DPROC glad_glCompressedTexImage1D = 
# 350 "include/glad.c" 3 4
                                                           __null
# 350 "include/glad.c"
                                                               ;
PFNGLCOMPRESSEDTEXIMAGE2DPROC glad_glCompressedTexImage2D = 
# 351 "include/glad.c" 3 4
                                                           __null
# 351 "include/glad.c"
                                                               ;
PFNGLCOMPRESSEDTEXIMAGE3DPROC glad_glCompressedTexImage3D = 
# 352 "include/glad.c" 3 4
                                                           __null
# 352 "include/glad.c"
                                                               ;
PFNGLCOMPRESSEDTEXSUBIMAGE1DPROC glad_glCompressedTexSubImage1D = 
# 353 "include/glad.c" 3 4
                                                                 __null
# 353 "include/glad.c"
                                                                     ;
PFNGLCOMPRESSEDTEXSUBIMAGE2DPROC glad_glCompressedTexSubImage2D = 
# 354 "include/glad.c" 3 4
                                                                 __null
# 354 "include/glad.c"
                                                                     ;
PFNGLCOMPRESSEDTEXSUBIMAGE3DPROC glad_glCompressedTexSubImage3D = 
# 355 "include/glad.c" 3 4
                                                                 __null
# 355 "include/glad.c"
                                                                     ;
PFNGLCOMPRESSEDTEXTURESUBIMAGE1DPROC glad_glCompressedTextureSubImage1D = 
# 356 "include/glad.c" 3 4
                                                                         __null
# 356 "include/glad.c"
                                                                             ;
PFNGLCOMPRESSEDTEXTURESUBIMAGE2DPROC glad_glCompressedTextureSubImage2D = 
# 357 "include/glad.c" 3 4
                                                                         __null
# 357 "include/glad.c"
                                                                             ;
PFNGLCOMPRESSEDTEXTURESUBIMAGE3DPROC glad_glCompressedTextureSubImage3D = 
# 358 "include/glad.c" 3 4
                                                                         __null
# 358 "include/glad.c"
                                                                             ;
PFNGLCOPYBUFFERSUBDATAPROC glad_glCopyBufferSubData = 
# 359 "include/glad.c" 3 4
                                                     __null
# 359 "include/glad.c"
                                                         ;
PFNGLCOPYIMAGESUBDATAPROC glad_glCopyImageSubData = 
# 360 "include/glad.c" 3 4
                                                   __null
# 360 "include/glad.c"
                                                       ;
PFNGLCOPYNAMEDBUFFERSUBDATAPROC glad_glCopyNamedBufferSubData = 
# 361 "include/glad.c" 3 4
                                                               __null
# 361 "include/glad.c"
                                                                   ;
PFNGLCOPYTEXIMAGE1DPROC glad_glCopyTexImage1D = 
# 362 "include/glad.c" 3 4
                                               __null
# 362 "include/glad.c"
                                                   ;
PFNGLCOPYTEXIMAGE2DPROC glad_glCopyTexImage2D = 
# 363 "include/glad.c" 3 4
                                               __null
# 363 "include/glad.c"
                                                   ;
PFNGLCOPYTEXSUBIMAGE1DPROC glad_glCopyTexSubImage1D = 
# 364 "include/glad.c" 3 4
                                                     __null
# 364 "include/glad.c"
                                                         ;
PFNGLCOPYTEXSUBIMAGE2DPROC glad_glCopyTexSubImage2D = 
# 365 "include/glad.c" 3 4
                                                     __null
# 365 "include/glad.c"
                                                         ;
PFNGLCOPYTEXSUBIMAGE3DPROC glad_glCopyTexSubImage3D = 
# 366 "include/glad.c" 3 4
                                                     __null
# 366 "include/glad.c"
                                                         ;
PFNGLCOPYTEXTURESUBIMAGE1DPROC glad_glCopyTextureSubImage1D = 
# 367 "include/glad.c" 3 4
                                                             __null
# 367 "include/glad.c"
                                                                 ;
PFNGLCOPYTEXTURESUBIMAGE2DPROC glad_glCopyTextureSubImage2D = 
# 368 "include/glad.c" 3 4
                                                             __null
# 368 "include/glad.c"
                                                                 ;
PFNGLCOPYTEXTURESUBIMAGE3DPROC glad_glCopyTextureSubImage3D = 
# 369 "include/glad.c" 3 4
                                                             __null
# 369 "include/glad.c"
                                                                 ;
PFNGLCREATEBUFFERSPROC glad_glCreateBuffers = 
# 370 "include/glad.c" 3 4
                                             __null
# 370 "include/glad.c"
                                                 ;
PFNGLCREATEFRAMEBUFFERSPROC glad_glCreateFramebuffers = 
# 371 "include/glad.c" 3 4
                                                       __null
# 371 "include/glad.c"
                                                           ;
PFNGLCREATEPROGRAMPROC glad_glCreateProgram = 
# 372 "include/glad.c" 3 4
                                             __null
# 372 "include/glad.c"
                                                 ;
PFNGLCREATEPROGRAMPIPELINESPROC glad_glCreateProgramPipelines = 
# 373 "include/glad.c" 3 4
                                                               __null
# 373 "include/glad.c"
                                                                   ;
PFNGLCREATEQUERIESPROC glad_glCreateQueries = 
# 374 "include/glad.c" 3 4
                                             __null
# 374 "include/glad.c"
                                                 ;
PFNGLCREATERENDERBUFFERSPROC glad_glCreateRenderbuffers = 
# 375 "include/glad.c" 3 4
                                                         __null
# 375 "include/glad.c"
                                                             ;
PFNGLCREATESAMPLERSPROC glad_glCreateSamplers = 
# 376 "include/glad.c" 3 4
                                               __null
# 376 "include/glad.c"
                                                   ;
PFNGLCREATESHADERPROC glad_glCreateShader = 
# 377 "include/glad.c" 3 4
                                           __null
# 377 "include/glad.c"
                                               ;
PFNGLCREATESHADERPROGRAMVPROC glad_glCreateShaderProgramv = 
# 378 "include/glad.c" 3 4
                                                           __null
# 378 "include/glad.c"
                                                               ;
PFNGLCREATETEXTURESPROC glad_glCreateTextures = 
# 379 "include/glad.c" 3 4
                                               __null
# 379 "include/glad.c"
                                                   ;
PFNGLCREATETRANSFORMFEEDBACKSPROC glad_glCreateTransformFeedbacks = 
# 380 "include/glad.c" 3 4
                                                                   __null
# 380 "include/glad.c"
                                                                       ;
PFNGLCREATEVERTEXARRAYSPROC glad_glCreateVertexArrays = 
# 381 "include/glad.c" 3 4
                                                       __null
# 381 "include/glad.c"
                                                           ;
PFNGLCULLFACEPROC glad_glCullFace = 
# 382 "include/glad.c" 3 4
                                   __null
# 382 "include/glad.c"
                                       ;
PFNGLDEBUGMESSAGECALLBACKPROC glad_glDebugMessageCallback = 
# 383 "include/glad.c" 3 4
                                                           __null
# 383 "include/glad.c"
                                                               ;
PFNGLDEBUGMESSAGECONTROLPROC glad_glDebugMessageControl = 
# 384 "include/glad.c" 3 4
                                                         __null
# 384 "include/glad.c"
                                                             ;
PFNGLDEBUGMESSAGEINSERTPROC glad_glDebugMessageInsert = 
# 385 "include/glad.c" 3 4
                                                       __null
# 385 "include/glad.c"
                                                           ;
PFNGLDELETEBUFFERSPROC glad_glDeleteBuffers = 
# 386 "include/glad.c" 3 4
                                             __null
# 386 "include/glad.c"
                                                 ;
PFNGLDELETEFRAMEBUFFERSPROC glad_glDeleteFramebuffers = 
# 387 "include/glad.c" 3 4
                                                       __null
# 387 "include/glad.c"
                                                           ;
PFNGLDELETEPROGRAMPROC glad_glDeleteProgram = 
# 388 "include/glad.c" 3 4
                                             __null
# 388 "include/glad.c"
                                                 ;
PFNGLDELETEPROGRAMPIPELINESPROC glad_glDeleteProgramPipelines = 
# 389 "include/glad.c" 3 4
                                                               __null
# 389 "include/glad.c"
                                                                   ;
PFNGLDELETEQUERIESPROC glad_glDeleteQueries = 
# 390 "include/glad.c" 3 4
                                             __null
# 390 "include/glad.c"
                                                 ;
PFNGLDELETERENDERBUFFERSPROC glad_glDeleteRenderbuffers = 
# 391 "include/glad.c" 3 4
                                                         __null
# 391 "include/glad.c"
                                                             ;
PFNGLDELETESAMPLERSPROC glad_glDeleteSamplers = 
# 392 "include/glad.c" 3 4
                                               __null
# 392 "include/glad.c"
                                                   ;
PFNGLDELETESHADERPROC glad_glDeleteShader = 
# 393 "include/glad.c" 3 4
                                           __null
# 393 "include/glad.c"
                                               ;
PFNGLDELETESYNCPROC glad_glDeleteSync = 
# 394 "include/glad.c" 3 4
                                       __null
# 394 "include/glad.c"
                                           ;
PFNGLDELETETEXTURESPROC glad_glDeleteTextures = 
# 395 "include/glad.c" 3 4
                                               __null
# 395 "include/glad.c"
                                                   ;
PFNGLDELETETRANSFORMFEEDBACKSPROC glad_glDeleteTransformFeedbacks = 
# 396 "include/glad.c" 3 4
                                                                   __null
# 396 "include/glad.c"
                                                                       ;
PFNGLDELETEVERTEXARRAYSPROC glad_glDeleteVertexArrays = 
# 397 "include/glad.c" 3 4
                                                       __null
# 397 "include/glad.c"
                                                           ;
PFNGLDEPTHFUNCPROC glad_glDepthFunc = 
# 398 "include/glad.c" 3 4
                                     __null
# 398 "include/glad.c"
                                         ;
PFNGLDEPTHMASKPROC glad_glDepthMask = 
# 399 "include/glad.c" 3 4
                                     __null
# 399 "include/glad.c"
                                         ;
PFNGLDEPTHRANGEPROC glad_glDepthRange = 
# 400 "include/glad.c" 3 4
                                       __null
# 400 "include/glad.c"
                                           ;
PFNGLDEPTHRANGEARRAYVPROC glad_glDepthRangeArrayv = 
# 401 "include/glad.c" 3 4
                                                   __null
# 401 "include/glad.c"
                                                       ;
PFNGLDEPTHRANGEINDEXEDPROC glad_glDepthRangeIndexed = 
# 402 "include/glad.c" 3 4
                                                     __null
# 402 "include/glad.c"
                                                         ;
PFNGLDEPTHRANGEFPROC glad_glDepthRangef = 
# 403 "include/glad.c" 3 4
                                         __null
# 403 "include/glad.c"
                                             ;
PFNGLDETACHSHADERPROC glad_glDetachShader = 
# 404 "include/glad.c" 3 4
                                           __null
# 404 "include/glad.c"
                                               ;
PFNGLDISABLEPROC glad_glDisable = 
# 405 "include/glad.c" 3 4
                                 __null
# 405 "include/glad.c"
                                     ;
PFNGLDISABLEVERTEXARRAYATTRIBPROC glad_glDisableVertexArrayAttrib = 
# 406 "include/glad.c" 3 4
                                                                   __null
# 406 "include/glad.c"
                                                                       ;
PFNGLDISABLEVERTEXATTRIBARRAYPROC glad_glDisableVertexAttribArray = 
# 407 "include/glad.c" 3 4
                                                                   __null
# 407 "include/glad.c"
                                                                       ;
PFNGLDISABLEIPROC glad_glDisablei = 
# 408 "include/glad.c" 3 4
                                   __null
# 408 "include/glad.c"
                                       ;
PFNGLDISPATCHCOMPUTEPROC glad_glDispatchCompute = 
# 409 "include/glad.c" 3 4
                                                 __null
# 409 "include/glad.c"
                                                     ;
PFNGLDISPATCHCOMPUTEINDIRECTPROC glad_glDispatchComputeIndirect = 
# 410 "include/glad.c" 3 4
                                                                 __null
# 410 "include/glad.c"
                                                                     ;
PFNGLDRAWARRAYSPROC glad_glDrawArrays = 
# 411 "include/glad.c" 3 4
                                       __null
# 411 "include/glad.c"
                                           ;
PFNGLDRAWARRAYSINDIRECTPROC glad_glDrawArraysIndirect = 
# 412 "include/glad.c" 3 4
                                                       __null
# 412 "include/glad.c"
                                                           ;
PFNGLDRAWARRAYSINSTANCEDPROC glad_glDrawArraysInstanced = 
# 413 "include/glad.c" 3 4
                                                         __null
# 413 "include/glad.c"
                                                             ;
PFNGLDRAWARRAYSINSTANCEDBASEINSTANCEPROC glad_glDrawArraysInstancedBaseInstance = 
# 414 "include/glad.c" 3 4
                                                                                 __null
# 414 "include/glad.c"
                                                                                     ;
PFNGLDRAWBUFFERPROC glad_glDrawBuffer = 
# 415 "include/glad.c" 3 4
                                       __null
# 415 "include/glad.c"
                                           ;
PFNGLDRAWBUFFERSPROC glad_glDrawBuffers = 
# 416 "include/glad.c" 3 4
                                         __null
# 416 "include/glad.c"
                                             ;
PFNGLDRAWELEMENTSPROC glad_glDrawElements = 
# 417 "include/glad.c" 3 4
                                           __null
# 417 "include/glad.c"
                                               ;
PFNGLDRAWELEMENTSBASEVERTEXPROC glad_glDrawElementsBaseVertex = 
# 418 "include/glad.c" 3 4
                                                               __null
# 418 "include/glad.c"
                                                                   ;
PFNGLDRAWELEMENTSINDIRECTPROC glad_glDrawElementsIndirect = 
# 419 "include/glad.c" 3 4
                                                           __null
# 419 "include/glad.c"
                                                               ;
PFNGLDRAWELEMENTSINSTANCEDPROC glad_glDrawElementsInstanced = 
# 420 "include/glad.c" 3 4
                                                             __null
# 420 "include/glad.c"
                                                                 ;
PFNGLDRAWELEMENTSINSTANCEDBASEINSTANCEPROC glad_glDrawElementsInstancedBaseInstance = 
# 421 "include/glad.c" 3 4
                                                                                     __null
# 421 "include/glad.c"
                                                                                         ;
PFNGLDRAWELEMENTSINSTANCEDBASEVERTEXPROC glad_glDrawElementsInstancedBaseVertex = 
# 422 "include/glad.c" 3 4
                                                                                 __null
# 422 "include/glad.c"
                                                                                     ;
PFNGLDRAWELEMENTSINSTANCEDBASEVERTEXBASEINSTANCEPROC glad_glDrawElementsInstancedBaseVertexBaseInstance = 
# 423 "include/glad.c" 3 4
                                                                                                         __null
# 423 "include/glad.c"
                                                                                                             ;
PFNGLDRAWRANGEELEMENTSPROC glad_glDrawRangeElements = 
# 424 "include/glad.c" 3 4
                                                     __null
# 424 "include/glad.c"
                                                         ;
PFNGLDRAWRANGEELEMENTSBASEVERTEXPROC glad_glDrawRangeElementsBaseVertex = 
# 425 "include/glad.c" 3 4
                                                                         __null
# 425 "include/glad.c"
                                                                             ;
PFNGLDRAWTRANSFORMFEEDBACKPROC glad_glDrawTransformFeedback = 
# 426 "include/glad.c" 3 4
                                                             __null
# 426 "include/glad.c"
                                                                 ;
PFNGLDRAWTRANSFORMFEEDBACKINSTANCEDPROC glad_glDrawTransformFeedbackInstanced = 
# 427 "include/glad.c" 3 4
                                                                               __null
# 427 "include/glad.c"
                                                                                   ;
PFNGLDRAWTRANSFORMFEEDBACKSTREAMPROC glad_glDrawTransformFeedbackStream = 
# 428 "include/glad.c" 3 4
                                                                         __null
# 428 "include/glad.c"
                                                                             ;
PFNGLDRAWTRANSFORMFEEDBACKSTREAMINSTANCEDPROC glad_glDrawTransformFeedbackStreamInstanced = 
# 429 "include/glad.c" 3 4
                                                                                           __null
# 429 "include/glad.c"
                                                                                               ;
PFNGLENABLEPROC glad_glEnable = 
# 430 "include/glad.c" 3 4
                               __null
# 430 "include/glad.c"
                                   ;
PFNGLENABLEVERTEXARRAYATTRIBPROC glad_glEnableVertexArrayAttrib = 
# 431 "include/glad.c" 3 4
                                                                 __null
# 431 "include/glad.c"
                                                                     ;
PFNGLENABLEVERTEXATTRIBARRAYPROC glad_glEnableVertexAttribArray = 
# 432 "include/glad.c" 3 4
                                                                 __null
# 432 "include/glad.c"
                                                                     ;
PFNGLENABLEIPROC glad_glEnablei = 
# 433 "include/glad.c" 3 4
                                 __null
# 433 "include/glad.c"
                                     ;
PFNGLENDCONDITIONALRENDERPROC glad_glEndConditionalRender = 
# 434 "include/glad.c" 3 4
                                                           __null
# 434 "include/glad.c"
                                                               ;
PFNGLENDQUERYPROC glad_glEndQuery = 
# 435 "include/glad.c" 3 4
                                   __null
# 435 "include/glad.c"
                                       ;
PFNGLENDQUERYINDEXEDPROC glad_glEndQueryIndexed = 
# 436 "include/glad.c" 3 4
                                                 __null
# 436 "include/glad.c"
                                                     ;
PFNGLENDTRANSFORMFEEDBACKPROC glad_glEndTransformFeedback = 
# 437 "include/glad.c" 3 4
                                                           __null
# 437 "include/glad.c"
                                                               ;
PFNGLFENCESYNCPROC glad_glFenceSync = 
# 438 "include/glad.c" 3 4
                                     __null
# 438 "include/glad.c"
                                         ;
PFNGLFINISHPROC glad_glFinish = 
# 439 "include/glad.c" 3 4
                               __null
# 439 "include/glad.c"
                                   ;
PFNGLFLUSHPROC glad_glFlush = 
# 440 "include/glad.c" 3 4
                             __null
# 440 "include/glad.c"
                                 ;
PFNGLFLUSHMAPPEDBUFFERRANGEPROC glad_glFlushMappedBufferRange = 
# 441 "include/glad.c" 3 4
                                                               __null
# 441 "include/glad.c"
                                                                   ;
PFNGLFLUSHMAPPEDNAMEDBUFFERRANGEPROC glad_glFlushMappedNamedBufferRange = 
# 442 "include/glad.c" 3 4
                                                                         __null
# 442 "include/glad.c"
                                                                             ;
PFNGLFRAMEBUFFERPARAMETERIPROC glad_glFramebufferParameteri = 
# 443 "include/glad.c" 3 4
                                                             __null
# 443 "include/glad.c"
                                                                 ;
PFNGLFRAMEBUFFERRENDERBUFFERPROC glad_glFramebufferRenderbuffer = 
# 444 "include/glad.c" 3 4
                                                                 __null
# 444 "include/glad.c"
                                                                     ;
PFNGLFRAMEBUFFERTEXTUREPROC glad_glFramebufferTexture = 
# 445 "include/glad.c" 3 4
                                                       __null
# 445 "include/glad.c"
                                                           ;
PFNGLFRAMEBUFFERTEXTURE1DPROC glad_glFramebufferTexture1D = 
# 446 "include/glad.c" 3 4
                                                           __null
# 446 "include/glad.c"
                                                               ;
PFNGLFRAMEBUFFERTEXTURE2DPROC glad_glFramebufferTexture2D = 
# 447 "include/glad.c" 3 4
                                                           __null
# 447 "include/glad.c"
                                                               ;
PFNGLFRAMEBUFFERTEXTURE3DPROC glad_glFramebufferTexture3D = 
# 448 "include/glad.c" 3 4
                                                           __null
# 448 "include/glad.c"
                                                               ;
PFNGLFRAMEBUFFERTEXTURELAYERPROC glad_glFramebufferTextureLayer = 
# 449 "include/glad.c" 3 4
                                                                 __null
# 449 "include/glad.c"
                                                                     ;
PFNGLFRONTFACEPROC glad_glFrontFace = 
# 450 "include/glad.c" 3 4
                                     __null
# 450 "include/glad.c"
                                         ;
PFNGLGENBUFFERSPROC glad_glGenBuffers = 
# 451 "include/glad.c" 3 4
                                       __null
# 451 "include/glad.c"
                                           ;
PFNGLGENFRAMEBUFFERSPROC glad_glGenFramebuffers = 
# 452 "include/glad.c" 3 4
                                                 __null
# 452 "include/glad.c"
                                                     ;
PFNGLGENPROGRAMPIPELINESPROC glad_glGenProgramPipelines = 
# 453 "include/glad.c" 3 4
                                                         __null
# 453 "include/glad.c"
                                                             ;
PFNGLGENQUERIESPROC glad_glGenQueries = 
# 454 "include/glad.c" 3 4
                                       __null
# 454 "include/glad.c"
                                           ;
PFNGLGENRENDERBUFFERSPROC glad_glGenRenderbuffers = 
# 455 "include/glad.c" 3 4
                                                   __null
# 455 "include/glad.c"
                                                       ;
PFNGLGENSAMPLERSPROC glad_glGenSamplers = 
# 456 "include/glad.c" 3 4
                                         __null
# 456 "include/glad.c"
                                             ;
PFNGLGENTEXTURESPROC glad_glGenTextures = 
# 457 "include/glad.c" 3 4
                                         __null
# 457 "include/glad.c"
                                             ;
PFNGLGENTRANSFORMFEEDBACKSPROC glad_glGenTransformFeedbacks = 
# 458 "include/glad.c" 3 4
                                                             __null
# 458 "include/glad.c"
                                                                 ;
PFNGLGENVERTEXARRAYSPROC glad_glGenVertexArrays = 
# 459 "include/glad.c" 3 4
                                                 __null
# 459 "include/glad.c"
                                                     ;
PFNGLGENERATEMIPMAPPROC glad_glGenerateMipmap = 
# 460 "include/glad.c" 3 4
                                               __null
# 460 "include/glad.c"
                                                   ;
PFNGLGENERATETEXTUREMIPMAPPROC glad_glGenerateTextureMipmap = 
# 461 "include/glad.c" 3 4
                                                             __null
# 461 "include/glad.c"
                                                                 ;
PFNGLGETACTIVEATOMICCOUNTERBUFFERIVPROC glad_glGetActiveAtomicCounterBufferiv = 
# 462 "include/glad.c" 3 4
                                                                               __null
# 462 "include/glad.c"
                                                                                   ;
PFNGLGETACTIVEATTRIBPROC glad_glGetActiveAttrib = 
# 463 "include/glad.c" 3 4
                                                 __null
# 463 "include/glad.c"
                                                     ;
PFNGLGETACTIVESUBROUTINENAMEPROC glad_glGetActiveSubroutineName = 
# 464 "include/glad.c" 3 4
                                                                 __null
# 464 "include/glad.c"
                                                                     ;
PFNGLGETACTIVESUBROUTINEUNIFORMNAMEPROC glad_glGetActiveSubroutineUniformName = 
# 465 "include/glad.c" 3 4
                                                                               __null
# 465 "include/glad.c"
                                                                                   ;
PFNGLGETACTIVESUBROUTINEUNIFORMIVPROC glad_glGetActiveSubroutineUniformiv = 
# 466 "include/glad.c" 3 4
                                                                           __null
# 466 "include/glad.c"
                                                                               ;
PFNGLGETACTIVEUNIFORMPROC glad_glGetActiveUniform = 
# 467 "include/glad.c" 3 4
                                                   __null
# 467 "include/glad.c"
                                                       ;
PFNGLGETACTIVEUNIFORMBLOCKNAMEPROC glad_glGetActiveUniformBlockName = 
# 468 "include/glad.c" 3 4
                                                                     __null
# 468 "include/glad.c"
                                                                         ;
PFNGLGETACTIVEUNIFORMBLOCKIVPROC glad_glGetActiveUniformBlockiv = 
# 469 "include/glad.c" 3 4
                                                                 __null
# 469 "include/glad.c"
                                                                     ;
PFNGLGETACTIVEUNIFORMNAMEPROC glad_glGetActiveUniformName = 
# 470 "include/glad.c" 3 4
                                                           __null
# 470 "include/glad.c"
                                                               ;
PFNGLGETACTIVEUNIFORMSIVPROC glad_glGetActiveUniformsiv = 
# 471 "include/glad.c" 3 4
                                                         __null
# 471 "include/glad.c"
                                                             ;
PFNGLGETATTACHEDSHADERSPROC glad_glGetAttachedShaders = 
# 472 "include/glad.c" 3 4
                                                       __null
# 472 "include/glad.c"
                                                           ;
PFNGLGETATTRIBLOCATIONPROC glad_glGetAttribLocation = 
# 473 "include/glad.c" 3 4
                                                     __null
# 473 "include/glad.c"
                                                         ;
PFNGLGETBOOLEANI_VPROC glad_glGetBooleani_v = 
# 474 "include/glad.c" 3 4
                                             __null
# 474 "include/glad.c"
                                                 ;
PFNGLGETBOOLEANVPROC glad_glGetBooleanv = 
# 475 "include/glad.c" 3 4
                                         __null
# 475 "include/glad.c"
                                             ;
PFNGLGETBUFFERPARAMETERI64VPROC glad_glGetBufferParameteri64v = 
# 476 "include/glad.c" 3 4
                                                               __null
# 476 "include/glad.c"
                                                                   ;
PFNGLGETBUFFERPARAMETERIVPROC glad_glGetBufferParameteriv = 
# 477 "include/glad.c" 3 4
                                                           __null
# 477 "include/glad.c"
                                                               ;
PFNGLGETBUFFERPOINTERVPROC glad_glGetBufferPointerv = 
# 478 "include/glad.c" 3 4
                                                     __null
# 478 "include/glad.c"
                                                         ;
PFNGLGETBUFFERSUBDATAPROC glad_glGetBufferSubData = 
# 479 "include/glad.c" 3 4
                                                   __null
# 479 "include/glad.c"
                                                       ;
PFNGLGETCOMPRESSEDTEXIMAGEPROC glad_glGetCompressedTexImage = 
# 480 "include/glad.c" 3 4
                                                             __null
# 480 "include/glad.c"
                                                                 ;
PFNGLGETCOMPRESSEDTEXTUREIMAGEPROC glad_glGetCompressedTextureImage = 
# 481 "include/glad.c" 3 4
                                                                     __null
# 481 "include/glad.c"
                                                                         ;
PFNGLGETCOMPRESSEDTEXTURESUBIMAGEPROC glad_glGetCompressedTextureSubImage = 
# 482 "include/glad.c" 3 4
                                                                           __null
# 482 "include/glad.c"
                                                                               ;
PFNGLGETDEBUGMESSAGELOGPROC glad_glGetDebugMessageLog = 
# 483 "include/glad.c" 3 4
                                                       __null
# 483 "include/glad.c"
                                                           ;
PFNGLGETDOUBLEI_VPROC glad_glGetDoublei_v = 
# 484 "include/glad.c" 3 4
                                           __null
# 484 "include/glad.c"
                                               ;
PFNGLGETDOUBLEVPROC glad_glGetDoublev = 
# 485 "include/glad.c" 3 4
                                       __null
# 485 "include/glad.c"
                                           ;
PFNGLGETERRORPROC glad_glGetError = 
# 486 "include/glad.c" 3 4
                                   __null
# 486 "include/glad.c"
                                       ;
PFNGLGETFLOATI_VPROC glad_glGetFloati_v = 
# 487 "include/glad.c" 3 4
                                         __null
# 487 "include/glad.c"
                                             ;
PFNGLGETFLOATVPROC glad_glGetFloatv = 
# 488 "include/glad.c" 3 4
                                     __null
# 488 "include/glad.c"
                                         ;
PFNGLGETFRAGDATAINDEXPROC glad_glGetFragDataIndex = 
# 489 "include/glad.c" 3 4
                                                   __null
# 489 "include/glad.c"
                                                       ;
PFNGLGETFRAGDATALOCATIONPROC glad_glGetFragDataLocation = 
# 490 "include/glad.c" 3 4
                                                         __null
# 490 "include/glad.c"
                                                             ;
PFNGLGETFRAMEBUFFERATTACHMENTPARAMETERIVPROC glad_glGetFramebufferAttachmentParameteriv = 
# 491 "include/glad.c" 3 4
                                                                                         __null
# 491 "include/glad.c"
                                                                                             ;
PFNGLGETFRAMEBUFFERPARAMETERIVPROC glad_glGetFramebufferParameteriv = 
# 492 "include/glad.c" 3 4
                                                                     __null
# 492 "include/glad.c"
                                                                         ;
PFNGLGETGRAPHICSRESETSTATUSPROC glad_glGetGraphicsResetStatus = 
# 493 "include/glad.c" 3 4
                                                               __null
# 493 "include/glad.c"
                                                                   ;
PFNGLGETINTEGER64I_VPROC glad_glGetInteger64i_v = 
# 494 "include/glad.c" 3 4
                                                 __null
# 494 "include/glad.c"
                                                     ;
PFNGLGETINTEGER64VPROC glad_glGetInteger64v = 
# 495 "include/glad.c" 3 4
                                             __null
# 495 "include/glad.c"
                                                 ;
PFNGLGETINTEGERI_VPROC glad_glGetIntegeri_v = 
# 496 "include/glad.c" 3 4
                                             __null
# 496 "include/glad.c"
                                                 ;
PFNGLGETINTEGERVPROC glad_glGetIntegerv = 
# 497 "include/glad.c" 3 4
                                         __null
# 497 "include/glad.c"
                                             ;
PFNGLGETINTERNALFORMATI64VPROC glad_glGetInternalformati64v = 
# 498 "include/glad.c" 3 4
                                                             __null
# 498 "include/glad.c"
                                                                 ;
PFNGLGETINTERNALFORMATIVPROC glad_glGetInternalformativ = 
# 499 "include/glad.c" 3 4
                                                         __null
# 499 "include/glad.c"
                                                             ;
PFNGLGETMULTISAMPLEFVPROC glad_glGetMultisamplefv = 
# 500 "include/glad.c" 3 4
                                                   __null
# 500 "include/glad.c"
                                                       ;
PFNGLGETNAMEDBUFFERPARAMETERI64VPROC glad_glGetNamedBufferParameteri64v = 
# 501 "include/glad.c" 3 4
                                                                         __null
# 501 "include/glad.c"
                                                                             ;
PFNGLGETNAMEDBUFFERPARAMETERIVPROC glad_glGetNamedBufferParameteriv = 
# 502 "include/glad.c" 3 4
                                                                     __null
# 502 "include/glad.c"
                                                                         ;
PFNGLGETNAMEDBUFFERPOINTERVPROC glad_glGetNamedBufferPointerv = 
# 503 "include/glad.c" 3 4
                                                               __null
# 503 "include/glad.c"
                                                                   ;
PFNGLGETNAMEDBUFFERSUBDATAPROC glad_glGetNamedBufferSubData = 
# 504 "include/glad.c" 3 4
                                                             __null
# 504 "include/glad.c"
                                                                 ;
PFNGLGETNAMEDFRAMEBUFFERATTACHMENTPARAMETERIVPROC glad_glGetNamedFramebufferAttachmentParameteriv = 
# 505 "include/glad.c" 3 4
                                                                                                   __null
# 505 "include/glad.c"
                                                                                                       ;
PFNGLGETNAMEDFRAMEBUFFERPARAMETERIVPROC glad_glGetNamedFramebufferParameteriv = 
# 506 "include/glad.c" 3 4
                                                                               __null
# 506 "include/glad.c"
                                                                                   ;
PFNGLGETNAMEDRENDERBUFFERPARAMETERIVPROC glad_glGetNamedRenderbufferParameteriv = 
# 507 "include/glad.c" 3 4
                                                                                 __null
# 507 "include/glad.c"
                                                                                     ;
PFNGLGETOBJECTLABELPROC glad_glGetObjectLabel = 
# 508 "include/glad.c" 3 4
                                               __null
# 508 "include/glad.c"
                                                   ;
PFNGLGETOBJECTPTRLABELPROC glad_glGetObjectPtrLabel = 
# 509 "include/glad.c" 3 4
                                                     __null
# 509 "include/glad.c"
                                                         ;
PFNGLGETPOINTERVPROC glad_glGetPointerv = 
# 510 "include/glad.c" 3 4
                                         __null
# 510 "include/glad.c"
                                             ;
PFNGLGETPROGRAMBINARYPROC glad_glGetProgramBinary = 
# 511 "include/glad.c" 3 4
                                                   __null
# 511 "include/glad.c"
                                                       ;
PFNGLGETPROGRAMINFOLOGPROC glad_glGetProgramInfoLog = 
# 512 "include/glad.c" 3 4
                                                     __null
# 512 "include/glad.c"
                                                         ;
PFNGLGETPROGRAMINTERFACEIVPROC glad_glGetProgramInterfaceiv = 
# 513 "include/glad.c" 3 4
                                                             __null
# 513 "include/glad.c"
                                                                 ;
PFNGLGETPROGRAMPIPELINEINFOLOGPROC glad_glGetProgramPipelineInfoLog = 
# 514 "include/glad.c" 3 4
                                                                     __null
# 514 "include/glad.c"
                                                                         ;
PFNGLGETPROGRAMPIPELINEIVPROC glad_glGetProgramPipelineiv = 
# 515 "include/glad.c" 3 4
                                                           __null
# 515 "include/glad.c"
                                                               ;
PFNGLGETPROGRAMRESOURCEINDEXPROC glad_glGetProgramResourceIndex = 
# 516 "include/glad.c" 3 4
                                                                 __null
# 516 "include/glad.c"
                                                                     ;
PFNGLGETPROGRAMRESOURCELOCATIONPROC glad_glGetProgramResourceLocation = 
# 517 "include/glad.c" 3 4
                                                                       __null
# 517 "include/glad.c"
                                                                           ;
PFNGLGETPROGRAMRESOURCELOCATIONINDEXPROC glad_glGetProgramResourceLocationIndex = 
# 518 "include/glad.c" 3 4
                                                                                 __null
# 518 "include/glad.c"
                                                                                     ;
PFNGLGETPROGRAMRESOURCENAMEPROC glad_glGetProgramResourceName = 
# 519 "include/glad.c" 3 4
                                                               __null
# 519 "include/glad.c"
                                                                   ;
PFNGLGETPROGRAMRESOURCEIVPROC glad_glGetProgramResourceiv = 
# 520 "include/glad.c" 3 4
                                                           __null
# 520 "include/glad.c"
                                                               ;
PFNGLGETPROGRAMSTAGEIVPROC glad_glGetProgramStageiv = 
# 521 "include/glad.c" 3 4
                                                     __null
# 521 "include/glad.c"
                                                         ;
PFNGLGETPROGRAMIVPROC glad_glGetProgramiv = 
# 522 "include/glad.c" 3 4
                                           __null
# 522 "include/glad.c"
                                               ;
PFNGLGETQUERYBUFFEROBJECTI64VPROC glad_glGetQueryBufferObjecti64v = 
# 523 "include/glad.c" 3 4
                                                                   __null
# 523 "include/glad.c"
                                                                       ;
PFNGLGETQUERYBUFFEROBJECTIVPROC glad_glGetQueryBufferObjectiv = 
# 524 "include/glad.c" 3 4
                                                               __null
# 524 "include/glad.c"
                                                                   ;
PFNGLGETQUERYBUFFEROBJECTUI64VPROC glad_glGetQueryBufferObjectui64v = 
# 525 "include/glad.c" 3 4
                                                                     __null
# 525 "include/glad.c"
                                                                         ;
PFNGLGETQUERYBUFFEROBJECTUIVPROC glad_glGetQueryBufferObjectuiv = 
# 526 "include/glad.c" 3 4
                                                                 __null
# 526 "include/glad.c"
                                                                     ;
PFNGLGETQUERYINDEXEDIVPROC glad_glGetQueryIndexediv = 
# 527 "include/glad.c" 3 4
                                                     __null
# 527 "include/glad.c"
                                                         ;
PFNGLGETQUERYOBJECTI64VPROC glad_glGetQueryObjecti64v = 
# 528 "include/glad.c" 3 4
                                                       __null
# 528 "include/glad.c"
                                                           ;
PFNGLGETQUERYOBJECTIVPROC glad_glGetQueryObjectiv = 
# 529 "include/glad.c" 3 4
                                                   __null
# 529 "include/glad.c"
                                                       ;
PFNGLGETQUERYOBJECTUI64VPROC glad_glGetQueryObjectui64v = 
# 530 "include/glad.c" 3 4
                                                         __null
# 530 "include/glad.c"
                                                             ;
PFNGLGETQUERYOBJECTUIVPROC glad_glGetQueryObjectuiv = 
# 531 "include/glad.c" 3 4
                                                     __null
# 531 "include/glad.c"
                                                         ;
PFNGLGETQUERYIVPROC glad_glGetQueryiv = 
# 532 "include/glad.c" 3 4
                                       __null
# 532 "include/glad.c"
                                           ;
PFNGLGETRENDERBUFFERPARAMETERIVPROC glad_glGetRenderbufferParameteriv = 
# 533 "include/glad.c" 3 4
                                                                       __null
# 533 "include/glad.c"
                                                                           ;
PFNGLGETSAMPLERPARAMETERIIVPROC glad_glGetSamplerParameterIiv = 
# 534 "include/glad.c" 3 4
                                                               __null
# 534 "include/glad.c"
                                                                   ;
PFNGLGETSAMPLERPARAMETERIUIVPROC glad_glGetSamplerParameterIuiv = 
# 535 "include/glad.c" 3 4
                                                                 __null
# 535 "include/glad.c"
                                                                     ;
PFNGLGETSAMPLERPARAMETERFVPROC glad_glGetSamplerParameterfv = 
# 536 "include/glad.c" 3 4
                                                             __null
# 536 "include/glad.c"
                                                                 ;
PFNGLGETSAMPLERPARAMETERIVPROC glad_glGetSamplerParameteriv = 
# 537 "include/glad.c" 3 4
                                                             __null
# 537 "include/glad.c"
                                                                 ;
PFNGLGETSHADERINFOLOGPROC glad_glGetShaderInfoLog = 
# 538 "include/glad.c" 3 4
                                                   __null
# 538 "include/glad.c"
                                                       ;
PFNGLGETSHADERPRECISIONFORMATPROC glad_glGetShaderPrecisionFormat = 
# 539 "include/glad.c" 3 4
                                                                   __null
# 539 "include/glad.c"
                                                                       ;
PFNGLGETSHADERSOURCEPROC glad_glGetShaderSource = 
# 540 "include/glad.c" 3 4
                                                 __null
# 540 "include/glad.c"
                                                     ;
PFNGLGETSHADERIVPROC glad_glGetShaderiv = 
# 541 "include/glad.c" 3 4
                                         __null
# 541 "include/glad.c"
                                             ;
PFNGLGETSTRINGPROC glad_glGetString = 
# 542 "include/glad.c" 3 4
                                     __null
# 542 "include/glad.c"
                                         ;
PFNGLGETSTRINGIPROC glad_glGetStringi = 
# 543 "include/glad.c" 3 4
                                       __null
# 543 "include/glad.c"
                                           ;
PFNGLGETSUBROUTINEINDEXPROC glad_glGetSubroutineIndex = 
# 544 "include/glad.c" 3 4
                                                       __null
# 544 "include/glad.c"
                                                           ;
PFNGLGETSUBROUTINEUNIFORMLOCATIONPROC glad_glGetSubroutineUniformLocation = 
# 545 "include/glad.c" 3 4
                                                                           __null
# 545 "include/glad.c"
                                                                               ;
PFNGLGETSYNCIVPROC glad_glGetSynciv = 
# 546 "include/glad.c" 3 4
                                     __null
# 546 "include/glad.c"
                                         ;
PFNGLGETTEXIMAGEPROC glad_glGetTexImage = 
# 547 "include/glad.c" 3 4
                                         __null
# 547 "include/glad.c"
                                             ;
PFNGLGETTEXLEVELPARAMETERFVPROC glad_glGetTexLevelParameterfv = 
# 548 "include/glad.c" 3 4
                                                               __null
# 548 "include/glad.c"
                                                                   ;
PFNGLGETTEXLEVELPARAMETERIVPROC glad_glGetTexLevelParameteriv = 
# 549 "include/glad.c" 3 4
                                                               __null
# 549 "include/glad.c"
                                                                   ;
PFNGLGETTEXPARAMETERIIVPROC glad_glGetTexParameterIiv = 
# 550 "include/glad.c" 3 4
                                                       __null
# 550 "include/glad.c"
                                                           ;
PFNGLGETTEXPARAMETERIUIVPROC glad_glGetTexParameterIuiv = 
# 551 "include/glad.c" 3 4
                                                         __null
# 551 "include/glad.c"
                                                             ;
PFNGLGETTEXPARAMETERFVPROC glad_glGetTexParameterfv = 
# 552 "include/glad.c" 3 4
                                                     __null
# 552 "include/glad.c"
                                                         ;
PFNGLGETTEXPARAMETERIVPROC glad_glGetTexParameteriv = 
# 553 "include/glad.c" 3 4
                                                     __null
# 553 "include/glad.c"
                                                         ;
PFNGLGETTEXTUREIMAGEPROC glad_glGetTextureImage = 
# 554 "include/glad.c" 3 4
                                                 __null
# 554 "include/glad.c"
                                                     ;
PFNGLGETTEXTURELEVELPARAMETERFVPROC glad_glGetTextureLevelParameterfv = 
# 555 "include/glad.c" 3 4
                                                                       __null
# 555 "include/glad.c"
                                                                           ;
PFNGLGETTEXTURELEVELPARAMETERIVPROC glad_glGetTextureLevelParameteriv = 
# 556 "include/glad.c" 3 4
                                                                       __null
# 556 "include/glad.c"
                                                                           ;
PFNGLGETTEXTUREPARAMETERIIVPROC glad_glGetTextureParameterIiv = 
# 557 "include/glad.c" 3 4
                                                               __null
# 557 "include/glad.c"
                                                                   ;
PFNGLGETTEXTUREPARAMETERIUIVPROC glad_glGetTextureParameterIuiv = 
# 558 "include/glad.c" 3 4
                                                                 __null
# 558 "include/glad.c"
                                                                     ;
PFNGLGETTEXTUREPARAMETERFVPROC glad_glGetTextureParameterfv = 
# 559 "include/glad.c" 3 4
                                                             __null
# 559 "include/glad.c"
                                                                 ;
PFNGLGETTEXTUREPARAMETERIVPROC glad_glGetTextureParameteriv = 
# 560 "include/glad.c" 3 4
                                                             __null
# 560 "include/glad.c"
                                                                 ;
PFNGLGETTEXTURESUBIMAGEPROC glad_glGetTextureSubImage = 
# 561 "include/glad.c" 3 4
                                                       __null
# 561 "include/glad.c"
                                                           ;
PFNGLGETTRANSFORMFEEDBACKVARYINGPROC glad_glGetTransformFeedbackVarying = 
# 562 "include/glad.c" 3 4
                                                                         __null
# 562 "include/glad.c"
                                                                             ;
PFNGLGETTRANSFORMFEEDBACKI64_VPROC glad_glGetTransformFeedbacki64_v = 
# 563 "include/glad.c" 3 4
                                                                     __null
# 563 "include/glad.c"
                                                                         ;
PFNGLGETTRANSFORMFEEDBACKI_VPROC glad_glGetTransformFeedbacki_v = 
# 564 "include/glad.c" 3 4
                                                                 __null
# 564 "include/glad.c"
                                                                     ;
PFNGLGETTRANSFORMFEEDBACKIVPROC glad_glGetTransformFeedbackiv = 
# 565 "include/glad.c" 3 4
                                                               __null
# 565 "include/glad.c"
                                                                   ;
PFNGLGETUNIFORMBLOCKINDEXPROC glad_glGetUniformBlockIndex = 
# 566 "include/glad.c" 3 4
                                                           __null
# 566 "include/glad.c"
                                                               ;
PFNGLGETUNIFORMINDICESPROC glad_glGetUniformIndices = 
# 567 "include/glad.c" 3 4
                                                     __null
# 567 "include/glad.c"
                                                         ;
PFNGLGETUNIFORMLOCATIONPROC glad_glGetUniformLocation = 
# 568 "include/glad.c" 3 4
                                                       __null
# 568 "include/glad.c"
                                                           ;
PFNGLGETUNIFORMSUBROUTINEUIVPROC glad_glGetUniformSubroutineuiv = 
# 569 "include/glad.c" 3 4
                                                                 __null
# 569 "include/glad.c"
                                                                     ;
PFNGLGETUNIFORMDVPROC glad_glGetUniformdv = 
# 570 "include/glad.c" 3 4
                                           __null
# 570 "include/glad.c"
                                               ;
PFNGLGETUNIFORMFVPROC glad_glGetUniformfv = 
# 571 "include/glad.c" 3 4
                                           __null
# 571 "include/glad.c"
                                               ;
PFNGLGETUNIFORMIVPROC glad_glGetUniformiv = 
# 572 "include/glad.c" 3 4
                                           __null
# 572 "include/glad.c"
                                               ;
PFNGLGETUNIFORMUIVPROC glad_glGetUniformuiv = 
# 573 "include/glad.c" 3 4
                                             __null
# 573 "include/glad.c"
                                                 ;
PFNGLGETVERTEXARRAYINDEXED64IVPROC glad_glGetVertexArrayIndexed64iv = 
# 574 "include/glad.c" 3 4
                                                                     __null
# 574 "include/glad.c"
                                                                         ;
PFNGLGETVERTEXARRAYINDEXEDIVPROC glad_glGetVertexArrayIndexediv = 
# 575 "include/glad.c" 3 4
                                                                 __null
# 575 "include/glad.c"
                                                                     ;
PFNGLGETVERTEXARRAYIVPROC glad_glGetVertexArrayiv = 
# 576 "include/glad.c" 3 4
                                                   __null
# 576 "include/glad.c"
                                                       ;
PFNGLGETVERTEXATTRIBIIVPROC glad_glGetVertexAttribIiv = 
# 577 "include/glad.c" 3 4
                                                       __null
# 577 "include/glad.c"
                                                           ;
PFNGLGETVERTEXATTRIBIUIVPROC glad_glGetVertexAttribIuiv = 
# 578 "include/glad.c" 3 4
                                                         __null
# 578 "include/glad.c"
                                                             ;
PFNGLGETVERTEXATTRIBLDVPROC glad_glGetVertexAttribLdv = 
# 579 "include/glad.c" 3 4
                                                       __null
# 579 "include/glad.c"
                                                           ;
PFNGLGETVERTEXATTRIBPOINTERVPROC glad_glGetVertexAttribPointerv = 
# 580 "include/glad.c" 3 4
                                                                 __null
# 580 "include/glad.c"
                                                                     ;
PFNGLGETVERTEXATTRIBDVPROC glad_glGetVertexAttribdv = 
# 581 "include/glad.c" 3 4
                                                     __null
# 581 "include/glad.c"
                                                         ;
PFNGLGETVERTEXATTRIBFVPROC glad_glGetVertexAttribfv = 
# 582 "include/glad.c" 3 4
                                                     __null
# 582 "include/glad.c"
                                                         ;
PFNGLGETVERTEXATTRIBIVPROC glad_glGetVertexAttribiv = 
# 583 "include/glad.c" 3 4
                                                     __null
# 583 "include/glad.c"
                                                         ;
PFNGLGETNCOLORTABLEPROC glad_glGetnColorTable = 
# 584 "include/glad.c" 3 4
                                               __null
# 584 "include/glad.c"
                                                   ;
PFNGLGETNCOMPRESSEDTEXIMAGEPROC glad_glGetnCompressedTexImage = 
# 585 "include/glad.c" 3 4
                                                               __null
# 585 "include/glad.c"
                                                                   ;
PFNGLGETNCONVOLUTIONFILTERPROC glad_glGetnConvolutionFilter = 
# 586 "include/glad.c" 3 4
                                                             __null
# 586 "include/glad.c"
                                                                 ;
PFNGLGETNHISTOGRAMPROC glad_glGetnHistogram = 
# 587 "include/glad.c" 3 4
                                             __null
# 587 "include/glad.c"
                                                 ;
PFNGLGETNMAPDVPROC glad_glGetnMapdv = 
# 588 "include/glad.c" 3 4
                                     __null
# 588 "include/glad.c"
                                         ;
PFNGLGETNMAPFVPROC glad_glGetnMapfv = 
# 589 "include/glad.c" 3 4
                                     __null
# 589 "include/glad.c"
                                         ;
PFNGLGETNMAPIVPROC glad_glGetnMapiv = 
# 590 "include/glad.c" 3 4
                                     __null
# 590 "include/glad.c"
                                         ;
PFNGLGETNMINMAXPROC glad_glGetnMinmax = 
# 591 "include/glad.c" 3 4
                                       __null
# 591 "include/glad.c"
                                           ;
PFNGLGETNPIXELMAPFVPROC glad_glGetnPixelMapfv = 
# 592 "include/glad.c" 3 4
                                               __null
# 592 "include/glad.c"
                                                   ;
PFNGLGETNPIXELMAPUIVPROC glad_glGetnPixelMapuiv = 
# 593 "include/glad.c" 3 4
                                                 __null
# 593 "include/glad.c"
                                                     ;
PFNGLGETNPIXELMAPUSVPROC glad_glGetnPixelMapusv = 
# 594 "include/glad.c" 3 4
                                                 __null
# 594 "include/glad.c"
                                                     ;
PFNGLGETNPOLYGONSTIPPLEPROC glad_glGetnPolygonStipple = 
# 595 "include/glad.c" 3 4
                                                       __null
# 595 "include/glad.c"
                                                           ;
PFNGLGETNSEPARABLEFILTERPROC glad_glGetnSeparableFilter = 
# 596 "include/glad.c" 3 4
                                                         __null
# 596 "include/glad.c"
                                                             ;
PFNGLGETNTEXIMAGEPROC glad_glGetnTexImage = 
# 597 "include/glad.c" 3 4
                                           __null
# 597 "include/glad.c"
                                               ;
PFNGLGETNUNIFORMDVPROC glad_glGetnUniformdv = 
# 598 "include/glad.c" 3 4
                                             __null
# 598 "include/glad.c"
                                                 ;
PFNGLGETNUNIFORMFVPROC glad_glGetnUniformfv = 
# 599 "include/glad.c" 3 4
                                             __null
# 599 "include/glad.c"
                                                 ;
PFNGLGETNUNIFORMIVPROC glad_glGetnUniformiv = 
# 600 "include/glad.c" 3 4
                                             __null
# 600 "include/glad.c"
                                                 ;
PFNGLGETNUNIFORMUIVPROC glad_glGetnUniformuiv = 
# 601 "include/glad.c" 3 4
                                               __null
# 601 "include/glad.c"
                                                   ;
PFNGLHINTPROC glad_glHint = 
# 602 "include/glad.c" 3 4
                           __null
# 602 "include/glad.c"
                               ;
PFNGLINVALIDATEBUFFERDATAPROC glad_glInvalidateBufferData = 
# 603 "include/glad.c" 3 4
                                                           __null
# 603 "include/glad.c"
                                                               ;
PFNGLINVALIDATEBUFFERSUBDATAPROC glad_glInvalidateBufferSubData = 
# 604 "include/glad.c" 3 4
                                                                 __null
# 604 "include/glad.c"
                                                                     ;
PFNGLINVALIDATEFRAMEBUFFERPROC glad_glInvalidateFramebuffer = 
# 605 "include/glad.c" 3 4
                                                             __null
# 605 "include/glad.c"
                                                                 ;
PFNGLINVALIDATENAMEDFRAMEBUFFERDATAPROC glad_glInvalidateNamedFramebufferData = 
# 606 "include/glad.c" 3 4
                                                                               __null
# 606 "include/glad.c"
                                                                                   ;
PFNGLINVALIDATENAMEDFRAMEBUFFERSUBDATAPROC glad_glInvalidateNamedFramebufferSubData = 
# 607 "include/glad.c" 3 4
                                                                                     __null
# 607 "include/glad.c"
                                                                                         ;
PFNGLINVALIDATESUBFRAMEBUFFERPROC glad_glInvalidateSubFramebuffer = 
# 608 "include/glad.c" 3 4
                                                                   __null
# 608 "include/glad.c"
                                                                       ;
PFNGLINVALIDATETEXIMAGEPROC glad_glInvalidateTexImage = 
# 609 "include/glad.c" 3 4
                                                       __null
# 609 "include/glad.c"
                                                           ;
PFNGLINVALIDATETEXSUBIMAGEPROC glad_glInvalidateTexSubImage = 
# 610 "include/glad.c" 3 4
                                                             __null
# 610 "include/glad.c"
                                                                 ;
PFNGLISBUFFERPROC glad_glIsBuffer = 
# 611 "include/glad.c" 3 4
                                   __null
# 611 "include/glad.c"
                                       ;
PFNGLISENABLEDPROC glad_glIsEnabled = 
# 612 "include/glad.c" 3 4
                                     __null
# 612 "include/glad.c"
                                         ;
PFNGLISENABLEDIPROC glad_glIsEnabledi = 
# 613 "include/glad.c" 3 4
                                       __null
# 613 "include/glad.c"
                                           ;
PFNGLISFRAMEBUFFERPROC glad_glIsFramebuffer = 
# 614 "include/glad.c" 3 4
                                             __null
# 614 "include/glad.c"
                                                 ;
PFNGLISPROGRAMPROC glad_glIsProgram = 
# 615 "include/glad.c" 3 4
                                     __null
# 615 "include/glad.c"
                                         ;
PFNGLISPROGRAMPIPELINEPROC glad_glIsProgramPipeline = 
# 616 "include/glad.c" 3 4
                                                     __null
# 616 "include/glad.c"
                                                         ;
PFNGLISQUERYPROC glad_glIsQuery = 
# 617 "include/glad.c" 3 4
                                 __null
# 617 "include/glad.c"
                                     ;
PFNGLISRENDERBUFFERPROC glad_glIsRenderbuffer = 
# 618 "include/glad.c" 3 4
                                               __null
# 618 "include/glad.c"
                                                   ;
PFNGLISSAMPLERPROC glad_glIsSampler = 
# 619 "include/glad.c" 3 4
                                     __null
# 619 "include/glad.c"
                                         ;
PFNGLISSHADERPROC glad_glIsShader = 
# 620 "include/glad.c" 3 4
                                   __null
# 620 "include/glad.c"
                                       ;
PFNGLISSYNCPROC glad_glIsSync = 
# 621 "include/glad.c" 3 4
                               __null
# 621 "include/glad.c"
                                   ;
PFNGLISTEXTUREPROC glad_glIsTexture = 
# 622 "include/glad.c" 3 4
                                     __null
# 622 "include/glad.c"
                                         ;
PFNGLISTRANSFORMFEEDBACKPROC glad_glIsTransformFeedback = 
# 623 "include/glad.c" 3 4
                                                         __null
# 623 "include/glad.c"
                                                             ;
PFNGLISVERTEXARRAYPROC glad_glIsVertexArray = 
# 624 "include/glad.c" 3 4
                                             __null
# 624 "include/glad.c"
                                                 ;
PFNGLLINEWIDTHPROC glad_glLineWidth = 
# 625 "include/glad.c" 3 4
                                     __null
# 625 "include/glad.c"
                                         ;
PFNGLLINKPROGRAMPROC glad_glLinkProgram = 
# 626 "include/glad.c" 3 4
                                         __null
# 626 "include/glad.c"
                                             ;
PFNGLLOGICOPPROC glad_glLogicOp = 
# 627 "include/glad.c" 3 4
                                 __null
# 627 "include/glad.c"
                                     ;
PFNGLMAPBUFFERPROC glad_glMapBuffer = 
# 628 "include/glad.c" 3 4
                                     __null
# 628 "include/glad.c"
                                         ;
PFNGLMAPBUFFERRANGEPROC glad_glMapBufferRange = 
# 629 "include/glad.c" 3 4
                                               __null
# 629 "include/glad.c"
                                                   ;
PFNGLMAPNAMEDBUFFERPROC glad_glMapNamedBuffer = 
# 630 "include/glad.c" 3 4
                                               __null
# 630 "include/glad.c"
                                                   ;
PFNGLMAPNAMEDBUFFERRANGEPROC glad_glMapNamedBufferRange = 
# 631 "include/glad.c" 3 4
                                                         __null
# 631 "include/glad.c"
                                                             ;
PFNGLMEMORYBARRIERPROC glad_glMemoryBarrier = 
# 632 "include/glad.c" 3 4
                                             __null
# 632 "include/glad.c"
                                                 ;
PFNGLMEMORYBARRIERBYREGIONPROC glad_glMemoryBarrierByRegion = 
# 633 "include/glad.c" 3 4
                                                             __null
# 633 "include/glad.c"
                                                                 ;
PFNGLMINSAMPLESHADINGPROC glad_glMinSampleShading = 
# 634 "include/glad.c" 3 4
                                                   __null
# 634 "include/glad.c"
                                                       ;
PFNGLMULTIDRAWARRAYSPROC glad_glMultiDrawArrays = 
# 635 "include/glad.c" 3 4
                                                 __null
# 635 "include/glad.c"
                                                     ;
PFNGLMULTIDRAWARRAYSINDIRECTPROC glad_glMultiDrawArraysIndirect = 
# 636 "include/glad.c" 3 4
                                                                 __null
# 636 "include/glad.c"
                                                                     ;
PFNGLMULTIDRAWELEMENTSPROC glad_glMultiDrawElements = 
# 637 "include/glad.c" 3 4
                                                     __null
# 637 "include/glad.c"
                                                         ;
PFNGLMULTIDRAWELEMENTSBASEVERTEXPROC glad_glMultiDrawElementsBaseVertex = 
# 638 "include/glad.c" 3 4
                                                                         __null
# 638 "include/glad.c"
                                                                             ;
PFNGLMULTIDRAWELEMENTSINDIRECTPROC glad_glMultiDrawElementsIndirect = 
# 639 "include/glad.c" 3 4
                                                                     __null
# 639 "include/glad.c"
                                                                         ;
PFNGLMULTITEXCOORDP1UIPROC glad_glMultiTexCoordP1ui = 
# 640 "include/glad.c" 3 4
                                                     __null
# 640 "include/glad.c"
                                                         ;
PFNGLMULTITEXCOORDP1UIVPROC glad_glMultiTexCoordP1uiv = 
# 641 "include/glad.c" 3 4
                                                       __null
# 641 "include/glad.c"
                                                           ;
PFNGLMULTITEXCOORDP2UIPROC glad_glMultiTexCoordP2ui = 
# 642 "include/glad.c" 3 4
                                                     __null
# 642 "include/glad.c"
                                                         ;
PFNGLMULTITEXCOORDP2UIVPROC glad_glMultiTexCoordP2uiv = 
# 643 "include/glad.c" 3 4
                                                       __null
# 643 "include/glad.c"
                                                           ;
PFNGLMULTITEXCOORDP3UIPROC glad_glMultiTexCoordP3ui = 
# 644 "include/glad.c" 3 4
                                                     __null
# 644 "include/glad.c"
                                                         ;
PFNGLMULTITEXCOORDP3UIVPROC glad_glMultiTexCoordP3uiv = 
# 645 "include/glad.c" 3 4
                                                       __null
# 645 "include/glad.c"
                                                           ;
PFNGLMULTITEXCOORDP4UIPROC glad_glMultiTexCoordP4ui = 
# 646 "include/glad.c" 3 4
                                                     __null
# 646 "include/glad.c"
                                                         ;
PFNGLMULTITEXCOORDP4UIVPROC glad_glMultiTexCoordP4uiv = 
# 647 "include/glad.c" 3 4
                                                       __null
# 647 "include/glad.c"
                                                           ;
PFNGLNAMEDBUFFERDATAPROC glad_glNamedBufferData = 
# 648 "include/glad.c" 3 4
                                                 __null
# 648 "include/glad.c"
                                                     ;
PFNGLNAMEDBUFFERSTORAGEPROC glad_glNamedBufferStorage = 
# 649 "include/glad.c" 3 4
                                                       __null
# 649 "include/glad.c"
                                                           ;
PFNGLNAMEDBUFFERSUBDATAPROC glad_glNamedBufferSubData = 
# 650 "include/glad.c" 3 4
                                                       __null
# 650 "include/glad.c"
                                                           ;
PFNGLNAMEDFRAMEBUFFERDRAWBUFFERPROC glad_glNamedFramebufferDrawBuffer = 
# 651 "include/glad.c" 3 4
                                                                       __null
# 651 "include/glad.c"
                                                                           ;
PFNGLNAMEDFRAMEBUFFERDRAWBUFFERSPROC glad_glNamedFramebufferDrawBuffers = 
# 652 "include/glad.c" 3 4
                                                                         __null
# 652 "include/glad.c"
                                                                             ;
PFNGLNAMEDFRAMEBUFFERPARAMETERIPROC glad_glNamedFramebufferParameteri = 
# 653 "include/glad.c" 3 4
                                                                       __null
# 653 "include/glad.c"
                                                                           ;
PFNGLNAMEDFRAMEBUFFERREADBUFFERPROC glad_glNamedFramebufferReadBuffer = 
# 654 "include/glad.c" 3 4
                                                                       __null
# 654 "include/glad.c"
                                                                           ;
PFNGLNAMEDFRAMEBUFFERRENDERBUFFERPROC glad_glNamedFramebufferRenderbuffer = 
# 655 "include/glad.c" 3 4
                                                                           __null
# 655 "include/glad.c"
                                                                               ;
PFNGLNAMEDFRAMEBUFFERTEXTUREPROC glad_glNamedFramebufferTexture = 
# 656 "include/glad.c" 3 4
                                                                 __null
# 656 "include/glad.c"
                                                                     ;
PFNGLNAMEDFRAMEBUFFERTEXTURELAYERPROC glad_glNamedFramebufferTextureLayer = 
# 657 "include/glad.c" 3 4
                                                                           __null
# 657 "include/glad.c"
                                                                               ;
PFNGLNAMEDRENDERBUFFERSTORAGEPROC glad_glNamedRenderbufferStorage = 
# 658 "include/glad.c" 3 4
                                                                   __null
# 658 "include/glad.c"
                                                                       ;
PFNGLNAMEDRENDERBUFFERSTORAGEMULTISAMPLEPROC glad_glNamedRenderbufferStorageMultisample = 
# 659 "include/glad.c" 3 4
                                                                                         __null
# 659 "include/glad.c"
                                                                                             ;
PFNGLNORMALP3UIPROC glad_glNormalP3ui = 
# 660 "include/glad.c" 3 4
                                       __null
# 660 "include/glad.c"
                                           ;
PFNGLNORMALP3UIVPROC glad_glNormalP3uiv = 
# 661 "include/glad.c" 3 4
                                         __null
# 661 "include/glad.c"
                                             ;
PFNGLOBJECTLABELPROC glad_glObjectLabel = 
# 662 "include/glad.c" 3 4
                                         __null
# 662 "include/glad.c"
                                             ;
PFNGLOBJECTPTRLABELPROC glad_glObjectPtrLabel = 
# 663 "include/glad.c" 3 4
                                               __null
# 663 "include/glad.c"
                                                   ;
PFNGLPATCHPARAMETERFVPROC glad_glPatchParameterfv = 
# 664 "include/glad.c" 3 4
                                                   __null
# 664 "include/glad.c"
                                                       ;
PFNGLPATCHPARAMETERIPROC glad_glPatchParameteri = 
# 665 "include/glad.c" 3 4
                                                 __null
# 665 "include/glad.c"
                                                     ;
PFNGLPAUSETRANSFORMFEEDBACKPROC glad_glPauseTransformFeedback = 
# 666 "include/glad.c" 3 4
                                                               __null
# 666 "include/glad.c"
                                                                   ;
PFNGLPIXELSTOREFPROC glad_glPixelStoref = 
# 667 "include/glad.c" 3 4
                                         __null
# 667 "include/glad.c"
                                             ;
PFNGLPIXELSTOREIPROC glad_glPixelStorei = 
# 668 "include/glad.c" 3 4
                                         __null
# 668 "include/glad.c"
                                             ;
PFNGLPOINTPARAMETERFPROC glad_glPointParameterf = 
# 669 "include/glad.c" 3 4
                                                 __null
# 669 "include/glad.c"
                                                     ;
PFNGLPOINTPARAMETERFVPROC glad_glPointParameterfv = 
# 670 "include/glad.c" 3 4
                                                   __null
# 670 "include/glad.c"
                                                       ;
PFNGLPOINTPARAMETERIPROC glad_glPointParameteri = 
# 671 "include/glad.c" 3 4
                                                 __null
# 671 "include/glad.c"
                                                     ;
PFNGLPOINTPARAMETERIVPROC glad_glPointParameteriv = 
# 672 "include/glad.c" 3 4
                                                   __null
# 672 "include/glad.c"
                                                       ;
PFNGLPOINTSIZEPROC glad_glPointSize = 
# 673 "include/glad.c" 3 4
                                     __null
# 673 "include/glad.c"
                                         ;
PFNGLPOLYGONMODEPROC glad_glPolygonMode = 
# 674 "include/glad.c" 3 4
                                         __null
# 674 "include/glad.c"
                                             ;
PFNGLPOLYGONOFFSETPROC glad_glPolygonOffset = 
# 675 "include/glad.c" 3 4
                                             __null
# 675 "include/glad.c"
                                                 ;
PFNGLPOPDEBUGGROUPPROC glad_glPopDebugGroup = 
# 676 "include/glad.c" 3 4
                                             __null
# 676 "include/glad.c"
                                                 ;
PFNGLPRIMITIVERESTARTINDEXPROC glad_glPrimitiveRestartIndex = 
# 677 "include/glad.c" 3 4
                                                             __null
# 677 "include/glad.c"
                                                                 ;
PFNGLPROGRAMBINARYPROC glad_glProgramBinary = 
# 678 "include/glad.c" 3 4
                                             __null
# 678 "include/glad.c"
                                                 ;
PFNGLPROGRAMPARAMETERIPROC glad_glProgramParameteri = 
# 679 "include/glad.c" 3 4
                                                     __null
# 679 "include/glad.c"
                                                         ;
PFNGLPROGRAMUNIFORM1DPROC glad_glProgramUniform1d = 
# 680 "include/glad.c" 3 4
                                                   __null
# 680 "include/glad.c"
                                                       ;
PFNGLPROGRAMUNIFORM1DVPROC glad_glProgramUniform1dv = 
# 681 "include/glad.c" 3 4
                                                     __null
# 681 "include/glad.c"
                                                         ;
PFNGLPROGRAMUNIFORM1FPROC glad_glProgramUniform1f = 
# 682 "include/glad.c" 3 4
                                                   __null
# 682 "include/glad.c"
                                                       ;
PFNGLPROGRAMUNIFORM1FVPROC glad_glProgramUniform1fv = 
# 683 "include/glad.c" 3 4
                                                     __null
# 683 "include/glad.c"
                                                         ;
PFNGLPROGRAMUNIFORM1IPROC glad_glProgramUniform1i = 
# 684 "include/glad.c" 3 4
                                                   __null
# 684 "include/glad.c"
                                                       ;
PFNGLPROGRAMUNIFORM1IVPROC glad_glProgramUniform1iv = 
# 685 "include/glad.c" 3 4
                                                     __null
# 685 "include/glad.c"
                                                         ;
PFNGLPROGRAMUNIFORM1UIPROC glad_glProgramUniform1ui = 
# 686 "include/glad.c" 3 4
                                                     __null
# 686 "include/glad.c"
                                                         ;
PFNGLPROGRAMUNIFORM1UIVPROC glad_glProgramUniform1uiv = 
# 687 "include/glad.c" 3 4
                                                       __null
# 687 "include/glad.c"
                                                           ;
PFNGLPROGRAMUNIFORM2DPROC glad_glProgramUniform2d = 
# 688 "include/glad.c" 3 4
                                                   __null
# 688 "include/glad.c"
                                                       ;
PFNGLPROGRAMUNIFORM2DVPROC glad_glProgramUniform2dv = 
# 689 "include/glad.c" 3 4
                                                     __null
# 689 "include/glad.c"
                                                         ;
PFNGLPROGRAMUNIFORM2FPROC glad_glProgramUniform2f = 
# 690 "include/glad.c" 3 4
                                                   __null
# 690 "include/glad.c"
                                                       ;
PFNGLPROGRAMUNIFORM2FVPROC glad_glProgramUniform2fv = 
# 691 "include/glad.c" 3 4
                                                     __null
# 691 "include/glad.c"
                                                         ;
PFNGLPROGRAMUNIFORM2IPROC glad_glProgramUniform2i = 
# 692 "include/glad.c" 3 4
                                                   __null
# 692 "include/glad.c"
                                                       ;
PFNGLPROGRAMUNIFORM2IVPROC glad_glProgramUniform2iv = 
# 693 "include/glad.c" 3 4
                                                     __null
# 693 "include/glad.c"
                                                         ;
PFNGLPROGRAMUNIFORM2UIPROC glad_glProgramUniform2ui = 
# 694 "include/glad.c" 3 4
                                                     __null
# 694 "include/glad.c"
                                                         ;
PFNGLPROGRAMUNIFORM2UIVPROC glad_glProgramUniform2uiv = 
# 695 "include/glad.c" 3 4
                                                       __null
# 695 "include/glad.c"
                                                           ;
PFNGLPROGRAMUNIFORM3DPROC glad_glProgramUniform3d = 
# 696 "include/glad.c" 3 4
                                                   __null
# 696 "include/glad.c"
                                                       ;
PFNGLPROGRAMUNIFORM3DVPROC glad_glProgramUniform3dv = 
# 697 "include/glad.c" 3 4
                                                     __null
# 697 "include/glad.c"
                                                         ;
PFNGLPROGRAMUNIFORM3FPROC glad_glProgramUniform3f = 
# 698 "include/glad.c" 3 4
                                                   __null
# 698 "include/glad.c"
                                                       ;
PFNGLPROGRAMUNIFORM3FVPROC glad_glProgramUniform3fv = 
# 699 "include/glad.c" 3 4
                                                     __null
# 699 "include/glad.c"
                                                         ;
PFNGLPROGRAMUNIFORM3IPROC glad_glProgramUniform3i = 
# 700 "include/glad.c" 3 4
                                                   __null
# 700 "include/glad.c"
                                                       ;
PFNGLPROGRAMUNIFORM3IVPROC glad_glProgramUniform3iv = 
# 701 "include/glad.c" 3 4
                                                     __null
# 701 "include/glad.c"
                                                         ;
PFNGLPROGRAMUNIFORM3UIPROC glad_glProgramUniform3ui = 
# 702 "include/glad.c" 3 4
                                                     __null
# 702 "include/glad.c"
                                                         ;
PFNGLPROGRAMUNIFORM3UIVPROC glad_glProgramUniform3uiv = 
# 703 "include/glad.c" 3 4
                                                       __null
# 703 "include/glad.c"
                                                           ;
PFNGLPROGRAMUNIFORM4DPROC glad_glProgramUniform4d = 
# 704 "include/glad.c" 3 4
                                                   __null
# 704 "include/glad.c"
                                                       ;
PFNGLPROGRAMUNIFORM4DVPROC glad_glProgramUniform4dv = 
# 705 "include/glad.c" 3 4
                                                     __null
# 705 "include/glad.c"
                                                         ;
PFNGLPROGRAMUNIFORM4FPROC glad_glProgramUniform4f = 
# 706 "include/glad.c" 3 4
                                                   __null
# 706 "include/glad.c"
                                                       ;
PFNGLPROGRAMUNIFORM4FVPROC glad_glProgramUniform4fv = 
# 707 "include/glad.c" 3 4
                                                     __null
# 707 "include/glad.c"
                                                         ;
PFNGLPROGRAMUNIFORM4IPROC glad_glProgramUniform4i = 
# 708 "include/glad.c" 3 4
                                                   __null
# 708 "include/glad.c"
                                                       ;
PFNGLPROGRAMUNIFORM4IVPROC glad_glProgramUniform4iv = 
# 709 "include/glad.c" 3 4
                                                     __null
# 709 "include/glad.c"
                                                         ;
PFNGLPROGRAMUNIFORM4UIPROC glad_glProgramUniform4ui = 
# 710 "include/glad.c" 3 4
                                                     __null
# 710 "include/glad.c"
                                                         ;
PFNGLPROGRAMUNIFORM4UIVPROC glad_glProgramUniform4uiv = 
# 711 "include/glad.c" 3 4
                                                       __null
# 711 "include/glad.c"
                                                           ;
PFNGLPROGRAMUNIFORMMATRIX2DVPROC glad_glProgramUniformMatrix2dv = 
# 712 "include/glad.c" 3 4
                                                                 __null
# 712 "include/glad.c"
                                                                     ;
PFNGLPROGRAMUNIFORMMATRIX2FVPROC glad_glProgramUniformMatrix2fv = 
# 713 "include/glad.c" 3 4
                                                                 __null
# 713 "include/glad.c"
                                                                     ;
PFNGLPROGRAMUNIFORMMATRIX2X3DVPROC glad_glProgramUniformMatrix2x3dv = 
# 714 "include/glad.c" 3 4
                                                                     __null
# 714 "include/glad.c"
                                                                         ;
PFNGLPROGRAMUNIFORMMATRIX2X3FVPROC glad_glProgramUniformMatrix2x3fv = 
# 715 "include/glad.c" 3 4
                                                                     __null
# 715 "include/glad.c"
                                                                         ;
PFNGLPROGRAMUNIFORMMATRIX2X4DVPROC glad_glProgramUniformMatrix2x4dv = 
# 716 "include/glad.c" 3 4
                                                                     __null
# 716 "include/glad.c"
                                                                         ;
PFNGLPROGRAMUNIFORMMATRIX2X4FVPROC glad_glProgramUniformMatrix2x4fv = 
# 717 "include/glad.c" 3 4
                                                                     __null
# 717 "include/glad.c"
                                                                         ;
PFNGLPROGRAMUNIFORMMATRIX3DVPROC glad_glProgramUniformMatrix3dv = 
# 718 "include/glad.c" 3 4
                                                                 __null
# 718 "include/glad.c"
                                                                     ;
PFNGLPROGRAMUNIFORMMATRIX3FVPROC glad_glProgramUniformMatrix3fv = 
# 719 "include/glad.c" 3 4
                                                                 __null
# 719 "include/glad.c"
                                                                     ;
PFNGLPROGRAMUNIFORMMATRIX3X2DVPROC glad_glProgramUniformMatrix3x2dv = 
# 720 "include/glad.c" 3 4
                                                                     __null
# 720 "include/glad.c"
                                                                         ;
PFNGLPROGRAMUNIFORMMATRIX3X2FVPROC glad_glProgramUniformMatrix3x2fv = 
# 721 "include/glad.c" 3 4
                                                                     __null
# 721 "include/glad.c"
                                                                         ;
PFNGLPROGRAMUNIFORMMATRIX3X4DVPROC glad_glProgramUniformMatrix3x4dv = 
# 722 "include/glad.c" 3 4
                                                                     __null
# 722 "include/glad.c"
                                                                         ;
PFNGLPROGRAMUNIFORMMATRIX3X4FVPROC glad_glProgramUniformMatrix3x4fv = 
# 723 "include/glad.c" 3 4
                                                                     __null
# 723 "include/glad.c"
                                                                         ;
PFNGLPROGRAMUNIFORMMATRIX4DVPROC glad_glProgramUniformMatrix4dv = 
# 724 "include/glad.c" 3 4
                                                                 __null
# 724 "include/glad.c"
                                                                     ;
PFNGLPROGRAMUNIFORMMATRIX4FVPROC glad_glProgramUniformMatrix4fv = 
# 725 "include/glad.c" 3 4
                                                                 __null
# 725 "include/glad.c"
                                                                     ;
PFNGLPROGRAMUNIFORMMATRIX4X2DVPROC glad_glProgramUniformMatrix4x2dv = 
# 726 "include/glad.c" 3 4
                                                                     __null
# 726 "include/glad.c"
                                                                         ;
PFNGLPROGRAMUNIFORMMATRIX4X2FVPROC glad_glProgramUniformMatrix4x2fv = 
# 727 "include/glad.c" 3 4
                                                                     __null
# 727 "include/glad.c"
                                                                         ;
PFNGLPROGRAMUNIFORMMATRIX4X3DVPROC glad_glProgramUniformMatrix4x3dv = 
# 728 "include/glad.c" 3 4
                                                                     __null
# 728 "include/glad.c"
                                                                         ;
PFNGLPROGRAMUNIFORMMATRIX4X3FVPROC glad_glProgramUniformMatrix4x3fv = 
# 729 "include/glad.c" 3 4
                                                                     __null
# 729 "include/glad.c"
                                                                         ;
PFNGLPROVOKINGVERTEXPROC glad_glProvokingVertex = 
# 730 "include/glad.c" 3 4
                                                 __null
# 730 "include/glad.c"
                                                     ;
PFNGLPUSHDEBUGGROUPPROC glad_glPushDebugGroup = 
# 731 "include/glad.c" 3 4
                                               __null
# 731 "include/glad.c"
                                                   ;
PFNGLQUERYCOUNTERPROC glad_glQueryCounter = 
# 732 "include/glad.c" 3 4
                                           __null
# 732 "include/glad.c"
                                               ;
PFNGLREADBUFFERPROC glad_glReadBuffer = 
# 733 "include/glad.c" 3 4
                                       __null
# 733 "include/glad.c"
                                           ;
PFNGLREADPIXELSPROC glad_glReadPixels = 
# 734 "include/glad.c" 3 4
                                       __null
# 734 "include/glad.c"
                                           ;
PFNGLREADNPIXELSPROC glad_glReadnPixels = 
# 735 "include/glad.c" 3 4
                                         __null
# 735 "include/glad.c"
                                             ;
PFNGLRELEASESHADERCOMPILERPROC glad_glReleaseShaderCompiler = 
# 736 "include/glad.c" 3 4
                                                             __null
# 736 "include/glad.c"
                                                                 ;
PFNGLRENDERBUFFERSTORAGEPROC glad_glRenderbufferStorage = 
# 737 "include/glad.c" 3 4
                                                         __null
# 737 "include/glad.c"
                                                             ;
PFNGLRENDERBUFFERSTORAGEMULTISAMPLEPROC glad_glRenderbufferStorageMultisample = 
# 738 "include/glad.c" 3 4
                                                                               __null
# 738 "include/glad.c"
                                                                                   ;
PFNGLRESUMETRANSFORMFEEDBACKPROC glad_glResumeTransformFeedback = 
# 739 "include/glad.c" 3 4
                                                                 __null
# 739 "include/glad.c"
                                                                     ;
PFNGLSAMPLECOVERAGEPROC glad_glSampleCoverage = 
# 740 "include/glad.c" 3 4
                                               __null
# 740 "include/glad.c"
                                                   ;
PFNGLSAMPLEMASKIPROC glad_glSampleMaski = 
# 741 "include/glad.c" 3 4
                                         __null
# 741 "include/glad.c"
                                             ;
PFNGLSAMPLERPARAMETERIIVPROC glad_glSamplerParameterIiv = 
# 742 "include/glad.c" 3 4
                                                         __null
# 742 "include/glad.c"
                                                             ;
PFNGLSAMPLERPARAMETERIUIVPROC glad_glSamplerParameterIuiv = 
# 743 "include/glad.c" 3 4
                                                           __null
# 743 "include/glad.c"
                                                               ;
PFNGLSAMPLERPARAMETERFPROC glad_glSamplerParameterf = 
# 744 "include/glad.c" 3 4
                                                     __null
# 744 "include/glad.c"
                                                         ;
PFNGLSAMPLERPARAMETERFVPROC glad_glSamplerParameterfv = 
# 745 "include/glad.c" 3 4
                                                       __null
# 745 "include/glad.c"
                                                           ;
PFNGLSAMPLERPARAMETERIPROC glad_glSamplerParameteri = 
# 746 "include/glad.c" 3 4
                                                     __null
# 746 "include/glad.c"
                                                         ;
PFNGLSAMPLERPARAMETERIVPROC glad_glSamplerParameteriv = 
# 747 "include/glad.c" 3 4
                                                       __null
# 747 "include/glad.c"
                                                           ;
PFNGLSCISSORPROC glad_glScissor = 
# 748 "include/glad.c" 3 4
                                 __null
# 748 "include/glad.c"
                                     ;
PFNGLSCISSORARRAYVPROC glad_glScissorArrayv = 
# 749 "include/glad.c" 3 4
                                             __null
# 749 "include/glad.c"
                                                 ;
PFNGLSCISSORINDEXEDPROC glad_glScissorIndexed = 
# 750 "include/glad.c" 3 4
                                               __null
# 750 "include/glad.c"
                                                   ;
PFNGLSCISSORINDEXEDVPROC glad_glScissorIndexedv = 
# 751 "include/glad.c" 3 4
                                                 __null
# 751 "include/glad.c"
                                                     ;
PFNGLSECONDARYCOLORP3UIPROC glad_glSecondaryColorP3ui = 
# 752 "include/glad.c" 3 4
                                                       __null
# 752 "include/glad.c"
                                                           ;
PFNGLSECONDARYCOLORP3UIVPROC glad_glSecondaryColorP3uiv = 
# 753 "include/glad.c" 3 4
                                                         __null
# 753 "include/glad.c"
                                                             ;
PFNGLSHADERBINARYPROC glad_glShaderBinary = 
# 754 "include/glad.c" 3 4
                                           __null
# 754 "include/glad.c"
                                               ;
PFNGLSHADERSOURCEPROC glad_glShaderSource = 
# 755 "include/glad.c" 3 4
                                           __null
# 755 "include/glad.c"
                                               ;
PFNGLSHADERSTORAGEBLOCKBINDINGPROC glad_glShaderStorageBlockBinding = 
# 756 "include/glad.c" 3 4
                                                                     __null
# 756 "include/glad.c"
                                                                         ;
PFNGLSTENCILFUNCPROC glad_glStencilFunc = 
# 757 "include/glad.c" 3 4
                                         __null
# 757 "include/glad.c"
                                             ;
PFNGLSTENCILFUNCSEPARATEPROC glad_glStencilFuncSeparate = 
# 758 "include/glad.c" 3 4
                                                         __null
# 758 "include/glad.c"
                                                             ;
PFNGLSTENCILMASKPROC glad_glStencilMask = 
# 759 "include/glad.c" 3 4
                                         __null
# 759 "include/glad.c"
                                             ;
PFNGLSTENCILMASKSEPARATEPROC glad_glStencilMaskSeparate = 
# 760 "include/glad.c" 3 4
                                                         __null
# 760 "include/glad.c"
                                                             ;
PFNGLSTENCILOPPROC glad_glStencilOp = 
# 761 "include/glad.c" 3 4
                                     __null
# 761 "include/glad.c"
                                         ;
PFNGLSTENCILOPSEPARATEPROC glad_glStencilOpSeparate = 
# 762 "include/glad.c" 3 4
                                                     __null
# 762 "include/glad.c"
                                                         ;
PFNGLTEXBUFFERPROC glad_glTexBuffer = 
# 763 "include/glad.c" 3 4
                                     __null
# 763 "include/glad.c"
                                         ;
PFNGLTEXBUFFERRANGEPROC glad_glTexBufferRange = 
# 764 "include/glad.c" 3 4
                                               __null
# 764 "include/glad.c"
                                                   ;
PFNGLTEXCOORDP1UIPROC glad_glTexCoordP1ui = 
# 765 "include/glad.c" 3 4
                                           __null
# 765 "include/glad.c"
                                               ;
PFNGLTEXCOORDP1UIVPROC glad_glTexCoordP1uiv = 
# 766 "include/glad.c" 3 4
                                             __null
# 766 "include/glad.c"
                                                 ;
PFNGLTEXCOORDP2UIPROC glad_glTexCoordP2ui = 
# 767 "include/glad.c" 3 4
                                           __null
# 767 "include/glad.c"
                                               ;
PFNGLTEXCOORDP2UIVPROC glad_glTexCoordP2uiv = 
# 768 "include/glad.c" 3 4
                                             __null
# 768 "include/glad.c"
                                                 ;
PFNGLTEXCOORDP3UIPROC glad_glTexCoordP3ui = 
# 769 "include/glad.c" 3 4
                                           __null
# 769 "include/glad.c"
                                               ;
PFNGLTEXCOORDP3UIVPROC glad_glTexCoordP3uiv = 
# 770 "include/glad.c" 3 4
                                             __null
# 770 "include/glad.c"
                                                 ;
PFNGLTEXCOORDP4UIPROC glad_glTexCoordP4ui = 
# 771 "include/glad.c" 3 4
                                           __null
# 771 "include/glad.c"
                                               ;
PFNGLTEXCOORDP4UIVPROC glad_glTexCoordP4uiv = 
# 772 "include/glad.c" 3 4
                                             __null
# 772 "include/glad.c"
                                                 ;
PFNGLTEXIMAGE1DPROC glad_glTexImage1D = 
# 773 "include/glad.c" 3 4
                                       __null
# 773 "include/glad.c"
                                           ;
PFNGLTEXIMAGE2DPROC glad_glTexImage2D = 
# 774 "include/glad.c" 3 4
                                       __null
# 774 "include/glad.c"
                                           ;
PFNGLTEXIMAGE2DMULTISAMPLEPROC glad_glTexImage2DMultisample = 
# 775 "include/glad.c" 3 4
                                                             __null
# 775 "include/glad.c"
                                                                 ;
PFNGLTEXIMAGE3DPROC glad_glTexImage3D = 
# 776 "include/glad.c" 3 4
                                       __null
# 776 "include/glad.c"
                                           ;
PFNGLTEXIMAGE3DMULTISAMPLEPROC glad_glTexImage3DMultisample = 
# 777 "include/glad.c" 3 4
                                                             __null
# 777 "include/glad.c"
                                                                 ;
PFNGLTEXPARAMETERIIVPROC glad_glTexParameterIiv = 
# 778 "include/glad.c" 3 4
                                                 __null
# 778 "include/glad.c"
                                                     ;
PFNGLTEXPARAMETERIUIVPROC glad_glTexParameterIuiv = 
# 779 "include/glad.c" 3 4
                                                   __null
# 779 "include/glad.c"
                                                       ;
PFNGLTEXPARAMETERFPROC glad_glTexParameterf = 
# 780 "include/glad.c" 3 4
                                             __null
# 780 "include/glad.c"
                                                 ;
PFNGLTEXPARAMETERFVPROC glad_glTexParameterfv = 
# 781 "include/glad.c" 3 4
                                               __null
# 781 "include/glad.c"
                                                   ;
PFNGLTEXPARAMETERIPROC glad_glTexParameteri = 
# 782 "include/glad.c" 3 4
                                             __null
# 782 "include/glad.c"
                                                 ;
PFNGLTEXPARAMETERIVPROC glad_glTexParameteriv = 
# 783 "include/glad.c" 3 4
                                               __null
# 783 "include/glad.c"
                                                   ;
PFNGLTEXSTORAGE1DPROC glad_glTexStorage1D = 
# 784 "include/glad.c" 3 4
                                           __null
# 784 "include/glad.c"
                                               ;
PFNGLTEXSTORAGE2DPROC glad_glTexStorage2D = 
# 785 "include/glad.c" 3 4
                                           __null
# 785 "include/glad.c"
                                               ;
PFNGLTEXSTORAGE2DMULTISAMPLEPROC glad_glTexStorage2DMultisample = 
# 786 "include/glad.c" 3 4
                                                                 __null
# 786 "include/glad.c"
                                                                     ;
PFNGLTEXSTORAGE3DPROC glad_glTexStorage3D = 
# 787 "include/glad.c" 3 4
                                           __null
# 787 "include/glad.c"
                                               ;
PFNGLTEXSTORAGE3DMULTISAMPLEPROC glad_glTexStorage3DMultisample = 
# 788 "include/glad.c" 3 4
                                                                 __null
# 788 "include/glad.c"
                                                                     ;
PFNGLTEXSUBIMAGE1DPROC glad_glTexSubImage1D = 
# 789 "include/glad.c" 3 4
                                             __null
# 789 "include/glad.c"
                                                 ;
PFNGLTEXSUBIMAGE2DPROC glad_glTexSubImage2D = 
# 790 "include/glad.c" 3 4
                                             __null
# 790 "include/glad.c"
                                                 ;
PFNGLTEXSUBIMAGE3DPROC glad_glTexSubImage3D = 
# 791 "include/glad.c" 3 4
                                             __null
# 791 "include/glad.c"
                                                 ;
PFNGLTEXTUREBARRIERPROC glad_glTextureBarrier = 
# 792 "include/glad.c" 3 4
                                               __null
# 792 "include/glad.c"
                                                   ;
PFNGLTEXTUREBUFFERPROC glad_glTextureBuffer = 
# 793 "include/glad.c" 3 4
                                             __null
# 793 "include/glad.c"
                                                 ;
PFNGLTEXTUREBUFFERRANGEPROC glad_glTextureBufferRange = 
# 794 "include/glad.c" 3 4
                                                       __null
# 794 "include/glad.c"
                                                           ;
PFNGLTEXTUREPARAMETERIIVPROC glad_glTextureParameterIiv = 
# 795 "include/glad.c" 3 4
                                                         __null
# 795 "include/glad.c"
                                                             ;
PFNGLTEXTUREPARAMETERIUIVPROC glad_glTextureParameterIuiv = 
# 796 "include/glad.c" 3 4
                                                           __null
# 796 "include/glad.c"
                                                               ;
PFNGLTEXTUREPARAMETERFPROC glad_glTextureParameterf = 
# 797 "include/glad.c" 3 4
                                                     __null
# 797 "include/glad.c"
                                                         ;
PFNGLTEXTUREPARAMETERFVPROC glad_glTextureParameterfv = 
# 798 "include/glad.c" 3 4
                                                       __null
# 798 "include/glad.c"
                                                           ;
PFNGLTEXTUREPARAMETERIPROC glad_glTextureParameteri = 
# 799 "include/glad.c" 3 4
                                                     __null
# 799 "include/glad.c"
                                                         ;
PFNGLTEXTUREPARAMETERIVPROC glad_glTextureParameteriv = 
# 800 "include/glad.c" 3 4
                                                       __null
# 800 "include/glad.c"
                                                           ;
PFNGLTEXTURESTORAGE1DPROC glad_glTextureStorage1D = 
# 801 "include/glad.c" 3 4
                                                   __null
# 801 "include/glad.c"
                                                       ;
PFNGLTEXTURESTORAGE2DPROC glad_glTextureStorage2D = 
# 802 "include/glad.c" 3 4
                                                   __null
# 802 "include/glad.c"
                                                       ;
PFNGLTEXTURESTORAGE2DMULTISAMPLEPROC glad_glTextureStorage2DMultisample = 
# 803 "include/glad.c" 3 4
                                                                         __null
# 803 "include/glad.c"
                                                                             ;
PFNGLTEXTURESTORAGE3DPROC glad_glTextureStorage3D = 
# 804 "include/glad.c" 3 4
                                                   __null
# 804 "include/glad.c"
                                                       ;
PFNGLTEXTURESTORAGE3DMULTISAMPLEPROC glad_glTextureStorage3DMultisample = 
# 805 "include/glad.c" 3 4
                                                                         __null
# 805 "include/glad.c"
                                                                             ;
PFNGLTEXTURESUBIMAGE1DPROC glad_glTextureSubImage1D = 
# 806 "include/glad.c" 3 4
                                                     __null
# 806 "include/glad.c"
                                                         ;
PFNGLTEXTURESUBIMAGE2DPROC glad_glTextureSubImage2D = 
# 807 "include/glad.c" 3 4
                                                     __null
# 807 "include/glad.c"
                                                         ;
PFNGLTEXTURESUBIMAGE3DPROC glad_glTextureSubImage3D = 
# 808 "include/glad.c" 3 4
                                                     __null
# 808 "include/glad.c"
                                                         ;
PFNGLTEXTUREVIEWPROC glad_glTextureView = 
# 809 "include/glad.c" 3 4
                                         __null
# 809 "include/glad.c"
                                             ;
PFNGLTRANSFORMFEEDBACKBUFFERBASEPROC glad_glTransformFeedbackBufferBase = 
# 810 "include/glad.c" 3 4
                                                                         __null
# 810 "include/glad.c"
                                                                             ;
PFNGLTRANSFORMFEEDBACKBUFFERRANGEPROC glad_glTransformFeedbackBufferRange = 
# 811 "include/glad.c" 3 4
                                                                           __null
# 811 "include/glad.c"
                                                                               ;
PFNGLTRANSFORMFEEDBACKVARYINGSPROC glad_glTransformFeedbackVaryings = 
# 812 "include/glad.c" 3 4
                                                                     __null
# 812 "include/glad.c"
                                                                         ;
PFNGLUNIFORM1DPROC glad_glUniform1d = 
# 813 "include/glad.c" 3 4
                                     __null
# 813 "include/glad.c"
                                         ;
PFNGLUNIFORM1DVPROC glad_glUniform1dv = 
# 814 "include/glad.c" 3 4
                                       __null
# 814 "include/glad.c"
                                           ;
PFNGLUNIFORM1FPROC glad_glUniform1f = 
# 815 "include/glad.c" 3 4
                                     __null
# 815 "include/glad.c"
                                         ;
PFNGLUNIFORM1FVPROC glad_glUniform1fv = 
# 816 "include/glad.c" 3 4
                                       __null
# 816 "include/glad.c"
                                           ;
PFNGLUNIFORM1IPROC glad_glUniform1i = 
# 817 "include/glad.c" 3 4
                                     __null
# 817 "include/glad.c"
                                         ;
PFNGLUNIFORM1IVPROC glad_glUniform1iv = 
# 818 "include/glad.c" 3 4
                                       __null
# 818 "include/glad.c"
                                           ;
PFNGLUNIFORM1UIPROC glad_glUniform1ui = 
# 819 "include/glad.c" 3 4
                                       __null
# 819 "include/glad.c"
                                           ;
PFNGLUNIFORM1UIVPROC glad_glUniform1uiv = 
# 820 "include/glad.c" 3 4
                                         __null
# 820 "include/glad.c"
                                             ;
PFNGLUNIFORM2DPROC glad_glUniform2d = 
# 821 "include/glad.c" 3 4
                                     __null
# 821 "include/glad.c"
                                         ;
PFNGLUNIFORM2DVPROC glad_glUniform2dv = 
# 822 "include/glad.c" 3 4
                                       __null
# 822 "include/glad.c"
                                           ;
PFNGLUNIFORM2FPROC glad_glUniform2f = 
# 823 "include/glad.c" 3 4
                                     __null
# 823 "include/glad.c"
                                         ;
PFNGLUNIFORM2FVPROC glad_glUniform2fv = 
# 824 "include/glad.c" 3 4
                                       __null
# 824 "include/glad.c"
                                           ;
PFNGLUNIFORM2IPROC glad_glUniform2i = 
# 825 "include/glad.c" 3 4
                                     __null
# 825 "include/glad.c"
                                         ;
PFNGLUNIFORM2IVPROC glad_glUniform2iv = 
# 826 "include/glad.c" 3 4
                                       __null
# 826 "include/glad.c"
                                           ;
PFNGLUNIFORM2UIPROC glad_glUniform2ui = 
# 827 "include/glad.c" 3 4
                                       __null
# 827 "include/glad.c"
                                           ;
PFNGLUNIFORM2UIVPROC glad_glUniform2uiv = 
# 828 "include/glad.c" 3 4
                                         __null
# 828 "include/glad.c"
                                             ;
PFNGLUNIFORM3DPROC glad_glUniform3d = 
# 829 "include/glad.c" 3 4
                                     __null
# 829 "include/glad.c"
                                         ;
PFNGLUNIFORM3DVPROC glad_glUniform3dv = 
# 830 "include/glad.c" 3 4
                                       __null
# 830 "include/glad.c"
                                           ;
PFNGLUNIFORM3FPROC glad_glUniform3f = 
# 831 "include/glad.c" 3 4
                                     __null
# 831 "include/glad.c"
                                         ;
PFNGLUNIFORM3FVPROC glad_glUniform3fv = 
# 832 "include/glad.c" 3 4
                                       __null
# 832 "include/glad.c"
                                           ;
PFNGLUNIFORM3IPROC glad_glUniform3i = 
# 833 "include/glad.c" 3 4
                                     __null
# 833 "include/glad.c"
                                         ;
PFNGLUNIFORM3IVPROC glad_glUniform3iv = 
# 834 "include/glad.c" 3 4
                                       __null
# 834 "include/glad.c"
                                           ;
PFNGLUNIFORM3UIPROC glad_glUniform3ui = 
# 835 "include/glad.c" 3 4
                                       __null
# 835 "include/glad.c"
                                           ;
PFNGLUNIFORM3UIVPROC glad_glUniform3uiv = 
# 836 "include/glad.c" 3 4
                                         __null
# 836 "include/glad.c"
                                             ;
PFNGLUNIFORM4DPROC glad_glUniform4d = 
# 837 "include/glad.c" 3 4
                                     __null
# 837 "include/glad.c"
                                         ;
PFNGLUNIFORM4DVPROC glad_glUniform4dv = 
# 838 "include/glad.c" 3 4
                                       __null
# 838 "include/glad.c"
                                           ;
PFNGLUNIFORM4FPROC glad_glUniform4f = 
# 839 "include/glad.c" 3 4
                                     __null
# 839 "include/glad.c"
                                         ;
PFNGLUNIFORM4FVPROC glad_glUniform4fv = 
# 840 "include/glad.c" 3 4
                                       __null
# 840 "include/glad.c"
                                           ;
PFNGLUNIFORM4IPROC glad_glUniform4i = 
# 841 "include/glad.c" 3 4
                                     __null
# 841 "include/glad.c"
                                         ;
PFNGLUNIFORM4IVPROC glad_glUniform4iv = 
# 842 "include/glad.c" 3 4
                                       __null
# 842 "include/glad.c"
                                           ;
PFNGLUNIFORM4UIPROC glad_glUniform4ui = 
# 843 "include/glad.c" 3 4
                                       __null
# 843 "include/glad.c"
                                           ;
PFNGLUNIFORM4UIVPROC glad_glUniform4uiv = 
# 844 "include/glad.c" 3 4
                                         __null
# 844 "include/glad.c"
                                             ;
PFNGLUNIFORMBLOCKBINDINGPROC glad_glUniformBlockBinding = 
# 845 "include/glad.c" 3 4
                                                         __null
# 845 "include/glad.c"
                                                             ;
PFNGLUNIFORMMATRIX2DVPROC glad_glUniformMatrix2dv = 
# 846 "include/glad.c" 3 4
                                                   __null
# 846 "include/glad.c"
                                                       ;
PFNGLUNIFORMMATRIX2FVPROC glad_glUniformMatrix2fv = 
# 847 "include/glad.c" 3 4
                                                   __null
# 847 "include/glad.c"
                                                       ;
PFNGLUNIFORMMATRIX2X3DVPROC glad_glUniformMatrix2x3dv = 
# 848 "include/glad.c" 3 4
                                                       __null
# 848 "include/glad.c"
                                                           ;
PFNGLUNIFORMMATRIX2X3FVPROC glad_glUniformMatrix2x3fv = 
# 849 "include/glad.c" 3 4
                                                       __null
# 849 "include/glad.c"
                                                           ;
PFNGLUNIFORMMATRIX2X4DVPROC glad_glUniformMatrix2x4dv = 
# 850 "include/glad.c" 3 4
                                                       __null
# 850 "include/glad.c"
                                                           ;
PFNGLUNIFORMMATRIX2X4FVPROC glad_glUniformMatrix2x4fv = 
# 851 "include/glad.c" 3 4
                                                       __null
# 851 "include/glad.c"
                                                           ;
PFNGLUNIFORMMATRIX3DVPROC glad_glUniformMatrix3dv = 
# 852 "include/glad.c" 3 4
                                                   __null
# 852 "include/glad.c"
                                                       ;
PFNGLUNIFORMMATRIX3FVPROC glad_glUniformMatrix3fv = 
# 853 "include/glad.c" 3 4
                                                   __null
# 853 "include/glad.c"
                                                       ;
PFNGLUNIFORMMATRIX3X2DVPROC glad_glUniformMatrix3x2dv = 
# 854 "include/glad.c" 3 4
                                                       __null
# 854 "include/glad.c"
                                                           ;
PFNGLUNIFORMMATRIX3X2FVPROC glad_glUniformMatrix3x2fv = 
# 855 "include/glad.c" 3 4
                                                       __null
# 855 "include/glad.c"
                                                           ;
PFNGLUNIFORMMATRIX3X4DVPROC glad_glUniformMatrix3x4dv = 
# 856 "include/glad.c" 3 4
                                                       __null
# 856 "include/glad.c"
                                                           ;
PFNGLUNIFORMMATRIX3X4FVPROC glad_glUniformMatrix3x4fv = 
# 857 "include/glad.c" 3 4
                                                       __null
# 857 "include/glad.c"
                                                           ;
PFNGLUNIFORMMATRIX4DVPROC glad_glUniformMatrix4dv = 
# 858 "include/glad.c" 3 4
                                                   __null
# 858 "include/glad.c"
                                                       ;
PFNGLUNIFORMMATRIX4FVPROC glad_glUniformMatrix4fv = 
# 859 "include/glad.c" 3 4
                                                   __null
# 859 "include/glad.c"
                                                       ;
PFNGLUNIFORMMATRIX4X2DVPROC glad_glUniformMatrix4x2dv = 
# 860 "include/glad.c" 3 4
                                                       __null
# 860 "include/glad.c"
                                                           ;
PFNGLUNIFORMMATRIX4X2FVPROC glad_glUniformMatrix4x2fv = 
# 861 "include/glad.c" 3 4
                                                       __null
# 861 "include/glad.c"
                                                           ;
PFNGLUNIFORMMATRIX4X3DVPROC glad_glUniformMatrix4x3dv = 
# 862 "include/glad.c" 3 4
                                                       __null
# 862 "include/glad.c"
                                                           ;
PFNGLUNIFORMMATRIX4X3FVPROC glad_glUniformMatrix4x3fv = 
# 863 "include/glad.c" 3 4
                                                       __null
# 863 "include/glad.c"
                                                           ;
PFNGLUNIFORMSUBROUTINESUIVPROC glad_glUniformSubroutinesuiv = 
# 864 "include/glad.c" 3 4
                                                             __null
# 864 "include/glad.c"
                                                                 ;
PFNGLUNMAPBUFFERPROC glad_glUnmapBuffer = 
# 865 "include/glad.c" 3 4
                                         __null
# 865 "include/glad.c"
                                             ;
PFNGLUNMAPNAMEDBUFFERPROC glad_glUnmapNamedBuffer = 
# 866 "include/glad.c" 3 4
                                                   __null
# 866 "include/glad.c"
                                                       ;
PFNGLUSEPROGRAMPROC glad_glUseProgram = 
# 867 "include/glad.c" 3 4
                                       __null
# 867 "include/glad.c"
                                           ;
PFNGLUSEPROGRAMSTAGESPROC glad_glUseProgramStages = 
# 868 "include/glad.c" 3 4
                                                   __null
# 868 "include/glad.c"
                                                       ;
PFNGLVALIDATEPROGRAMPROC glad_glValidateProgram = 
# 869 "include/glad.c" 3 4
                                                 __null
# 869 "include/glad.c"
                                                     ;
PFNGLVALIDATEPROGRAMPIPELINEPROC glad_glValidateProgramPipeline = 
# 870 "include/glad.c" 3 4
                                                                 __null
# 870 "include/glad.c"
                                                                     ;
PFNGLVERTEXARRAYATTRIBBINDINGPROC glad_glVertexArrayAttribBinding = 
# 871 "include/glad.c" 3 4
                                                                   __null
# 871 "include/glad.c"
                                                                       ;
PFNGLVERTEXARRAYATTRIBFORMATPROC glad_glVertexArrayAttribFormat = 
# 872 "include/glad.c" 3 4
                                                                 __null
# 872 "include/glad.c"
                                                                     ;
PFNGLVERTEXARRAYATTRIBIFORMATPROC glad_glVertexArrayAttribIFormat = 
# 873 "include/glad.c" 3 4
                                                                   __null
# 873 "include/glad.c"
                                                                       ;
PFNGLVERTEXARRAYATTRIBLFORMATPROC glad_glVertexArrayAttribLFormat = 
# 874 "include/glad.c" 3 4
                                                                   __null
# 874 "include/glad.c"
                                                                       ;
PFNGLVERTEXARRAYBINDINGDIVISORPROC glad_glVertexArrayBindingDivisor = 
# 875 "include/glad.c" 3 4
                                                                     __null
# 875 "include/glad.c"
                                                                         ;
PFNGLVERTEXARRAYELEMENTBUFFERPROC glad_glVertexArrayElementBuffer = 
# 876 "include/glad.c" 3 4
                                                                   __null
# 876 "include/glad.c"
                                                                       ;
PFNGLVERTEXARRAYVERTEXBUFFERPROC glad_glVertexArrayVertexBuffer = 
# 877 "include/glad.c" 3 4
                                                                 __null
# 877 "include/glad.c"
                                                                     ;
PFNGLVERTEXARRAYVERTEXBUFFERSPROC glad_glVertexArrayVertexBuffers = 
# 878 "include/glad.c" 3 4
                                                                   __null
# 878 "include/glad.c"
                                                                       ;
PFNGLVERTEXATTRIB1DPROC glad_glVertexAttrib1d = 
# 879 "include/glad.c" 3 4
                                               __null
# 879 "include/glad.c"
                                                   ;
PFNGLVERTEXATTRIB1DVPROC glad_glVertexAttrib1dv = 
# 880 "include/glad.c" 3 4
                                                 __null
# 880 "include/glad.c"
                                                     ;
PFNGLVERTEXATTRIB1FPROC glad_glVertexAttrib1f = 
# 881 "include/glad.c" 3 4
                                               __null
# 881 "include/glad.c"
                                                   ;
PFNGLVERTEXATTRIB1FVPROC glad_glVertexAttrib1fv = 
# 882 "include/glad.c" 3 4
                                                 __null
# 882 "include/glad.c"
                                                     ;
PFNGLVERTEXATTRIB1SPROC glad_glVertexAttrib1s = 
# 883 "include/glad.c" 3 4
                                               __null
# 883 "include/glad.c"
                                                   ;
PFNGLVERTEXATTRIB1SVPROC glad_glVertexAttrib1sv = 
# 884 "include/glad.c" 3 4
                                                 __null
# 884 "include/glad.c"
                                                     ;
PFNGLVERTEXATTRIB2DPROC glad_glVertexAttrib2d = 
# 885 "include/glad.c" 3 4
                                               __null
# 885 "include/glad.c"
                                                   ;
PFNGLVERTEXATTRIB2DVPROC glad_glVertexAttrib2dv = 
# 886 "include/glad.c" 3 4
                                                 __null
# 886 "include/glad.c"
                                                     ;
PFNGLVERTEXATTRIB2FPROC glad_glVertexAttrib2f = 
# 887 "include/glad.c" 3 4
                                               __null
# 887 "include/glad.c"
                                                   ;
PFNGLVERTEXATTRIB2FVPROC glad_glVertexAttrib2fv = 
# 888 "include/glad.c" 3 4
                                                 __null
# 888 "include/glad.c"
                                                     ;
PFNGLVERTEXATTRIB2SPROC glad_glVertexAttrib2s = 
# 889 "include/glad.c" 3 4
                                               __null
# 889 "include/glad.c"
                                                   ;
PFNGLVERTEXATTRIB2SVPROC glad_glVertexAttrib2sv = 
# 890 "include/glad.c" 3 4
                                                 __null
# 890 "include/glad.c"
                                                     ;
PFNGLVERTEXATTRIB3DPROC glad_glVertexAttrib3d = 
# 891 "include/glad.c" 3 4
                                               __null
# 891 "include/glad.c"
                                                   ;
PFNGLVERTEXATTRIB3DVPROC glad_glVertexAttrib3dv = 
# 892 "include/glad.c" 3 4
                                                 __null
# 892 "include/glad.c"
                                                     ;
PFNGLVERTEXATTRIB3FPROC glad_glVertexAttrib3f = 
# 893 "include/glad.c" 3 4
                                               __null
# 893 "include/glad.c"
                                                   ;
PFNGLVERTEXATTRIB3FVPROC glad_glVertexAttrib3fv = 
# 894 "include/glad.c" 3 4
                                                 __null
# 894 "include/glad.c"
                                                     ;
PFNGLVERTEXATTRIB3SPROC glad_glVertexAttrib3s = 
# 895 "include/glad.c" 3 4
                                               __null
# 895 "include/glad.c"
                                                   ;
PFNGLVERTEXATTRIB3SVPROC glad_glVertexAttrib3sv = 
# 896 "include/glad.c" 3 4
                                                 __null
# 896 "include/glad.c"
                                                     ;
PFNGLVERTEXATTRIB4NBVPROC glad_glVertexAttrib4Nbv = 
# 897 "include/glad.c" 3 4
                                                   __null
# 897 "include/glad.c"
                                                       ;
PFNGLVERTEXATTRIB4NIVPROC glad_glVertexAttrib4Niv = 
# 898 "include/glad.c" 3 4
                                                   __null
# 898 "include/glad.c"
                                                       ;
PFNGLVERTEXATTRIB4NSVPROC glad_glVertexAttrib4Nsv = 
# 899 "include/glad.c" 3 4
                                                   __null
# 899 "include/glad.c"
                                                       ;
PFNGLVERTEXATTRIB4NUBPROC glad_glVertexAttrib4Nub = 
# 900 "include/glad.c" 3 4
                                                   __null
# 900 "include/glad.c"
                                                       ;
PFNGLVERTEXATTRIB4NUBVPROC glad_glVertexAttrib4Nubv = 
# 901 "include/glad.c" 3 4
                                                     __null
# 901 "include/glad.c"
                                                         ;
PFNGLVERTEXATTRIB4NUIVPROC glad_glVertexAttrib4Nuiv = 
# 902 "include/glad.c" 3 4
                                                     __null
# 902 "include/glad.c"
                                                         ;
PFNGLVERTEXATTRIB4NUSVPROC glad_glVertexAttrib4Nusv = 
# 903 "include/glad.c" 3 4
                                                     __null
# 903 "include/glad.c"
                                                         ;
PFNGLVERTEXATTRIB4BVPROC glad_glVertexAttrib4bv = 
# 904 "include/glad.c" 3 4
                                                 __null
# 904 "include/glad.c"
                                                     ;
PFNGLVERTEXATTRIB4DPROC glad_glVertexAttrib4d = 
# 905 "include/glad.c" 3 4
                                               __null
# 905 "include/glad.c"
                                                   ;
PFNGLVERTEXATTRIB4DVPROC glad_glVertexAttrib4dv = 
# 906 "include/glad.c" 3 4
                                                 __null
# 906 "include/glad.c"
                                                     ;
PFNGLVERTEXATTRIB4FPROC glad_glVertexAttrib4f = 
# 907 "include/glad.c" 3 4
                                               __null
# 907 "include/glad.c"
                                                   ;
PFNGLVERTEXATTRIB4FVPROC glad_glVertexAttrib4fv = 
# 908 "include/glad.c" 3 4
                                                 __null
# 908 "include/glad.c"
                                                     ;
PFNGLVERTEXATTRIB4IVPROC glad_glVertexAttrib4iv = 
# 909 "include/glad.c" 3 4
                                                 __null
# 909 "include/glad.c"
                                                     ;
PFNGLVERTEXATTRIB4SPROC glad_glVertexAttrib4s = 
# 910 "include/glad.c" 3 4
                                               __null
# 910 "include/glad.c"
                                                   ;
PFNGLVERTEXATTRIB4SVPROC glad_glVertexAttrib4sv = 
# 911 "include/glad.c" 3 4
                                                 __null
# 911 "include/glad.c"
                                                     ;
PFNGLVERTEXATTRIB4UBVPROC glad_glVertexAttrib4ubv = 
# 912 "include/glad.c" 3 4
                                                   __null
# 912 "include/glad.c"
                                                       ;
PFNGLVERTEXATTRIB4UIVPROC glad_glVertexAttrib4uiv = 
# 913 "include/glad.c" 3 4
                                                   __null
# 913 "include/glad.c"
                                                       ;
PFNGLVERTEXATTRIB4USVPROC glad_glVertexAttrib4usv = 
# 914 "include/glad.c" 3 4
                                                   __null
# 914 "include/glad.c"
                                                       ;
PFNGLVERTEXATTRIBBINDINGPROC glad_glVertexAttribBinding = 
# 915 "include/glad.c" 3 4
                                                         __null
# 915 "include/glad.c"
                                                             ;
PFNGLVERTEXATTRIBDIVISORPROC glad_glVertexAttribDivisor = 
# 916 "include/glad.c" 3 4
                                                         __null
# 916 "include/glad.c"
                                                             ;
PFNGLVERTEXATTRIBFORMATPROC glad_glVertexAttribFormat = 
# 917 "include/glad.c" 3 4
                                                       __null
# 917 "include/glad.c"
                                                           ;
PFNGLVERTEXATTRIBI1IPROC glad_glVertexAttribI1i = 
# 918 "include/glad.c" 3 4
                                                 __null
# 918 "include/glad.c"
                                                     ;
PFNGLVERTEXATTRIBI1IVPROC glad_glVertexAttribI1iv = 
# 919 "include/glad.c" 3 4
                                                   __null
# 919 "include/glad.c"
                                                       ;
PFNGLVERTEXATTRIBI1UIPROC glad_glVertexAttribI1ui = 
# 920 "include/glad.c" 3 4
                                                   __null
# 920 "include/glad.c"
                                                       ;
PFNGLVERTEXATTRIBI1UIVPROC glad_glVertexAttribI1uiv = 
# 921 "include/glad.c" 3 4
                                                     __null
# 921 "include/glad.c"
                                                         ;
PFNGLVERTEXATTRIBI2IPROC glad_glVertexAttribI2i = 
# 922 "include/glad.c" 3 4
                                                 __null
# 922 "include/glad.c"
                                                     ;
PFNGLVERTEXATTRIBI2IVPROC glad_glVertexAttribI2iv = 
# 923 "include/glad.c" 3 4
                                                   __null
# 923 "include/glad.c"
                                                       ;
PFNGLVERTEXATTRIBI2UIPROC glad_glVertexAttribI2ui = 
# 924 "include/glad.c" 3 4
                                                   __null
# 924 "include/glad.c"
                                                       ;
PFNGLVERTEXATTRIBI2UIVPROC glad_glVertexAttribI2uiv = 
# 925 "include/glad.c" 3 4
                                                     __null
# 925 "include/glad.c"
                                                         ;
PFNGLVERTEXATTRIBI3IPROC glad_glVertexAttribI3i = 
# 926 "include/glad.c" 3 4
                                                 __null
# 926 "include/glad.c"
                                                     ;
PFNGLVERTEXATTRIBI3IVPROC glad_glVertexAttribI3iv = 
# 927 "include/glad.c" 3 4
                                                   __null
# 927 "include/glad.c"
                                                       ;
PFNGLVERTEXATTRIBI3UIPROC glad_glVertexAttribI3ui = 
# 928 "include/glad.c" 3 4
                                                   __null
# 928 "include/glad.c"
                                                       ;
PFNGLVERTEXATTRIBI3UIVPROC glad_glVertexAttribI3uiv = 
# 929 "include/glad.c" 3 4
                                                     __null
# 929 "include/glad.c"
                                                         ;
PFNGLVERTEXATTRIBI4BVPROC glad_glVertexAttribI4bv = 
# 930 "include/glad.c" 3 4
                                                   __null
# 930 "include/glad.c"
                                                       ;
PFNGLVERTEXATTRIBI4IPROC glad_glVertexAttribI4i = 
# 931 "include/glad.c" 3 4
                                                 __null
# 931 "include/glad.c"
                                                     ;
PFNGLVERTEXATTRIBI4IVPROC glad_glVertexAttribI4iv = 
# 932 "include/glad.c" 3 4
                                                   __null
# 932 "include/glad.c"
                                                       ;
PFNGLVERTEXATTRIBI4SVPROC glad_glVertexAttribI4sv = 
# 933 "include/glad.c" 3 4
                                                   __null
# 933 "include/glad.c"
                                                       ;
PFNGLVERTEXATTRIBI4UBVPROC glad_glVertexAttribI4ubv = 
# 934 "include/glad.c" 3 4
                                                     __null
# 934 "include/glad.c"
                                                         ;
PFNGLVERTEXATTRIBI4UIPROC glad_glVertexAttribI4ui = 
# 935 "include/glad.c" 3 4
                                                   __null
# 935 "include/glad.c"
                                                       ;
PFNGLVERTEXATTRIBI4UIVPROC glad_glVertexAttribI4uiv = 
# 936 "include/glad.c" 3 4
                                                     __null
# 936 "include/glad.c"
                                                         ;
PFNGLVERTEXATTRIBI4USVPROC glad_glVertexAttribI4usv = 
# 937 "include/glad.c" 3 4
                                                     __null
# 937 "include/glad.c"
                                                         ;
PFNGLVERTEXATTRIBIFORMATPROC glad_glVertexAttribIFormat = 
# 938 "include/glad.c" 3 4
                                                         __null
# 938 "include/glad.c"
                                                             ;
PFNGLVERTEXATTRIBIPOINTERPROC glad_glVertexAttribIPointer = 
# 939 "include/glad.c" 3 4
                                                           __null
# 939 "include/glad.c"
                                                               ;
PFNGLVERTEXATTRIBL1DPROC glad_glVertexAttribL1d = 
# 940 "include/glad.c" 3 4
                                                 __null
# 940 "include/glad.c"
                                                     ;
PFNGLVERTEXATTRIBL1DVPROC glad_glVertexAttribL1dv = 
# 941 "include/glad.c" 3 4
                                                   __null
# 941 "include/glad.c"
                                                       ;
PFNGLVERTEXATTRIBL2DPROC glad_glVertexAttribL2d = 
# 942 "include/glad.c" 3 4
                                                 __null
# 942 "include/glad.c"
                                                     ;
PFNGLVERTEXATTRIBL2DVPROC glad_glVertexAttribL2dv = 
# 943 "include/glad.c" 3 4
                                                   __null
# 943 "include/glad.c"
                                                       ;
PFNGLVERTEXATTRIBL3DPROC glad_glVertexAttribL3d = 
# 944 "include/glad.c" 3 4
                                                 __null
# 944 "include/glad.c"
                                                     ;
PFNGLVERTEXATTRIBL3DVPROC glad_glVertexAttribL3dv = 
# 945 "include/glad.c" 3 4
                                                   __null
# 945 "include/glad.c"
                                                       ;
PFNGLVERTEXATTRIBL4DPROC glad_glVertexAttribL4d = 
# 946 "include/glad.c" 3 4
                                                 __null
# 946 "include/glad.c"
                                                     ;
PFNGLVERTEXATTRIBL4DVPROC glad_glVertexAttribL4dv = 
# 947 "include/glad.c" 3 4
                                                   __null
# 947 "include/glad.c"
                                                       ;
PFNGLVERTEXATTRIBLFORMATPROC glad_glVertexAttribLFormat = 
# 948 "include/glad.c" 3 4
                                                         __null
# 948 "include/glad.c"
                                                             ;
PFNGLVERTEXATTRIBLPOINTERPROC glad_glVertexAttribLPointer = 
# 949 "include/glad.c" 3 4
                                                           __null
# 949 "include/glad.c"
                                                               ;
PFNGLVERTEXATTRIBP1UIPROC glad_glVertexAttribP1ui = 
# 950 "include/glad.c" 3 4
                                                   __null
# 950 "include/glad.c"
                                                       ;
PFNGLVERTEXATTRIBP1UIVPROC glad_glVertexAttribP1uiv = 
# 951 "include/glad.c" 3 4
                                                     __null
# 951 "include/glad.c"
                                                         ;
PFNGLVERTEXATTRIBP2UIPROC glad_glVertexAttribP2ui = 
# 952 "include/glad.c" 3 4
                                                   __null
# 952 "include/glad.c"
                                                       ;
PFNGLVERTEXATTRIBP2UIVPROC glad_glVertexAttribP2uiv = 
# 953 "include/glad.c" 3 4
                                                     __null
# 953 "include/glad.c"
                                                         ;
PFNGLVERTEXATTRIBP3UIPROC glad_glVertexAttribP3ui = 
# 954 "include/glad.c" 3 4
                                                   __null
# 954 "include/glad.c"
                                                       ;
PFNGLVERTEXATTRIBP3UIVPROC glad_glVertexAttribP3uiv = 
# 955 "include/glad.c" 3 4
                                                     __null
# 955 "include/glad.c"
                                                         ;
PFNGLVERTEXATTRIBP4UIPROC glad_glVertexAttribP4ui = 
# 956 "include/glad.c" 3 4
                                                   __null
# 956 "include/glad.c"
                                                       ;
PFNGLVERTEXATTRIBP4UIVPROC glad_glVertexAttribP4uiv = 
# 957 "include/glad.c" 3 4
                                                     __null
# 957 "include/glad.c"
                                                         ;
PFNGLVERTEXATTRIBPOINTERPROC glad_glVertexAttribPointer = 
# 958 "include/glad.c" 3 4
                                                         __null
# 958 "include/glad.c"
                                                             ;
PFNGLVERTEXBINDINGDIVISORPROC glad_glVertexBindingDivisor = 
# 959 "include/glad.c" 3 4
                                                           __null
# 959 "include/glad.c"
                                                               ;
PFNGLVERTEXP2UIPROC glad_glVertexP2ui = 
# 960 "include/glad.c" 3 4
                                       __null
# 960 "include/glad.c"
                                           ;
PFNGLVERTEXP2UIVPROC glad_glVertexP2uiv = 
# 961 "include/glad.c" 3 4
                                         __null
# 961 "include/glad.c"
                                             ;
PFNGLVERTEXP3UIPROC glad_glVertexP3ui = 
# 962 "include/glad.c" 3 4
                                       __null
# 962 "include/glad.c"
                                           ;
PFNGLVERTEXP3UIVPROC glad_glVertexP3uiv = 
# 963 "include/glad.c" 3 4
                                         __null
# 963 "include/glad.c"
                                             ;
PFNGLVERTEXP4UIPROC glad_glVertexP4ui = 
# 964 "include/glad.c" 3 4
                                       __null
# 964 "include/glad.c"
                                           ;
PFNGLVERTEXP4UIVPROC glad_glVertexP4uiv = 
# 965 "include/glad.c" 3 4
                                         __null
# 965 "include/glad.c"
                                             ;
PFNGLVIEWPORTPROC glad_glViewport = 
# 966 "include/glad.c" 3 4
                                   __null
# 966 "include/glad.c"
                                       ;
PFNGLVIEWPORTARRAYVPROC glad_glViewportArrayv = 
# 967 "include/glad.c" 3 4
                                               __null
# 967 "include/glad.c"
                                                   ;
PFNGLVIEWPORTINDEXEDFPROC glad_glViewportIndexedf = 
# 968 "include/glad.c" 3 4
                                                   __null
# 968 "include/glad.c"
                                                       ;
PFNGLVIEWPORTINDEXEDFVPROC glad_glViewportIndexedfv = 
# 969 "include/glad.c" 3 4
                                                     __null
# 969 "include/glad.c"
                                                         ;
PFNGLWAITSYNCPROC glad_glWaitSync = 
# 970 "include/glad.c" 3 4
                                   __null
# 970 "include/glad.c"
                                       ;
static void load_GL_VERSION_1_0(GLADloadproc load) {
 if(!GLAD_GL_VERSION_1_0) return;
 glad_glCullFace = (PFNGLCULLFACEPROC)load("glCullFace");
 glad_glFrontFace = (PFNGLFRONTFACEPROC)load("glFrontFace");
 glad_glHint = (PFNGLHINTPROC)load("glHint");
 glad_glLineWidth = (PFNGLLINEWIDTHPROC)load("glLineWidth");
 glad_glPointSize = (PFNGLPOINTSIZEPROC)load("glPointSize");
 glad_glPolygonMode = (PFNGLPOLYGONMODEPROC)load("glPolygonMode");
 glad_glScissor = (PFNGLSCISSORPROC)load("glScissor");
 glad_glTexParameterf = (PFNGLTEXPARAMETERFPROC)load("glTexParameterf");
 glad_glTexParameterfv = (PFNGLTEXPARAMETERFVPROC)load("glTexParameterfv");
 glad_glTexParameteri = (PFNGLTEXPARAMETERIPROC)load("glTexParameteri");
 glad_glTexParameteriv = (PFNGLTEXPARAMETERIVPROC)load("glTexParameteriv");
 glad_glTexImage1D = (PFNGLTEXIMAGE1DPROC)load("glTexImage1D");
 glad_glTexImage2D = (PFNGLTEXIMAGE2DPROC)load("glTexImage2D");
 glad_glDrawBuffer = (PFNGLDRAWBUFFERPROC)load("glDrawBuffer");
 glad_glClear = (PFNGLCLEARPROC)load("glClear");
 glad_glClearColor = (PFNGLCLEARCOLORPROC)load("glClearColor");
 glad_glClearStencil = (PFNGLCLEARSTENCILPROC)load("glClearStencil");
 glad_glClearDepth = (PFNGLCLEARDEPTHPROC)load("glClearDepth");
 glad_glStencilMask = (PFNGLSTENCILMASKPROC)load("glStencilMask");
 glad_glColorMask = (PFNGLCOLORMASKPROC)load("glColorMask");
 glad_glDepthMask = (PFNGLDEPTHMASKPROC)load("glDepthMask");
 glad_glDisable = (PFNGLDISABLEPROC)load("glDisable");
 glad_glEnable = (PFNGLENABLEPROC)load("glEnable");
 glad_glFinish = (PFNGLFINISHPROC)load("glFinish");
 glad_glFlush = (PFNGLFLUSHPROC)load("glFlush");
 glad_glBlendFunc = (PFNGLBLENDFUNCPROC)load("glBlendFunc");
 glad_glLogicOp = (PFNGLLOGICOPPROC)load("glLogicOp");
 glad_glStencilFunc = (PFNGLSTENCILFUNCPROC)load("glStencilFunc");
 glad_glStencilOp = (PFNGLSTENCILOPPROC)load("glStencilOp");
 glad_glDepthFunc = (PFNGLDEPTHFUNCPROC)load("glDepthFunc");
 glad_glPixelStoref = (PFNGLPIXELSTOREFPROC)load("glPixelStoref");
 glad_glPixelStorei = (PFNGLPIXELSTOREIPROC)load("glPixelStorei");
 glad_glReadBuffer = (PFNGLREADBUFFERPROC)load("glReadBuffer");
 glad_glReadPixels = (PFNGLREADPIXELSPROC)load("glReadPixels");
 glad_glGetBooleanv = (PFNGLGETBOOLEANVPROC)load("glGetBooleanv");
 glad_glGetDoublev = (PFNGLGETDOUBLEVPROC)load("glGetDoublev");
 glad_glGetError = (PFNGLGETERRORPROC)load("glGetError");
 glad_glGetFloatv = (PFNGLGETFLOATVPROC)load("glGetFloatv");
 glad_glGetIntegerv = (PFNGLGETINTEGERVPROC)load("glGetIntegerv");
 glad_glGetString = (PFNGLGETSTRINGPROC)load("glGetString");
 glad_glGetTexImage = (PFNGLGETTEXIMAGEPROC)load("glGetTexImage");
 glad_glGetTexParameterfv = (PFNGLGETTEXPARAMETERFVPROC)load("glGetTexParameterfv");
 glad_glGetTexParameteriv = (PFNGLGETTEXPARAMETERIVPROC)load("glGetTexParameteriv");
 glad_glGetTexLevelParameterfv = (PFNGLGETTEXLEVELPARAMETERFVPROC)load("glGetTexLevelParameterfv");
 glad_glGetTexLevelParameteriv = (PFNGLGETTEXLEVELPARAMETERIVPROC)load("glGetTexLevelParameteriv");
 glad_glIsEnabled = (PFNGLISENABLEDPROC)load("glIsEnabled");
 glad_glDepthRange = (PFNGLDEPTHRANGEPROC)load("glDepthRange");
 glad_glViewport = (PFNGLVIEWPORTPROC)load("glViewport");
}
static void load_GL_VERSION_1_1(GLADloadproc load) {
 if(!GLAD_GL_VERSION_1_1) return;
 glad_glDrawArrays = (PFNGLDRAWARRAYSPROC)load("glDrawArrays");
 glad_glDrawElements = (PFNGLDRAWELEMENTSPROC)load("glDrawElements");
 glad_glPolygonOffset = (PFNGLPOLYGONOFFSETPROC)load("glPolygonOffset");
 glad_glCopyTexImage1D = (PFNGLCOPYTEXIMAGE1DPROC)load("glCopyTexImage1D");
 glad_glCopyTexImage2D = (PFNGLCOPYTEXIMAGE2DPROC)load("glCopyTexImage2D");
 glad_glCopyTexSubImage1D = (PFNGLCOPYTEXSUBIMAGE1DPROC)load("glCopyTexSubImage1D");
 glad_glCopyTexSubImage2D = (PFNGLCOPYTEXSUBIMAGE2DPROC)load("glCopyTexSubImage2D");
 glad_glTexSubImage1D = (PFNGLTEXSUBIMAGE1DPROC)load("glTexSubImage1D");
 glad_glTexSubImage2D = (PFNGLTEXSUBIMAGE2DPROC)load("glTexSubImage2D");
 glad_glBindTexture = (PFNGLBINDTEXTUREPROC)load("glBindTexture");
 glad_glDeleteTextures = (PFNGLDELETETEXTURESPROC)load("glDeleteTextures");
 glad_glGenTextures = (PFNGLGENTEXTURESPROC)load("glGenTextures");
 glad_glIsTexture = (PFNGLISTEXTUREPROC)load("glIsTexture");
}
static void load_GL_VERSION_1_2(GLADloadproc load) {
 if(!GLAD_GL_VERSION_1_2) return;
 glad_glDrawRangeElements = (PFNGLDRAWRANGEELEMENTSPROC)load("glDrawRangeElements");
 glad_glTexImage3D = (PFNGLTEXIMAGE3DPROC)load("glTexImage3D");
 glad_glTexSubImage3D = (PFNGLTEXSUBIMAGE3DPROC)load("glTexSubImage3D");
 glad_glCopyTexSubImage3D = (PFNGLCOPYTEXSUBIMAGE3DPROC)load("glCopyTexSubImage3D");
}
static void load_GL_VERSION_1_3(GLADloadproc load) {
 if(!GLAD_GL_VERSION_1_3) return;
 glad_glActiveTexture = (PFNGLACTIVETEXTUREPROC)load("glActiveTexture");
 glad_glSampleCoverage = (PFNGLSAMPLECOVERAGEPROC)load("glSampleCoverage");
 glad_glCompressedTexImage3D = (PFNGLCOMPRESSEDTEXIMAGE3DPROC)load("glCompressedTexImage3D");
 glad_glCompressedTexImage2D = (PFNGLCOMPRESSEDTEXIMAGE2DPROC)load("glCompressedTexImage2D");
 glad_glCompressedTexImage1D = (PFNGLCOMPRESSEDTEXIMAGE1DPROC)load("glCompressedTexImage1D");
 glad_glCompressedTexSubImage3D = (PFNGLCOMPRESSEDTEXSUBIMAGE3DPROC)load("glCompressedTexSubImage3D");
 glad_glCompressedTexSubImage2D = (PFNGLCOMPRESSEDTEXSUBIMAGE2DPROC)load("glCompressedTexSubImage2D");
 glad_glCompressedTexSubImage1D = (PFNGLCOMPRESSEDTEXSUBIMAGE1DPROC)load("glCompressedTexSubImage1D");
 glad_glGetCompressedTexImage = (PFNGLGETCOMPRESSEDTEXIMAGEPROC)load("glGetCompressedTexImage");
}
static void load_GL_VERSION_1_4(GLADloadproc load) {
 if(!GLAD_GL_VERSION_1_4) return;
 glad_glBlendFuncSeparate = (PFNGLBLENDFUNCSEPARATEPROC)load("glBlendFuncSeparate");
 glad_glMultiDrawArrays = (PFNGLMULTIDRAWARRAYSPROC)load("glMultiDrawArrays");
 glad_glMultiDrawElements = (PFNGLMULTIDRAWELEMENTSPROC)load("glMultiDrawElements");
 glad_glPointParameterf = (PFNGLPOINTPARAMETERFPROC)load("glPointParameterf");
 glad_glPointParameterfv = (PFNGLPOINTPARAMETERFVPROC)load("glPointParameterfv");
 glad_glPointParameteri = (PFNGLPOINTPARAMETERIPROC)load("glPointParameteri");
 glad_glPointParameteriv = (PFNGLPOINTPARAMETERIVPROC)load("glPointParameteriv");
 glad_glBlendColor = (PFNGLBLENDCOLORPROC)load("glBlendColor");
 glad_glBlendEquation = (PFNGLBLENDEQUATIONPROC)load("glBlendEquation");
}
static void load_GL_VERSION_1_5(GLADloadproc load) {
 if(!GLAD_GL_VERSION_1_5) return;
 glad_glGenQueries = (PFNGLGENQUERIESPROC)load("glGenQueries");
 glad_glDeleteQueries = (PFNGLDELETEQUERIESPROC)load("glDeleteQueries");
 glad_glIsQuery = (PFNGLISQUERYPROC)load("glIsQuery");
 glad_glBeginQuery = (PFNGLBEGINQUERYPROC)load("glBeginQuery");
 glad_glEndQuery = (PFNGLENDQUERYPROC)load("glEndQuery");
 glad_glGetQueryiv = (PFNGLGETQUERYIVPROC)load("glGetQueryiv");
 glad_glGetQueryObjectiv = (PFNGLGETQUERYOBJECTIVPROC)load("glGetQueryObjectiv");
 glad_glGetQueryObjectuiv = (PFNGLGETQUERYOBJECTUIVPROC)load("glGetQueryObjectuiv");
 glad_glBindBuffer = (PFNGLBINDBUFFERPROC)load("glBindBuffer");
 glad_glDeleteBuffers = (PFNGLDELETEBUFFERSPROC)load("glDeleteBuffers");
 glad_glGenBuffers = (PFNGLGENBUFFERSPROC)load("glGenBuffers");
 glad_glIsBuffer = (PFNGLISBUFFERPROC)load("glIsBuffer");
 glad_glBufferData = (PFNGLBUFFERDATAPROC)load("glBufferData");
 glad_glBufferSubData = (PFNGLBUFFERSUBDATAPROC)load("glBufferSubData");
 glad_glGetBufferSubData = (PFNGLGETBUFFERSUBDATAPROC)load("glGetBufferSubData");
 glad_glMapBuffer = (PFNGLMAPBUFFERPROC)load("glMapBuffer");
 glad_glUnmapBuffer = (PFNGLUNMAPBUFFERPROC)load("glUnmapBuffer");
 glad_glGetBufferParameteriv = (PFNGLGETBUFFERPARAMETERIVPROC)load("glGetBufferParameteriv");
 glad_glGetBufferPointerv = (PFNGLGETBUFFERPOINTERVPROC)load("glGetBufferPointerv");
}
static void load_GL_VERSION_2_0(GLADloadproc load) {
 if(!GLAD_GL_VERSION_2_0) return;
 glad_glBlendEquationSeparate = (PFNGLBLENDEQUATIONSEPARATEPROC)load("glBlendEquationSeparate");
 glad_glDrawBuffers = (PFNGLDRAWBUFFERSPROC)load("glDrawBuffers");
 glad_glStencilOpSeparate = (PFNGLSTENCILOPSEPARATEPROC)load("glStencilOpSeparate");
 glad_glStencilFuncSeparate = (PFNGLSTENCILFUNCSEPARATEPROC)load("glStencilFuncSeparate");
 glad_glStencilMaskSeparate = (PFNGLSTENCILMASKSEPARATEPROC)load("glStencilMaskSeparate");
 glad_glAttachShader = (PFNGLATTACHSHADERPROC)load("glAttachShader");
 glad_glBindAttribLocation = (PFNGLBINDATTRIBLOCATIONPROC)load("glBindAttribLocation");
 glad_glCompileShader = (PFNGLCOMPILESHADERPROC)load("glCompileShader");
 glad_glCreateProgram = (PFNGLCREATEPROGRAMPROC)load("glCreateProgram");
 glad_glCreateShader = (PFNGLCREATESHADERPROC)load("glCreateShader");
 glad_glDeleteProgram = (PFNGLDELETEPROGRAMPROC)load("glDeleteProgram");
 glad_glDeleteShader = (PFNGLDELETESHADERPROC)load("glDeleteShader");
 glad_glDetachShader = (PFNGLDETACHSHADERPROC)load("glDetachShader");
 glad_glDisableVertexAttribArray = (PFNGLDISABLEVERTEXATTRIBARRAYPROC)load("glDisableVertexAttribArray");
 glad_glEnableVertexAttribArray = (PFNGLENABLEVERTEXATTRIBARRAYPROC)load("glEnableVertexAttribArray");
 glad_glGetActiveAttrib = (PFNGLGETACTIVEATTRIBPROC)load("glGetActiveAttrib");
 glad_glGetActiveUniform = (PFNGLGETACTIVEUNIFORMPROC)load("glGetActiveUniform");
 glad_glGetAttachedShaders = (PFNGLGETATTACHEDSHADERSPROC)load("glGetAttachedShaders");
 glad_glGetAttribLocation = (PFNGLGETATTRIBLOCATIONPROC)load("glGetAttribLocation");
 glad_glGetProgramiv = (PFNGLGETPROGRAMIVPROC)load("glGetProgramiv");
 glad_glGetProgramInfoLog = (PFNGLGETPROGRAMINFOLOGPROC)load("glGetProgramInfoLog");
 glad_glGetShaderiv = (PFNGLGETSHADERIVPROC)load("glGetShaderiv");
 glad_glGetShaderInfoLog = (PFNGLGETSHADERINFOLOGPROC)load("glGetShaderInfoLog");
 glad_glGetShaderSource = (PFNGLGETSHADERSOURCEPROC)load("glGetShaderSource");
 glad_glGetUniformLocation = (PFNGLGETUNIFORMLOCATIONPROC)load("glGetUniformLocation");
 glad_glGetUniformfv = (PFNGLGETUNIFORMFVPROC)load("glGetUniformfv");
 glad_glGetUniformiv = (PFNGLGETUNIFORMIVPROC)load("glGetUniformiv");
 glad_glGetVertexAttribdv = (PFNGLGETVERTEXATTRIBDVPROC)load("glGetVertexAttribdv");
 glad_glGetVertexAttribfv = (PFNGLGETVERTEXATTRIBFVPROC)load("glGetVertexAttribfv");
 glad_glGetVertexAttribiv = (PFNGLGETVERTEXATTRIBIVPROC)load("glGetVertexAttribiv");
 glad_glGetVertexAttribPointerv = (PFNGLGETVERTEXATTRIBPOINTERVPROC)load("glGetVertexAttribPointerv");
 glad_glIsProgram = (PFNGLISPROGRAMPROC)load("glIsProgram");
 glad_glIsShader = (PFNGLISSHADERPROC)load("glIsShader");
 glad_glLinkProgram = (PFNGLLINKPROGRAMPROC)load("glLinkProgram");
 glad_glShaderSource = (PFNGLSHADERSOURCEPROC)load("glShaderSource");
 glad_glUseProgram = (PFNGLUSEPROGRAMPROC)load("glUseProgram");
 glad_glUniform1f = (PFNGLUNIFORM1FPROC)load("glUniform1f");
 glad_glUniform2f = (PFNGLUNIFORM2FPROC)load("glUniform2f");
 glad_glUniform3f = (PFNGLUNIFORM3FPROC)load("glUniform3f");
 glad_glUniform4f = (PFNGLUNIFORM4FPROC)load("glUniform4f");
 glad_glUniform1i = (PFNGLUNIFORM1IPROC)load("glUniform1i");
 glad_glUniform2i = (PFNGLUNIFORM2IPROC)load("glUniform2i");
 glad_glUniform3i = (PFNGLUNIFORM3IPROC)load("glUniform3i");
 glad_glUniform4i = (PFNGLUNIFORM4IPROC)load("glUniform4i");
 glad_glUniform1fv = (PFNGLUNIFORM1FVPROC)load("glUniform1fv");
 glad_glUniform2fv = (PFNGLUNIFORM2FVPROC)load("glUniform2fv");
 glad_glUniform3fv = (PFNGLUNIFORM3FVPROC)load("glUniform3fv");
 glad_glUniform4fv = (PFNGLUNIFORM4FVPROC)load("glUniform4fv");
 glad_glUniform1iv = (PFNGLUNIFORM1IVPROC)load("glUniform1iv");
 glad_glUniform2iv = (PFNGLUNIFORM2IVPROC)load("glUniform2iv");
 glad_glUniform3iv = (PFNGLUNIFORM3IVPROC)load("glUniform3iv");
 glad_glUniform4iv = (PFNGLUNIFORM4IVPROC)load("glUniform4iv");
 glad_glUniformMatrix2fv = (PFNGLUNIFORMMATRIX2FVPROC)load("glUniformMatrix2fv");
 glad_glUniformMatrix3fv = (PFNGLUNIFORMMATRIX3FVPROC)load("glUniformMatrix3fv");
 glad_glUniformMatrix4fv = (PFNGLUNIFORMMATRIX4FVPROC)load("glUniformMatrix4fv");
 glad_glValidateProgram = (PFNGLVALIDATEPROGRAMPROC)load("glValidateProgram");
 glad_glVertexAttrib1d = (PFNGLVERTEXATTRIB1DPROC)load("glVertexAttrib1d");
 glad_glVertexAttrib1dv = (PFNGLVERTEXATTRIB1DVPROC)load("glVertexAttrib1dv");
 glad_glVertexAttrib1f = (PFNGLVERTEXATTRIB1FPROC)load("glVertexAttrib1f");
 glad_glVertexAttrib1fv = (PFNGLVERTEXATTRIB1FVPROC)load("glVertexAttrib1fv");
 glad_glVertexAttrib1s = (PFNGLVERTEXATTRIB1SPROC)load("glVertexAttrib1s");
 glad_glVertexAttrib1sv = (PFNGLVERTEXATTRIB1SVPROC)load("glVertexAttrib1sv");
 glad_glVertexAttrib2d = (PFNGLVERTEXATTRIB2DPROC)load("glVertexAttrib2d");
 glad_glVertexAttrib2dv = (PFNGLVERTEXATTRIB2DVPROC)load("glVertexAttrib2dv");
 glad_glVertexAttrib2f = (PFNGLVERTEXATTRIB2FPROC)load("glVertexAttrib2f");
 glad_glVertexAttrib2fv = (PFNGLVERTEXATTRIB2FVPROC)load("glVertexAttrib2fv");
 glad_glVertexAttrib2s = (PFNGLVERTEXATTRIB2SPROC)load("glVertexAttrib2s");
 glad_glVertexAttrib2sv = (PFNGLVERTEXATTRIB2SVPROC)load("glVertexAttrib2sv");
 glad_glVertexAttrib3d = (PFNGLVERTEXATTRIB3DPROC)load("glVertexAttrib3d");
 glad_glVertexAttrib3dv = (PFNGLVERTEXATTRIB3DVPROC)load("glVertexAttrib3dv");
 glad_glVertexAttrib3f = (PFNGLVERTEXATTRIB3FPROC)load("glVertexAttrib3f");
 glad_glVertexAttrib3fv = (PFNGLVERTEXATTRIB3FVPROC)load("glVertexAttrib3fv");
 glad_glVertexAttrib3s = (PFNGLVERTEXATTRIB3SPROC)load("glVertexAttrib3s");
 glad_glVertexAttrib3sv = (PFNGLVERTEXATTRIB3SVPROC)load("glVertexAttrib3sv");
 glad_glVertexAttrib4Nbv = (PFNGLVERTEXATTRIB4NBVPROC)load("glVertexAttrib4Nbv");
 glad_glVertexAttrib4Niv = (PFNGLVERTEXATTRIB4NIVPROC)load("glVertexAttrib4Niv");
 glad_glVertexAttrib4Nsv = (PFNGLVERTEXATTRIB4NSVPROC)load("glVertexAttrib4Nsv");
 glad_glVertexAttrib4Nub = (PFNGLVERTEXATTRIB4NUBPROC)load("glVertexAttrib4Nub");
 glad_glVertexAttrib4Nubv = (PFNGLVERTEXATTRIB4NUBVPROC)load("glVertexAttrib4Nubv");
 glad_glVertexAttrib4Nuiv = (PFNGLVERTEXATTRIB4NUIVPROC)load("glVertexAttrib4Nuiv");
 glad_glVertexAttrib4Nusv = (PFNGLVERTEXATTRIB4NUSVPROC)load("glVertexAttrib4Nusv");
 glad_glVertexAttrib4bv = (PFNGLVERTEXATTRIB4BVPROC)load("glVertexAttrib4bv");
 glad_glVertexAttrib4d = (PFNGLVERTEXATTRIB4DPROC)load("glVertexAttrib4d");
 glad_glVertexAttrib4dv = (PFNGLVERTEXATTRIB4DVPROC)load("glVertexAttrib4dv");
 glad_glVertexAttrib4f = (PFNGLVERTEXATTRIB4FPROC)load("glVertexAttrib4f");
 glad_glVertexAttrib4fv = (PFNGLVERTEXATTRIB4FVPROC)load("glVertexAttrib4fv");
 glad_glVertexAttrib4iv = (PFNGLVERTEXATTRIB4IVPROC)load("glVertexAttrib4iv");
 glad_glVertexAttrib4s = (PFNGLVERTEXATTRIB4SPROC)load("glVertexAttrib4s");
 glad_glVertexAttrib4sv = (PFNGLVERTEXATTRIB4SVPROC)load("glVertexAttrib4sv");
 glad_glVertexAttrib4ubv = (PFNGLVERTEXATTRIB4UBVPROC)load("glVertexAttrib4ubv");
 glad_glVertexAttrib4uiv = (PFNGLVERTEXATTRIB4UIVPROC)load("glVertexAttrib4uiv");
 glad_glVertexAttrib4usv = (PFNGLVERTEXATTRIB4USVPROC)load("glVertexAttrib4usv");
 glad_glVertexAttribPointer = (PFNGLVERTEXATTRIBPOINTERPROC)load("glVertexAttribPointer");
}
static void load_GL_VERSION_2_1(GLADloadproc load) {
 if(!GLAD_GL_VERSION_2_1) return;
 glad_glUniformMatrix2x3fv = (PFNGLUNIFORMMATRIX2X3FVPROC)load("glUniformMatrix2x3fv");
 glad_glUniformMatrix3x2fv = (PFNGLUNIFORMMATRIX3X2FVPROC)load("glUniformMatrix3x2fv");
 glad_glUniformMatrix2x4fv = (PFNGLUNIFORMMATRIX2X4FVPROC)load("glUniformMatrix2x4fv");
 glad_glUniformMatrix4x2fv = (PFNGLUNIFORMMATRIX4X2FVPROC)load("glUniformMatrix4x2fv");
 glad_glUniformMatrix3x4fv = (PFNGLUNIFORMMATRIX3X4FVPROC)load("glUniformMatrix3x4fv");
 glad_glUniformMatrix4x3fv = (PFNGLUNIFORMMATRIX4X3FVPROC)load("glUniformMatrix4x3fv");
}
static void load_GL_VERSION_3_0(GLADloadproc load) {
 if(!GLAD_GL_VERSION_3_0) return;
 glad_glColorMaski = (PFNGLCOLORMASKIPROC)load("glColorMaski");
 glad_glGetBooleani_v = (PFNGLGETBOOLEANI_VPROC)load("glGetBooleani_v");
 glad_glGetIntegeri_v = (PFNGLGETINTEGERI_VPROC)load("glGetIntegeri_v");
 glad_glEnablei = (PFNGLENABLEIPROC)load("glEnablei");
 glad_glDisablei = (PFNGLDISABLEIPROC)load("glDisablei");
 glad_glIsEnabledi = (PFNGLISENABLEDIPROC)load("glIsEnabledi");
 glad_glBeginTransformFeedback = (PFNGLBEGINTRANSFORMFEEDBACKPROC)load("glBeginTransformFeedback");
 glad_glEndTransformFeedback = (PFNGLENDTRANSFORMFEEDBACKPROC)load("glEndTransformFeedback");
 glad_glBindBufferRange = (PFNGLBINDBUFFERRANGEPROC)load("glBindBufferRange");
 glad_glBindBufferBase = (PFNGLBINDBUFFERBASEPROC)load("glBindBufferBase");
 glad_glTransformFeedbackVaryings = (PFNGLTRANSFORMFEEDBACKVARYINGSPROC)load("glTransformFeedbackVaryings");
 glad_glGetTransformFeedbackVarying = (PFNGLGETTRANSFORMFEEDBACKVARYINGPROC)load("glGetTransformFeedbackVarying");
 glad_glClampColor = (PFNGLCLAMPCOLORPROC)load("glClampColor");
 glad_glBeginConditionalRender = (PFNGLBEGINCONDITIONALRENDERPROC)load("glBeginConditionalRender");
 glad_glEndConditionalRender = (PFNGLENDCONDITIONALRENDERPROC)load("glEndConditionalRender");
 glad_glVertexAttribIPointer = (PFNGLVERTEXATTRIBIPOINTERPROC)load("glVertexAttribIPointer");
 glad_glGetVertexAttribIiv = (PFNGLGETVERTEXATTRIBIIVPROC)load("glGetVertexAttribIiv");
 glad_glGetVertexAttribIuiv = (PFNGLGETVERTEXATTRIBIUIVPROC)load("glGetVertexAttribIuiv");
 glad_glVertexAttribI1i = (PFNGLVERTEXATTRIBI1IPROC)load("glVertexAttribI1i");
 glad_glVertexAttribI2i = (PFNGLVERTEXATTRIBI2IPROC)load("glVertexAttribI2i");
 glad_glVertexAttribI3i = (PFNGLVERTEXATTRIBI3IPROC)load("glVertexAttribI3i");
 glad_glVertexAttribI4i = (PFNGLVERTEXATTRIBI4IPROC)load("glVertexAttribI4i");
 glad_glVertexAttribI1ui = (PFNGLVERTEXATTRIBI1UIPROC)load("glVertexAttribI1ui");
 glad_glVertexAttribI2ui = (PFNGLVERTEXATTRIBI2UIPROC)load("glVertexAttribI2ui");
 glad_glVertexAttribI3ui = (PFNGLVERTEXATTRIBI3UIPROC)load("glVertexAttribI3ui");
 glad_glVertexAttribI4ui = (PFNGLVERTEXATTRIBI4UIPROC)load("glVertexAttribI4ui");
 glad_glVertexAttribI1iv = (PFNGLVERTEXATTRIBI1IVPROC)load("glVertexAttribI1iv");
 glad_glVertexAttribI2iv = (PFNGLVERTEXATTRIBI2IVPROC)load("glVertexAttribI2iv");
 glad_glVertexAttribI3iv = (PFNGLVERTEXATTRIBI3IVPROC)load("glVertexAttribI3iv");
 glad_glVertexAttribI4iv = (PFNGLVERTEXATTRIBI4IVPROC)load("glVertexAttribI4iv");
 glad_glVertexAttribI1uiv = (PFNGLVERTEXATTRIBI1UIVPROC)load("glVertexAttribI1uiv");
 glad_glVertexAttribI2uiv = (PFNGLVERTEXATTRIBI2UIVPROC)load("glVertexAttribI2uiv");
 glad_glVertexAttribI3uiv = (PFNGLVERTEXATTRIBI3UIVPROC)load("glVertexAttribI3uiv");
 glad_glVertexAttribI4uiv = (PFNGLVERTEXATTRIBI4UIVPROC)load("glVertexAttribI4uiv");
 glad_glVertexAttribI4bv = (PFNGLVERTEXATTRIBI4BVPROC)load("glVertexAttribI4bv");
 glad_glVertexAttribI4sv = (PFNGLVERTEXATTRIBI4SVPROC)load("glVertexAttribI4sv");
 glad_glVertexAttribI4ubv = (PFNGLVERTEXATTRIBI4UBVPROC)load("glVertexAttribI4ubv");
 glad_glVertexAttribI4usv = (PFNGLVERTEXATTRIBI4USVPROC)load("glVertexAttribI4usv");
 glad_glGetUniformuiv = (PFNGLGETUNIFORMUIVPROC)load("glGetUniformuiv");
 glad_glBindFragDataLocation = (PFNGLBINDFRAGDATALOCATIONPROC)load("glBindFragDataLocation");
 glad_glGetFragDataLocation = (PFNGLGETFRAGDATALOCATIONPROC)load("glGetFragDataLocation");
 glad_glUniform1ui = (PFNGLUNIFORM1UIPROC)load("glUniform1ui");
 glad_glUniform2ui = (PFNGLUNIFORM2UIPROC)load("glUniform2ui");
 glad_glUniform3ui = (PFNGLUNIFORM3UIPROC)load("glUniform3ui");
 glad_glUniform4ui = (PFNGLUNIFORM4UIPROC)load("glUniform4ui");
 glad_glUniform1uiv = (PFNGLUNIFORM1UIVPROC)load("glUniform1uiv");
 glad_glUniform2uiv = (PFNGLUNIFORM2UIVPROC)load("glUniform2uiv");
 glad_glUniform3uiv = (PFNGLUNIFORM3UIVPROC)load("glUniform3uiv");
 glad_glUniform4uiv = (PFNGLUNIFORM4UIVPROC)load("glUniform4uiv");
 glad_glTexParameterIiv = (PFNGLTEXPARAMETERIIVPROC)load("glTexParameterIiv");
 glad_glTexParameterIuiv = (PFNGLTEXPARAMETERIUIVPROC)load("glTexParameterIuiv");
 glad_glGetTexParameterIiv = (PFNGLGETTEXPARAMETERIIVPROC)load("glGetTexParameterIiv");
 glad_glGetTexParameterIuiv = (PFNGLGETTEXPARAMETERIUIVPROC)load("glGetTexParameterIuiv");
 glad_glClearBufferiv = (PFNGLCLEARBUFFERIVPROC)load("glClearBufferiv");
 glad_glClearBufferuiv = (PFNGLCLEARBUFFERUIVPROC)load("glClearBufferuiv");
 glad_glClearBufferfv = (PFNGLCLEARBUFFERFVPROC)load("glClearBufferfv");
 glad_glClearBufferfi = (PFNGLCLEARBUFFERFIPROC)load("glClearBufferfi");
 glad_glGetStringi = (PFNGLGETSTRINGIPROC)load("glGetStringi");
 glad_glIsRenderbuffer = (PFNGLISRENDERBUFFERPROC)load("glIsRenderbuffer");
 glad_glBindRenderbuffer = (PFNGLBINDRENDERBUFFERPROC)load("glBindRenderbuffer");
 glad_glDeleteRenderbuffers = (PFNGLDELETERENDERBUFFERSPROC)load("glDeleteRenderbuffers");
 glad_glGenRenderbuffers = (PFNGLGENRENDERBUFFERSPROC)load("glGenRenderbuffers");
 glad_glRenderbufferStorage = (PFNGLRENDERBUFFERSTORAGEPROC)load("glRenderbufferStorage");
 glad_glGetRenderbufferParameteriv = (PFNGLGETRENDERBUFFERPARAMETERIVPROC)load("glGetRenderbufferParameteriv");
 glad_glIsFramebuffer = (PFNGLISFRAMEBUFFERPROC)load("glIsFramebuffer");
 glad_glBindFramebuffer = (PFNGLBINDFRAMEBUFFERPROC)load("glBindFramebuffer");
 glad_glDeleteFramebuffers = (PFNGLDELETEFRAMEBUFFERSPROC)load("glDeleteFramebuffers");
 glad_glGenFramebuffers = (PFNGLGENFRAMEBUFFERSPROC)load("glGenFramebuffers");
 glad_glCheckFramebufferStatus = (PFNGLCHECKFRAMEBUFFERSTATUSPROC)load("glCheckFramebufferStatus");
 glad_glFramebufferTexture1D = (PFNGLFRAMEBUFFERTEXTURE1DPROC)load("glFramebufferTexture1D");
 glad_glFramebufferTexture2D = (PFNGLFRAMEBUFFERTEXTURE2DPROC)load("glFramebufferTexture2D");
 glad_glFramebufferTexture3D = (PFNGLFRAMEBUFFERTEXTURE3DPROC)load("glFramebufferTexture3D");
 glad_glFramebufferRenderbuffer = (PFNGLFRAMEBUFFERRENDERBUFFERPROC)load("glFramebufferRenderbuffer");
 glad_glGetFramebufferAttachmentParameteriv = (PFNGLGETFRAMEBUFFERATTACHMENTPARAMETERIVPROC)load("glGetFramebufferAttachmentParameteriv");
 glad_glGenerateMipmap = (PFNGLGENERATEMIPMAPPROC)load("glGenerateMipmap");
 glad_glBlitFramebuffer = (PFNGLBLITFRAMEBUFFERPROC)load("glBlitFramebuffer");
 glad_glRenderbufferStorageMultisample = (PFNGLRENDERBUFFERSTORAGEMULTISAMPLEPROC)load("glRenderbufferStorageMultisample");
 glad_glFramebufferTextureLayer = (PFNGLFRAMEBUFFERTEXTURELAYERPROC)load("glFramebufferTextureLayer");
 glad_glMapBufferRange = (PFNGLMAPBUFFERRANGEPROC)load("glMapBufferRange");
 glad_glFlushMappedBufferRange = (PFNGLFLUSHMAPPEDBUFFERRANGEPROC)load("glFlushMappedBufferRange");
 glad_glBindVertexArray = (PFNGLBINDVERTEXARRAYPROC)load("glBindVertexArray");
 glad_glDeleteVertexArrays = (PFNGLDELETEVERTEXARRAYSPROC)load("glDeleteVertexArrays");
 glad_glGenVertexArrays = (PFNGLGENVERTEXARRAYSPROC)load("glGenVertexArrays");
 glad_glIsVertexArray = (PFNGLISVERTEXARRAYPROC)load("glIsVertexArray");
}
static void load_GL_VERSION_3_1(GLADloadproc load) {
 if(!GLAD_GL_VERSION_3_1) return;
 glad_glDrawArraysInstanced = (PFNGLDRAWARRAYSINSTANCEDPROC)load("glDrawArraysInstanced");
 glad_glDrawElementsInstanced = (PFNGLDRAWELEMENTSINSTANCEDPROC)load("glDrawElementsInstanced");
 glad_glTexBuffer = (PFNGLTEXBUFFERPROC)load("glTexBuffer");
 glad_glPrimitiveRestartIndex = (PFNGLPRIMITIVERESTARTINDEXPROC)load("glPrimitiveRestartIndex");
 glad_glCopyBufferSubData = (PFNGLCOPYBUFFERSUBDATAPROC)load("glCopyBufferSubData");
 glad_glGetUniformIndices = (PFNGLGETUNIFORMINDICESPROC)load("glGetUniformIndices");
 glad_glGetActiveUniformsiv = (PFNGLGETACTIVEUNIFORMSIVPROC)load("glGetActiveUniformsiv");
 glad_glGetActiveUniformName = (PFNGLGETACTIVEUNIFORMNAMEPROC)load("glGetActiveUniformName");
 glad_glGetUniformBlockIndex = (PFNGLGETUNIFORMBLOCKINDEXPROC)load("glGetUniformBlockIndex");
 glad_glGetActiveUniformBlockiv = (PFNGLGETACTIVEUNIFORMBLOCKIVPROC)load("glGetActiveUniformBlockiv");
 glad_glGetActiveUniformBlockName = (PFNGLGETACTIVEUNIFORMBLOCKNAMEPROC)load("glGetActiveUniformBlockName");
 glad_glUniformBlockBinding = (PFNGLUNIFORMBLOCKBINDINGPROC)load("glUniformBlockBinding");
 glad_glBindBufferRange = (PFNGLBINDBUFFERRANGEPROC)load("glBindBufferRange");
 glad_glBindBufferBase = (PFNGLBINDBUFFERBASEPROC)load("glBindBufferBase");
 glad_glGetIntegeri_v = (PFNGLGETINTEGERI_VPROC)load("glGetIntegeri_v");
}
static void load_GL_VERSION_3_2(GLADloadproc load) {
 if(!GLAD_GL_VERSION_3_2) return;
 glad_glDrawElementsBaseVertex = (PFNGLDRAWELEMENTSBASEVERTEXPROC)load("glDrawElementsBaseVertex");
 glad_glDrawRangeElementsBaseVertex = (PFNGLDRAWRANGEELEMENTSBASEVERTEXPROC)load("glDrawRangeElementsBaseVertex");
 glad_glDrawElementsInstancedBaseVertex = (PFNGLDRAWELEMENTSINSTANCEDBASEVERTEXPROC)load("glDrawElementsInstancedBaseVertex");
 glad_glMultiDrawElementsBaseVertex = (PFNGLMULTIDRAWELEMENTSBASEVERTEXPROC)load("glMultiDrawElementsBaseVertex");
 glad_glProvokingVertex = (PFNGLPROVOKINGVERTEXPROC)load("glProvokingVertex");
 glad_glFenceSync = (PFNGLFENCESYNCPROC)load("glFenceSync");
 glad_glIsSync = (PFNGLISSYNCPROC)load("glIsSync");
 glad_glDeleteSync = (PFNGLDELETESYNCPROC)load("glDeleteSync");
 glad_glClientWaitSync = (PFNGLCLIENTWAITSYNCPROC)load("glClientWaitSync");
 glad_glWaitSync = (PFNGLWAITSYNCPROC)load("glWaitSync");
 glad_glGetInteger64v = (PFNGLGETINTEGER64VPROC)load("glGetInteger64v");
 glad_glGetSynciv = (PFNGLGETSYNCIVPROC)load("glGetSynciv");
 glad_glGetInteger64i_v = (PFNGLGETINTEGER64I_VPROC)load("glGetInteger64i_v");
 glad_glGetBufferParameteri64v = (PFNGLGETBUFFERPARAMETERI64VPROC)load("glGetBufferParameteri64v");
 glad_glFramebufferTexture = (PFNGLFRAMEBUFFERTEXTUREPROC)load("glFramebufferTexture");
 glad_glTexImage2DMultisample = (PFNGLTEXIMAGE2DMULTISAMPLEPROC)load("glTexImage2DMultisample");
 glad_glTexImage3DMultisample = (PFNGLTEXIMAGE3DMULTISAMPLEPROC)load("glTexImage3DMultisample");
 glad_glGetMultisamplefv = (PFNGLGETMULTISAMPLEFVPROC)load("glGetMultisamplefv");
 glad_glSampleMaski = (PFNGLSAMPLEMASKIPROC)load("glSampleMaski");
}
static void load_GL_VERSION_3_3(GLADloadproc load) {
 if(!GLAD_GL_VERSION_3_3) return;
 glad_glBindFragDataLocationIndexed = (PFNGLBINDFRAGDATALOCATIONINDEXEDPROC)load("glBindFragDataLocationIndexed");
 glad_glGetFragDataIndex = (PFNGLGETFRAGDATAINDEXPROC)load("glGetFragDataIndex");
 glad_glGenSamplers = (PFNGLGENSAMPLERSPROC)load("glGenSamplers");
 glad_glDeleteSamplers = (PFNGLDELETESAMPLERSPROC)load("glDeleteSamplers");
 glad_glIsSampler = (PFNGLISSAMPLERPROC)load("glIsSampler");
 glad_glBindSampler = (PFNGLBINDSAMPLERPROC)load("glBindSampler");
 glad_glSamplerParameteri = (PFNGLSAMPLERPARAMETERIPROC)load("glSamplerParameteri");
 glad_glSamplerParameteriv = (PFNGLSAMPLERPARAMETERIVPROC)load("glSamplerParameteriv");
 glad_glSamplerParameterf = (PFNGLSAMPLERPARAMETERFPROC)load("glSamplerParameterf");
 glad_glSamplerParameterfv = (PFNGLSAMPLERPARAMETERFVPROC)load("glSamplerParameterfv");
 glad_glSamplerParameterIiv = (PFNGLSAMPLERPARAMETERIIVPROC)load("glSamplerParameterIiv");
 glad_glSamplerParameterIuiv = (PFNGLSAMPLERPARAMETERIUIVPROC)load("glSamplerParameterIuiv");
 glad_glGetSamplerParameteriv = (PFNGLGETSAMPLERPARAMETERIVPROC)load("glGetSamplerParameteriv");
 glad_glGetSamplerParameterIiv = (PFNGLGETSAMPLERPARAMETERIIVPROC)load("glGetSamplerParameterIiv");
 glad_glGetSamplerParameterfv = (PFNGLGETSAMPLERPARAMETERFVPROC)load("glGetSamplerParameterfv");
 glad_glGetSamplerParameterIuiv = (PFNGLGETSAMPLERPARAMETERIUIVPROC)load("glGetSamplerParameterIuiv");
 glad_glQueryCounter = (PFNGLQUERYCOUNTERPROC)load("glQueryCounter");
 glad_glGetQueryObjecti64v = (PFNGLGETQUERYOBJECTI64VPROC)load("glGetQueryObjecti64v");
 glad_glGetQueryObjectui64v = (PFNGLGETQUERYOBJECTUI64VPROC)load("glGetQueryObjectui64v");
 glad_glVertexAttribDivisor = (PFNGLVERTEXATTRIBDIVISORPROC)load("glVertexAttribDivisor");
 glad_glVertexAttribP1ui = (PFNGLVERTEXATTRIBP1UIPROC)load("glVertexAttribP1ui");
 glad_glVertexAttribP1uiv = (PFNGLVERTEXATTRIBP1UIVPROC)load("glVertexAttribP1uiv");
 glad_glVertexAttribP2ui = (PFNGLVERTEXATTRIBP2UIPROC)load("glVertexAttribP2ui");
 glad_glVertexAttribP2uiv = (PFNGLVERTEXATTRIBP2UIVPROC)load("glVertexAttribP2uiv");
 glad_glVertexAttribP3ui = (PFNGLVERTEXATTRIBP3UIPROC)load("glVertexAttribP3ui");
 glad_glVertexAttribP3uiv = (PFNGLVERTEXATTRIBP3UIVPROC)load("glVertexAttribP3uiv");
 glad_glVertexAttribP4ui = (PFNGLVERTEXATTRIBP4UIPROC)load("glVertexAttribP4ui");
 glad_glVertexAttribP4uiv = (PFNGLVERTEXATTRIBP4UIVPROC)load("glVertexAttribP4uiv");
 glad_glVertexP2ui = (PFNGLVERTEXP2UIPROC)load("glVertexP2ui");
 glad_glVertexP2uiv = (PFNGLVERTEXP2UIVPROC)load("glVertexP2uiv");
 glad_glVertexP3ui = (PFNGLVERTEXP3UIPROC)load("glVertexP3ui");
 glad_glVertexP3uiv = (PFNGLVERTEXP3UIVPROC)load("glVertexP3uiv");
 glad_glVertexP4ui = (PFNGLVERTEXP4UIPROC)load("glVertexP4ui");
 glad_glVertexP4uiv = (PFNGLVERTEXP4UIVPROC)load("glVertexP4uiv");
 glad_glTexCoordP1ui = (PFNGLTEXCOORDP1UIPROC)load("glTexCoordP1ui");
 glad_glTexCoordP1uiv = (PFNGLTEXCOORDP1UIVPROC)load("glTexCoordP1uiv");
 glad_glTexCoordP2ui = (PFNGLTEXCOORDP2UIPROC)load("glTexCoordP2ui");
 glad_glTexCoordP2uiv = (PFNGLTEXCOORDP2UIVPROC)load("glTexCoordP2uiv");
 glad_glTexCoordP3ui = (PFNGLTEXCOORDP3UIPROC)load("glTexCoordP3ui");
 glad_glTexCoordP3uiv = (PFNGLTEXCOORDP3UIVPROC)load("glTexCoordP3uiv");
 glad_glTexCoordP4ui = (PFNGLTEXCOORDP4UIPROC)load("glTexCoordP4ui");
 glad_glTexCoordP4uiv = (PFNGLTEXCOORDP4UIVPROC)load("glTexCoordP4uiv");
 glad_glMultiTexCoordP1ui = (PFNGLMULTITEXCOORDP1UIPROC)load("glMultiTexCoordP1ui");
 glad_glMultiTexCoordP1uiv = (PFNGLMULTITEXCOORDP1UIVPROC)load("glMultiTexCoordP1uiv");
 glad_glMultiTexCoordP2ui = (PFNGLMULTITEXCOORDP2UIPROC)load("glMultiTexCoordP2ui");
 glad_glMultiTexCoordP2uiv = (PFNGLMULTITEXCOORDP2UIVPROC)load("glMultiTexCoordP2uiv");
 glad_glMultiTexCoordP3ui = (PFNGLMULTITEXCOORDP3UIPROC)load("glMultiTexCoordP3ui");
 glad_glMultiTexCoordP3uiv = (PFNGLMULTITEXCOORDP3UIVPROC)load("glMultiTexCoordP3uiv");
 glad_glMultiTexCoordP4ui = (PFNGLMULTITEXCOORDP4UIPROC)load("glMultiTexCoordP4ui");
 glad_glMultiTexCoordP4uiv = (PFNGLMULTITEXCOORDP4UIVPROC)load("glMultiTexCoordP4uiv");
 glad_glNormalP3ui = (PFNGLNORMALP3UIPROC)load("glNormalP3ui");
 glad_glNormalP3uiv = (PFNGLNORMALP3UIVPROC)load("glNormalP3uiv");
 glad_glColorP3ui = (PFNGLCOLORP3UIPROC)load("glColorP3ui");
 glad_glColorP3uiv = (PFNGLCOLORP3UIVPROC)load("glColorP3uiv");
 glad_glColorP4ui = (PFNGLCOLORP4UIPROC)load("glColorP4ui");
 glad_glColorP4uiv = (PFNGLCOLORP4UIVPROC)load("glColorP4uiv");
 glad_glSecondaryColorP3ui = (PFNGLSECONDARYCOLORP3UIPROC)load("glSecondaryColorP3ui");
 glad_glSecondaryColorP3uiv = (PFNGLSECONDARYCOLORP3UIVPROC)load("glSecondaryColorP3uiv");
}
static void load_GL_VERSION_4_0(GLADloadproc load) {
 if(!GLAD_GL_VERSION_4_0) return;
 glad_glMinSampleShading = (PFNGLMINSAMPLESHADINGPROC)load("glMinSampleShading");
 glad_glBlendEquationi = (PFNGLBLENDEQUATIONIPROC)load("glBlendEquationi");
 glad_glBlendEquationSeparatei = (PFNGLBLENDEQUATIONSEPARATEIPROC)load("glBlendEquationSeparatei");
 glad_glBlendFunci = (PFNGLBLENDFUNCIPROC)load("glBlendFunci");
 glad_glBlendFuncSeparatei = (PFNGLBLENDFUNCSEPARATEIPROC)load("glBlendFuncSeparatei");
 glad_glDrawArraysIndirect = (PFNGLDRAWARRAYSINDIRECTPROC)load("glDrawArraysIndirect");
 glad_glDrawElementsIndirect = (PFNGLDRAWELEMENTSINDIRECTPROC)load("glDrawElementsIndirect");
 glad_glUniform1d = (PFNGLUNIFORM1DPROC)load("glUniform1d");
 glad_glUniform2d = (PFNGLUNIFORM2DPROC)load("glUniform2d");
 glad_glUniform3d = (PFNGLUNIFORM3DPROC)load("glUniform3d");
 glad_glUniform4d = (PFNGLUNIFORM4DPROC)load("glUniform4d");
 glad_glUniform1dv = (PFNGLUNIFORM1DVPROC)load("glUniform1dv");
 glad_glUniform2dv = (PFNGLUNIFORM2DVPROC)load("glUniform2dv");
 glad_glUniform3dv = (PFNGLUNIFORM3DVPROC)load("glUniform3dv");
 glad_glUniform4dv = (PFNGLUNIFORM4DVPROC)load("glUniform4dv");
 glad_glUniformMatrix2dv = (PFNGLUNIFORMMATRIX2DVPROC)load("glUniformMatrix2dv");
 glad_glUniformMatrix3dv = (PFNGLUNIFORMMATRIX3DVPROC)load("glUniformMatrix3dv");
 glad_glUniformMatrix4dv = (PFNGLUNIFORMMATRIX4DVPROC)load("glUniformMatrix4dv");
 glad_glUniformMatrix2x3dv = (PFNGLUNIFORMMATRIX2X3DVPROC)load("glUniformMatrix2x3dv");
 glad_glUniformMatrix2x4dv = (PFNGLUNIFORMMATRIX2X4DVPROC)load("glUniformMatrix2x4dv");
 glad_glUniformMatrix3x2dv = (PFNGLUNIFORMMATRIX3X2DVPROC)load("glUniformMatrix3x2dv");
 glad_glUniformMatrix3x4dv = (PFNGLUNIFORMMATRIX3X4DVPROC)load("glUniformMatrix3x4dv");
 glad_glUniformMatrix4x2dv = (PFNGLUNIFORMMATRIX4X2DVPROC)load("glUniformMatrix4x2dv");
 glad_glUniformMatrix4x3dv = (PFNGLUNIFORMMATRIX4X3DVPROC)load("glUniformMatrix4x3dv");
 glad_glGetUniformdv = (PFNGLGETUNIFORMDVPROC)load("glGetUniformdv");
 glad_glGetSubroutineUniformLocation = (PFNGLGETSUBROUTINEUNIFORMLOCATIONPROC)load("glGetSubroutineUniformLocation");
 glad_glGetSubroutineIndex = (PFNGLGETSUBROUTINEINDEXPROC)load("glGetSubroutineIndex");
 glad_glGetActiveSubroutineUniformiv = (PFNGLGETACTIVESUBROUTINEUNIFORMIVPROC)load("glGetActiveSubroutineUniformiv");
 glad_glGetActiveSubroutineUniformName = (PFNGLGETACTIVESUBROUTINEUNIFORMNAMEPROC)load("glGetActiveSubroutineUniformName");
 glad_glGetActiveSubroutineName = (PFNGLGETACTIVESUBROUTINENAMEPROC)load("glGetActiveSubroutineName");
 glad_glUniformSubroutinesuiv = (PFNGLUNIFORMSUBROUTINESUIVPROC)load("glUniformSubroutinesuiv");
 glad_glGetUniformSubroutineuiv = (PFNGLGETUNIFORMSUBROUTINEUIVPROC)load("glGetUniformSubroutineuiv");
 glad_glGetProgramStageiv = (PFNGLGETPROGRAMSTAGEIVPROC)load("glGetProgramStageiv");
 glad_glPatchParameteri = (PFNGLPATCHPARAMETERIPROC)load("glPatchParameteri");
 glad_glPatchParameterfv = (PFNGLPATCHPARAMETERFVPROC)load("glPatchParameterfv");
 glad_glBindTransformFeedback = (PFNGLBINDTRANSFORMFEEDBACKPROC)load("glBindTransformFeedback");
 glad_glDeleteTransformFeedbacks = (PFNGLDELETETRANSFORMFEEDBACKSPROC)load("glDeleteTransformFeedbacks");
 glad_glGenTransformFeedbacks = (PFNGLGENTRANSFORMFEEDBACKSPROC)load("glGenTransformFeedbacks");
 glad_glIsTransformFeedback = (PFNGLISTRANSFORMFEEDBACKPROC)load("glIsTransformFeedback");
 glad_glPauseTransformFeedback = (PFNGLPAUSETRANSFORMFEEDBACKPROC)load("glPauseTransformFeedback");
 glad_glResumeTransformFeedback = (PFNGLRESUMETRANSFORMFEEDBACKPROC)load("glResumeTransformFeedback");
 glad_glDrawTransformFeedback = (PFNGLDRAWTRANSFORMFEEDBACKPROC)load("glDrawTransformFeedback");
 glad_glDrawTransformFeedbackStream = (PFNGLDRAWTRANSFORMFEEDBACKSTREAMPROC)load("glDrawTransformFeedbackStream");
 glad_glBeginQueryIndexed = (PFNGLBEGINQUERYINDEXEDPROC)load("glBeginQueryIndexed");
 glad_glEndQueryIndexed = (PFNGLENDQUERYINDEXEDPROC)load("glEndQueryIndexed");
 glad_glGetQueryIndexediv = (PFNGLGETQUERYINDEXEDIVPROC)load("glGetQueryIndexediv");
}
static void load_GL_VERSION_4_1(GLADloadproc load) {
 if(!GLAD_GL_VERSION_4_1) return;
 glad_glReleaseShaderCompiler = (PFNGLRELEASESHADERCOMPILERPROC)load("glReleaseShaderCompiler");
 glad_glShaderBinary = (PFNGLSHADERBINARYPROC)load("glShaderBinary");
 glad_glGetShaderPrecisionFormat = (PFNGLGETSHADERPRECISIONFORMATPROC)load("glGetShaderPrecisionFormat");
 glad_glDepthRangef = (PFNGLDEPTHRANGEFPROC)load("glDepthRangef");
 glad_glClearDepthf = (PFNGLCLEARDEPTHFPROC)load("glClearDepthf");
 glad_glGetProgramBinary = (PFNGLGETPROGRAMBINARYPROC)load("glGetProgramBinary");
 glad_glProgramBinary = (PFNGLPROGRAMBINARYPROC)load("glProgramBinary");
 glad_glProgramParameteri = (PFNGLPROGRAMPARAMETERIPROC)load("glProgramParameteri");
 glad_glUseProgramStages = (PFNGLUSEPROGRAMSTAGESPROC)load("glUseProgramStages");
 glad_glActiveShaderProgram = (PFNGLACTIVESHADERPROGRAMPROC)load("glActiveShaderProgram");
 glad_glCreateShaderProgramv = (PFNGLCREATESHADERPROGRAMVPROC)load("glCreateShaderProgramv");
 glad_glBindProgramPipeline = (PFNGLBINDPROGRAMPIPELINEPROC)load("glBindProgramPipeline");
 glad_glDeleteProgramPipelines = (PFNGLDELETEPROGRAMPIPELINESPROC)load("glDeleteProgramPipelines");
 glad_glGenProgramPipelines = (PFNGLGENPROGRAMPIPELINESPROC)load("glGenProgramPipelines");
 glad_glIsProgramPipeline = (PFNGLISPROGRAMPIPELINEPROC)load("glIsProgramPipeline");
 glad_glGetProgramPipelineiv = (PFNGLGETPROGRAMPIPELINEIVPROC)load("glGetProgramPipelineiv");
 glad_glProgramParameteri = (PFNGLPROGRAMPARAMETERIPROC)load("glProgramParameteri");
 glad_glProgramUniform1i = (PFNGLPROGRAMUNIFORM1IPROC)load("glProgramUniform1i");
 glad_glProgramUniform1iv = (PFNGLPROGRAMUNIFORM1IVPROC)load("glProgramUniform1iv");
 glad_glProgramUniform1f = (PFNGLPROGRAMUNIFORM1FPROC)load("glProgramUniform1f");
 glad_glProgramUniform1fv = (PFNGLPROGRAMUNIFORM1FVPROC)load("glProgramUniform1fv");
 glad_glProgramUniform1d = (PFNGLPROGRAMUNIFORM1DPROC)load("glProgramUniform1d");
 glad_glProgramUniform1dv = (PFNGLPROGRAMUNIFORM1DVPROC)load("glProgramUniform1dv");
 glad_glProgramUniform1ui = (PFNGLPROGRAMUNIFORM1UIPROC)load("glProgramUniform1ui");
 glad_glProgramUniform1uiv = (PFNGLPROGRAMUNIFORM1UIVPROC)load("glProgramUniform1uiv");
 glad_glProgramUniform2i = (PFNGLPROGRAMUNIFORM2IPROC)load("glProgramUniform2i");
 glad_glProgramUniform2iv = (PFNGLPROGRAMUNIFORM2IVPROC)load("glProgramUniform2iv");
 glad_glProgramUniform2f = (PFNGLPROGRAMUNIFORM2FPROC)load("glProgramUniform2f");
 glad_glProgramUniform2fv = (PFNGLPROGRAMUNIFORM2FVPROC)load("glProgramUniform2fv");
 glad_glProgramUniform2d = (PFNGLPROGRAMUNIFORM2DPROC)load("glProgramUniform2d");
 glad_glProgramUniform2dv = (PFNGLPROGRAMUNIFORM2DVPROC)load("glProgramUniform2dv");
 glad_glProgramUniform2ui = (PFNGLPROGRAMUNIFORM2UIPROC)load("glProgramUniform2ui");
 glad_glProgramUniform2uiv = (PFNGLPROGRAMUNIFORM2UIVPROC)load("glProgramUniform2uiv");
 glad_glProgramUniform3i = (PFNGLPROGRAMUNIFORM3IPROC)load("glProgramUniform3i");
 glad_glProgramUniform3iv = (PFNGLPROGRAMUNIFORM3IVPROC)load("glProgramUniform3iv");
 glad_glProgramUniform3f = (PFNGLPROGRAMUNIFORM3FPROC)load("glProgramUniform3f");
 glad_glProgramUniform3fv = (PFNGLPROGRAMUNIFORM3FVPROC)load("glProgramUniform3fv");
 glad_glProgramUniform3d = (PFNGLPROGRAMUNIFORM3DPROC)load("glProgramUniform3d");
 glad_glProgramUniform3dv = (PFNGLPROGRAMUNIFORM3DVPROC)load("glProgramUniform3dv");
 glad_glProgramUniform3ui = (PFNGLPROGRAMUNIFORM3UIPROC)load("glProgramUniform3ui");
 glad_glProgramUniform3uiv = (PFNGLPROGRAMUNIFORM3UIVPROC)load("glProgramUniform3uiv");
 glad_glProgramUniform4i = (PFNGLPROGRAMUNIFORM4IPROC)load("glProgramUniform4i");
 glad_glProgramUniform4iv = (PFNGLPROGRAMUNIFORM4IVPROC)load("glProgramUniform4iv");
 glad_glProgramUniform4f = (PFNGLPROGRAMUNIFORM4FPROC)load("glProgramUniform4f");
 glad_glProgramUniform4fv = (PFNGLPROGRAMUNIFORM4FVPROC)load("glProgramUniform4fv");
 glad_glProgramUniform4d = (PFNGLPROGRAMUNIFORM4DPROC)load("glProgramUniform4d");
 glad_glProgramUniform4dv = (PFNGLPROGRAMUNIFORM4DVPROC)load("glProgramUniform4dv");
 glad_glProgramUniform4ui = (PFNGLPROGRAMUNIFORM4UIPROC)load("glProgramUniform4ui");
 glad_glProgramUniform4uiv = (PFNGLPROGRAMUNIFORM4UIVPROC)load("glProgramUniform4uiv");
 glad_glProgramUniformMatrix2fv = (PFNGLPROGRAMUNIFORMMATRIX2FVPROC)load("glProgramUniformMatrix2fv");
 glad_glProgramUniformMatrix3fv = (PFNGLPROGRAMUNIFORMMATRIX3FVPROC)load("glProgramUniformMatrix3fv");
 glad_glProgramUniformMatrix4fv = (PFNGLPROGRAMUNIFORMMATRIX4FVPROC)load("glProgramUniformMatrix4fv");
 glad_glProgramUniformMatrix2dv = (PFNGLPROGRAMUNIFORMMATRIX2DVPROC)load("glProgramUniformMatrix2dv");
 glad_glProgramUniformMatrix3dv = (PFNGLPROGRAMUNIFORMMATRIX3DVPROC)load("glProgramUniformMatrix3dv");
 glad_glProgramUniformMatrix4dv = (PFNGLPROGRAMUNIFORMMATRIX4DVPROC)load("glProgramUniformMatrix4dv");
 glad_glProgramUniformMatrix2x3fv = (PFNGLPROGRAMUNIFORMMATRIX2X3FVPROC)load("glProgramUniformMatrix2x3fv");
 glad_glProgramUniformMatrix3x2fv = (PFNGLPROGRAMUNIFORMMATRIX3X2FVPROC)load("glProgramUniformMatrix3x2fv");
 glad_glProgramUniformMatrix2x4fv = (PFNGLPROGRAMUNIFORMMATRIX2X4FVPROC)load("glProgramUniformMatrix2x4fv");
 glad_glProgramUniformMatrix4x2fv = (PFNGLPROGRAMUNIFORMMATRIX4X2FVPROC)load("glProgramUniformMatrix4x2fv");
 glad_glProgramUniformMatrix3x4fv = (PFNGLPROGRAMUNIFORMMATRIX3X4FVPROC)load("glProgramUniformMatrix3x4fv");
 glad_glProgramUniformMatrix4x3fv = (PFNGLPROGRAMUNIFORMMATRIX4X3FVPROC)load("glProgramUniformMatrix4x3fv");
 glad_glProgramUniformMatrix2x3dv = (PFNGLPROGRAMUNIFORMMATRIX2X3DVPROC)load("glProgramUniformMatrix2x3dv");
 glad_glProgramUniformMatrix3x2dv = (PFNGLPROGRAMUNIFORMMATRIX3X2DVPROC)load("glProgramUniformMatrix3x2dv");
 glad_glProgramUniformMatrix2x4dv = (PFNGLPROGRAMUNIFORMMATRIX2X4DVPROC)load("glProgramUniformMatrix2x4dv");
 glad_glProgramUniformMatrix4x2dv = (PFNGLPROGRAMUNIFORMMATRIX4X2DVPROC)load("glProgramUniformMatrix4x2dv");
 glad_glProgramUniformMatrix3x4dv = (PFNGLPROGRAMUNIFORMMATRIX3X4DVPROC)load("glProgramUniformMatrix3x4dv");
 glad_glProgramUniformMatrix4x3dv = (PFNGLPROGRAMUNIFORMMATRIX4X3DVPROC)load("glProgramUniformMatrix4x3dv");
 glad_glValidateProgramPipeline = (PFNGLVALIDATEPROGRAMPIPELINEPROC)load("glValidateProgramPipeline");
 glad_glGetProgramPipelineInfoLog = (PFNGLGETPROGRAMPIPELINEINFOLOGPROC)load("glGetProgramPipelineInfoLog");
 glad_glVertexAttribL1d = (PFNGLVERTEXATTRIBL1DPROC)load("glVertexAttribL1d");
 glad_glVertexAttribL2d = (PFNGLVERTEXATTRIBL2DPROC)load("glVertexAttribL2d");
 glad_glVertexAttribL3d = (PFNGLVERTEXATTRIBL3DPROC)load("glVertexAttribL3d");
 glad_glVertexAttribL4d = (PFNGLVERTEXATTRIBL4DPROC)load("glVertexAttribL4d");
 glad_glVertexAttribL1dv = (PFNGLVERTEXATTRIBL1DVPROC)load("glVertexAttribL1dv");
 glad_glVertexAttribL2dv = (PFNGLVERTEXATTRIBL2DVPROC)load("glVertexAttribL2dv");
 glad_glVertexAttribL3dv = (PFNGLVERTEXATTRIBL3DVPROC)load("glVertexAttribL3dv");
 glad_glVertexAttribL4dv = (PFNGLVERTEXATTRIBL4DVPROC)load("glVertexAttribL4dv");
 glad_glVertexAttribLPointer = (PFNGLVERTEXATTRIBLPOINTERPROC)load("glVertexAttribLPointer");
 glad_glGetVertexAttribLdv = (PFNGLGETVERTEXATTRIBLDVPROC)load("glGetVertexAttribLdv");
 glad_glViewportArrayv = (PFNGLVIEWPORTARRAYVPROC)load("glViewportArrayv");
 glad_glViewportIndexedf = (PFNGLVIEWPORTINDEXEDFPROC)load("glViewportIndexedf");
 glad_glViewportIndexedfv = (PFNGLVIEWPORTINDEXEDFVPROC)load("glViewportIndexedfv");
 glad_glScissorArrayv = (PFNGLSCISSORARRAYVPROC)load("glScissorArrayv");
 glad_glScissorIndexed = (PFNGLSCISSORINDEXEDPROC)load("glScissorIndexed");
 glad_glScissorIndexedv = (PFNGLSCISSORINDEXEDVPROC)load("glScissorIndexedv");
 glad_glDepthRangeArrayv = (PFNGLDEPTHRANGEARRAYVPROC)load("glDepthRangeArrayv");
 glad_glDepthRangeIndexed = (PFNGLDEPTHRANGEINDEXEDPROC)load("glDepthRangeIndexed");
 glad_glGetFloati_v = (PFNGLGETFLOATI_VPROC)load("glGetFloati_v");
 glad_glGetDoublei_v = (PFNGLGETDOUBLEI_VPROC)load("glGetDoublei_v");
}
static void load_GL_VERSION_4_2(GLADloadproc load) {
 if(!GLAD_GL_VERSION_4_2) return;
 glad_glDrawArraysInstancedBaseInstance = (PFNGLDRAWARRAYSINSTANCEDBASEINSTANCEPROC)load("glDrawArraysInstancedBaseInstance");
 glad_glDrawElementsInstancedBaseInstance = (PFNGLDRAWELEMENTSINSTANCEDBASEINSTANCEPROC)load("glDrawElementsInstancedBaseInstance");
 glad_glDrawElementsInstancedBaseVertexBaseInstance = (PFNGLDRAWELEMENTSINSTANCEDBASEVERTEXBASEINSTANCEPROC)load("glDrawElementsInstancedBaseVertexBaseInstance");
 glad_glGetInternalformativ = (PFNGLGETINTERNALFORMATIVPROC)load("glGetInternalformativ");
 glad_glGetActiveAtomicCounterBufferiv = (PFNGLGETACTIVEATOMICCOUNTERBUFFERIVPROC)load("glGetActiveAtomicCounterBufferiv");
 glad_glBindImageTexture = (PFNGLBINDIMAGETEXTUREPROC)load("glBindImageTexture");
 glad_glMemoryBarrier = (PFNGLMEMORYBARRIERPROC)load("glMemoryBarrier");
 glad_glTexStorage1D = (PFNGLTEXSTORAGE1DPROC)load("glTexStorage1D");
 glad_glTexStorage2D = (PFNGLTEXSTORAGE2DPROC)load("glTexStorage2D");
 glad_glTexStorage3D = (PFNGLTEXSTORAGE3DPROC)load("glTexStorage3D");
 glad_glDrawTransformFeedbackInstanced = (PFNGLDRAWTRANSFORMFEEDBACKINSTANCEDPROC)load("glDrawTransformFeedbackInstanced");
 glad_glDrawTransformFeedbackStreamInstanced = (PFNGLDRAWTRANSFORMFEEDBACKSTREAMINSTANCEDPROC)load("glDrawTransformFeedbackStreamInstanced");
}
static void load_GL_VERSION_4_3(GLADloadproc load) {
 if(!GLAD_GL_VERSION_4_3) return;
 glad_glClearBufferData = (PFNGLCLEARBUFFERDATAPROC)load("glClearBufferData");
 glad_glClearBufferSubData = (PFNGLCLEARBUFFERSUBDATAPROC)load("glClearBufferSubData");
 glad_glDispatchCompute = (PFNGLDISPATCHCOMPUTEPROC)load("glDispatchCompute");
 glad_glDispatchComputeIndirect = (PFNGLDISPATCHCOMPUTEINDIRECTPROC)load("glDispatchComputeIndirect");
 glad_glCopyImageSubData = (PFNGLCOPYIMAGESUBDATAPROC)load("glCopyImageSubData");
 glad_glFramebufferParameteri = (PFNGLFRAMEBUFFERPARAMETERIPROC)load("glFramebufferParameteri");
 glad_glGetFramebufferParameteriv = (PFNGLGETFRAMEBUFFERPARAMETERIVPROC)load("glGetFramebufferParameteriv");
 glad_glGetInternalformati64v = (PFNGLGETINTERNALFORMATI64VPROC)load("glGetInternalformati64v");
 glad_glInvalidateTexSubImage = (PFNGLINVALIDATETEXSUBIMAGEPROC)load("glInvalidateTexSubImage");
 glad_glInvalidateTexImage = (PFNGLINVALIDATETEXIMAGEPROC)load("glInvalidateTexImage");
 glad_glInvalidateBufferSubData = (PFNGLINVALIDATEBUFFERSUBDATAPROC)load("glInvalidateBufferSubData");
 glad_glInvalidateBufferData = (PFNGLINVALIDATEBUFFERDATAPROC)load("glInvalidateBufferData");
 glad_glInvalidateFramebuffer = (PFNGLINVALIDATEFRAMEBUFFERPROC)load("glInvalidateFramebuffer");
 glad_glInvalidateSubFramebuffer = (PFNGLINVALIDATESUBFRAMEBUFFERPROC)load("glInvalidateSubFramebuffer");
 glad_glMultiDrawArraysIndirect = (PFNGLMULTIDRAWARRAYSINDIRECTPROC)load("glMultiDrawArraysIndirect");
 glad_glMultiDrawElementsIndirect = (PFNGLMULTIDRAWELEMENTSINDIRECTPROC)load("glMultiDrawElementsIndirect");
 glad_glGetProgramInterfaceiv = (PFNGLGETPROGRAMINTERFACEIVPROC)load("glGetProgramInterfaceiv");
 glad_glGetProgramResourceIndex = (PFNGLGETPROGRAMRESOURCEINDEXPROC)load("glGetProgramResourceIndex");
 glad_glGetProgramResourceName = (PFNGLGETPROGRAMRESOURCENAMEPROC)load("glGetProgramResourceName");
 glad_glGetProgramResourceiv = (PFNGLGETPROGRAMRESOURCEIVPROC)load("glGetProgramResourceiv");
 glad_glGetProgramResourceLocation = (PFNGLGETPROGRAMRESOURCELOCATIONPROC)load("glGetProgramResourceLocation");
 glad_glGetProgramResourceLocationIndex = (PFNGLGETPROGRAMRESOURCELOCATIONINDEXPROC)load("glGetProgramResourceLocationIndex");
 glad_glShaderStorageBlockBinding = (PFNGLSHADERSTORAGEBLOCKBINDINGPROC)load("glShaderStorageBlockBinding");
 glad_glTexBufferRange = (PFNGLTEXBUFFERRANGEPROC)load("glTexBufferRange");
 glad_glTexStorage2DMultisample = (PFNGLTEXSTORAGE2DMULTISAMPLEPROC)load("glTexStorage2DMultisample");
 glad_glTexStorage3DMultisample = (PFNGLTEXSTORAGE3DMULTISAMPLEPROC)load("glTexStorage3DMultisample");
 glad_glTextureView = (PFNGLTEXTUREVIEWPROC)load("glTextureView");
 glad_glBindVertexBuffer = (PFNGLBINDVERTEXBUFFERPROC)load("glBindVertexBuffer");
 glad_glVertexAttribFormat = (PFNGLVERTEXATTRIBFORMATPROC)load("glVertexAttribFormat");
 glad_glVertexAttribIFormat = (PFNGLVERTEXATTRIBIFORMATPROC)load("glVertexAttribIFormat");
 glad_glVertexAttribLFormat = (PFNGLVERTEXATTRIBLFORMATPROC)load("glVertexAttribLFormat");
 glad_glVertexAttribBinding = (PFNGLVERTEXATTRIBBINDINGPROC)load("glVertexAttribBinding");
 glad_glVertexBindingDivisor = (PFNGLVERTEXBINDINGDIVISORPROC)load("glVertexBindingDivisor");
 glad_glDebugMessageControl = (PFNGLDEBUGMESSAGECONTROLPROC)load("glDebugMessageControl");
 glad_glDebugMessageInsert = (PFNGLDEBUGMESSAGEINSERTPROC)load("glDebugMessageInsert");
 glad_glDebugMessageCallback = (PFNGLDEBUGMESSAGECALLBACKPROC)load("glDebugMessageCallback");
 glad_glGetDebugMessageLog = (PFNGLGETDEBUGMESSAGELOGPROC)load("glGetDebugMessageLog");
 glad_glPushDebugGroup = (PFNGLPUSHDEBUGGROUPPROC)load("glPushDebugGroup");
 glad_glPopDebugGroup = (PFNGLPOPDEBUGGROUPPROC)load("glPopDebugGroup");
 glad_glObjectLabel = (PFNGLOBJECTLABELPROC)load("glObjectLabel");
 glad_glGetObjectLabel = (PFNGLGETOBJECTLABELPROC)load("glGetObjectLabel");
 glad_glObjectPtrLabel = (PFNGLOBJECTPTRLABELPROC)load("glObjectPtrLabel");
 glad_glGetObjectPtrLabel = (PFNGLGETOBJECTPTRLABELPROC)load("glGetObjectPtrLabel");
 glad_glGetPointerv = (PFNGLGETPOINTERVPROC)load("glGetPointerv");
}
static void load_GL_VERSION_4_4(GLADloadproc load) {
 if(!GLAD_GL_VERSION_4_4) return;
 glad_glBufferStorage = (PFNGLBUFFERSTORAGEPROC)load("glBufferStorage");
 glad_glClearTexImage = (PFNGLCLEARTEXIMAGEPROC)load("glClearTexImage");
 glad_glClearTexSubImage = (PFNGLCLEARTEXSUBIMAGEPROC)load("glClearTexSubImage");
 glad_glBindBuffersBase = (PFNGLBINDBUFFERSBASEPROC)load("glBindBuffersBase");
 glad_glBindBuffersRange = (PFNGLBINDBUFFERSRANGEPROC)load("glBindBuffersRange");
 glad_glBindTextures = (PFNGLBINDTEXTURESPROC)load("glBindTextures");
 glad_glBindSamplers = (PFNGLBINDSAMPLERSPROC)load("glBindSamplers");
 glad_glBindImageTextures = (PFNGLBINDIMAGETEXTURESPROC)load("glBindImageTextures");
 glad_glBindVertexBuffers = (PFNGLBINDVERTEXBUFFERSPROC)load("glBindVertexBuffers");
}
static void load_GL_VERSION_4_5(GLADloadproc load) {
 if(!GLAD_GL_VERSION_4_5) return;
 glad_glClipControl = (PFNGLCLIPCONTROLPROC)load("glClipControl");
 glad_glCreateTransformFeedbacks = (PFNGLCREATETRANSFORMFEEDBACKSPROC)load("glCreateTransformFeedbacks");
 glad_glTransformFeedbackBufferBase = (PFNGLTRANSFORMFEEDBACKBUFFERBASEPROC)load("glTransformFeedbackBufferBase");
 glad_glTransformFeedbackBufferRange = (PFNGLTRANSFORMFEEDBACKBUFFERRANGEPROC)load("glTransformFeedbackBufferRange");
 glad_glGetTransformFeedbackiv = (PFNGLGETTRANSFORMFEEDBACKIVPROC)load("glGetTransformFeedbackiv");
 glad_glGetTransformFeedbacki_v = (PFNGLGETTRANSFORMFEEDBACKI_VPROC)load("glGetTransformFeedbacki_v");
 glad_glGetTransformFeedbacki64_v = (PFNGLGETTRANSFORMFEEDBACKI64_VPROC)load("glGetTransformFeedbacki64_v");
 glad_glCreateBuffers = (PFNGLCREATEBUFFERSPROC)load("glCreateBuffers");
 glad_glNamedBufferStorage = (PFNGLNAMEDBUFFERSTORAGEPROC)load("glNamedBufferStorage");
 glad_glNamedBufferData = (PFNGLNAMEDBUFFERDATAPROC)load("glNamedBufferData");
 glad_glNamedBufferSubData = (PFNGLNAMEDBUFFERSUBDATAPROC)load("glNamedBufferSubData");
 glad_glCopyNamedBufferSubData = (PFNGLCOPYNAMEDBUFFERSUBDATAPROC)load("glCopyNamedBufferSubData");
 glad_glClearNamedBufferData = (PFNGLCLEARNAMEDBUFFERDATAPROC)load("glClearNamedBufferData");
 glad_glClearNamedBufferSubData = (PFNGLCLEARNAMEDBUFFERSUBDATAPROC)load("glClearNamedBufferSubData");
 glad_glMapNamedBuffer = (PFNGLMAPNAMEDBUFFERPROC)load("glMapNamedBuffer");
 glad_glMapNamedBufferRange = (PFNGLMAPNAMEDBUFFERRANGEPROC)load("glMapNamedBufferRange");
 glad_glUnmapNamedBuffer = (PFNGLUNMAPNAMEDBUFFERPROC)load("glUnmapNamedBuffer");
 glad_glFlushMappedNamedBufferRange = (PFNGLFLUSHMAPPEDNAMEDBUFFERRANGEPROC)load("glFlushMappedNamedBufferRange");
 glad_glGetNamedBufferParameteriv = (PFNGLGETNAMEDBUFFERPARAMETERIVPROC)load("glGetNamedBufferParameteriv");
 glad_glGetNamedBufferParameteri64v = (PFNGLGETNAMEDBUFFERPARAMETERI64VPROC)load("glGetNamedBufferParameteri64v");
 glad_glGetNamedBufferPointerv = (PFNGLGETNAMEDBUFFERPOINTERVPROC)load("glGetNamedBufferPointerv");
 glad_glGetNamedBufferSubData = (PFNGLGETNAMEDBUFFERSUBDATAPROC)load("glGetNamedBufferSubData");
 glad_glCreateFramebuffers = (PFNGLCREATEFRAMEBUFFERSPROC)load("glCreateFramebuffers");
 glad_glNamedFramebufferRenderbuffer = (PFNGLNAMEDFRAMEBUFFERRENDERBUFFERPROC)load("glNamedFramebufferRenderbuffer");
 glad_glNamedFramebufferParameteri = (PFNGLNAMEDFRAMEBUFFERPARAMETERIPROC)load("glNamedFramebufferParameteri");
 glad_glNamedFramebufferTexture = (PFNGLNAMEDFRAMEBUFFERTEXTUREPROC)load("glNamedFramebufferTexture");
 glad_glNamedFramebufferTextureLayer = (PFNGLNAMEDFRAMEBUFFERTEXTURELAYERPROC)load("glNamedFramebufferTextureLayer");
 glad_glNamedFramebufferDrawBuffer = (PFNGLNAMEDFRAMEBUFFERDRAWBUFFERPROC)load("glNamedFramebufferDrawBuffer");
 glad_glNamedFramebufferDrawBuffers = (PFNGLNAMEDFRAMEBUFFERDRAWBUFFERSPROC)load("glNamedFramebufferDrawBuffers");
 glad_glNamedFramebufferReadBuffer = (PFNGLNAMEDFRAMEBUFFERREADBUFFERPROC)load("glNamedFramebufferReadBuffer");
 glad_glInvalidateNamedFramebufferData = (PFNGLINVALIDATENAMEDFRAMEBUFFERDATAPROC)load("glInvalidateNamedFramebufferData");
 glad_glInvalidateNamedFramebufferSubData = (PFNGLINVALIDATENAMEDFRAMEBUFFERSUBDATAPROC)load("glInvalidateNamedFramebufferSubData");
 glad_glClearNamedFramebufferiv = (PFNGLCLEARNAMEDFRAMEBUFFERIVPROC)load("glClearNamedFramebufferiv");
 glad_glClearNamedFramebufferuiv = (PFNGLCLEARNAMEDFRAMEBUFFERUIVPROC)load("glClearNamedFramebufferuiv");
 glad_glClearNamedFramebufferfv = (PFNGLCLEARNAMEDFRAMEBUFFERFVPROC)load("glClearNamedFramebufferfv");
 glad_glClearNamedFramebufferfi = (PFNGLCLEARNAMEDFRAMEBUFFERFIPROC)load("glClearNamedFramebufferfi");
 glad_glBlitNamedFramebuffer = (PFNGLBLITNAMEDFRAMEBUFFERPROC)load("glBlitNamedFramebuffer");
 glad_glCheckNamedFramebufferStatus = (PFNGLCHECKNAMEDFRAMEBUFFERSTATUSPROC)load("glCheckNamedFramebufferStatus");
 glad_glGetNamedFramebufferParameteriv = (PFNGLGETNAMEDFRAMEBUFFERPARAMETERIVPROC)load("glGetNamedFramebufferParameteriv");
 glad_glGetNamedFramebufferAttachmentParameteriv = (PFNGLGETNAMEDFRAMEBUFFERATTACHMENTPARAMETERIVPROC)load("glGetNamedFramebufferAttachmentParameteriv");
 glad_glCreateRenderbuffers = (PFNGLCREATERENDERBUFFERSPROC)load("glCreateRenderbuffers");
 glad_glNamedRenderbufferStorage = (PFNGLNAMEDRENDERBUFFERSTORAGEPROC)load("glNamedRenderbufferStorage");
 glad_glNamedRenderbufferStorageMultisample = (PFNGLNAMEDRENDERBUFFERSTORAGEMULTISAMPLEPROC)load("glNamedRenderbufferStorageMultisample");
 glad_glGetNamedRenderbufferParameteriv = (PFNGLGETNAMEDRENDERBUFFERPARAMETERIVPROC)load("glGetNamedRenderbufferParameteriv");
 glad_glCreateTextures = (PFNGLCREATETEXTURESPROC)load("glCreateTextures");
 glad_glTextureBuffer = (PFNGLTEXTUREBUFFERPROC)load("glTextureBuffer");
 glad_glTextureBufferRange = (PFNGLTEXTUREBUFFERRANGEPROC)load("glTextureBufferRange");
 glad_glTextureStorage1D = (PFNGLTEXTURESTORAGE1DPROC)load("glTextureStorage1D");
 glad_glTextureStorage2D = (PFNGLTEXTURESTORAGE2DPROC)load("glTextureStorage2D");
 glad_glTextureStorage3D = (PFNGLTEXTURESTORAGE3DPROC)load("glTextureStorage3D");
 glad_glTextureStorage2DMultisample = (PFNGLTEXTURESTORAGE2DMULTISAMPLEPROC)load("glTextureStorage2DMultisample");
 glad_glTextureStorage3DMultisample = (PFNGLTEXTURESTORAGE3DMULTISAMPLEPROC)load("glTextureStorage3DMultisample");
 glad_glTextureSubImage1D = (PFNGLTEXTURESUBIMAGE1DPROC)load("glTextureSubImage1D");
 glad_glTextureSubImage2D = (PFNGLTEXTURESUBIMAGE2DPROC)load("glTextureSubImage2D");
 glad_glTextureSubImage3D = (PFNGLTEXTURESUBIMAGE3DPROC)load("glTextureSubImage3D");
 glad_glCompressedTextureSubImage1D = (PFNGLCOMPRESSEDTEXTURESUBIMAGE1DPROC)load("glCompressedTextureSubImage1D");
 glad_glCompressedTextureSubImage2D = (PFNGLCOMPRESSEDTEXTURESUBIMAGE2DPROC)load("glCompressedTextureSubImage2D");
 glad_glCompressedTextureSubImage3D = (PFNGLCOMPRESSEDTEXTURESUBIMAGE3DPROC)load("glCompressedTextureSubImage3D");
 glad_glCopyTextureSubImage1D = (PFNGLCOPYTEXTURESUBIMAGE1DPROC)load("glCopyTextureSubImage1D");
 glad_glCopyTextureSubImage2D = (PFNGLCOPYTEXTURESUBIMAGE2DPROC)load("glCopyTextureSubImage2D");
 glad_glCopyTextureSubImage3D = (PFNGLCOPYTEXTURESUBIMAGE3DPROC)load("glCopyTextureSubImage3D");
 glad_glTextureParameterf = (PFNGLTEXTUREPARAMETERFPROC)load("glTextureParameterf");
 glad_glTextureParameterfv = (PFNGLTEXTUREPARAMETERFVPROC)load("glTextureParameterfv");
 glad_glTextureParameteri = (PFNGLTEXTUREPARAMETERIPROC)load("glTextureParameteri");
 glad_glTextureParameterIiv = (PFNGLTEXTUREPARAMETERIIVPROC)load("glTextureParameterIiv");
 glad_glTextureParameterIuiv = (PFNGLTEXTUREPARAMETERIUIVPROC)load("glTextureParameterIuiv");
 glad_glTextureParameteriv = (PFNGLTEXTUREPARAMETERIVPROC)load("glTextureParameteriv");
 glad_glGenerateTextureMipmap = (PFNGLGENERATETEXTUREMIPMAPPROC)load("glGenerateTextureMipmap");
 glad_glBindTextureUnit = (PFNGLBINDTEXTUREUNITPROC)load("glBindTextureUnit");
 glad_glGetTextureImage = (PFNGLGETTEXTUREIMAGEPROC)load("glGetTextureImage");
 glad_glGetCompressedTextureImage = (PFNGLGETCOMPRESSEDTEXTUREIMAGEPROC)load("glGetCompressedTextureImage");
 glad_glGetTextureLevelParameterfv = (PFNGLGETTEXTURELEVELPARAMETERFVPROC)load("glGetTextureLevelParameterfv");
 glad_glGetTextureLevelParameteriv = (PFNGLGETTEXTURELEVELPARAMETERIVPROC)load("glGetTextureLevelParameteriv");
 glad_glGetTextureParameterfv = (PFNGLGETTEXTUREPARAMETERFVPROC)load("glGetTextureParameterfv");
 glad_glGetTextureParameterIiv = (PFNGLGETTEXTUREPARAMETERIIVPROC)load("glGetTextureParameterIiv");
 glad_glGetTextureParameterIuiv = (PFNGLGETTEXTUREPARAMETERIUIVPROC)load("glGetTextureParameterIuiv");
 glad_glGetTextureParameteriv = (PFNGLGETTEXTUREPARAMETERIVPROC)load("glGetTextureParameteriv");
 glad_glCreateVertexArrays = (PFNGLCREATEVERTEXARRAYSPROC)load("glCreateVertexArrays");
 glad_glDisableVertexArrayAttrib = (PFNGLDISABLEVERTEXARRAYATTRIBPROC)load("glDisableVertexArrayAttrib");
 glad_glEnableVertexArrayAttrib = (PFNGLENABLEVERTEXARRAYATTRIBPROC)load("glEnableVertexArrayAttrib");
 glad_glVertexArrayElementBuffer = (PFNGLVERTEXARRAYELEMENTBUFFERPROC)load("glVertexArrayElementBuffer");
 glad_glVertexArrayVertexBuffer = (PFNGLVERTEXARRAYVERTEXBUFFERPROC)load("glVertexArrayVertexBuffer");
 glad_glVertexArrayVertexBuffers = (PFNGLVERTEXARRAYVERTEXBUFFERSPROC)load("glVertexArrayVertexBuffers");
 glad_glVertexArrayAttribBinding = (PFNGLVERTEXARRAYATTRIBBINDINGPROC)load("glVertexArrayAttribBinding");
 glad_glVertexArrayAttribFormat = (PFNGLVERTEXARRAYATTRIBFORMATPROC)load("glVertexArrayAttribFormat");
 glad_glVertexArrayAttribIFormat = (PFNGLVERTEXARRAYATTRIBIFORMATPROC)load("glVertexArrayAttribIFormat");
 glad_glVertexArrayAttribLFormat = (PFNGLVERTEXARRAYATTRIBLFORMATPROC)load("glVertexArrayAttribLFormat");
 glad_glVertexArrayBindingDivisor = (PFNGLVERTEXARRAYBINDINGDIVISORPROC)load("glVertexArrayBindingDivisor");
 glad_glGetVertexArrayiv = (PFNGLGETVERTEXARRAYIVPROC)load("glGetVertexArrayiv");
 glad_glGetVertexArrayIndexediv = (PFNGLGETVERTEXARRAYINDEXEDIVPROC)load("glGetVertexArrayIndexediv");
 glad_glGetVertexArrayIndexed64iv = (PFNGLGETVERTEXARRAYINDEXED64IVPROC)load("glGetVertexArrayIndexed64iv");
 glad_glCreateSamplers = (PFNGLCREATESAMPLERSPROC)load("glCreateSamplers");
 glad_glCreateProgramPipelines = (PFNGLCREATEPROGRAMPIPELINESPROC)load("glCreateProgramPipelines");
 glad_glCreateQueries = (PFNGLCREATEQUERIESPROC)load("glCreateQueries");
 glad_glGetQueryBufferObjecti64v = (PFNGLGETQUERYBUFFEROBJECTI64VPROC)load("glGetQueryBufferObjecti64v");
 glad_glGetQueryBufferObjectiv = (PFNGLGETQUERYBUFFEROBJECTIVPROC)load("glGetQueryBufferObjectiv");
 glad_glGetQueryBufferObjectui64v = (PFNGLGETQUERYBUFFEROBJECTUI64VPROC)load("glGetQueryBufferObjectui64v");
 glad_glGetQueryBufferObjectuiv = (PFNGLGETQUERYBUFFEROBJECTUIVPROC)load("glGetQueryBufferObjectuiv");
 glad_glMemoryBarrierByRegion = (PFNGLMEMORYBARRIERBYREGIONPROC)load("glMemoryBarrierByRegion");
 glad_glGetTextureSubImage = (PFNGLGETTEXTURESUBIMAGEPROC)load("glGetTextureSubImage");
 glad_glGetCompressedTextureSubImage = (PFNGLGETCOMPRESSEDTEXTURESUBIMAGEPROC)load("glGetCompressedTextureSubImage");
 glad_glGetGraphicsResetStatus = (PFNGLGETGRAPHICSRESETSTATUSPROC)load("glGetGraphicsResetStatus");
 glad_glGetnCompressedTexImage = (PFNGLGETNCOMPRESSEDTEXIMAGEPROC)load("glGetnCompressedTexImage");
 glad_glGetnTexImage = (PFNGLGETNTEXIMAGEPROC)load("glGetnTexImage");
 glad_glGetnUniformdv = (PFNGLGETNUNIFORMDVPROC)load("glGetnUniformdv");
 glad_glGetnUniformfv = (PFNGLGETNUNIFORMFVPROC)load("glGetnUniformfv");
 glad_glGetnUniformiv = (PFNGLGETNUNIFORMIVPROC)load("glGetnUniformiv");
 glad_glGetnUniformuiv = (PFNGLGETNUNIFORMUIVPROC)load("glGetnUniformuiv");
 glad_glReadnPixels = (PFNGLREADNPIXELSPROC)load("glReadnPixels");
 glad_glGetnMapdv = (PFNGLGETNMAPDVPROC)load("glGetnMapdv");
 glad_glGetnMapfv = (PFNGLGETNMAPFVPROC)load("glGetnMapfv");
 glad_glGetnMapiv = (PFNGLGETNMAPIVPROC)load("glGetnMapiv");
 glad_glGetnPixelMapfv = (PFNGLGETNPIXELMAPFVPROC)load("glGetnPixelMapfv");
 glad_glGetnPixelMapuiv = (PFNGLGETNPIXELMAPUIVPROC)load("glGetnPixelMapuiv");
 glad_glGetnPixelMapusv = (PFNGLGETNPIXELMAPUSVPROC)load("glGetnPixelMapusv");
 glad_glGetnPolygonStipple = (PFNGLGETNPOLYGONSTIPPLEPROC)load("glGetnPolygonStipple");
 glad_glGetnColorTable = (PFNGLGETNCOLORTABLEPROC)load("glGetnColorTable");
 glad_glGetnConvolutionFilter = (PFNGLGETNCONVOLUTIONFILTERPROC)load("glGetnConvolutionFilter");
 glad_glGetnSeparableFilter = (PFNGLGETNSEPARABLEFILTERPROC)load("glGetnSeparableFilter");
 glad_glGetnHistogram = (PFNGLGETNHISTOGRAMPROC)load("glGetnHistogram");
 glad_glGetnMinmax = (PFNGLGETNMINMAXPROC)load("glGetnMinmax");
 glad_glTextureBarrier = (PFNGLTEXTUREBARRIERPROC)load("glTextureBarrier");
}
static int find_extensionsGL(void) {
 if (!get_exts()) return 0;
 (void)&has_ext;
 free_exts();
 return 1;
}

static void find_coreGL(void) {





    int i, major, minor;

    const char* version;
    const char* prefixes[] = {
        "OpenGL ES-CM ",
        "OpenGL ES-CL ",
        "OpenGL ES ",
        
# 1744 "include/glad.c" 3 4
       __null
    
# 1745 "include/glad.c"
   };

    version = (const char*) glad_glGetString(0x1F02);
    if (!version) return;

    for (i = 0; prefixes[i]; i++) {
        const size_t length = strlen(prefixes[i]);
        if (strncmp(version, prefixes[i], length) == 0) {
            version += length;
            break;
        }
    }





    sscanf(version, "%d.%d", &major, &minor);


    GLVersion.major = major; GLVersion.minor = minor;
    max_loaded_major = major; max_loaded_minor = minor;
 GLAD_GL_VERSION_1_0 = (major == 1 && minor >= 0) || major > 1;
 GLAD_GL_VERSION_1_1 = (major == 1 && minor >= 1) || major > 1;
 GLAD_GL_VERSION_1_2 = (major == 1 && minor >= 2) || major > 1;
 GLAD_GL_VERSION_1_3 = (major == 1 && minor >= 3) || major > 1;
 GLAD_GL_VERSION_1_4 = (major == 1 && minor >= 4) || major > 1;
 GLAD_GL_VERSION_1_5 = (major == 1 && minor >= 5) || major > 1;
 GLAD_GL_VERSION_2_0 = (major == 2 && minor >= 0) || major > 2;
 GLAD_GL_VERSION_2_1 = (major == 2 && minor >= 1) || major > 2;
 GLAD_GL_VERSION_3_0 = (major == 3 && minor >= 0) || major > 3;
 GLAD_GL_VERSION_3_1 = (major == 3 && minor >= 1) || major > 3;
 GLAD_GL_VERSION_3_2 = (major == 3 && minor >= 2) || major > 3;
 GLAD_GL_VERSION_3_3 = (major == 3 && minor >= 3) || major > 3;
 GLAD_GL_VERSION_4_0 = (major == 4 && minor >= 0) || major > 4;
 GLAD_GL_VERSION_4_1 = (major == 4 && minor >= 1) || major > 4;
 GLAD_GL_VERSION_4_2 = (major == 4 && minor >= 2) || major > 4;
 GLAD_GL_VERSION_4_3 = (major == 4 && minor >= 3) || major > 4;
 GLAD_GL_VERSION_4_4 = (major == 4 && minor >= 4) || major > 4;
 GLAD_GL_VERSION_4_5 = (major == 4 && minor >= 5) || major > 4;
 if (GLVersion.major > 4 || (GLVersion.major >= 4 && GLVersion.minor >= 5)) {
  max_loaded_major = 4;
  max_loaded_minor = 5;
 }
}

int gladLoadGLLoader(GLADloadproc load) {
 GLVersion.major = 0; GLVersion.minor = 0;
 glad_glGetString = (PFNGLGETSTRINGPROC)load("glGetString");
 if(glad_glGetString == 
# 1794 "include/glad.c" 3 4
                  __null
# 1794 "include/glad.c"
                      ) return 0;
 if(glad_glGetString(0x1F02) == 
# 1795 "include/glad.c" 3 4
                              __null
# 1795 "include/glad.c"
                                  ) return 0;
 find_coreGL();
 load_GL_VERSION_1_0(load);
 load_GL_VERSION_1_1(load);
 load_GL_VERSION_1_2(load);
 load_GL_VERSION_1_3(load);
 load_GL_VERSION_1_4(load);
 load_GL_VERSION_1_5(load);
 load_GL_VERSION_2_0(load);
 load_GL_VERSION_2_1(load);
 load_GL_VERSION_3_0(load);
 load_GL_VERSION_3_1(load);
 load_GL_VERSION_3_2(load);
 load_GL_VERSION_3_3(load);
 load_GL_VERSION_4_0(load);
 load_GL_VERSION_4_1(load);
 load_GL_VERSION_4_2(load);
 load_GL_VERSION_4_3(load);
 load_GL_VERSION_4_4(load);
 load_GL_VERSION_4_5(load);

 if (!find_extensionsGL()) return 0;
 return GLVersion.major != 0 || GLVersion.minor != 0;
}
# 11 "code/glfw_main.cpp" 2

# 1 "include/imgui/imgui.h" 1
# 51 "include/imgui/imgui.h"
       






# 1 "include/imgui/imconfig.h" 1
# 15 "include/imgui/imconfig.h"
       
# 59 "include/imgui/imgui.h" 2
# 67 "include/imgui/imgui.h"
# 1 "/usr/lib/gcc/x86_64-linux-gnu/10/include/float.h" 1 3 4
# 68 "include/imgui/imgui.h" 2
# 1 "/usr/lib/gcc/x86_64-linux-gnu/10/include/stdarg.h" 1 3 4
# 69 "include/imgui/imgui.h" 2
# 1 "/usr/lib/gcc/x86_64-linux-gnu/10/include/stddef.h" 1 3 4
# 70 "include/imgui/imgui.h" 2
# 84 "include/imgui/imgui.h"
# 1 "/usr/include/assert.h" 1 3 4
# 85 "include/imgui/imgui.h" 2
# 128 "include/imgui/imgui.h"
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wpragmas"
#pragma GCC diagnostic ignored "-Wclass-memaccess"







struct ImDrawChannel;
struct ImDrawCmd;
struct ImDrawData;
struct ImDrawList;
struct ImDrawListSharedData;
struct ImDrawListSplitter;
struct ImDrawVert;
struct ImFont;
struct ImFontAtlas;
struct ImFontBuilderIO;
struct ImFontConfig;
struct ImFontGlyph;
struct ImFontGlyphRangesBuilder;
struct ImColor;
struct ImGuiContext;
struct ImGuiIO;
struct ImGuiInputTextCallbackData;
struct ImGuiKeyData;
struct ImGuiListClipper;
struct ImGuiOnceUponAFrame;
struct ImGuiPayload;
struct ImGuiPlatformImeData;
struct ImGuiSizeCallbackData;
struct ImGuiStorage;
struct ImGuiStyle;
struct ImGuiTableSortSpecs;
struct ImGuiTableColumnSortSpecs;
struct ImGuiTextBuffer;
struct ImGuiTextFilter;
struct ImGuiViewport;






enum ImGuiKey : int;
enum ImGuiMouseSource : int;
typedef int ImGuiCol;
typedef int ImGuiCond;
typedef int ImGuiDataType;
typedef int ImGuiDir;
typedef int ImGuiMouseButton;
typedef int ImGuiMouseCursor;
typedef int ImGuiSortDirection;
typedef int ImGuiStyleVar;
typedef int ImGuiTableBgTarget;





typedef int ImDrawFlags;
typedef int ImDrawListFlags;
typedef int ImFontAtlasFlags;
typedef int ImGuiBackendFlags;
typedef int ImGuiButtonFlags;
typedef int ImGuiChildFlags;
typedef int ImGuiColorEditFlags;
typedef int ImGuiConfigFlags;
typedef int ImGuiComboFlags;
typedef int ImGuiDragDropFlags;
typedef int ImGuiFocusedFlags;
typedef int ImGuiHoveredFlags;
typedef int ImGuiInputTextFlags;
typedef int ImGuiKeyChord;
typedef int ImGuiPopupFlags;
typedef int ImGuiSelectableFlags;
typedef int ImGuiSliderFlags;
typedef int ImGuiTabBarFlags;
typedef int ImGuiTabItemFlags;
typedef int ImGuiTableFlags;
typedef int ImGuiTableColumnFlags;
typedef int ImGuiTableRowFlags;
typedef int ImGuiTreeNodeFlags;
typedef int ImGuiViewportFlags;
typedef int ImGuiWindowFlags;





typedef void* ImTextureID;






typedef unsigned short ImDrawIdx;



typedef unsigned int ImGuiID;
typedef signed char ImS8;
typedef unsigned char ImU8;
typedef signed short ImS16;
typedef unsigned short ImU16;
typedef signed int ImS32;
typedef unsigned int ImU32;
typedef signed long long ImS64;
typedef unsigned long long ImU64;



typedef unsigned int ImWchar32;
typedef unsigned short ImWchar16;



typedef ImWchar16 ImWchar;



typedef int (*ImGuiInputTextCallback)(ImGuiInputTextCallbackData* data);
typedef void (*ImGuiSizeCallback)(ImGuiSizeCallbackData* data);
typedef void* (*ImGuiMemAllocFunc)(size_t sz, void* user_data);
typedef void (*ImGuiMemFreeFunc)(void* ptr, void* user_data);





struct ImVec2
{
    float x, y;
    constexpr ImVec2() : x(0.0f), y(0.0f) { }
    constexpr ImVec2(float _x, float _y) : x(_x), y(_y) { }
    float& operator[] (size_t idx) { 
# 266 "include/imgui/imgui.h" 3 4
                                             (static_cast <bool> (
# 266 "include/imgui/imgui.h"
                                             idx == 0 || idx == 1
# 266 "include/imgui/imgui.h" 3 4
                                             ) ? void (0) : __assert_fail (
# 266 "include/imgui/imgui.h"
                                             "idx == 0 || idx == 1"
# 266 "include/imgui/imgui.h" 3 4
                                             , "include/imgui/imgui.h", 266, __extension__ __PRETTY_FUNCTION__))
# 266 "include/imgui/imgui.h"
                                                                            ; return ((float*)(void*)(char*)this)[idx]; }
    float operator[] (size_t idx) const { 
# 267 "include/imgui/imgui.h" 3 4
                                             (static_cast <bool> (
# 267 "include/imgui/imgui.h"
                                             idx == 0 || idx == 1
# 267 "include/imgui/imgui.h" 3 4
                                             ) ? void (0) : __assert_fail (
# 267 "include/imgui/imgui.h"
                                             "idx == 0 || idx == 1"
# 267 "include/imgui/imgui.h" 3 4
                                             , "include/imgui/imgui.h", 267, __extension__ __PRETTY_FUNCTION__))
# 267 "include/imgui/imgui.h"
                                                                            ; return ((const float*)(const void*)(const char*)this)[idx]; }



};


struct ImVec4
{
    float x, y, z, w;
    constexpr ImVec4() : x(0.0f), y(0.0f), z(0.0f), w(0.0f) { }
    constexpr ImVec4(float _x, float _y, float _z, float _w) : x(_x), y(_y), z(_z), w(_w) { }



};







namespace ImGui
{




    ImGuiContext* CreateContext(ImFontAtlas* shared_font_atlas = 
# 296 "include/imgui/imgui.h" 3 4
                                                                          __null
# 296 "include/imgui/imgui.h"
                                                                              );
    void DestroyContext(ImGuiContext* ctx = 
# 297 "include/imgui/imgui.h" 3 4
                                                              __null
# 297 "include/imgui/imgui.h"
                                                                  );
    ImGuiContext* GetCurrentContext();
    void SetCurrentContext(ImGuiContext* ctx);


    ImGuiIO& GetIO();
    ImGuiStyle& GetStyle();
    void NewFrame();
    void EndFrame();
    void Render();
    ImDrawData* GetDrawData();


    void ShowDemoWindow(bool* p_open = 
# 310 "include/imgui/imgui.h" 3 4
                                                         __null
# 310 "include/imgui/imgui.h"
                                                             );
    void ShowMetricsWindow(bool* p_open = 
# 311 "include/imgui/imgui.h" 3 4
                                                            __null
# 311 "include/imgui/imgui.h"
                                                                );
    void ShowDebugLogWindow(bool* p_open = 
# 312 "include/imgui/imgui.h" 3 4
                                                             __null
# 312 "include/imgui/imgui.h"
                                                                 );
    void ShowIDStackToolWindow(bool* p_open = 
# 313 "include/imgui/imgui.h" 3 4
                                                                __null
# 313 "include/imgui/imgui.h"
                                                                    );
    void ShowAboutWindow(bool* p_open = 
# 314 "include/imgui/imgui.h" 3 4
                                                          __null
# 314 "include/imgui/imgui.h"
                                                              );
    void ShowStyleEditor(ImGuiStyle* ref = 
# 315 "include/imgui/imgui.h" 3 4
                                                             __null
# 315 "include/imgui/imgui.h"
                                                                 );
    bool ShowStyleSelector(const char* label);
    void ShowFontSelector(const char* label);
    void ShowUserGuide();
    const char* GetVersion();


    void StyleColorsDark(ImGuiStyle* dst = 
# 322 "include/imgui/imgui.h" 3 4
                                                             __null
# 322 "include/imgui/imgui.h"
                                                                 );
    void StyleColorsLight(ImGuiStyle* dst = 
# 323 "include/imgui/imgui.h" 3 4
                                                              __null
# 323 "include/imgui/imgui.h"
                                                                  );
    void StyleColorsClassic(ImGuiStyle* dst = 
# 324 "include/imgui/imgui.h" 3 4
                                                                __null
# 324 "include/imgui/imgui.h"
                                                                    );
# 338 "include/imgui/imgui.h"
    bool Begin(const char* name, bool* p_open = 
# 338 "include/imgui/imgui.h" 3 4
                                                                  __null
# 338 "include/imgui/imgui.h"
                                                                      , ImGuiWindowFlags flags = 0);
    void End();
# 359 "include/imgui/imgui.h"
    bool BeginChild(const char* str_id, const ImVec2& size = ImVec2(0, 0), ImGuiChildFlags child_flags = 0, ImGuiWindowFlags window_flags = 0);
    bool BeginChild(ImGuiID id, const ImVec2& size = ImVec2(0, 0), ImGuiChildFlags child_flags = 0, ImGuiWindowFlags window_flags = 0);
    void EndChild();



    bool IsWindowAppearing();
    bool IsWindowCollapsed();
    bool IsWindowFocused(ImGuiFocusedFlags flags=0);
    bool IsWindowHovered(ImGuiHoveredFlags flags=0);
    ImDrawList* GetWindowDrawList();
    ImVec2 GetWindowPos();
    ImVec2 GetWindowSize();
    float GetWindowWidth();
    float GetWindowHeight();



    void SetNextWindowPos(const ImVec2& pos, ImGuiCond cond = 0, const ImVec2& pivot = ImVec2(0, 0));
    void SetNextWindowSize(const ImVec2& size, ImGuiCond cond = 0);
    void SetNextWindowSizeConstraints(const ImVec2& size_min, const ImVec2& size_max, ImGuiSizeCallback custom_callback = 
# 379 "include/imgui/imgui.h" 3 4
                                                                                                                                            __null
# 379 "include/imgui/imgui.h"
                                                                                                                                                , void* custom_callback_data = 
# 379 "include/imgui/imgui.h" 3 4
                                                                                                                                                                               __null
# 379 "include/imgui/imgui.h"
                                                                                                                                                                                   );
    void SetNextWindowContentSize(const ImVec2& size);
    void SetNextWindowCollapsed(bool collapsed, ImGuiCond cond = 0);
    void SetNextWindowFocus();
    void SetNextWindowScroll(const ImVec2& scroll);
    void SetNextWindowBgAlpha(float alpha);
    void SetWindowPos(const ImVec2& pos, ImGuiCond cond = 0);
    void SetWindowSize(const ImVec2& size, ImGuiCond cond = 0);
    void SetWindowCollapsed(bool collapsed, ImGuiCond cond = 0);
    void SetWindowFocus();
    void SetWindowFontScale(float scale);
    void SetWindowPos(const char* name, const ImVec2& pos, ImGuiCond cond = 0);
    void SetWindowSize(const char* name, const ImVec2& size, ImGuiCond cond = 0);
    void SetWindowCollapsed(const char* name, bool collapsed, ImGuiCond cond = 0);
    void SetWindowFocus(const char* name);




    ImVec2 GetContentRegionAvail();
    ImVec2 GetContentRegionMax();
    ImVec2 GetWindowContentRegionMin();
    ImVec2 GetWindowContentRegionMax();




    float GetScrollX();
    float GetScrollY();
    void SetScrollX(float scroll_x);
    void SetScrollY(float scroll_y);
    float GetScrollMaxX();
    float GetScrollMaxY();
    void SetScrollHereX(float center_x_ratio = 0.5f);
    void SetScrollHereY(float center_y_ratio = 0.5f);
    void SetScrollFromPosX(float local_x, float center_x_ratio = 0.5f);
    void SetScrollFromPosY(float local_y, float center_y_ratio = 0.5f);


    void PushFont(ImFont* font);
    void PopFont();
    void PushStyleColor(ImGuiCol idx, ImU32 col);
    void PushStyleColor(ImGuiCol idx, const ImVec4& col);
    void PopStyleColor(int count = 1);
    void PushStyleVar(ImGuiStyleVar idx, float val);
    void PushStyleVar(ImGuiStyleVar idx, const ImVec2& val);
    void PopStyleVar(int count = 1);
    void PushTabStop(bool tab_stop);
    void PopTabStop();
    void PushButtonRepeat(bool repeat);
    void PopButtonRepeat();


    void PushItemWidth(float item_width);
    void PopItemWidth();
    void SetNextItemWidth(float item_width);
    float CalcItemWidth();
    void PushTextWrapPos(float wrap_local_pos_x = 0.0f);
    void PopTextWrapPos();



    ImFont* GetFont();
    float GetFontSize();
    ImVec2 GetFontTexUvWhitePixel();
    ImU32 GetColorU32(ImGuiCol idx, float alpha_mul = 1.0f);
    ImU32 GetColorU32(const ImVec4& col);
    ImU32 GetColorU32(ImU32 col);
    const ImVec4& GetStyleColorVec4(ImGuiCol idx);
# 457 "include/imgui/imgui.h"
    ImVec2 GetCursorScreenPos();
    void SetCursorScreenPos(const ImVec2& pos);
    ImVec2 GetCursorPos();
    float GetCursorPosX();
    float GetCursorPosY();
    void SetCursorPos(const ImVec2& local_pos);
    void SetCursorPosX(float local_x);
    void SetCursorPosY(float local_y);
    ImVec2 GetCursorStartPos();


    void Separator();
    void SameLine(float offset_from_start_x=0.0f, float spacing=-1.0f);
    void NewLine();
    void Spacing();
    void Dummy(const ImVec2& size);
    void Indent(float indent_w = 0.0f);
    void Unindent(float indent_w = 0.0f);
    void BeginGroup();
    void EndGroup();
    void AlignTextToFramePadding();
    float GetTextLineHeight();
    float GetTextLineHeightWithSpacing();
    float GetFrameHeight();
    float GetFrameHeightWithSpacing();
# 494 "include/imgui/imgui.h"
    void PushID(const char* str_id);
    void PushID(const char* str_id_begin, const char* str_id_end);
    void PushID(const void* ptr_id);
    void PushID(int int_id);
    void PopID();
    ImGuiID GetID(const char* str_id);
    ImGuiID GetID(const char* str_id_begin, const char* str_id_end);
    ImGuiID GetID(const void* ptr_id);


    void TextUnformatted(const char* text, const char* text_end = 
# 504 "include/imgui/imgui.h" 3 4
                                                                                    __null
# 504 "include/imgui/imgui.h"
                                                                                        );
    void Text(const char* fmt, ...) __attribute__((format(printf, 1, 1 +1)));
    void TextV(const char* fmt, va_list args) __attribute__((format(printf, 1, 0)));
    void TextColored(const ImVec4& col, const char* fmt, ...) __attribute__((format(printf, 2, 2 +1)));
    void TextColoredV(const ImVec4& col, const char* fmt, va_list args) __attribute__((format(printf, 2, 0)));
    void TextDisabled(const char* fmt, ...) __attribute__((format(printf, 1, 1 +1)));
    void TextDisabledV(const char* fmt, va_list args) __attribute__((format(printf, 1, 0)));
    void TextWrapped(const char* fmt, ...) __attribute__((format(printf, 1, 1 +1)));
    void TextWrappedV(const char* fmt, va_list args) __attribute__((format(printf, 1, 0)));
    void LabelText(const char* label, const char* fmt, ...) __attribute__((format(printf, 2, 2 +1)));
    void LabelTextV(const char* label, const char* fmt, va_list args) __attribute__((format(printf, 2, 0)));
    void BulletText(const char* fmt, ...) __attribute__((format(printf, 1, 1 +1)));
    void BulletTextV(const char* fmt, va_list args) __attribute__((format(printf, 1, 0)));
    void SeparatorText(const char* label);




    bool Button(const char* label, const ImVec2& size = ImVec2(0, 0));
    bool SmallButton(const char* label);
    bool InvisibleButton(const char* str_id, const ImVec2& size, ImGuiButtonFlags flags = 0);
    bool ArrowButton(const char* str_id, ImGuiDir dir);
    bool Checkbox(const char* label, bool* v);
    bool CheckboxFlags(const char* label, int* flags, int flags_value);
    bool CheckboxFlags(const char* label, unsigned int* flags, unsigned int flags_value);
    bool RadioButton(const char* label, bool active);
    bool RadioButton(const char* label, int* v, int v_button);
    void ProgressBar(float fraction, const ImVec2& size_arg = ImVec2(-1.17549435082228750796873653722224568e-38F, 0), const char* overlay = 
# 531 "include/imgui/imgui.h" 3 4
                                                                                                                           __null
# 531 "include/imgui/imgui.h"
                                                                                                                               );
    void Bullet();





    void Image(ImTextureID user_texture_id, const ImVec2& image_size, const ImVec2& uv0 = ImVec2(0, 0), const ImVec2& uv1 = ImVec2(1, 1), const ImVec4& tint_col = ImVec4(1, 1, 1, 1), const ImVec4& border_col = ImVec4(0, 0, 0, 0));
    bool ImageButton(const char* str_id, ImTextureID user_texture_id, const ImVec2& image_size, const ImVec2& uv0 = ImVec2(0, 0), const ImVec2& uv1 = ImVec2(1, 1), const ImVec4& bg_col = ImVec4(0, 0, 0, 0), const ImVec4& tint_col = ImVec4(1, 1, 1, 1));




    bool BeginCombo(const char* label, const char* preview_value, ImGuiComboFlags flags = 0);
    void EndCombo();
    bool Combo(const char* label, int* current_item, const char* const items[], int items_count, int popup_max_height_in_items = -1);
    bool Combo(const char* label, int* current_item, const char* items_separated_by_zeros, int popup_max_height_in_items = -1);
    bool Combo(const char* label, int* current_item, const char* (*getter)(void* user_data, int idx), void* user_data, int items_count, int popup_max_height_in_items = -1);
# 562 "include/imgui/imgui.h"
    bool DragFloat(const char* label, float* v, float v_speed = 1.0f, float v_min = 0.0f, float v_max = 0.0f, const char* format = "%.3f", ImGuiSliderFlags flags = 0);
    bool DragFloat2(const char* label, float v[2], float v_speed = 1.0f, float v_min = 0.0f, float v_max = 0.0f, const char* format = "%.3f", ImGuiSliderFlags flags = 0);
    bool DragFloat3(const char* label, float v[3], float v_speed = 1.0f, float v_min = 0.0f, float v_max = 0.0f, const char* format = "%.3f", ImGuiSliderFlags flags = 0);
    bool DragFloat4(const char* label, float v[4], float v_speed = 1.0f, float v_min = 0.0f, float v_max = 0.0f, const char* format = "%.3f", ImGuiSliderFlags flags = 0);
    bool DragFloatRange2(const char* label, float* v_current_min, float* v_current_max, float v_speed = 1.0f, float v_min = 0.0f, float v_max = 0.0f, const char* format = "%.3f", const char* format_max = 
# 566 "include/imgui/imgui.h" 3 4
                                                                                                                                                                                                                              __null
# 566 "include/imgui/imgui.h"
                                                                                                                                                                                                                                  , ImGuiSliderFlags flags = 0);
    bool DragInt(const char* label, int* v, float v_speed = 1.0f, int v_min = 0, int v_max = 0, const char* format = "%d", ImGuiSliderFlags flags = 0);
    bool DragInt2(const char* label, int v[2], float v_speed = 1.0f, int v_min = 0, int v_max = 0, const char* format = "%d", ImGuiSliderFlags flags = 0);
    bool DragInt3(const char* label, int v[3], float v_speed = 1.0f, int v_min = 0, int v_max = 0, const char* format = "%d", ImGuiSliderFlags flags = 0);
    bool DragInt4(const char* label, int v[4], float v_speed = 1.0f, int v_min = 0, int v_max = 0, const char* format = "%d", ImGuiSliderFlags flags = 0);
    bool DragIntRange2(const char* label, int* v_current_min, int* v_current_max, float v_speed = 1.0f, int v_min = 0, int v_max = 0, const char* format = "%d", const char* format_max = 
# 571 "include/imgui/imgui.h" 3 4
                                                                                                                                                                                                            __null
# 571 "include/imgui/imgui.h"
                                                                                                                                                                                                                , ImGuiSliderFlags flags = 0);
    bool DragScalar(const char* label, ImGuiDataType data_type, void* p_data, float v_speed = 1.0f, const void* p_min = 
# 572 "include/imgui/imgui.h" 3 4
                                                                                                                                          __null
# 572 "include/imgui/imgui.h"
                                                                                                                                              , const void* p_max = 
# 572 "include/imgui/imgui.h" 3 4
                                                                                                                                                                    __null
# 572 "include/imgui/imgui.h"
                                                                                                                                                                        , const char* format = 
# 572 "include/imgui/imgui.h" 3 4
                                                                                                                                                                                               __null
# 572 "include/imgui/imgui.h"
                                                                                                                                                                                                   , ImGuiSliderFlags flags = 0);
    bool DragScalarN(const char* label, ImGuiDataType data_type, void* p_data, int components, float v_speed = 1.0f, const void* p_min = 
# 573 "include/imgui/imgui.h" 3 4
                                                                                                                                                           __null
# 573 "include/imgui/imgui.h"
                                                                                                                                                               , const void* p_max = 
# 573 "include/imgui/imgui.h" 3 4
                                                                                                                                                                                     __null
# 573 "include/imgui/imgui.h"
                                                                                                                                                                                         , const char* format = 
# 573 "include/imgui/imgui.h" 3 4
                                                                                                                                                                                                                __null
# 573 "include/imgui/imgui.h"
                                                                                                                                                                                                                    , ImGuiSliderFlags flags = 0);







    bool SliderFloat(const char* label, float* v, float v_min, float v_max, const char* format = "%.3f", ImGuiSliderFlags flags = 0);
    bool SliderFloat2(const char* label, float v[2], float v_min, float v_max, const char* format = "%.3f", ImGuiSliderFlags flags = 0);
    bool SliderFloat3(const char* label, float v[3], float v_min, float v_max, const char* format = "%.3f", ImGuiSliderFlags flags = 0);
    bool SliderFloat4(const char* label, float v[4], float v_min, float v_max, const char* format = "%.3f", ImGuiSliderFlags flags = 0);
    bool SliderAngle(const char* label, float* v_rad, float v_degrees_min = -360.0f, float v_degrees_max = +360.0f, const char* format = "%.0f deg", ImGuiSliderFlags flags = 0);
    bool SliderInt(const char* label, int* v, int v_min, int v_max, const char* format = "%d", ImGuiSliderFlags flags = 0);
    bool SliderInt2(const char* label, int v[2], int v_min, int v_max, const char* format = "%d", ImGuiSliderFlags flags = 0);
    bool SliderInt3(const char* label, int v[3], int v_min, int v_max, const char* format = "%d", ImGuiSliderFlags flags = 0);
    bool SliderInt4(const char* label, int v[4], int v_min, int v_max, const char* format = "%d", ImGuiSliderFlags flags = 0);
    bool SliderScalar(const char* label, ImGuiDataType data_type, void* p_data, const void* p_min, const void* p_max, const char* format = 
# 590 "include/imgui/imgui.h" 3 4
                                                                                                                                                             __null
# 590 "include/imgui/imgui.h"
                                                                                                                                                                 , ImGuiSliderFlags flags = 0);
    bool SliderScalarN(const char* label, ImGuiDataType data_type, void* p_data, int components, const void* p_min, const void* p_max, const char* format = 
# 591 "include/imgui/imgui.h" 3 4
                                                                                                                                                                              __null
# 591 "include/imgui/imgui.h"
                                                                                                                                                                                  , ImGuiSliderFlags flags = 0);
    bool VSliderFloat(const char* label, const ImVec2& size, float* v, float v_min, float v_max, const char* format = "%.3f", ImGuiSliderFlags flags = 0);
    bool VSliderInt(const char* label, const ImVec2& size, int* v, int v_min, int v_max, const char* format = "%d", ImGuiSliderFlags flags = 0);
    bool VSliderScalar(const char* label, const ImVec2& size, ImGuiDataType data_type, void* p_data, const void* p_min, const void* p_max, const char* format = 
# 594 "include/imgui/imgui.h" 3 4
                                                                                                                                                                                  __null
# 594 "include/imgui/imgui.h"
                                                                                                                                                                                      , ImGuiSliderFlags flags = 0);




    bool InputText(const char* label, char* buf, size_t buf_size, ImGuiInputTextFlags flags = 0, ImGuiInputTextCallback callback = 
# 599 "include/imgui/imgui.h" 3 4
                                                                                                                                                     __null
# 599 "include/imgui/imgui.h"
                                                                                                                                                         , void* user_data = 
# 599 "include/imgui/imgui.h" 3 4
                                                                                                                                                                             __null
# 599 "include/imgui/imgui.h"
                                                                                                                                                                                 );
    bool InputTextMultiline(const char* label, char* buf, size_t buf_size, const ImVec2& size = ImVec2(0, 0), ImGuiInputTextFlags flags = 0, ImGuiInputTextCallback callback = 
# 600 "include/imgui/imgui.h" 3 4
                                                                                                                                                                                                 __null
# 600 "include/imgui/imgui.h"
                                                                                                                                                                                                     , void* user_data = 
# 600 "include/imgui/imgui.h" 3 4
                                                                                                                                                                                                                         __null
# 600 "include/imgui/imgui.h"
                                                                                                                                                                                                                             );
    bool InputTextWithHint(const char* label, const char* hint, char* buf, size_t buf_size, ImGuiInputTextFlags flags = 0, ImGuiInputTextCallback callback = 
# 601 "include/imgui/imgui.h" 3 4
                                                                                                                                                                               __null
# 601 "include/imgui/imgui.h"
                                                                                                                                                                                   , void* user_data = 
# 601 "include/imgui/imgui.h" 3 4
                                                                                                                                                                                                       __null
# 601 "include/imgui/imgui.h"
                                                                                                                                                                                                           );
    bool InputFloat(const char* label, float* v, float step = 0.0f, float step_fast = 0.0f, const char* format = "%.3f", ImGuiInputTextFlags flags = 0);
    bool InputFloat2(const char* label, float v[2], const char* format = "%.3f", ImGuiInputTextFlags flags = 0);
    bool InputFloat3(const char* label, float v[3], const char* format = "%.3f", ImGuiInputTextFlags flags = 0);
    bool InputFloat4(const char* label, float v[4], const char* format = "%.3f", ImGuiInputTextFlags flags = 0);
    bool InputInt(const char* label, int* v, int step = 1, int step_fast = 100, ImGuiInputTextFlags flags = 0);
    bool InputInt2(const char* label, int v[2], ImGuiInputTextFlags flags = 0);
    bool InputInt3(const char* label, int v[3], ImGuiInputTextFlags flags = 0);
    bool InputInt4(const char* label, int v[4], ImGuiInputTextFlags flags = 0);
    bool InputDouble(const char* label, double* v, double step = 0.0, double step_fast = 0.0, const char* format = "%.6f", ImGuiInputTextFlags flags = 0);
    bool InputScalar(const char* label, ImGuiDataType data_type, void* p_data, const void* p_step = 
# 611 "include/imgui/imgui.h" 3 4
                                                                                                                      __null
# 611 "include/imgui/imgui.h"
                                                                                                                          , const void* p_step_fast = 
# 611 "include/imgui/imgui.h" 3 4
                                                                                                                                                      __null
# 611 "include/imgui/imgui.h"
                                                                                                                                                          , const char* format = 
# 611 "include/imgui/imgui.h" 3 4
                                                                                                                                                                                 __null
# 611 "include/imgui/imgui.h"
                                                                                                                                                                                     , ImGuiInputTextFlags flags = 0);
    bool InputScalarN(const char* label, ImGuiDataType data_type, void* p_data, int components, const void* p_step = 
# 612 "include/imgui/imgui.h" 3 4
                                                                                                                                       __null
# 612 "include/imgui/imgui.h"
                                                                                                                                           , const void* p_step_fast = 
# 612 "include/imgui/imgui.h" 3 4
                                                                                                                                                                       __null
# 612 "include/imgui/imgui.h"
                                                                                                                                                                           , const char* format = 
# 612 "include/imgui/imgui.h" 3 4
                                                                                                                                                                                                  __null
# 612 "include/imgui/imgui.h"
                                                                                                                                                                                                      , ImGuiInputTextFlags flags = 0);




    bool ColorEdit3(const char* label, float col[3], ImGuiColorEditFlags flags = 0);
    bool ColorEdit4(const char* label, float col[4], ImGuiColorEditFlags flags = 0);
    bool ColorPicker3(const char* label, float col[3], ImGuiColorEditFlags flags = 0);
    bool ColorPicker4(const char* label, float col[4], ImGuiColorEditFlags flags = 0, const float* ref_col = 
# 620 "include/imgui/imgui.h" 3 4
                                                                                                                               __null
# 620 "include/imgui/imgui.h"
                                                                                                                                   );
    bool ColorButton(const char* desc_id, const ImVec4& col, ImGuiColorEditFlags flags = 0, const ImVec2& size = ImVec2(0, 0));
    void SetColorEditOptions(ImGuiColorEditFlags flags);



    bool TreeNode(const char* label);
    bool TreeNode(const char* str_id, const char* fmt, ...) __attribute__((format(printf, 2, 2 +1)));
    bool TreeNode(const void* ptr_id, const char* fmt, ...) __attribute__((format(printf, 2, 2 +1)));
    bool TreeNodeV(const char* str_id, const char* fmt, va_list args) __attribute__((format(printf, 2, 0)));
    bool TreeNodeV(const void* ptr_id, const char* fmt, va_list args) __attribute__((format(printf, 2, 0)));
    bool TreeNodeEx(const char* label, ImGuiTreeNodeFlags flags = 0);
    bool TreeNodeEx(const char* str_id, ImGuiTreeNodeFlags flags, const char* fmt, ...) __attribute__((format(printf, 3, 3 +1)));
    bool TreeNodeEx(const void* ptr_id, ImGuiTreeNodeFlags flags, const char* fmt, ...) __attribute__((format(printf, 3, 3 +1)));
    bool TreeNodeExV(const char* str_id, ImGuiTreeNodeFlags flags, const char* fmt, va_list args) __attribute__((format(printf, 3, 0)));
    bool TreeNodeExV(const void* ptr_id, ImGuiTreeNodeFlags flags, const char* fmt, va_list args) __attribute__((format(printf, 3, 0)));
    void TreePush(const char* str_id);
    void TreePush(const void* ptr_id);
    void TreePop();
    float GetTreeNodeToLabelSpacing();
    bool CollapsingHeader(const char* label, ImGuiTreeNodeFlags flags = 0);
    bool CollapsingHeader(const char* label, bool* p_visible, ImGuiTreeNodeFlags flags = 0);
    void SetNextItemOpen(bool is_open, ImGuiCond cond = 0);




    bool Selectable(const char* label, bool selected = false, ImGuiSelectableFlags flags = 0, const ImVec2& size = ImVec2(0, 0));
    bool Selectable(const char* label, bool* p_selected, ImGuiSelectableFlags flags = 0, const ImVec2& size = ImVec2(0, 0));







    bool BeginListBox(const char* label, const ImVec2& size = ImVec2(0, 0));
    void EndListBox();
    bool ListBox(const char* label, int* current_item, const char* const items[], int items_count, int height_in_items = -1);
    bool ListBox(const char* label, int* current_item, const char* (*getter)(void* user_data, int idx), void* user_data, int items_count, int height_in_items = -1);



    void PlotLines(const char* label, const float* values, int values_count, int values_offset = 0, const char* overlay_text = 
# 663 "include/imgui/imgui.h" 3 4
                                                                                                                                                 __null
# 663 "include/imgui/imgui.h"
                                                                                                                                                     , float scale_min = 3.40282346638528859811704183484516925e+38F, float scale_max = 3.40282346638528859811704183484516925e+38F, ImVec2 graph_size = ImVec2(0, 0), int stride = sizeof(float));
    void PlotLines(const char* label, float(*values_getter)(void* data, int idx), void* data, int values_count, int values_offset = 0, const char* overlay_text = 
# 664 "include/imgui/imgui.h" 3 4
                                                                                                                                                                                    __null
# 664 "include/imgui/imgui.h"
                                                                                                                                                                                        , float scale_min = 3.40282346638528859811704183484516925e+38F, float scale_max = 3.40282346638528859811704183484516925e+38F, ImVec2 graph_size = ImVec2(0, 0));
    void PlotHistogram(const char* label, const float* values, int values_count, int values_offset = 0, const char* overlay_text = 
# 665 "include/imgui/imgui.h" 3 4
                                                                                                                                                     __null
# 665 "include/imgui/imgui.h"
                                                                                                                                                         , float scale_min = 3.40282346638528859811704183484516925e+38F, float scale_max = 3.40282346638528859811704183484516925e+38F, ImVec2 graph_size = ImVec2(0, 0), int stride = sizeof(float));
    void PlotHistogram(const char* label, float (*values_getter)(void* data, int idx), void* data, int values_count, int values_offset = 0, const char* overlay_text = 
# 666 "include/imgui/imgui.h" 3 4
                                                                                                                                                                                         __null
# 666 "include/imgui/imgui.h"
                                                                                                                                                                                             , float scale_min = 3.40282346638528859811704183484516925e+38F, float scale_max = 3.40282346638528859811704183484516925e+38F, ImVec2 graph_size = ImVec2(0, 0));



    void Value(const char* prefix, bool b);
    void Value(const char* prefix, int v);
    void Value(const char* prefix, unsigned int v);
    void Value(const char* prefix, float v, const char* float_format = 
# 673 "include/imgui/imgui.h" 3 4
                                                                                         __null
# 673 "include/imgui/imgui.h"
                                                                                             );






    bool BeginMenuBar();
    void EndMenuBar();
    bool BeginMainMenuBar();
    void EndMainMenuBar();
    bool BeginMenu(const char* label, bool enabled = true);
    void EndMenu();
    bool MenuItem(const char* label, const char* shortcut = 
# 686 "include/imgui/imgui.h" 3 4
                                                                              __null
# 686 "include/imgui/imgui.h"
                                                                                  , bool selected = false, bool enabled = true);
    bool MenuItem(const char* label, const char* shortcut, bool* p_selected, bool enabled = true);




    bool BeginTooltip();
    void EndTooltip();
    void SetTooltip(const char* fmt, ...) __attribute__((format(printf, 1, 1 +1)));
    void SetTooltipV(const char* fmt, va_list args) __attribute__((format(printf, 1, 0)));





    bool BeginItemTooltip();
    void SetItemTooltip(const char* fmt, ...) __attribute__((format(printf, 1, 1 +1)));
    void SetItemTooltipV(const char* fmt, va_list args) __attribute__((format(printf, 1, 0)));
# 715 "include/imgui/imgui.h"
    bool BeginPopup(const char* str_id, ImGuiWindowFlags flags = 0);
    bool BeginPopupModal(const char* name, bool* p_open = 
# 716 "include/imgui/imgui.h" 3 4
                                                                            __null
# 716 "include/imgui/imgui.h"
                                                                                , ImGuiWindowFlags flags = 0);
    void EndPopup();
# 727 "include/imgui/imgui.h"
    void OpenPopup(const char* str_id, ImGuiPopupFlags popup_flags = 0);
    void OpenPopup(ImGuiID id, ImGuiPopupFlags popup_flags = 0);
    void OpenPopupOnItemClick(const char* str_id = 
# 729 "include/imgui/imgui.h" 3 4
                                                                     __null
# 729 "include/imgui/imgui.h"
                                                                         , ImGuiPopupFlags popup_flags = 1);
    void CloseCurrentPopup();






    bool BeginPopupContextItem(const char* str_id = 
# 737 "include/imgui/imgui.h" 3 4
                                                                      __null
# 737 "include/imgui/imgui.h"
                                                                          , ImGuiPopupFlags popup_flags = 1);
    bool BeginPopupContextWindow(const char* str_id = 
# 738 "include/imgui/imgui.h" 3 4
                                                                        __null
# 738 "include/imgui/imgui.h"
                                                                            , ImGuiPopupFlags popup_flags = 1);
    bool BeginPopupContextVoid(const char* str_id = 
# 739 "include/imgui/imgui.h" 3 4
                                                                      __null
# 739 "include/imgui/imgui.h"
                                                                          , ImGuiPopupFlags popup_flags = 1);





    bool IsPopupOpen(const char* str_id, ImGuiPopupFlags flags = 0);
# 768 "include/imgui/imgui.h"
    bool BeginTable(const char* str_id, int column, ImGuiTableFlags flags = 0, const ImVec2& outer_size = ImVec2(0.0f, 0.0f), float inner_width = 0.0f);
    void EndTable();
    void TableNextRow(ImGuiTableRowFlags row_flags = 0, float min_row_height = 0.0f);
    bool TableNextColumn();
    bool TableSetColumnIndex(int column_n);
# 782 "include/imgui/imgui.h"
    void TableSetupColumn(const char* label, ImGuiTableColumnFlags flags = 0, float init_width_or_weight = 0.0f, ImGuiID user_id = 0);
    void TableSetupScrollFreeze(int cols, int rows);
    void TableHeader(const char* label);
    void TableHeadersRow();
    void TableAngledHeadersRow();







    ImGuiTableSortSpecs* TableGetSortSpecs();
    int TableGetColumnCount();
    int TableGetColumnIndex();
    int TableGetRowIndex();
    const char* TableGetColumnName(int column_n = -1);
    ImGuiTableColumnFlags TableGetColumnFlags(int column_n = -1);
    void TableSetColumnEnabled(int column_n, bool v);
    void TableSetBgColor(ImGuiTableBgTarget target, ImU32 color, int column_n = -1);



    void Columns(int count = 1, const char* id = 
# 805 "include/imgui/imgui.h" 3 4
                                                                   __null
# 805 "include/imgui/imgui.h"
                                                                       , bool border = true);
    void NextColumn();
    int GetColumnIndex();
    float GetColumnWidth(int column_index = -1);
    void SetColumnWidth(int column_index, float width);
    float GetColumnOffset(int column_index = -1);
    void SetColumnOffset(int column_index, float offset_x);
    int GetColumnsCount();



    bool BeginTabBar(const char* str_id, ImGuiTabBarFlags flags = 0);
    void EndTabBar();
    bool BeginTabItem(const char* label, bool* p_open = 
# 818 "include/imgui/imgui.h" 3 4
                                                                          __null
# 818 "include/imgui/imgui.h"
                                                                              , ImGuiTabItemFlags flags = 0);
    void EndTabItem();
    bool TabItemButton(const char* label, ImGuiTabItemFlags flags = 0);
    void SetTabItemClosed(const char* tab_or_docked_window_label);



    void LogToTTY(int auto_open_depth = -1);
    void LogToFile(int auto_open_depth = -1, const char* filename = 
# 826 "include/imgui/imgui.h" 3 4
                                                                                      __null
# 826 "include/imgui/imgui.h"
                                                                                          );
    void LogToClipboard(int auto_open_depth = -1);
    void LogFinish();
    void LogButtons();
    void LogText(const char* fmt, ...) __attribute__((format(printf, 1, 1 +1)));
    void LogTextV(const char* fmt, va_list args) __attribute__((format(printf, 1, 0)));






    bool BeginDragDropSource(ImGuiDragDropFlags flags = 0);
    bool SetDragDropPayload(const char* type, const void* data, size_t sz, ImGuiCond cond = 0);
    void EndDragDropSource();
    bool BeginDragDropTarget();
    const ImGuiPayload* AcceptDragDropPayload(const char* type, ImGuiDragDropFlags flags = 0);
    void EndDragDropTarget();
    const ImGuiPayload* GetDragDropPayload();





    void BeginDisabled(bool disabled = true);
    void EndDisabled();



    void PushClipRect(const ImVec2& clip_rect_min, const ImVec2& clip_rect_max, bool intersect_with_current_clip_rect);
    void PopClipRect();



    void SetItemDefaultFocus();
    void SetKeyboardFocusHere(int offset = 0);


    void SetNextItemAllowOverlap();




    bool IsItemHovered(ImGuiHoveredFlags flags = 0);
    bool IsItemActive();
    bool IsItemFocused();
    bool IsItemClicked(ImGuiMouseButton mouse_button = 0);
    bool IsItemVisible();
    bool IsItemEdited();
    bool IsItemActivated();
    bool IsItemDeactivated();
    bool IsItemDeactivatedAfterEdit();
    bool IsItemToggledOpen();
    bool IsAnyItemHovered();
    bool IsAnyItemActive();
    bool IsAnyItemFocused();
    ImGuiID GetItemID();
    ImVec2 GetItemRectMin();
    ImVec2 GetItemRectMax();
    ImVec2 GetItemRectSize();





    ImGuiViewport* GetMainViewport();


    ImDrawList* GetBackgroundDrawList();
    ImDrawList* GetForegroundDrawList();


    bool IsRectVisible(const ImVec2& size);
    bool IsRectVisible(const ImVec2& rect_min, const ImVec2& rect_max);
    double GetTime();
    int GetFrameCount();
    ImDrawListSharedData* GetDrawListSharedData();
    const char* GetStyleColorName(ImGuiCol idx);
    void SetStateStorage(ImGuiStorage* storage);
    ImGuiStorage* GetStateStorage();


    ImVec2 CalcTextSize(const char* text, const char* text_end = 
# 908 "include/imgui/imgui.h" 3 4
                                                                                 __null
# 908 "include/imgui/imgui.h"
                                                                                     , bool hide_text_after_double_hash = false, float wrap_width = -1.0f);


    ImVec4 ColorConvertU32ToFloat4(ImU32 in);
    ImU32 ColorConvertFloat4ToU32(const ImVec4& in);
    void ColorConvertRGBtoHSV(float r, float g, float b, float& out_h, float& out_s, float& out_v);
    void ColorConvertHSVtoRGB(float h, float s, float v, float& out_r, float& out_g, float& out_b);






    bool IsKeyDown(ImGuiKey key);
    bool IsKeyPressed(ImGuiKey key, bool repeat = true);
    bool IsKeyReleased(ImGuiKey key);
    bool IsKeyChordPressed(ImGuiKeyChord key_chord);
    int GetKeyPressedAmount(ImGuiKey key, float repeat_delay, float rate);
    const char* GetKeyName(ImGuiKey key);
    void SetNextFrameWantCaptureKeyboard(bool want_capture_keyboard);





    bool IsMouseDown(ImGuiMouseButton button);
    bool IsMouseClicked(ImGuiMouseButton button, bool repeat = false);
    bool IsMouseReleased(ImGuiMouseButton button);
    bool IsMouseDoubleClicked(ImGuiMouseButton button);
    int GetMouseClickedCount(ImGuiMouseButton button);
    bool IsMouseHoveringRect(const ImVec2& r_min, const ImVec2& r_max, bool clip = true);
    bool IsMousePosValid(const ImVec2* mouse_pos = 
# 939 "include/imgui/imgui.h" 3 4
                                                                     __null
# 939 "include/imgui/imgui.h"
                                                                         );
    bool IsAnyMouseDown();
    ImVec2 GetMousePos();
    ImVec2 GetMousePosOnOpeningCurrentPopup();
    bool IsMouseDragging(ImGuiMouseButton button, float lock_threshold = -1.0f);
    ImVec2 GetMouseDragDelta(ImGuiMouseButton button = 0, float lock_threshold = -1.0f);
    void ResetMouseDragDelta(ImGuiMouseButton button = 0);
    ImGuiMouseCursor GetMouseCursor();
    void SetMouseCursor(ImGuiMouseCursor cursor_type);
    void SetNextFrameWantCaptureMouse(bool want_capture_mouse);



    const char* GetClipboardText();
    void SetClipboardText(const char* text);





    void LoadIniSettingsFromDisk(const char* ini_filename);
    void LoadIniSettingsFromMemory(const char* ini_data, size_t ini_size=0);
    void SaveIniSettingsToDisk(const char* ini_filename);
    const char* SaveIniSettingsToMemory(size_t* out_ini_size = 
# 962 "include/imgui/imgui.h" 3 4
                                                                          __null
# 962 "include/imgui/imgui.h"
                                                                              );



    void DebugTextEncoding(const char* text);
    void DebugFlashStyleColor(ImGuiCol idx);
    bool DebugCheckVersionAndDataLayout(const char* version_str, size_t sz_io, size_t sz_style, size_t sz_vec2, size_t sz_vec4, size_t sz_drawvert, size_t sz_drawidx);





    void SetAllocatorFunctions(ImGuiMemAllocFunc alloc_func, ImGuiMemFreeFunc free_func, void* user_data = 
# 974 "include/imgui/imgui.h" 3 4
                                                                                                                             __null
# 974 "include/imgui/imgui.h"
                                                                                                                                 );
    void GetAllocatorFunctions(ImGuiMemAllocFunc* p_alloc_func, ImGuiMemFreeFunc* p_free_func, void** p_user_data);
    void* MemAlloc(size_t size);
    void MemFree(void* ptr);

}







enum ImGuiWindowFlags_
{
    ImGuiWindowFlags_None = 0,
    ImGuiWindowFlags_NoTitleBar = 1 << 0,
    ImGuiWindowFlags_NoResize = 1 << 1,
    ImGuiWindowFlags_NoMove = 1 << 2,
    ImGuiWindowFlags_NoScrollbar = 1 << 3,
    ImGuiWindowFlags_NoScrollWithMouse = 1 << 4,
    ImGuiWindowFlags_NoCollapse = 1 << 5,
    ImGuiWindowFlags_AlwaysAutoResize = 1 << 6,
    ImGuiWindowFlags_NoBackground = 1 << 7,
    ImGuiWindowFlags_NoSavedSettings = 1 << 8,
    ImGuiWindowFlags_NoMouseInputs = 1 << 9,
    ImGuiWindowFlags_MenuBar = 1 << 10,
    ImGuiWindowFlags_HorizontalScrollbar = 1 << 11,
    ImGuiWindowFlags_NoFocusOnAppearing = 1 << 12,
    ImGuiWindowFlags_NoBringToFrontOnFocus = 1 << 13,
    ImGuiWindowFlags_AlwaysVerticalScrollbar= 1 << 14,
    ImGuiWindowFlags_AlwaysHorizontalScrollbar=1<< 15,
    ImGuiWindowFlags_NoNavInputs = 1 << 16,
    ImGuiWindowFlags_NoNavFocus = 1 << 17,
    ImGuiWindowFlags_UnsavedDocument = 1 << 18,
    ImGuiWindowFlags_NoNav = ImGuiWindowFlags_NoNavInputs | ImGuiWindowFlags_NoNavFocus,
    ImGuiWindowFlags_NoDecoration = ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_NoResize | ImGuiWindowFlags_NoScrollbar | ImGuiWindowFlags_NoCollapse,
    ImGuiWindowFlags_NoInputs = ImGuiWindowFlags_NoMouseInputs | ImGuiWindowFlags_NoNavInputs | ImGuiWindowFlags_NoNavFocus,


    ImGuiWindowFlags_NavFlattened = 1 << 23,
    ImGuiWindowFlags_ChildWindow = 1 << 24,
    ImGuiWindowFlags_Tooltip = 1 << 25,
    ImGuiWindowFlags_Popup = 1 << 26,
    ImGuiWindowFlags_Modal = 1 << 27,
    ImGuiWindowFlags_ChildMenu = 1 << 28,



    ImGuiWindowFlags_AlwaysUseWindowPadding = 1 << 30,

};
# 1036 "include/imgui/imgui.h"
enum ImGuiChildFlags_
{
    ImGuiChildFlags_None = 0,
    ImGuiChildFlags_Border = 1 << 0,
    ImGuiChildFlags_AlwaysUseWindowPadding = 1 << 1,
    ImGuiChildFlags_ResizeX = 1 << 2,
    ImGuiChildFlags_ResizeY = 1 << 3,
    ImGuiChildFlags_AutoResizeX = 1 << 4,
    ImGuiChildFlags_AutoResizeY = 1 << 5,
    ImGuiChildFlags_AlwaysAutoResize = 1 << 6,
    ImGuiChildFlags_FrameStyle = 1 << 7,
};



enum ImGuiInputTextFlags_
{
    ImGuiInputTextFlags_None = 0,
    ImGuiInputTextFlags_CharsDecimal = 1 << 0,
    ImGuiInputTextFlags_CharsHexadecimal = 1 << 1,
    ImGuiInputTextFlags_CharsUppercase = 1 << 2,
    ImGuiInputTextFlags_CharsNoBlank = 1 << 3,
    ImGuiInputTextFlags_AutoSelectAll = 1 << 4,
    ImGuiInputTextFlags_EnterReturnsTrue = 1 << 5,
    ImGuiInputTextFlags_CallbackCompletion = 1 << 6,
    ImGuiInputTextFlags_CallbackHistory = 1 << 7,
    ImGuiInputTextFlags_CallbackAlways = 1 << 8,
    ImGuiInputTextFlags_CallbackCharFilter = 1 << 9,
    ImGuiInputTextFlags_AllowTabInput = 1 << 10,
    ImGuiInputTextFlags_CtrlEnterForNewLine = 1 << 11,
    ImGuiInputTextFlags_NoHorizontalScroll = 1 << 12,
    ImGuiInputTextFlags_AlwaysOverwrite = 1 << 13,
    ImGuiInputTextFlags_ReadOnly = 1 << 14,
    ImGuiInputTextFlags_Password = 1 << 15,
    ImGuiInputTextFlags_NoUndoRedo = 1 << 16,
    ImGuiInputTextFlags_CharsScientific = 1 << 17,
    ImGuiInputTextFlags_CallbackResize = 1 << 18,
    ImGuiInputTextFlags_CallbackEdit = 1 << 19,
    ImGuiInputTextFlags_EscapeClearsAll = 1 << 20,



};


enum ImGuiTreeNodeFlags_
{
    ImGuiTreeNodeFlags_None = 0,
    ImGuiTreeNodeFlags_Selected = 1 << 0,
    ImGuiTreeNodeFlags_Framed = 1 << 1,
    ImGuiTreeNodeFlags_AllowOverlap = 1 << 2,
    ImGuiTreeNodeFlags_NoTreePushOnOpen = 1 << 3,
    ImGuiTreeNodeFlags_NoAutoOpenOnLog = 1 << 4,
    ImGuiTreeNodeFlags_DefaultOpen = 1 << 5,
    ImGuiTreeNodeFlags_OpenOnDoubleClick = 1 << 6,
    ImGuiTreeNodeFlags_OpenOnArrow = 1 << 7,
    ImGuiTreeNodeFlags_Leaf = 1 << 8,
    ImGuiTreeNodeFlags_Bullet = 1 << 9,
    ImGuiTreeNodeFlags_FramePadding = 1 << 10,
    ImGuiTreeNodeFlags_SpanAvailWidth = 1 << 11,
    ImGuiTreeNodeFlags_SpanFullWidth = 1 << 12,
    ImGuiTreeNodeFlags_SpanAllColumns = 1 << 13,
    ImGuiTreeNodeFlags_NavLeftJumpsBackHere = 1 << 14,

    ImGuiTreeNodeFlags_CollapsingHeader = ImGuiTreeNodeFlags_Framed | ImGuiTreeNodeFlags_NoTreePushOnOpen | ImGuiTreeNodeFlags_NoAutoOpenOnLog,


    ImGuiTreeNodeFlags_AllowItemOverlap = ImGuiTreeNodeFlags_AllowOverlap,

};
# 1115 "include/imgui/imgui.h"
enum ImGuiPopupFlags_
{
    ImGuiPopupFlags_None = 0,
    ImGuiPopupFlags_MouseButtonLeft = 0,
    ImGuiPopupFlags_MouseButtonRight = 1,
    ImGuiPopupFlags_MouseButtonMiddle = 2,
    ImGuiPopupFlags_MouseButtonMask_ = 0x1F,
    ImGuiPopupFlags_MouseButtonDefault_ = 1,
    ImGuiPopupFlags_NoOpenOverExistingPopup = 1 << 5,
    ImGuiPopupFlags_NoOpenOverItems = 1 << 6,
    ImGuiPopupFlags_AnyPopupId = 1 << 7,
    ImGuiPopupFlags_AnyPopupLevel = 1 << 8,
    ImGuiPopupFlags_AnyPopup = ImGuiPopupFlags_AnyPopupId | ImGuiPopupFlags_AnyPopupLevel,
};


enum ImGuiSelectableFlags_
{
    ImGuiSelectableFlags_None = 0,
    ImGuiSelectableFlags_DontClosePopups = 1 << 0,
    ImGuiSelectableFlags_SpanAllColumns = 1 << 1,
    ImGuiSelectableFlags_AllowDoubleClick = 1 << 2,
    ImGuiSelectableFlags_Disabled = 1 << 3,
    ImGuiSelectableFlags_AllowOverlap = 1 << 4,


    ImGuiSelectableFlags_AllowItemOverlap = ImGuiSelectableFlags_AllowOverlap,

};


enum ImGuiComboFlags_
{
    ImGuiComboFlags_None = 0,
    ImGuiComboFlags_PopupAlignLeft = 1 << 0,
    ImGuiComboFlags_HeightSmall = 1 << 1,
    ImGuiComboFlags_HeightRegular = 1 << 2,
    ImGuiComboFlags_HeightLarge = 1 << 3,
    ImGuiComboFlags_HeightLargest = 1 << 4,
    ImGuiComboFlags_NoArrowButton = 1 << 5,
    ImGuiComboFlags_NoPreview = 1 << 6,
    ImGuiComboFlags_WidthFitPreview = 1 << 7,
    ImGuiComboFlags_HeightMask_ = ImGuiComboFlags_HeightSmall | ImGuiComboFlags_HeightRegular | ImGuiComboFlags_HeightLarge | ImGuiComboFlags_HeightLargest,
};


enum ImGuiTabBarFlags_
{
    ImGuiTabBarFlags_None = 0,
    ImGuiTabBarFlags_Reorderable = 1 << 0,
    ImGuiTabBarFlags_AutoSelectNewTabs = 1 << 1,
    ImGuiTabBarFlags_TabListPopupButton = 1 << 2,
    ImGuiTabBarFlags_NoCloseWithMiddleMouseButton = 1 << 3,
    ImGuiTabBarFlags_NoTabListScrollingButtons = 1 << 4,
    ImGuiTabBarFlags_NoTooltip = 1 << 5,
    ImGuiTabBarFlags_FittingPolicyResizeDown = 1 << 6,
    ImGuiTabBarFlags_FittingPolicyScroll = 1 << 7,
    ImGuiTabBarFlags_FittingPolicyMask_ = ImGuiTabBarFlags_FittingPolicyResizeDown | ImGuiTabBarFlags_FittingPolicyScroll,
    ImGuiTabBarFlags_FittingPolicyDefault_ = ImGuiTabBarFlags_FittingPolicyResizeDown,
};


enum ImGuiTabItemFlags_
{
    ImGuiTabItemFlags_None = 0,
    ImGuiTabItemFlags_UnsavedDocument = 1 << 0,
    ImGuiTabItemFlags_SetSelected = 1 << 1,
    ImGuiTabItemFlags_NoCloseWithMiddleMouseButton = 1 << 2,
    ImGuiTabItemFlags_NoPushId = 1 << 3,
    ImGuiTabItemFlags_NoTooltip = 1 << 4,
    ImGuiTabItemFlags_NoReorder = 1 << 5,
    ImGuiTabItemFlags_Leading = 1 << 6,
    ImGuiTabItemFlags_Trailing = 1 << 7,
    ImGuiTabItemFlags_NoAssumedClosure = 1 << 8,
};


enum ImGuiFocusedFlags_
{
    ImGuiFocusedFlags_None = 0,
    ImGuiFocusedFlags_ChildWindows = 1 << 0,
    ImGuiFocusedFlags_RootWindow = 1 << 1,
    ImGuiFocusedFlags_AnyWindow = 1 << 2,
    ImGuiFocusedFlags_NoPopupHierarchy = 1 << 3,

    ImGuiFocusedFlags_RootAndChildWindows = ImGuiFocusedFlags_RootWindow | ImGuiFocusedFlags_ChildWindows,
};




enum ImGuiHoveredFlags_
{
    ImGuiHoveredFlags_None = 0,
    ImGuiHoveredFlags_ChildWindows = 1 << 0,
    ImGuiHoveredFlags_RootWindow = 1 << 1,
    ImGuiHoveredFlags_AnyWindow = 1 << 2,
    ImGuiHoveredFlags_NoPopupHierarchy = 1 << 3,

    ImGuiHoveredFlags_AllowWhenBlockedByPopup = 1 << 5,

    ImGuiHoveredFlags_AllowWhenBlockedByActiveItem = 1 << 7,
    ImGuiHoveredFlags_AllowWhenOverlappedByItem = 1 << 8,
    ImGuiHoveredFlags_AllowWhenOverlappedByWindow = 1 << 9,
    ImGuiHoveredFlags_AllowWhenDisabled = 1 << 10,
    ImGuiHoveredFlags_NoNavOverride = 1 << 11,
    ImGuiHoveredFlags_AllowWhenOverlapped = ImGuiHoveredFlags_AllowWhenOverlappedByItem | ImGuiHoveredFlags_AllowWhenOverlappedByWindow,
    ImGuiHoveredFlags_RectOnly = ImGuiHoveredFlags_AllowWhenBlockedByPopup | ImGuiHoveredFlags_AllowWhenBlockedByActiveItem | ImGuiHoveredFlags_AllowWhenOverlapped,
    ImGuiHoveredFlags_RootAndChildWindows = ImGuiHoveredFlags_RootWindow | ImGuiHoveredFlags_ChildWindows,







    ImGuiHoveredFlags_ForTooltip = 1 << 12,




    ImGuiHoveredFlags_Stationary = 1 << 13,
    ImGuiHoveredFlags_DelayNone = 1 << 14,
    ImGuiHoveredFlags_DelayShort = 1 << 15,
    ImGuiHoveredFlags_DelayNormal = 1 << 16,
    ImGuiHoveredFlags_NoSharedDelay = 1 << 17,
};


enum ImGuiDragDropFlags_
{
    ImGuiDragDropFlags_None = 0,

    ImGuiDragDropFlags_SourceNoPreviewTooltip = 1 << 0,
    ImGuiDragDropFlags_SourceNoDisableHover = 1 << 1,
    ImGuiDragDropFlags_SourceNoHoldToOpenOthers = 1 << 2,
    ImGuiDragDropFlags_SourceAllowNullID = 1 << 3,
    ImGuiDragDropFlags_SourceExtern = 1 << 4,
    ImGuiDragDropFlags_SourceAutoExpirePayload = 1 << 5,

    ImGuiDragDropFlags_AcceptBeforeDelivery = 1 << 10,
    ImGuiDragDropFlags_AcceptNoDrawDefaultRect = 1 << 11,
    ImGuiDragDropFlags_AcceptNoPreviewTooltip = 1 << 12,
    ImGuiDragDropFlags_AcceptPeekOnly = ImGuiDragDropFlags_AcceptBeforeDelivery | ImGuiDragDropFlags_AcceptNoDrawDefaultRect,
};






enum ImGuiDataType_
{
    ImGuiDataType_S8,
    ImGuiDataType_U8,
    ImGuiDataType_S16,
    ImGuiDataType_U16,
    ImGuiDataType_S32,
    ImGuiDataType_U32,
    ImGuiDataType_S64,
    ImGuiDataType_U64,
    ImGuiDataType_Float,
    ImGuiDataType_Double,
    ImGuiDataType_COUNT
};


enum ImGuiDir_
{
    ImGuiDir_None = -1,
    ImGuiDir_Left = 0,
    ImGuiDir_Right = 1,
    ImGuiDir_Up = 2,
    ImGuiDir_Down = 3,
    ImGuiDir_COUNT
};


enum ImGuiSortDirection_
{
    ImGuiSortDirection_None = 0,
    ImGuiSortDirection_Ascending = 1,
    ImGuiSortDirection_Descending = 2
};
# 1311 "include/imgui/imgui.h"
enum ImGuiKey : int
{

    ImGuiKey_None = 0,
    ImGuiKey_Tab = 512,
    ImGuiKey_LeftArrow,
    ImGuiKey_RightArrow,
    ImGuiKey_UpArrow,
    ImGuiKey_DownArrow,
    ImGuiKey_PageUp,
    ImGuiKey_PageDown,
    ImGuiKey_Home,
    ImGuiKey_End,
    ImGuiKey_Insert,
    ImGuiKey_Delete,
    ImGuiKey_Backspace,
    ImGuiKey_Space,
    ImGuiKey_Enter,
    ImGuiKey_Escape,
    ImGuiKey_LeftCtrl, ImGuiKey_LeftShift, ImGuiKey_LeftAlt, ImGuiKey_LeftSuper,
    ImGuiKey_RightCtrl, ImGuiKey_RightShift, ImGuiKey_RightAlt, ImGuiKey_RightSuper,
    ImGuiKey_Menu,
    ImGuiKey_0, ImGuiKey_1, ImGuiKey_2, ImGuiKey_3, ImGuiKey_4, ImGuiKey_5, ImGuiKey_6, ImGuiKey_7, ImGuiKey_8, ImGuiKey_9,
    ImGuiKey_A, ImGuiKey_B, ImGuiKey_C, ImGuiKey_D, ImGuiKey_E, ImGuiKey_F, ImGuiKey_G, ImGuiKey_H, ImGuiKey_I, ImGuiKey_J,
    ImGuiKey_K, ImGuiKey_L, ImGuiKey_M, ImGuiKey_N, ImGuiKey_O, ImGuiKey_P, ImGuiKey_Q, ImGuiKey_R, ImGuiKey_S, ImGuiKey_T,
    ImGuiKey_U, ImGuiKey_V, ImGuiKey_W, ImGuiKey_X, ImGuiKey_Y, ImGuiKey_Z,
    ImGuiKey_F1, ImGuiKey_F2, ImGuiKey_F3, ImGuiKey_F4, ImGuiKey_F5, ImGuiKey_F6,
    ImGuiKey_F7, ImGuiKey_F8, ImGuiKey_F9, ImGuiKey_F10, ImGuiKey_F11, ImGuiKey_F12,
    ImGuiKey_F13, ImGuiKey_F14, ImGuiKey_F15, ImGuiKey_F16, ImGuiKey_F17, ImGuiKey_F18,
    ImGuiKey_F19, ImGuiKey_F20, ImGuiKey_F21, ImGuiKey_F22, ImGuiKey_F23, ImGuiKey_F24,
    ImGuiKey_Apostrophe,
    ImGuiKey_Comma,
    ImGuiKey_Minus,
    ImGuiKey_Period,
    ImGuiKey_Slash,
    ImGuiKey_Semicolon,
    ImGuiKey_Equal,
    ImGuiKey_LeftBracket,
    ImGuiKey_Backslash,
    ImGuiKey_RightBracket,
    ImGuiKey_GraveAccent,
    ImGuiKey_CapsLock,
    ImGuiKey_ScrollLock,
    ImGuiKey_NumLock,
    ImGuiKey_PrintScreen,
    ImGuiKey_Pause,
    ImGuiKey_Keypad0, ImGuiKey_Keypad1, ImGuiKey_Keypad2, ImGuiKey_Keypad3, ImGuiKey_Keypad4,
    ImGuiKey_Keypad5, ImGuiKey_Keypad6, ImGuiKey_Keypad7, ImGuiKey_Keypad8, ImGuiKey_Keypad9,
    ImGuiKey_KeypadDecimal,
    ImGuiKey_KeypadDivide,
    ImGuiKey_KeypadMultiply,
    ImGuiKey_KeypadSubtract,
    ImGuiKey_KeypadAdd,
    ImGuiKey_KeypadEnter,
    ImGuiKey_KeypadEqual,
    ImGuiKey_AppBack,
    ImGuiKey_AppForward,



    ImGuiKey_GamepadStart,
    ImGuiKey_GamepadBack,
    ImGuiKey_GamepadFaceLeft,
    ImGuiKey_GamepadFaceRight,
    ImGuiKey_GamepadFaceUp,
    ImGuiKey_GamepadFaceDown,
    ImGuiKey_GamepadDpadLeft,
    ImGuiKey_GamepadDpadRight,
    ImGuiKey_GamepadDpadUp,
    ImGuiKey_GamepadDpadDown,
    ImGuiKey_GamepadL1,
    ImGuiKey_GamepadR1,
    ImGuiKey_GamepadL2,
    ImGuiKey_GamepadR2,
    ImGuiKey_GamepadL3,
    ImGuiKey_GamepadR3,
    ImGuiKey_GamepadLStickLeft,
    ImGuiKey_GamepadLStickRight,
    ImGuiKey_GamepadLStickUp,
    ImGuiKey_GamepadLStickDown,
    ImGuiKey_GamepadRStickLeft,
    ImGuiKey_GamepadRStickRight,
    ImGuiKey_GamepadRStickUp,
    ImGuiKey_GamepadRStickDown,



    ImGuiKey_MouseLeft, ImGuiKey_MouseRight, ImGuiKey_MouseMiddle, ImGuiKey_MouseX1, ImGuiKey_MouseX2, ImGuiKey_MouseWheelX, ImGuiKey_MouseWheelY,


    ImGuiKey_ReservedForModCtrl, ImGuiKey_ReservedForModShift, ImGuiKey_ReservedForModAlt, ImGuiKey_ReservedForModSuper,
    ImGuiKey_COUNT,
# 1412 "include/imgui/imgui.h"
    ImGuiMod_None = 0,
    ImGuiMod_Ctrl = 1 << 12,
    ImGuiMod_Shift = 1 << 13,
    ImGuiMod_Alt = 1 << 14,
    ImGuiMod_Super = 1 << 15,
    ImGuiMod_Shortcut = 1 << 11,
    ImGuiMod_Mask_ = 0xF800,




    ImGuiKey_NamedKey_BEGIN = 512,
    ImGuiKey_NamedKey_END = ImGuiKey_COUNT,
    ImGuiKey_NamedKey_COUNT = ImGuiKey_NamedKey_END - ImGuiKey_NamedKey_BEGIN,




    ImGuiKey_KeysData_SIZE = ImGuiKey_COUNT,
    ImGuiKey_KeysData_OFFSET = 0,



    ImGuiKey_ModCtrl = ImGuiMod_Ctrl, ImGuiKey_ModShift = ImGuiMod_Shift, ImGuiKey_ModAlt = ImGuiMod_Alt, ImGuiKey_ModSuper = ImGuiMod_Super,


};





enum ImGuiNavInput
{
    ImGuiNavInput_Activate, ImGuiNavInput_Cancel, ImGuiNavInput_Input, ImGuiNavInput_Menu, ImGuiNavInput_DpadLeft, ImGuiNavInput_DpadRight, ImGuiNavInput_DpadUp, ImGuiNavInput_DpadDown,
    ImGuiNavInput_LStickLeft, ImGuiNavInput_LStickRight, ImGuiNavInput_LStickUp, ImGuiNavInput_LStickDown, ImGuiNavInput_FocusPrev, ImGuiNavInput_FocusNext, ImGuiNavInput_TweakSlow, ImGuiNavInput_TweakFast,
    ImGuiNavInput_COUNT,
};



enum ImGuiConfigFlags_
{
    ImGuiConfigFlags_None = 0,
    ImGuiConfigFlags_NavEnableKeyboard = 1 << 0,
    ImGuiConfigFlags_NavEnableGamepad = 1 << 1,
    ImGuiConfigFlags_NavEnableSetMousePos = 1 << 2,
    ImGuiConfigFlags_NavNoCaptureKeyboard = 1 << 3,
    ImGuiConfigFlags_NoMouse = 1 << 4,
    ImGuiConfigFlags_NoMouseCursorChange = 1 << 5,


    ImGuiConfigFlags_IsSRGB = 1 << 20,
    ImGuiConfigFlags_IsTouchScreen = 1 << 21,
};


enum ImGuiBackendFlags_
{
    ImGuiBackendFlags_None = 0,
    ImGuiBackendFlags_HasGamepad = 1 << 0,
    ImGuiBackendFlags_HasMouseCursors = 1 << 1,
    ImGuiBackendFlags_HasSetMousePos = 1 << 2,
    ImGuiBackendFlags_RendererHasVtxOffset = 1 << 3,
};


enum ImGuiCol_
{
    ImGuiCol_Text,
    ImGuiCol_TextDisabled,
    ImGuiCol_WindowBg,
    ImGuiCol_ChildBg,
    ImGuiCol_PopupBg,
    ImGuiCol_Border,
    ImGuiCol_BorderShadow,
    ImGuiCol_FrameBg,
    ImGuiCol_FrameBgHovered,
    ImGuiCol_FrameBgActive,
    ImGuiCol_TitleBg,
    ImGuiCol_TitleBgActive,
    ImGuiCol_TitleBgCollapsed,
    ImGuiCol_MenuBarBg,
    ImGuiCol_ScrollbarBg,
    ImGuiCol_ScrollbarGrab,
    ImGuiCol_ScrollbarGrabHovered,
    ImGuiCol_ScrollbarGrabActive,
    ImGuiCol_CheckMark,
    ImGuiCol_SliderGrab,
    ImGuiCol_SliderGrabActive,
    ImGuiCol_Button,
    ImGuiCol_ButtonHovered,
    ImGuiCol_ButtonActive,
    ImGuiCol_Header,
    ImGuiCol_HeaderHovered,
    ImGuiCol_HeaderActive,
    ImGuiCol_Separator,
    ImGuiCol_SeparatorHovered,
    ImGuiCol_SeparatorActive,
    ImGuiCol_ResizeGrip,
    ImGuiCol_ResizeGripHovered,
    ImGuiCol_ResizeGripActive,
    ImGuiCol_Tab,
    ImGuiCol_TabHovered,
    ImGuiCol_TabActive,
    ImGuiCol_TabUnfocused,
    ImGuiCol_TabUnfocusedActive,
    ImGuiCol_PlotLines,
    ImGuiCol_PlotLinesHovered,
    ImGuiCol_PlotHistogram,
    ImGuiCol_PlotHistogramHovered,
    ImGuiCol_TableHeaderBg,
    ImGuiCol_TableBorderStrong,
    ImGuiCol_TableBorderLight,
    ImGuiCol_TableRowBg,
    ImGuiCol_TableRowBgAlt,
    ImGuiCol_TextSelectedBg,
    ImGuiCol_DragDropTarget,
    ImGuiCol_NavHighlight,
    ImGuiCol_NavWindowingHighlight,
    ImGuiCol_NavWindowingDimBg,
    ImGuiCol_ModalWindowDimBg,
    ImGuiCol_COUNT
};
# 1544 "include/imgui/imgui.h"
enum ImGuiStyleVar_
{

    ImGuiStyleVar_Alpha,
    ImGuiStyleVar_DisabledAlpha,
    ImGuiStyleVar_WindowPadding,
    ImGuiStyleVar_WindowRounding,
    ImGuiStyleVar_WindowBorderSize,
    ImGuiStyleVar_WindowMinSize,
    ImGuiStyleVar_WindowTitleAlign,
    ImGuiStyleVar_ChildRounding,
    ImGuiStyleVar_ChildBorderSize,
    ImGuiStyleVar_PopupRounding,
    ImGuiStyleVar_PopupBorderSize,
    ImGuiStyleVar_FramePadding,
    ImGuiStyleVar_FrameRounding,
    ImGuiStyleVar_FrameBorderSize,
    ImGuiStyleVar_ItemSpacing,
    ImGuiStyleVar_ItemInnerSpacing,
    ImGuiStyleVar_IndentSpacing,
    ImGuiStyleVar_CellPadding,
    ImGuiStyleVar_ScrollbarSize,
    ImGuiStyleVar_ScrollbarRounding,
    ImGuiStyleVar_GrabMinSize,
    ImGuiStyleVar_GrabRounding,
    ImGuiStyleVar_TabRounding,
    ImGuiStyleVar_TabBarBorderSize,
    ImGuiStyleVar_ButtonTextAlign,
    ImGuiStyleVar_SelectableTextAlign,
    ImGuiStyleVar_SeparatorTextBorderSize,
    ImGuiStyleVar_SeparatorTextAlign,
    ImGuiStyleVar_SeparatorTextPadding,
    ImGuiStyleVar_COUNT
};


enum ImGuiButtonFlags_
{
    ImGuiButtonFlags_None = 0,
    ImGuiButtonFlags_MouseButtonLeft = 1 << 0,
    ImGuiButtonFlags_MouseButtonRight = 1 << 1,
    ImGuiButtonFlags_MouseButtonMiddle = 1 << 2,


    ImGuiButtonFlags_MouseButtonMask_ = ImGuiButtonFlags_MouseButtonLeft | ImGuiButtonFlags_MouseButtonRight | ImGuiButtonFlags_MouseButtonMiddle,
    ImGuiButtonFlags_MouseButtonDefault_ = ImGuiButtonFlags_MouseButtonLeft,
};


enum ImGuiColorEditFlags_
{
    ImGuiColorEditFlags_None = 0,
    ImGuiColorEditFlags_NoAlpha = 1 << 1,
    ImGuiColorEditFlags_NoPicker = 1 << 2,
    ImGuiColorEditFlags_NoOptions = 1 << 3,
    ImGuiColorEditFlags_NoSmallPreview = 1 << 4,
    ImGuiColorEditFlags_NoInputs = 1 << 5,
    ImGuiColorEditFlags_NoTooltip = 1 << 6,
    ImGuiColorEditFlags_NoLabel = 1 << 7,
    ImGuiColorEditFlags_NoSidePreview = 1 << 8,
    ImGuiColorEditFlags_NoDragDrop = 1 << 9,
    ImGuiColorEditFlags_NoBorder = 1 << 10,


    ImGuiColorEditFlags_AlphaBar = 1 << 16,
    ImGuiColorEditFlags_AlphaPreview = 1 << 17,
    ImGuiColorEditFlags_AlphaPreviewHalf= 1 << 18,
    ImGuiColorEditFlags_HDR = 1 << 19,
    ImGuiColorEditFlags_DisplayRGB = 1 << 20,
    ImGuiColorEditFlags_DisplayHSV = 1 << 21,
    ImGuiColorEditFlags_DisplayHex = 1 << 22,
    ImGuiColorEditFlags_Uint8 = 1 << 23,
    ImGuiColorEditFlags_Float = 1 << 24,
    ImGuiColorEditFlags_PickerHueBar = 1 << 25,
    ImGuiColorEditFlags_PickerHueWheel = 1 << 26,
    ImGuiColorEditFlags_InputRGB = 1 << 27,
    ImGuiColorEditFlags_InputHSV = 1 << 28,



    ImGuiColorEditFlags_DefaultOptions_ = ImGuiColorEditFlags_Uint8 | ImGuiColorEditFlags_DisplayRGB | ImGuiColorEditFlags_InputRGB | ImGuiColorEditFlags_PickerHueBar,


    ImGuiColorEditFlags_DisplayMask_ = ImGuiColorEditFlags_DisplayRGB | ImGuiColorEditFlags_DisplayHSV | ImGuiColorEditFlags_DisplayHex,
    ImGuiColorEditFlags_DataTypeMask_ = ImGuiColorEditFlags_Uint8 | ImGuiColorEditFlags_Float,
    ImGuiColorEditFlags_PickerMask_ = ImGuiColorEditFlags_PickerHueWheel | ImGuiColorEditFlags_PickerHueBar,
    ImGuiColorEditFlags_InputMask_ = ImGuiColorEditFlags_InputRGB | ImGuiColorEditFlags_InputHSV,



};




enum ImGuiSliderFlags_
{
    ImGuiSliderFlags_None = 0,
    ImGuiSliderFlags_AlwaysClamp = 1 << 4,
    ImGuiSliderFlags_Logarithmic = 1 << 5,
    ImGuiSliderFlags_NoRoundToFormat = 1 << 6,
    ImGuiSliderFlags_NoInput = 1 << 7,
    ImGuiSliderFlags_InvalidMask_ = 0x7000000F,



};



enum ImGuiMouseButton_
{
    ImGuiMouseButton_Left = 0,
    ImGuiMouseButton_Right = 1,
    ImGuiMouseButton_Middle = 2,
    ImGuiMouseButton_COUNT = 5
};



enum ImGuiMouseCursor_
{
    ImGuiMouseCursor_None = -1,
    ImGuiMouseCursor_Arrow = 0,
    ImGuiMouseCursor_TextInput,
    ImGuiMouseCursor_ResizeAll,
    ImGuiMouseCursor_ResizeNS,
    ImGuiMouseCursor_ResizeEW,
    ImGuiMouseCursor_ResizeNESW,
    ImGuiMouseCursor_ResizeNWSE,
    ImGuiMouseCursor_Hand,
    ImGuiMouseCursor_NotAllowed,
    ImGuiMouseCursor_COUNT
};





enum ImGuiMouseSource : int
{
    ImGuiMouseSource_Mouse = 0,
    ImGuiMouseSource_TouchScreen,
    ImGuiMouseSource_Pen,
    ImGuiMouseSource_COUNT
};




enum ImGuiCond_
{
    ImGuiCond_None = 0,
    ImGuiCond_Always = 1 << 0,
    ImGuiCond_Once = 1 << 1,
    ImGuiCond_FirstUseEver = 1 << 2,
    ImGuiCond_Appearing = 1 << 3,
};
# 1729 "include/imgui/imgui.h"
enum ImGuiTableFlags_
{

    ImGuiTableFlags_None = 0,
    ImGuiTableFlags_Resizable = 1 << 0,
    ImGuiTableFlags_Reorderable = 1 << 1,
    ImGuiTableFlags_Hideable = 1 << 2,
    ImGuiTableFlags_Sortable = 1 << 3,
    ImGuiTableFlags_NoSavedSettings = 1 << 4,
    ImGuiTableFlags_ContextMenuInBody = 1 << 5,

    ImGuiTableFlags_RowBg = 1 << 6,
    ImGuiTableFlags_BordersInnerH = 1 << 7,
    ImGuiTableFlags_BordersOuterH = 1 << 8,
    ImGuiTableFlags_BordersInnerV = 1 << 9,
    ImGuiTableFlags_BordersOuterV = 1 << 10,
    ImGuiTableFlags_BordersH = ImGuiTableFlags_BordersInnerH | ImGuiTableFlags_BordersOuterH,
    ImGuiTableFlags_BordersV = ImGuiTableFlags_BordersInnerV | ImGuiTableFlags_BordersOuterV,
    ImGuiTableFlags_BordersInner = ImGuiTableFlags_BordersInnerV | ImGuiTableFlags_BordersInnerH,
    ImGuiTableFlags_BordersOuter = ImGuiTableFlags_BordersOuterV | ImGuiTableFlags_BordersOuterH,
    ImGuiTableFlags_Borders = ImGuiTableFlags_BordersInner | ImGuiTableFlags_BordersOuter,
    ImGuiTableFlags_NoBordersInBody = 1 << 11,
    ImGuiTableFlags_NoBordersInBodyUntilResize = 1 << 12,

    ImGuiTableFlags_SizingFixedFit = 1 << 13,
    ImGuiTableFlags_SizingFixedSame = 2 << 13,
    ImGuiTableFlags_SizingStretchProp = 3 << 13,
    ImGuiTableFlags_SizingStretchSame = 4 << 13,

    ImGuiTableFlags_NoHostExtendX = 1 << 16,
    ImGuiTableFlags_NoHostExtendY = 1 << 17,
    ImGuiTableFlags_NoKeepColumnsVisible = 1 << 18,
    ImGuiTableFlags_PreciseWidths = 1 << 19,

    ImGuiTableFlags_NoClip = 1 << 20,

    ImGuiTableFlags_PadOuterX = 1 << 21,
    ImGuiTableFlags_NoPadOuterX = 1 << 22,
    ImGuiTableFlags_NoPadInnerX = 1 << 23,

    ImGuiTableFlags_ScrollX = 1 << 24,
    ImGuiTableFlags_ScrollY = 1 << 25,

    ImGuiTableFlags_SortMulti = 1 << 26,
    ImGuiTableFlags_SortTristate = 1 << 27,

    ImGuiTableFlags_HighlightHoveredColumn = 1 << 28,


    ImGuiTableFlags_SizingMask_ = ImGuiTableFlags_SizingFixedFit | ImGuiTableFlags_SizingFixedSame | ImGuiTableFlags_SizingStretchProp | ImGuiTableFlags_SizingStretchSame,
};


enum ImGuiTableColumnFlags_
{

    ImGuiTableColumnFlags_None = 0,
    ImGuiTableColumnFlags_Disabled = 1 << 0,
    ImGuiTableColumnFlags_DefaultHide = 1 << 1,
    ImGuiTableColumnFlags_DefaultSort = 1 << 2,
    ImGuiTableColumnFlags_WidthStretch = 1 << 3,
    ImGuiTableColumnFlags_WidthFixed = 1 << 4,
    ImGuiTableColumnFlags_NoResize = 1 << 5,
    ImGuiTableColumnFlags_NoReorder = 1 << 6,
    ImGuiTableColumnFlags_NoHide = 1 << 7,
    ImGuiTableColumnFlags_NoClip = 1 << 8,
    ImGuiTableColumnFlags_NoSort = 1 << 9,
    ImGuiTableColumnFlags_NoSortAscending = 1 << 10,
    ImGuiTableColumnFlags_NoSortDescending = 1 << 11,
    ImGuiTableColumnFlags_NoHeaderLabel = 1 << 12,
    ImGuiTableColumnFlags_NoHeaderWidth = 1 << 13,
    ImGuiTableColumnFlags_PreferSortAscending = 1 << 14,
    ImGuiTableColumnFlags_PreferSortDescending = 1 << 15,
    ImGuiTableColumnFlags_IndentEnable = 1 << 16,
    ImGuiTableColumnFlags_IndentDisable = 1 << 17,
    ImGuiTableColumnFlags_AngledHeader = 1 << 18,


    ImGuiTableColumnFlags_IsEnabled = 1 << 24,
    ImGuiTableColumnFlags_IsVisible = 1 << 25,
    ImGuiTableColumnFlags_IsSorted = 1 << 26,
    ImGuiTableColumnFlags_IsHovered = 1 << 27,


    ImGuiTableColumnFlags_WidthMask_ = ImGuiTableColumnFlags_WidthStretch | ImGuiTableColumnFlags_WidthFixed,
    ImGuiTableColumnFlags_IndentMask_ = ImGuiTableColumnFlags_IndentEnable | ImGuiTableColumnFlags_IndentDisable,
    ImGuiTableColumnFlags_StatusMask_ = ImGuiTableColumnFlags_IsEnabled | ImGuiTableColumnFlags_IsVisible | ImGuiTableColumnFlags_IsSorted | ImGuiTableColumnFlags_IsHovered,
    ImGuiTableColumnFlags_NoDirectResize_ = 1 << 30,
};


enum ImGuiTableRowFlags_
{
    ImGuiTableRowFlags_None = 0,
    ImGuiTableRowFlags_Headers = 1 << 0,
};
# 1835 "include/imgui/imgui.h"
enum ImGuiTableBgTarget_
{
    ImGuiTableBgTarget_None = 0,
    ImGuiTableBgTarget_RowBg0 = 1,
    ImGuiTableBgTarget_RowBg1 = 2,
    ImGuiTableBgTarget_CellBg = 3,
};





struct ImGuiTableSortSpecs
{
    const ImGuiTableColumnSortSpecs* Specs;
    int SpecsCount;
    bool SpecsDirty;

    ImGuiTableSortSpecs() { memset(this, 0, sizeof(*this)); }
};


struct ImGuiTableColumnSortSpecs
{
    ImGuiID ColumnUserID;
    ImS16 ColumnIndex;
    ImS16 SortOrder;
    ImGuiSortDirection SortDirection : 8;

    ImGuiTableColumnSortSpecs() { memset(this, 0, sizeof(*this)); }
};
# 1877 "include/imgui/imgui.h"
struct ImNewWrapper {};
inline void* operator new(size_t, ImNewWrapper, void* ptr) { return ptr; }
inline void operator delete(void*, ImNewWrapper, void*) {}




template<typename T> void IM_DELETE(T* p) { if (p) { p->~T(); ImGui::MemFree(p); } }
# 1897 "include/imgui/imgui.h"

template<typename T>
struct ImVector
{
    int Size;
    int Capacity;
    T* Data;


    typedef T value_type;
    typedef value_type* iterator;
    typedef const value_type* const_iterator;


    inline ImVector() { Size = Capacity = 0; Data = 
# 1911 "include/imgui/imgui.h" 3 4
                                                                                         __null
# 1911 "include/imgui/imgui.h"
                                                                                             ; }
    inline ImVector(const ImVector<T>& src) { Size = Capacity = 0; Data = 
# 1912 "include/imgui/imgui.h" 3 4
                                                                                         __null
# 1912 "include/imgui/imgui.h"
                                                                                             ; operator=(src); }
    inline ImVector<T>& operator=(const ImVector<T>& src) { clear(); resize(src.Size); if (src.Data) memcpy(Data, src.Data, (size_t)Size * sizeof(T)); return *this; }
    inline ~ImVector() { if (Data) ImGui::MemFree(Data); }

    inline void clear() { if (Data) { Size = Capacity = 0; ImGui::MemFree(Data); Data = 
# 1916 "include/imgui/imgui.h" 3 4
                                                                                                                    __null
# 1916 "include/imgui/imgui.h"
                                                                                                                        ; } }
    inline void clear_delete() { for (int n = 0; n < Size; n++) IM_DELETE(Data[n]); clear(); }
    inline void clear_destruct() { for (int n = 0; n < Size; n++) Data[n].~T(); clear(); }

    inline bool empty() const { return Size == 0; }
    inline int size() const { return Size; }
    inline int size_in_bytes() const { return Size * (int)sizeof(T); }
    inline int max_size() const { return 0x7FFFFFFF / (int)sizeof(T); }
    inline int capacity() const { return Capacity; }
    inline T& operator[](int i) { 
# 1925 "include/imgui/imgui.h" 3 4
                                                             (static_cast <bool> (
# 1925 "include/imgui/imgui.h"
                                                             i >= 0 && i < Size
# 1925 "include/imgui/imgui.h" 3 4
                                                             ) ? void (0) : __assert_fail (
# 1925 "include/imgui/imgui.h"
                                                             "i >= 0 && i < Size"
# 1925 "include/imgui/imgui.h" 3 4
                                                             , "include/imgui/imgui.h", 1925, __extension__ __PRETTY_FUNCTION__))
# 1925 "include/imgui/imgui.h"
                                                                                          ; return Data[i]; }
    inline const T& operator[](int i) const { 
# 1926 "include/imgui/imgui.h" 3 4
                                                             (static_cast <bool> (
# 1926 "include/imgui/imgui.h"
                                                             i >= 0 && i < Size
# 1926 "include/imgui/imgui.h" 3 4
                                                             ) ? void (0) : __assert_fail (
# 1926 "include/imgui/imgui.h"
                                                             "i >= 0 && i < Size"
# 1926 "include/imgui/imgui.h" 3 4
                                                             , "include/imgui/imgui.h", 1926, __extension__ __PRETTY_FUNCTION__))
# 1926 "include/imgui/imgui.h"
                                                                                          ; return Data[i]; }

    inline T* begin() { return Data; }
    inline const T* begin() const { return Data; }
    inline T* end() { return Data + Size; }
    inline const T* end() const { return Data + Size; }
    inline T& front() { 
# 1932 "include/imgui/imgui.h" 3 4
                                                             (static_cast <bool> (
# 1932 "include/imgui/imgui.h"
                                                             Size > 0
# 1932 "include/imgui/imgui.h" 3 4
                                                             ) ? void (0) : __assert_fail (
# 1932 "include/imgui/imgui.h"
                                                             "Size > 0"
# 1932 "include/imgui/imgui.h" 3 4
                                                             , "include/imgui/imgui.h", 1932, __extension__ __PRETTY_FUNCTION__))
# 1932 "include/imgui/imgui.h"
                                                                                ; return Data[0]; }
    inline const T& front() const { 
# 1933 "include/imgui/imgui.h" 3 4
                                                             (static_cast <bool> (
# 1933 "include/imgui/imgui.h"
                                                             Size > 0
# 1933 "include/imgui/imgui.h" 3 4
                                                             ) ? void (0) : __assert_fail (
# 1933 "include/imgui/imgui.h"
                                                             "Size > 0"
# 1933 "include/imgui/imgui.h" 3 4
                                                             , "include/imgui/imgui.h", 1933, __extension__ __PRETTY_FUNCTION__))
# 1933 "include/imgui/imgui.h"
                                                                                ; return Data[0]; }
    inline T& back() { 
# 1934 "include/imgui/imgui.h" 3 4
                                                             (static_cast <bool> (
# 1934 "include/imgui/imgui.h"
                                                             Size > 0
# 1934 "include/imgui/imgui.h" 3 4
                                                             ) ? void (0) : __assert_fail (
# 1934 "include/imgui/imgui.h"
                                                             "Size > 0"
# 1934 "include/imgui/imgui.h" 3 4
                                                             , "include/imgui/imgui.h", 1934, __extension__ __PRETTY_FUNCTION__))
# 1934 "include/imgui/imgui.h"
                                                                                ; return Data[Size - 1]; }
    inline const T& back() const { 
# 1935 "include/imgui/imgui.h" 3 4
                                                             (static_cast <bool> (
# 1935 "include/imgui/imgui.h"
                                                             Size > 0
# 1935 "include/imgui/imgui.h" 3 4
                                                             ) ? void (0) : __assert_fail (
# 1935 "include/imgui/imgui.h"
                                                             "Size > 0"
# 1935 "include/imgui/imgui.h" 3 4
                                                             , "include/imgui/imgui.h", 1935, __extension__ __PRETTY_FUNCTION__))
# 1935 "include/imgui/imgui.h"
                                                                                ; return Data[Size - 1]; }
    inline void swap(ImVector<T>& rhs) { int rhs_size = rhs.Size; rhs.Size = Size; Size = rhs_size; int rhs_cap = rhs.Capacity; rhs.Capacity = Capacity; Capacity = rhs_cap; T* rhs_data = rhs.Data; rhs.Data = Data; Data = rhs_data; }

    inline int _grow_capacity(int sz) const { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }
    inline void resize(int new_size) { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }
    inline void resize(int new_size, const T& v) { if (new_size > Capacity) reserve(_grow_capacity(new_size)); if (new_size > Size) for (int n = Size; n < new_size; n++) memcpy(&Data[n], &v, sizeof(v)); Size = new_size; }
    inline void shrink(int new_size) { 
# 1941 "include/imgui/imgui.h" 3 4
                                                             (static_cast <bool> (
# 1941 "include/imgui/imgui.h"
                                                             new_size <= Size
# 1941 "include/imgui/imgui.h" 3 4
                                                             ) ? void (0) : __assert_fail (
# 1941 "include/imgui/imgui.h"
                                                             "new_size <= Size"
# 1941 "include/imgui/imgui.h" 3 4
                                                             , "include/imgui/imgui.h", 1941, __extension__ __PRETTY_FUNCTION__))
# 1941 "include/imgui/imgui.h"
                                                                                        ; Size = new_size; }
    inline void reserve(int new_capacity) { if (new_capacity <= Capacity) return; T* new_data = (T*)ImGui::MemAlloc((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); ImGui::MemFree(Data); } Data = new_data; Capacity = new_capacity; }
    inline void reserve_discard(int new_capacity) { if (new_capacity <= Capacity) return; if (Data) ImGui::MemFree(Data); Data = (T*)ImGui::MemAlloc((size_t)new_capacity * sizeof(T)); Capacity = new_capacity; }


    inline void push_back(const T& v) { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }
    inline void pop_back() { 
# 1947 "include/imgui/imgui.h" 3 4
                                                             (static_cast <bool> (
# 1947 "include/imgui/imgui.h"
                                                             Size > 0
# 1947 "include/imgui/imgui.h" 3 4
                                                             ) ? void (0) : __assert_fail (
# 1947 "include/imgui/imgui.h"
                                                             "Size > 0"
# 1947 "include/imgui/imgui.h" 3 4
                                                             , "include/imgui/imgui.h", 1947, __extension__ __PRETTY_FUNCTION__))
# 1947 "include/imgui/imgui.h"
                                                                                ; Size--; }
    inline void push_front(const T& v) { if (Size == 0) push_back(v); else insert(Data, v); }
    inline T* erase(const T* it) { 
# 1949 "include/imgui/imgui.h" 3 4
                                                             (static_cast <bool> (
# 1949 "include/imgui/imgui.h"
                                                             it >= Data && it < Data + Size
# 1949 "include/imgui/imgui.h" 3 4
                                                             ) ? void (0) : __assert_fail (
# 1949 "include/imgui/imgui.h"
                                                             "it >= Data && it < Data + Size"
# 1949 "include/imgui/imgui.h" 3 4
                                                             , "include/imgui/imgui.h", 1949, __extension__ __PRETTY_FUNCTION__))
# 1949 "include/imgui/imgui.h"
                                                                                                      ; const ptrdiff_t off = it - Data; memmove(Data + off, Data + off + 1, ((size_t)Size - (size_t)off - 1) * sizeof(T)); Size--; return Data + off; }
    inline T* erase(const T* it, const T* it_last){ 
# 1950 "include/imgui/imgui.h" 3 4
                                                             (static_cast <bool> (
# 1950 "include/imgui/imgui.h"
                                                             it >= Data && it < Data + Size && it_last >= it && it_last <= Data + Size
# 1950 "include/imgui/imgui.h" 3 4
                                                             ) ? void (0) : __assert_fail (
# 1950 "include/imgui/imgui.h"
                                                             "it >= Data && it < Data + Size && it_last >= it && it_last <= Data + Size"
# 1950 "include/imgui/imgui.h" 3 4
                                                             , "include/imgui/imgui.h", 1950, __extension__ __PRETTY_FUNCTION__))
# 1950 "include/imgui/imgui.h"
                                                                                                                                                 ; const ptrdiff_t count = it_last - it; const ptrdiff_t off = it - Data; memmove(Data + off, Data + off + count, ((size_t)Size - (size_t)off - (size_t)count) * sizeof(T)); Size -= (int)count; return Data + off; }
    inline T* erase_unsorted(const T* it) { 
# 1951 "include/imgui/imgui.h" 3 4
                                                             (static_cast <bool> (
# 1951 "include/imgui/imgui.h"
                                                             it >= Data && it < Data + Size
# 1951 "include/imgui/imgui.h" 3 4
                                                             ) ? void (0) : __assert_fail (
# 1951 "include/imgui/imgui.h"
                                                             "it >= Data && it < Data + Size"
# 1951 "include/imgui/imgui.h" 3 4
                                                             , "include/imgui/imgui.h", 1951, __extension__ __PRETTY_FUNCTION__))
# 1951 "include/imgui/imgui.h"
                                                                                                      ; const ptrdiff_t off = it - Data; if (it < Data + Size - 1) memcpy(Data + off, Data + Size - 1, sizeof(T)); Size--; return Data + off; }
    inline T* insert(const T* it, const T& v) { 
# 1952 "include/imgui/imgui.h" 3 4
                                                             (static_cast <bool> (
# 1952 "include/imgui/imgui.h"
                                                             it >= Data && it <= Data + Size
# 1952 "include/imgui/imgui.h" 3 4
                                                             ) ? void (0) : __assert_fail (
# 1952 "include/imgui/imgui.h"
                                                             "it >= Data && it <= Data + Size"
# 1952 "include/imgui/imgui.h" 3 4
                                                             , "include/imgui/imgui.h", 1952, __extension__ __PRETTY_FUNCTION__))
# 1952 "include/imgui/imgui.h"
                                                                                                       ; const ptrdiff_t off = it - Data; if (Size == Capacity) reserve(_grow_capacity(Size + 1)); if (off < (int)Size) memmove(Data + off + 1, Data + off, ((size_t)Size - (size_t)off) * sizeof(T)); memcpy(&Data[off], &v, sizeof(v)); Size++; return Data + off; }
    inline bool contains(const T& v) const { const T* data = Data; const T* data_end = Data + Size; while (data < data_end) if (*data++ == v) return true; return false; }
    inline T* find(const T& v) { T* data = Data; const T* data_end = Data + Size; while (data < data_end) if (*data == v) break; else ++data; return data; }
    inline const T* find(const T& v) const { const T* data = Data; const T* data_end = Data + Size; while (data < data_end) if (*data == v) break; else ++data; return data; }
    inline int find_index(const T& v) const { const T* data_end = Data + Size; const T* it = find(v); if (it == data_end) return -1; const ptrdiff_t off = it - Data; return (int)off; }
    inline bool find_erase(const T& v) { const T* it = find(v); if (it < Data + Size) { erase(it); return true; } return false; }
    inline bool find_erase_unsorted(const T& v) { const T* it = find(v); if (it < Data + Size) { erase_unsorted(it); return true; } return false; }
    inline int index_from_ptr(const T* it) const { 
# 1959 "include/imgui/imgui.h" 3 4
                                                             (static_cast <bool> (
# 1959 "include/imgui/imgui.h"
                                                             it >= Data && it < Data + Size
# 1959 "include/imgui/imgui.h" 3 4
                                                             ) ? void (0) : __assert_fail (
# 1959 "include/imgui/imgui.h"
                                                             "it >= Data && it < Data + Size"
# 1959 "include/imgui/imgui.h" 3 4
                                                             , "include/imgui/imgui.h", 1959, __extension__ __PRETTY_FUNCTION__))
# 1959 "include/imgui/imgui.h"
                                                                                                      ; const ptrdiff_t off = it - Data; return (int)off; }
};

# 1971 "include/imgui/imgui.h"
struct ImGuiStyle
{
    float Alpha;
    float DisabledAlpha;
    ImVec2 WindowPadding;
    float WindowRounding;
    float WindowBorderSize;
    ImVec2 WindowMinSize;
    ImVec2 WindowTitleAlign;
    ImGuiDir WindowMenuButtonPosition;
    float ChildRounding;
    float ChildBorderSize;
    float PopupRounding;
    float PopupBorderSize;
    ImVec2 FramePadding;
    float FrameRounding;
    float FrameBorderSize;
    ImVec2 ItemSpacing;
    ImVec2 ItemInnerSpacing;
    ImVec2 CellPadding;
    ImVec2 TouchExtraPadding;
    float IndentSpacing;
    float ColumnsMinSpacing;
    float ScrollbarSize;
    float ScrollbarRounding;
    float GrabMinSize;
    float GrabRounding;
    float LogSliderDeadzone;
    float TabRounding;
    float TabBorderSize;
    float TabMinWidthForCloseButton;
    float TabBarBorderSize;
    float TableAngledHeadersAngle;
    ImGuiDir ColorButtonPosition;
    ImVec2 ButtonTextAlign;
    ImVec2 SelectableTextAlign;
    float SeparatorTextBorderSize;
    ImVec2 SeparatorTextAlign;
    ImVec2 SeparatorTextPadding;
    ImVec2 DisplayWindowPadding;
    ImVec2 DisplaySafeAreaPadding;
    float MouseCursorScale;
    bool AntiAliasedLines;
    bool AntiAliasedLinesUseTex;
    bool AntiAliasedFill;
    float CurveTessellationTol;
    float CircleTessellationMaxError;
    ImVec4 Colors[ImGuiCol_COUNT];



    float HoverStationaryDelay;
    float HoverDelayShort;
    float HoverDelayNormal;
    ImGuiHoveredFlags HoverFlagsForTooltipMouse;
    ImGuiHoveredFlags HoverFlagsForTooltipNav;

    ImGuiStyle();
    void ScaleAllSizes(float scale_factor);
};
# 2041 "include/imgui/imgui.h"
struct ImGuiKeyData
{
    bool Down;
    float DownDuration;
    float DownDurationPrev;
    float AnalogValue;
};

struct ImGuiIO
{




    ImGuiConfigFlags ConfigFlags;
    ImGuiBackendFlags BackendFlags;
    ImVec2 DisplaySize;
    float DeltaTime;
    float IniSavingRate;
    const char* IniFilename;
    const char* LogFilename;
    void* UserData;

    ImFontAtlas*Fonts;
    float FontGlobalScale;
    bool FontAllowUserScaling;
    ImFont* FontDefault;
    ImVec2 DisplayFramebufferScale;


    bool MouseDrawCursor;
    bool ConfigMacOSXBehaviors;
    bool ConfigInputTrickleEventQueue;
    bool ConfigInputTextCursorBlink;
    bool ConfigInputTextEnterKeepActive;
    bool ConfigDragClickToInputText;
    bool ConfigWindowsResizeFromEdges;
    bool ConfigWindowsMoveFromTitleBarOnly;
    float ConfigMemoryCompactTimer;



    float MouseDoubleClickTime;
    float MouseDoubleClickMaxDist;
    float MouseDragThreshold;
    float KeyRepeatDelay;
    float KeyRepeatRate;
# 2097 "include/imgui/imgui.h"
    bool ConfigDebugIsDebuggerPresent;





    bool ConfigDebugBeginReturnValueOnce;
    bool ConfigDebugBeginReturnValueLoop;




    bool ConfigDebugIgnoreFocusLoss;


    bool ConfigDebugIniSettings;







    const char* BackendPlatformName;
    const char* BackendRendererName;
    void* BackendPlatformUserData;
    void* BackendRendererUserData;
    void* BackendLanguageUserData;



    const char* (*GetClipboardTextFn)(void* user_data);
    void (*SetClipboardTextFn)(void* user_data, const char* text);
    void* ClipboardUserData;



    void (*SetPlatformImeDataFn)(ImGuiViewport* viewport, ImGuiPlatformImeData* data);


    ImWchar PlatformLocaleDecimalPoint;






    void AddKeyEvent(ImGuiKey key, bool down);
    void AddKeyAnalogEvent(ImGuiKey key, bool down, float v);
    void AddMousePosEvent(float x, float y);
    void AddMouseButtonEvent(int button, bool down);
    void AddMouseWheelEvent(float wheel_x, float wheel_y);
    void AddMouseSourceEvent(ImGuiMouseSource source);
    void AddFocusEvent(bool focused);
    void AddInputCharacter(unsigned int c);
    void AddInputCharacterUTF16(ImWchar16 c);
    void AddInputCharactersUTF8(const char* str);

    void SetKeyEventNativeData(ImGuiKey key, int native_keycode, int native_scancode, int native_legacy_index = -1);
    void SetAppAcceptingEvents(bool accepting_events);
    void ClearEventsQueue();
    void ClearInputKeys();

    void ClearInputCharacters();
# 2169 "include/imgui/imgui.h"
    bool WantCaptureMouse;
    bool WantCaptureKeyboard;
    bool WantTextInput;
    bool WantSetMousePos;
    bool WantSaveIniSettings;
    bool NavActive;
    bool NavVisible;
    float Framerate;
    int MetricsRenderVertices;
    int MetricsRenderIndices;
    int MetricsRenderWindows;
    int MetricsActiveWindows;
    ImVec2 MouseDelta;





    int KeyMap[ImGuiKey_COUNT];
    bool KeysDown[ImGuiKey_COUNT];
    float NavInputs[ImGuiNavInput_COUNT];







    ImGuiContext* Ctx;




    ImVec2 MousePos;
    bool MouseDown[5];
    float MouseWheel;
    float MouseWheelH;
    ImGuiMouseSource MouseSource;
    bool KeyCtrl;
    bool KeyShift;
    bool KeyAlt;
    bool KeySuper;


    ImGuiKeyChord KeyMods;
    ImGuiKeyData KeysData[ImGuiKey_KeysData_SIZE];
    bool WantCaptureMouseUnlessPopupClose;
    ImVec2 MousePosPrev;
    ImVec2 MouseClickedPos[5];
    double MouseClickedTime[5];
    bool MouseClicked[5];
    bool MouseDoubleClicked[5];
    ImU16 MouseClickedCount[5];
    ImU16 MouseClickedLastCount[5];
    bool MouseReleased[5];
    bool MouseDownOwned[5];
    bool MouseDownOwnedUnlessPopupClose[5];
    bool MouseWheelRequestAxisSwap;
    float MouseDownDuration[5];
    float MouseDownDurationPrev[5];
    float MouseDragMaxDistanceSqr[5];
    float PenPressure;
    bool AppFocusLost;
    bool AppAcceptingEvents;
    ImS8 BackendUsingLegacyKeyArrays;
    bool BackendUsingLegacyNavInputArray;
    ImWchar16 InputQueueSurrogate;
    ImVector<ImWchar> InputQueueCharacters;

    ImGuiIO();
};
# 2254 "include/imgui/imgui.h"
struct ImGuiInputTextCallbackData
{
    ImGuiContext* Ctx;
    ImGuiInputTextFlags EventFlag;
    ImGuiInputTextFlags Flags;
    void* UserData;




    ImWchar EventChar;
    ImGuiKey EventKey;
    char* Buf;
    int BufTextLen;
    int BufSize;
    bool BufDirty;
    int CursorPos;
    int SelectionStart;
    int SelectionEnd;



    ImGuiInputTextCallbackData();
    void DeleteChars(int pos, int bytes_count);
    void InsertChars(int pos, const char* text, const char* text_end = 
# 2278 "include/imgui/imgui.h" 3 4
                                                                                     __null
# 2278 "include/imgui/imgui.h"
                                                                                         );
    void SelectAll() { SelectionStart = 0; SelectionEnd = BufTextLen; }
    void ClearSelection() { SelectionStart = SelectionEnd = BufTextLen; }
    bool HasSelection() const { return SelectionStart != SelectionEnd; }
};



struct ImGuiSizeCallbackData
{
    void* UserData;
    ImVec2 Pos;
    ImVec2 CurrentSize;
    ImVec2 DesiredSize;
};


struct ImGuiPayload
{

    void* Data;
    int DataSize;


    ImGuiID SourceId;
    ImGuiID SourceParentId;
    int DataFrameCount;
    char DataType[32 + 1];
    bool Preview;
    bool Delivery;

    ImGuiPayload() { Clear(); }
    void Clear() { SourceId = SourceParentId = 0; Data = 
# 2310 "include/imgui/imgui.h" 3 4
                                                           __null
# 2310 "include/imgui/imgui.h"
                                                               ; DataSize = 0; memset(DataType, 0, sizeof(DataType)); DataFrameCount = -1; Preview = Delivery = false; }
    bool IsDataType(const char* type) const { return DataFrameCount != -1 && strcmp(type, DataType) == 0; }
    bool IsPreview() const { return Preview; }
    bool IsDelivery() const { return Delivery; }
};
# 2330 "include/imgui/imgui.h"
struct ImGuiOnceUponAFrame
{
    ImGuiOnceUponAFrame() { RefFrame = -1; }
    mutable int RefFrame;
    operator bool() const { int current_frame = ImGui::GetFrameCount(); if (RefFrame == current_frame) return false; RefFrame = current_frame; return true; }
};


struct ImGuiTextFilter
{
    ImGuiTextFilter(const char* default_filter = "");
    bool Draw(const char* label = "Filter (inc,-exc)", float width = 0.0f);
    bool PassFilter(const char* text, const char* text_end = 
# 2342 "include/imgui/imgui.h" 3 4
                                                                           __null
# 2342 "include/imgui/imgui.h"
                                                                               ) const;
    void Build();
    void Clear() { InputBuf[0] = 0; Build(); }
    bool IsActive() const { return !Filters.empty(); }


    struct ImGuiTextRange
    {
        const char* b;
        const char* e;

        ImGuiTextRange() { b = e = 
# 2353 "include/imgui/imgui.h" 3 4
                                                                 __null
# 2353 "include/imgui/imgui.h"
                                                                     ; }
        ImGuiTextRange(const char* _b, const char* _e) { b = _b; e = _e; }
        bool empty() const { return b == e; }
        void split(char separator, ImVector<ImGuiTextRange>* out) const;
    };
    char InputBuf[256];
    ImVector<ImGuiTextRange>Filters;
    int CountGrep;
};



struct ImGuiTextBuffer
{
    ImVector<char> Buf;
    static char EmptyString[1];

    ImGuiTextBuffer() { }
    inline char operator[](int i) const { 
# 2371 "include/imgui/imgui.h" 3 4
                                                 (static_cast <bool> (
# 2371 "include/imgui/imgui.h"
                                                 Buf.Data != 
# 2371 "include/imgui/imgui.h" 3 4
                                                 __null) ? void (0) : __assert_fail (
# 2371 "include/imgui/imgui.h"
                                                 "Buf.Data != __null"
# 2371 "include/imgui/imgui.h" 3 4
                                                 , "include/imgui/imgui.h", 2371, __extension__ __PRETTY_FUNCTION__))
# 2371 "include/imgui/imgui.h"
                                                                            ; return Buf.Data[i]; }
    const char* begin() const { return Buf.Data ? &Buf.front() : EmptyString; }
    const char* end() const { return Buf.Data ? &Buf.back() : EmptyString; }
    int size() const { return Buf.Size ? Buf.Size - 1 : 0; }
    bool empty() const { return Buf.Size <= 1; }
    void clear() { Buf.clear(); }
    void reserve(int capacity) { Buf.reserve(capacity); }
    const char* c_str() const { return Buf.Data ? Buf.Data : EmptyString; }
    void append(const char* str, const char* str_end = 
# 2379 "include/imgui/imgui.h" 3 4
                                                                     __null
# 2379 "include/imgui/imgui.h"
                                                                         );
    void appendf(const char* fmt, ...) __attribute__((format(printf, 2, 2 +1)));
    void appendfv(const char* fmt, va_list args) __attribute__((format(printf, 2, 0)));
};
# 2392 "include/imgui/imgui.h"
struct ImGuiStorage
{

    struct ImGuiStoragePair
    {
        ImGuiID key;
        union { int val_i; float val_f; void* val_p; };
        ImGuiStoragePair(ImGuiID _key, int _val) { key = _key; val_i = _val; }
        ImGuiStoragePair(ImGuiID _key, float _val) { key = _key; val_f = _val; }
        ImGuiStoragePair(ImGuiID _key, void* _val) { key = _key; val_p = _val; }
    };

    ImVector<ImGuiStoragePair> Data;




    void Clear() { Data.clear(); }
    int GetInt(ImGuiID key, int default_val = 0) const;
    void SetInt(ImGuiID key, int val);
    bool GetBool(ImGuiID key, bool default_val = false) const;
    void SetBool(ImGuiID key, bool val);
    float GetFloat(ImGuiID key, float default_val = 0.0f) const;
    void SetFloat(ImGuiID key, float val);
    void* GetVoidPtr(ImGuiID key) const;
    void SetVoidPtr(ImGuiID key, void* val);





    int* GetIntRef(ImGuiID key, int default_val = 0);
    bool* GetBoolRef(ImGuiID key, bool default_val = false);
    float* GetFloatRef(ImGuiID key, float default_val = 0.0f);
    void** GetVoidPtrRef(ImGuiID key, void* default_val = 
# 2426 "include/imgui/imgui.h" 3 4
                                                                      __null
# 2426 "include/imgui/imgui.h"
                                                                          );


    void BuildSortByKey();

    void SetAllInt(int val);
};
# 2454 "include/imgui/imgui.h"
struct ImGuiListClipper
{
    ImGuiContext* Ctx;
    int DisplayStart;
    int DisplayEnd;
    int ItemsCount;
    float ItemsHeight;
    float StartPosY;
    void* TempData;



    ImGuiListClipper();
    ~ImGuiListClipper();
    void Begin(int items_count, float items_height = -1.0f);
    void End();
    bool Step();



    inline void IncludeItemByIndex(int item_index) { IncludeItemsByIndex(item_index, item_index + 1); }
    void IncludeItemsByIndex(int item_begin, int item_end);


    inline void IncludeRangeByIndices(int item_begin, int item_end) { IncludeItemsByIndex(item_begin, item_end); }
    inline void ForceDisplayRangeByIndices(int item_begin, int item_end) { IncludeItemsByIndex(item_begin, item_end); }


};
# 2540 "include/imgui/imgui.h"
struct ImColor
{
    ImVec4 Value;

    constexpr ImColor() { }
    constexpr ImColor(float r, float g, float b, float a = 1.0f) : Value(r, g, b, a) { }
    constexpr ImColor(const ImVec4& col) : Value(col) {}
    constexpr ImColor(int r, int g, int b, int a = 255) : Value((float)r * (1.0f / 255.0f), (float)g * (1.0f / 255.0f), (float)b * (1.0f / 255.0f), (float)a* (1.0f / 255.0f)) {}
    constexpr ImColor(ImU32 rgba) : Value((float)((rgba >> 0) & 0xFF) * (1.0f / 255.0f), (float)((rgba >> 8) & 0xFF) * (1.0f / 255.0f), (float)((rgba >> 16) & 0xFF) * (1.0f / 255.0f), (float)((rgba >> 24) & 0xFF) * (1.0f / 255.0f)) {}
    inline operator ImU32() const { return ImGui::ColorConvertFloat4ToU32(Value); }
    inline operator ImVec4() const { return Value; }


    inline void SetHSV(float h, float s, float v, float a = 1.0f){ ImGui::ColorConvertHSVtoRGB(h, s, v, Value.x, Value.y, Value.z); Value.w = a; }
    static ImColor HSV(float h, float s, float v, float a = 1.0f) { float r, g, b; ImGui::ColorConvertHSVtoRGB(h, s, v, r, g, b); return ImColor(r, g, b, a); }
};
# 2575 "include/imgui/imgui.h"
typedef void (*ImDrawCallback)(const ImDrawList* parent_list, const ImDrawCmd* cmd);
# 2589 "include/imgui/imgui.h"
struct ImDrawCmd
{
    ImVec4 ClipRect;
    ImTextureID TextureId;
    unsigned int VtxOffset;
    unsigned int IdxOffset;
    unsigned int ElemCount;
    ImDrawCallback UserCallback;
    void* UserCallbackData;

    ImDrawCmd() { memset(this, 0, sizeof(*this)); }


    inline ImTextureID GetTexID() const { return TextureId; }
};



struct ImDrawVert
{
    ImVec2 pos;
    ImVec2 uv;
    ImU32 col;
};
# 2622 "include/imgui/imgui.h"
struct ImDrawCmdHeader
{
    ImVec4 ClipRect;
    ImTextureID TextureId;
    unsigned int VtxOffset;
};


struct ImDrawChannel
{
    ImVector<ImDrawCmd> _CmdBuffer;
    ImVector<ImDrawIdx> _IdxBuffer;
};




struct ImDrawListSplitter
{
    int _Current;
    int _Count;
    ImVector<ImDrawChannel> _Channels;

    inline ImDrawListSplitter() { memset(this, 0, sizeof(*this)); }
    inline ~ImDrawListSplitter() { ClearFreeMemory(); }
    inline void Clear() { _Current = 0; _Count = 1; }
    void ClearFreeMemory();
    void Split(ImDrawList* draw_list, int count);
    void Merge(ImDrawList* draw_list);
    void SetCurrentChannel(ImDrawList* draw_list, int channel_idx);
};



enum ImDrawFlags_
{
    ImDrawFlags_None = 0,
    ImDrawFlags_Closed = 1 << 0,
    ImDrawFlags_RoundCornersTopLeft = 1 << 4,
    ImDrawFlags_RoundCornersTopRight = 1 << 5,
    ImDrawFlags_RoundCornersBottomLeft = 1 << 6,
    ImDrawFlags_RoundCornersBottomRight = 1 << 7,
    ImDrawFlags_RoundCornersNone = 1 << 8,
    ImDrawFlags_RoundCornersTop = ImDrawFlags_RoundCornersTopLeft | ImDrawFlags_RoundCornersTopRight,
    ImDrawFlags_RoundCornersBottom = ImDrawFlags_RoundCornersBottomLeft | ImDrawFlags_RoundCornersBottomRight,
    ImDrawFlags_RoundCornersLeft = ImDrawFlags_RoundCornersBottomLeft | ImDrawFlags_RoundCornersTopLeft,
    ImDrawFlags_RoundCornersRight = ImDrawFlags_RoundCornersBottomRight | ImDrawFlags_RoundCornersTopRight,
    ImDrawFlags_RoundCornersAll = ImDrawFlags_RoundCornersTopLeft | ImDrawFlags_RoundCornersTopRight | ImDrawFlags_RoundCornersBottomLeft | ImDrawFlags_RoundCornersBottomRight,
    ImDrawFlags_RoundCornersDefault_ = ImDrawFlags_RoundCornersAll,
    ImDrawFlags_RoundCornersMask_ = ImDrawFlags_RoundCornersAll | ImDrawFlags_RoundCornersNone,
};



enum ImDrawListFlags_
{
    ImDrawListFlags_None = 0,
    ImDrawListFlags_AntiAliasedLines = 1 << 0,
    ImDrawListFlags_AntiAliasedLinesUseTex = 1 << 1,
    ImDrawListFlags_AntiAliasedFill = 1 << 2,
    ImDrawListFlags_AllowVtxOffset = 1 << 3,
};
# 2694 "include/imgui/imgui.h"
struct ImDrawList
{

    ImVector<ImDrawCmd> CmdBuffer;
    ImVector<ImDrawIdx> IdxBuffer;
    ImVector<ImDrawVert> VtxBuffer;
    ImDrawListFlags Flags;


    unsigned int _VtxCurrentIdx;
    ImDrawListSharedData* _Data;
    const char* _OwnerName;
    ImDrawVert* _VtxWritePtr;
    ImDrawIdx* _IdxWritePtr;
    ImVector<ImVec4> _ClipRectStack;
    ImVector<ImTextureID> _TextureIdStack;
    ImVector<ImVec2> _Path;
    ImDrawCmdHeader _CmdHeader;
    ImDrawListSplitter _Splitter;
    float _FringeScale;


    ImDrawList(ImDrawListSharedData* shared_data) { memset(this, 0, sizeof(*this)); _Data = shared_data; }

    ~ImDrawList() { _ClearFreeMemory(); }
    void PushClipRect(const ImVec2& clip_rect_min, const ImVec2& clip_rect_max, bool intersect_with_current_clip_rect = false);
    void PushClipRectFullScreen();
    void PopClipRect();
    void PushTextureID(ImTextureID texture_id);
    void PopTextureID();
    inline ImVec2 GetClipRectMin() const { const ImVec4& cr = _ClipRectStack.back(); return ImVec2(cr.x, cr.y); }
    inline ImVec2 GetClipRectMax() const { const ImVec4& cr = _ClipRectStack.back(); return ImVec2(cr.z, cr.w); }
# 2734 "include/imgui/imgui.h"
    void AddLine(const ImVec2& p1, const ImVec2& p2, ImU32 col, float thickness = 1.0f);
    void AddRect(const ImVec2& p_min, const ImVec2& p_max, ImU32 col, float rounding = 0.0f, ImDrawFlags flags = 0, float thickness = 1.0f);
    void AddRectFilled(const ImVec2& p_min, const ImVec2& p_max, ImU32 col, float rounding = 0.0f, ImDrawFlags flags = 0);
    void AddRectFilledMultiColor(const ImVec2& p_min, const ImVec2& p_max, ImU32 col_upr_left, ImU32 col_upr_right, ImU32 col_bot_right, ImU32 col_bot_left);
    void AddQuad(const ImVec2& p1, const ImVec2& p2, const ImVec2& p3, const ImVec2& p4, ImU32 col, float thickness = 1.0f);
    void AddQuadFilled(const ImVec2& p1, const ImVec2& p2, const ImVec2& p3, const ImVec2& p4, ImU32 col);
    void AddTriangle(const ImVec2& p1, const ImVec2& p2, const ImVec2& p3, ImU32 col, float thickness = 1.0f);
    void AddTriangleFilled(const ImVec2& p1, const ImVec2& p2, const ImVec2& p3, ImU32 col);
    void AddCircle(const ImVec2& center, float radius, ImU32 col, int num_segments = 0, float thickness = 1.0f);
    void AddCircleFilled(const ImVec2& center, float radius, ImU32 col, int num_segments = 0);
    void AddNgon(const ImVec2& center, float radius, ImU32 col, int num_segments, float thickness = 1.0f);
    void AddNgonFilled(const ImVec2& center, float radius, ImU32 col, int num_segments);
    void AddEllipse(const ImVec2& center, float radius_x, float radius_y, ImU32 col, float rot = 0.0f, int num_segments = 0, float thickness = 1.0f);
    void AddEllipseFilled(const ImVec2& center, float radius_x, float radius_y, ImU32 col, float rot = 0.0f, int num_segments = 0);
    void AddText(const ImVec2& pos, ImU32 col, const char* text_begin, const char* text_end = 
# 2748 "include/imgui/imgui.h" 3 4
                                                                                                        __null
# 2748 "include/imgui/imgui.h"
                                                                                                            );
    void AddText(const ImFont* font, float font_size, const ImVec2& pos, ImU32 col, const char* text_begin, const char* text_end = 
# 2749 "include/imgui/imgui.h" 3 4
                                                                                                                                             __null
# 2749 "include/imgui/imgui.h"
                                                                                                                                                 , float wrap_width = 0.0f, const ImVec4* cpu_fine_clip_rect = 
# 2749 "include/imgui/imgui.h" 3 4
                                                                                                                                                                                                               __null
# 2749 "include/imgui/imgui.h"
                                                                                                                                                                                                                   );
    void AddPolyline(const ImVec2* points, int num_points, ImU32 col, ImDrawFlags flags, float thickness);
    void AddConvexPolyFilled(const ImVec2* points, int num_points, ImU32 col);
    void AddBezierCubic(const ImVec2& p1, const ImVec2& p2, const ImVec2& p3, const ImVec2& p4, ImU32 col, float thickness, int num_segments = 0);
    void AddBezierQuadratic(const ImVec2& p1, const ImVec2& p2, const ImVec2& p3, ImU32 col, float thickness, int num_segments = 0);





    void AddImage(ImTextureID user_texture_id, const ImVec2& p_min, const ImVec2& p_max, const ImVec2& uv_min = ImVec2(0, 0), const ImVec2& uv_max = ImVec2(1, 1), ImU32 col = (((ImU32)(255)<<24) | ((ImU32)(255)<<16) | ((ImU32)(255)<<8) | ((ImU32)(255)<<0)));
    void AddImageQuad(ImTextureID user_texture_id, const ImVec2& p1, const ImVec2& p2, const ImVec2& p3, const ImVec2& p4, const ImVec2& uv1 = ImVec2(0, 0), const ImVec2& uv2 = ImVec2(1, 0), const ImVec2& uv3 = ImVec2(1, 1), const ImVec2& uv4 = ImVec2(0, 1), ImU32 col = (((ImU32)(255)<<24) | ((ImU32)(255)<<16) | ((ImU32)(255)<<8) | ((ImU32)(255)<<0)));
    void AddImageRounded(ImTextureID user_texture_id, const ImVec2& p_min, const ImVec2& p_max, const ImVec2& uv_min, const ImVec2& uv_max, ImU32 col, float rounding, ImDrawFlags flags = 0);



    inline void PathClear() { _Path.Size = 0; }
    inline void PathLineTo(const ImVec2& pos) { _Path.push_back(pos); }
    inline void PathLineToMergeDuplicate(const ImVec2& pos) { if (_Path.Size == 0 || memcmp(&_Path.Data[_Path.Size - 1], &pos, 8) != 0) _Path.push_back(pos); }
    inline void PathFillConvex(ImU32 col) { AddConvexPolyFilled(_Path.Data, _Path.Size, col); _Path.Size = 0; }
    inline void PathStroke(ImU32 col, ImDrawFlags flags = 0, float thickness = 1.0f) { AddPolyline(_Path.Data, _Path.Size, col, flags, thickness); _Path.Size = 0; }
    void PathArcTo(const ImVec2& center, float radius, float a_min, float a_max, int num_segments = 0);
    void PathArcToFast(const ImVec2& center, float radius, int a_min_of_12, int a_max_of_12);
    void PathEllipticalArcTo(const ImVec2& center, float radius_x, float radius_y, float rot, float a_min, float a_max, int num_segments = 0);
    void PathBezierCubicCurveTo(const ImVec2& p2, const ImVec2& p3, const ImVec2& p4, int num_segments = 0);
    void PathBezierQuadraticCurveTo(const ImVec2& p2, const ImVec2& p3, int num_segments = 0);
    void PathRect(const ImVec2& rect_min, const ImVec2& rect_max, float rounding = 0.0f, ImDrawFlags flags = 0);


    void AddCallback(ImDrawCallback callback, void* callback_data);
    void AddDrawCmd();
    ImDrawList* CloneOutput() const;







    inline void ChannelsSplit(int count) { _Splitter.Split(this, count); }
    inline void ChannelsMerge() { _Splitter.Merge(this); }
    inline void ChannelsSetCurrent(int n) { _Splitter.SetCurrentChannel(this, n); }




    void PrimReserve(int idx_count, int vtx_count);
    void PrimUnreserve(int idx_count, int vtx_count);
    void PrimRect(const ImVec2& a, const ImVec2& b, ImU32 col);
    void PrimRectUV(const ImVec2& a, const ImVec2& b, const ImVec2& uv_a, const ImVec2& uv_b, ImU32 col);
    void PrimQuadUV(const ImVec2& a, const ImVec2& b, const ImVec2& c, const ImVec2& d, const ImVec2& uv_a, const ImVec2& uv_b, const ImVec2& uv_c, const ImVec2& uv_d, ImU32 col);
    inline void PrimWriteVtx(const ImVec2& pos, const ImVec2& uv, ImU32 col) { _VtxWritePtr->pos = pos; _VtxWritePtr->uv = uv; _VtxWritePtr->col = col; _VtxWritePtr++; _VtxCurrentIdx++; }
    inline void PrimWriteIdx(ImDrawIdx idx) { *_IdxWritePtr = idx; _IdxWritePtr++; }
    inline void PrimVtx(const ImVec2& pos, const ImVec2& uv, ImU32 col) { PrimWriteIdx((ImDrawIdx)_VtxCurrentIdx); PrimWriteVtx(pos, uv, col); }






    void _ResetForNewFrame();
    void _ClearFreeMemory();
    void _PopUnusedDrawCmd();
    void _TryMergeDrawCmds();
    void _OnChangedClipRect();
    void _OnChangedTextureID();
    void _OnChangedVtxOffset();
    int _CalcCircleAutoSegmentCount(float radius) const;
    void _PathArcToFastEx(const ImVec2& center, float radius, int a_min_sample, int a_max_sample, int a_step);
    void _PathArcToN(const ImVec2& center, float radius, float a_min, float a_max, int num_segments);
};




struct ImDrawData
{
    bool Valid;
    int CmdListsCount;
    int TotalIdxCount;
    int TotalVtxCount;
    ImVector<ImDrawList*> CmdLists;
    ImVec2 DisplayPos;
    ImVec2 DisplaySize;
    ImVec2 FramebufferScale;
    ImGuiViewport* OwnerViewport;


    ImDrawData() { Clear(); }
    void Clear();
    void AddDrawList(ImDrawList* draw_list);
    void DeIndexAllBuffers();
    void ScaleClipRects(const ImVec2& fb_scale);
};





struct ImFontConfig
{
    void* FontData;
    int FontDataSize;
    bool FontDataOwnedByAtlas;
    int FontNo;
    float SizePixels;
    int OversampleH;
    int OversampleV;
    bool PixelSnapH;
    ImVec2 GlyphExtraSpacing;
    ImVec2 GlyphOffset;
    const ImWchar* GlyphRanges;
    float GlyphMinAdvanceX;
    float GlyphMaxAdvanceX;
    bool MergeMode;
    unsigned int FontBuilderFlags;
    float RasterizerMultiply;
    float RasterizerDensity;
    ImWchar EllipsisChar;


    char Name[40];
    ImFont* DstFont;

    ImFontConfig();
};



struct ImFontGlyph
{
    unsigned int Colored : 1;
    unsigned int Visible : 1;
    unsigned int Codepoint : 30;
    float AdvanceX;
    float X0, Y0, X1, Y1;
    float U0, V0, U1, V1;
};



struct ImFontGlyphRangesBuilder
{
    ImVector<ImU32> UsedChars;

    ImFontGlyphRangesBuilder() { Clear(); }
    inline void Clear() { int size_in_bytes = (0xFFFF + 1) / 8; UsedChars.resize(size_in_bytes / (int)sizeof(ImU32)); memset(UsedChars.Data, 0, (size_t)size_in_bytes); }
    inline bool GetBit(size_t n) const { int off = (int)(n >> 5); ImU32 mask = 1u << (n & 31); return (UsedChars[off] & mask) != 0; }
    inline void SetBit(size_t n) { int off = (int)(n >> 5); ImU32 mask = 1u << (n & 31); UsedChars[off] |= mask; }
    inline void AddChar(ImWchar c) { SetBit(c); }
    void AddText(const char* text, const char* text_end = 
# 2899 "include/imgui/imgui.h" 3 4
                                                                    __null
# 2899 "include/imgui/imgui.h"
                                                                        );
    void AddRanges(const ImWchar* ranges);
    void BuildRanges(ImVector<ImWchar>* out_ranges);
};


struct ImFontAtlasCustomRect
{
    unsigned short Width, Height;
    unsigned short X, Y;
    unsigned int GlyphID;
    float GlyphAdvanceX;
    ImVec2 GlyphOffset;
    ImFont* Font;
    ImFontAtlasCustomRect() { Width = Height = 0; X = Y = 0xFFFF; GlyphID = 0; GlyphAdvanceX = 0.0f; GlyphOffset = ImVec2(0, 0); Font = 
# 2913 "include/imgui/imgui.h" 3 4
                                                                                                                                               __null
# 2913 "include/imgui/imgui.h"
                                                                                                                                                   ; }
    bool IsPacked() const { return X != 0xFFFF; }
};


enum ImFontAtlasFlags_
{
    ImFontAtlasFlags_None = 0,
    ImFontAtlasFlags_NoPowerOfTwoHeight = 1 << 0,
    ImFontAtlasFlags_NoMouseCursors = 1 << 1,
    ImFontAtlasFlags_NoBakedLines = 1 << 2,
};
# 2943 "include/imgui/imgui.h"
struct ImFontAtlas
{
    ImFontAtlas();
    ~ImFontAtlas();
    ImFont* AddFont(const ImFontConfig* font_cfg);
    ImFont* AddFontDefault(const ImFontConfig* font_cfg = 
# 2948 "include/imgui/imgui.h" 3 4
                                                                             __null
# 2948 "include/imgui/imgui.h"
                                                                                 );
    ImFont* AddFontFromFileTTF(const char* filename, float size_pixels, const ImFontConfig* font_cfg = 
# 2949 "include/imgui/imgui.h" 3 4
                                                                                                                          __null
# 2949 "include/imgui/imgui.h"
                                                                                                                              , const ImWchar* glyph_ranges = 
# 2949 "include/imgui/imgui.h" 3 4
                                                                                                                                                              __null
# 2949 "include/imgui/imgui.h"
                                                                                                                                                                  );
    ImFont* AddFontFromMemoryTTF(void* font_data, int font_data_size, float size_pixels, const ImFontConfig* font_cfg = 
# 2950 "include/imgui/imgui.h" 3 4
                                                                                                                                           __null
# 2950 "include/imgui/imgui.h"
                                                                                                                                               , const ImWchar* glyph_ranges = 
# 2950 "include/imgui/imgui.h" 3 4
                                                                                                                                                                               __null
# 2950 "include/imgui/imgui.h"
                                                                                                                                                                                   );
    ImFont* AddFontFromMemoryCompressedTTF(const void* compressed_font_data, int compressed_font_data_size, float size_pixels, const ImFontConfig* font_cfg = 
# 2951 "include/imgui/imgui.h" 3 4
                                                                                                                                                                                 __null
# 2951 "include/imgui/imgui.h"
                                                                                                                                                                                     , const ImWchar* glyph_ranges = 
# 2951 "include/imgui/imgui.h" 3 4
                                                                                                                                                                                                                     __null
# 2951 "include/imgui/imgui.h"
                                                                                                                                                                                                                         );
    ImFont* AddFontFromMemoryCompressedBase85TTF(const char* compressed_font_data_base85, float size_pixels, const ImFontConfig* font_cfg = 
# 2952 "include/imgui/imgui.h" 3 4
                                                                                                                                                               __null
# 2952 "include/imgui/imgui.h"
                                                                                                                                                                   , const ImWchar* glyph_ranges = 
# 2952 "include/imgui/imgui.h" 3 4
                                                                                                                                                                                                   __null
# 2952 "include/imgui/imgui.h"
                                                                                                                                                                                                       );
    void ClearInputData();
    void ClearTexData();
    void ClearFonts();
    void Clear();






    bool Build();
    void GetTexDataAsAlpha8(unsigned char** out_pixels, int* out_width, int* out_height, int* out_bytes_per_pixel = 
# 2964 "include/imgui/imgui.h" 3 4
                                                                                                                                          __null
# 2964 "include/imgui/imgui.h"
                                                                                                                                              );
    void GetTexDataAsRGBA32(unsigned char** out_pixels, int* out_width, int* out_height, int* out_bytes_per_pixel = 
# 2965 "include/imgui/imgui.h" 3 4
                                                                                                                                          __null
# 2965 "include/imgui/imgui.h"
                                                                                                                                              );
    bool IsBuilt() const { return Fonts.Size > 0 && TexReady; }
    void SetTexID(ImTextureID id) { TexID = id; }
# 2977 "include/imgui/imgui.h"
    const ImWchar* GetGlyphRangesDefault();
    const ImWchar* GetGlyphRangesGreek();
    const ImWchar* GetGlyphRangesKorean();
    const ImWchar* GetGlyphRangesJapanese();
    const ImWchar* GetGlyphRangesChineseFull();
    const ImWchar* GetGlyphRangesChineseSimplifiedCommon();
    const ImWchar* GetGlyphRangesCyrillic();
    const ImWchar* GetGlyphRangesThai();
    const ImWchar* GetGlyphRangesVietnamese();
# 2998 "include/imgui/imgui.h"
    int AddCustomRectRegular(int width, int height);
    int AddCustomRectFontGlyph(ImFont* font, ImWchar id, int width, int height, float advance_x, const ImVec2& offset = ImVec2(0, 0));
    ImFontAtlasCustomRect* GetCustomRectByIndex(int index) { 
# 3000 "include/imgui/imgui.h" 3 4
                                                                 (static_cast <bool> (
# 3000 "include/imgui/imgui.h"
                                                                 index >= 0
# 3000 "include/imgui/imgui.h" 3 4
                                                                 ) ? void (0) : __assert_fail (
# 3000 "include/imgui/imgui.h"
                                                                 "index >= 0"
# 3000 "include/imgui/imgui.h" 3 4
                                                                 , "include/imgui/imgui.h", 3000, __extension__ __PRETTY_FUNCTION__))
# 3000 "include/imgui/imgui.h"
                                                                                      ; return &CustomRects[index]; }


    void CalcCustomRectUV(const ImFontAtlasCustomRect* rect, ImVec2* out_uv_min, ImVec2* out_uv_max) const;
    bool GetMouseCursorTexData(ImGuiMouseCursor cursor, ImVec2* out_offset, ImVec2* out_size, ImVec2 out_uv_border[2], ImVec2 out_uv_fill[2]);





    ImFontAtlasFlags Flags;
    ImTextureID TexID;
    int TexDesiredWidth;
    int TexGlyphPadding;
    bool Locked;
    void* UserData;



    bool TexReady;
    bool TexPixelsUseColors;
    unsigned char* TexPixelsAlpha8;
    unsigned int* TexPixelsRGBA32;
    int TexWidth;
    int TexHeight;
    ImVec2 TexUvScale;
    ImVec2 TexUvWhitePixel;
    ImVector<ImFont*> Fonts;
    ImVector<ImFontAtlasCustomRect> CustomRects;
    ImVector<ImFontConfig> ConfigData;
    ImVec4 TexUvLines[(63) + 1];


    const ImFontBuilderIO* FontBuilderIO;
    unsigned int FontBuilderFlags;


    int PackIdMouseCursors;
    int PackIdLines;




};



struct ImFont
{

    ImVector<float> IndexAdvanceX;
    float FallbackAdvanceX;
    float FontSize;


    ImVector<ImWchar> IndexLookup;
    ImVector<ImFontGlyph> Glyphs;
    const ImFontGlyph* FallbackGlyph;


    ImFontAtlas* ContainerAtlas;
    const ImFontConfig* ConfigData;
    short ConfigDataCount;
    ImWchar FallbackChar;
    ImWchar EllipsisChar;
    short EllipsisCharCount;
    float EllipsisWidth;
    float EllipsisCharStep;
    bool DirtyLookupTables;
    float Scale;
    float Ascent, Descent;
    int MetricsTotalSurface;
    ImU8 Used4kPagesMap[(0xFFFF +1)/4096/8];


    ImFont();
    ~ImFont();
    const ImFontGlyph*FindGlyph(ImWchar c) const;
    const ImFontGlyph*FindGlyphNoFallback(ImWchar c) const;
    float GetCharAdvance(ImWchar c) const { return ((int)c < IndexAdvanceX.Size) ? IndexAdvanceX[(int)c] : FallbackAdvanceX; }
    bool IsLoaded() const { return ContainerAtlas != 
# 3080 "include/imgui/imgui.h" 3 4
                                                                                              __null
# 3080 "include/imgui/imgui.h"
                                                                                                  ; }
    const char* GetDebugName() const { return ConfigData ? ConfigData->Name : "<unknown>"; }



    ImVec2 CalcTextSizeA(float size, float max_width, float wrap_width, const char* text_begin, const char* text_end = 
# 3085 "include/imgui/imgui.h" 3 4
                                                                                                                                           __null
# 3085 "include/imgui/imgui.h"
                                                                                                                                               , const char** remaining = 
# 3085 "include/imgui/imgui.h" 3 4
                                                                                                                                                                          __null
# 3085 "include/imgui/imgui.h"
                                                                                                                                                                              ) const;
    const char* CalcWordWrapPositionA(float scale, const char* text, const char* text_end, float wrap_width) const;
    void RenderChar(ImDrawList* draw_list, float size, const ImVec2& pos, ImU32 col, ImWchar c) const;
    void RenderText(ImDrawList* draw_list, float size, const ImVec2& pos, ImU32 col, const ImVec4& clip_rect, const char* text_begin, const char* text_end, float wrap_width = 0.0f, bool cpu_fine_clip = false) const;


    void BuildLookupTable();
    void ClearOutputData();
    void GrowIndex(int new_size);
    void AddGlyph(const ImFontConfig* src_cfg, ImWchar c, float x0, float y0, float x1, float y1, float u0, float v0, float u1, float v1, float advance_x);
    void AddRemapChar(ImWchar dst, ImWchar src, bool overwrite_dst = true);
    void SetGlyphVisible(ImWchar c, bool visible);
    bool IsGlyphRangeUnused(unsigned int c_begin, unsigned int c_last);
};






enum ImGuiViewportFlags_
{
    ImGuiViewportFlags_None = 0,
    ImGuiViewportFlags_IsPlatformWindow = 1 << 0,
    ImGuiViewportFlags_IsPlatformMonitor = 1 << 1,
    ImGuiViewportFlags_OwnedByApp = 1 << 2,
};
# 3120 "include/imgui/imgui.h"
struct ImGuiViewport
{
    ImGuiViewportFlags Flags;
    ImVec2 Pos;
    ImVec2 Size;
    ImVec2 WorkPos;
    ImVec2 WorkSize;


    void* PlatformHandleRaw;

    ImGuiViewport() { memset(this, 0, sizeof(*this)); }


    ImVec2 GetCenter() const { return ImVec2(Pos.x + Size.x * 0.5f, Pos.y + Size.y * 0.5f); }
    ImVec2 GetWorkCenter() const { return ImVec2(WorkPos.x + WorkSize.x * 0.5f, WorkPos.y + WorkSize.y * 0.5f); }
};






struct ImGuiPlatformImeData
{
    bool WantVisible;
    ImVec2 InputPos;
    float InputLineHeight;

    ImGuiPlatformImeData() { memset(this, 0, sizeof(*this)); }
};







namespace ImGui
{

    ImGuiKey GetKeyIndex(ImGuiKey key);



}


namespace ImGui
{

    static inline bool BeginChildFrame(ImGuiID id, const ImVec2& size, ImGuiWindowFlags window_flags = 0) { return BeginChild(id, size, ImGuiChildFlags_FrameStyle, window_flags); }
    static inline void EndChildFrame() { EndChild(); }


    static inline void ShowStackToolWindow(bool* p_open = 
# 3175 "include/imgui/imgui.h" 3 4
                                                          __null
# 3175 "include/imgui/imgui.h"
                                                              ) { ShowIDStackToolWindow(p_open); }
    bool ListBox(const char* label, int* current_item, bool (*old_callback)(void* user_data, int idx, const char** out_text), void* user_data, int items_count, int height_in_items = -1);
    bool Combo(const char* label, int* current_item, bool (*old_callback)(void* user_data, int idx, const char** out_text), void* user_data, int items_count, int popup_max_height_in_items = -1);

    void SetItemAllowOverlap();

    static inline void PushAllowKeyboardFocus(bool tab_stop) { PushTabStop(tab_stop); }
    static inline void PopAllowKeyboardFocus() { PopTabStop(); }

    bool ImageButton(ImTextureID user_texture_id, const ImVec2& size, const ImVec2& uv0 = ImVec2(0, 0), const ImVec2& uv1 = ImVec2(1, 1), int frame_padding = -1, const ImVec4& bg_col = ImVec4(0, 0, 0, 0), const ImVec4& tint_col = ImVec4(1, 1, 1, 1));

    static inline void CaptureKeyboardFromApp(bool want_capture_keyboard = true) { SetNextFrameWantCaptureKeyboard(want_capture_keyboard); }
    static inline void CaptureMouseFromApp(bool want_capture_mouse = true) { SetNextFrameWantCaptureMouse(want_capture_mouse); }
# 3242 "include/imgui/imgui.h"
}
# 3262 "include/imgui/imgui.h"
typedef ImGuiKeyChord ImGuiModFlags;
enum ImGuiModFlags_ { ImGuiModFlags_None = 0, ImGuiModFlags_Ctrl = ImGuiMod_Ctrl, ImGuiModFlags_Shift = ImGuiMod_Shift, ImGuiModFlags_Alt = ImGuiMod_Alt, ImGuiModFlags_Super = ImGuiMod_Super };
# 3284 "include/imgui/imgui.h"
#pragma GCC diagnostic pop
# 13 "code/glfw_main.cpp" 2
# 1 "include/imgui/imgui_impl_glfw.h" 1
# 20 "include/imgui/imgui_impl_glfw.h"
       



struct GLFWwindow;
struct GLFWmonitor;

 bool ImGui_ImplGlfw_InitForOpenGL(GLFWwindow* window, bool install_callbacks);
 bool ImGui_ImplGlfw_InitForVulkan(GLFWwindow* window, bool install_callbacks);
 bool ImGui_ImplGlfw_InitForOther(GLFWwindow* window, bool install_callbacks);
 void ImGui_ImplGlfw_Shutdown();
 void ImGui_ImplGlfw_NewFrame();
# 42 "include/imgui/imgui_impl_glfw.h"
 void ImGui_ImplGlfw_InstallCallbacks(GLFWwindow* window);
 void ImGui_ImplGlfw_RestoreCallbacks(GLFWwindow* window);



 void ImGui_ImplGlfw_SetCallbacksChainForAllWindows(bool chain_for_all_windows);


 void ImGui_ImplGlfw_WindowFocusCallback(GLFWwindow* window, int focused);
 void ImGui_ImplGlfw_CursorEnterCallback(GLFWwindow* window, int entered);
 void ImGui_ImplGlfw_CursorPosCallback(GLFWwindow* window, double x, double y);
 void ImGui_ImplGlfw_MouseButtonCallback(GLFWwindow* window, int button, int action, int mods);
 void ImGui_ImplGlfw_ScrollCallback(GLFWwindow* window, double xoffset, double yoffset);
 void ImGui_ImplGlfw_KeyCallback(GLFWwindow* window, int key, int scancode, int action, int mods);
 void ImGui_ImplGlfw_CharCallback(GLFWwindow* window, unsigned int c);
 void ImGui_ImplGlfw_MonitorCallback(GLFWmonitor* monitor, int event);
# 14 "code/glfw_main.cpp" 2
# 1 "include/imgui/imgui_impl_opengl3.h" 1
# 28 "include/imgui/imgui_impl_opengl3.h"
       




 bool ImGui_ImplOpenGL3_Init(const char* glsl_version = nullptr);
 void ImGui_ImplOpenGL3_Shutdown();
 void ImGui_ImplOpenGL3_NewFrame();
 void ImGui_ImplOpenGL3_RenderDrawData(ImDrawData* draw_data);


 bool ImGui_ImplOpenGL3_CreateFontsTexture();
 void ImGui_ImplOpenGL3_DestroyFontsTexture();
 bool ImGui_ImplOpenGL3_CreateDeviceObjects();
 void ImGui_ImplOpenGL3_DestroyDeviceObjects();
# 15 "code/glfw_main.cpp" 2






# 1 "code/game.cpp" 1
# 1 "include/stb_image.h" 1
# 376 "include/stb_image.h"
enum
{
   STBI_default = 0,

   STBI_grey = 1,
   STBI_grey_alpha = 2,
   STBI_rgb = 3,
   STBI_rgb_alpha = 4
};

# 1 "/usr/include/c++/10/stdlib.h" 1 3
# 387 "include/stb_image.h" 2
typedef unsigned char stbi_uc;
typedef unsigned short stbi_us;


extern "C" {
# 411 "include/stb_image.h"
typedef struct
{
   int (*read) (void *user,char *data,int size);
   void (*skip) (void *user,int n);
   int (*eof) (void *user);
} stbi_io_callbacks;






extern stbi_uc *stbi_load_from_memory (stbi_uc const *buffer, int len , int *x, int *y, int *channels_in_file, int desired_channels);
extern stbi_uc *stbi_load_from_callbacks(stbi_io_callbacks const *clbk , void *user, int *x, int *y, int *channels_in_file, int desired_channels);


extern stbi_uc *stbi_load (char const *filename, int *x, int *y, int *channels_in_file, int desired_channels);
extern stbi_uc *stbi_load_from_file (FILE *f, int *x, int *y, int *channels_in_file, int desired_channels);




extern stbi_uc *stbi_load_gif_from_memory(stbi_uc const *buffer, int len, int **delays, int *x, int *y, int *z, int *comp, int req_comp);
# 445 "include/stb_image.h"
extern stbi_us *stbi_load_16_from_memory (stbi_uc const *buffer, int len, int *x, int *y, int *channels_in_file, int desired_channels);
extern stbi_us *stbi_load_16_from_callbacks(stbi_io_callbacks const *clbk, void *user, int *x, int *y, int *channels_in_file, int desired_channels);


extern stbi_us *stbi_load_16 (char const *filename, int *x, int *y, int *channels_in_file, int desired_channels);
extern stbi_us *stbi_load_from_file_16(FILE *f, int *x, int *y, int *channels_in_file, int desired_channels);







   extern float *stbi_loadf_from_memory (stbi_uc const *buffer, int len, int *x, int *y, int *channels_in_file, int desired_channels);
   extern float *stbi_loadf_from_callbacks (stbi_io_callbacks const *clbk, void *user, int *x, int *y, int *channels_in_file, int desired_channels);


   extern float *stbi_loadf (char const *filename, int *x, int *y, int *channels_in_file, int desired_channels);
   extern float *stbi_loadf_from_file (FILE *f, int *x, int *y, int *channels_in_file, int desired_channels);




   extern void stbi_hdr_to_ldr_gamma(float gamma);
   extern void stbi_hdr_to_ldr_scale(float scale);



   extern void stbi_ldr_to_hdr_gamma(float gamma);
   extern void stbi_ldr_to_hdr_scale(float scale);



extern int stbi_is_hdr_from_callbacks(stbi_io_callbacks const *clbk, void *user);
extern int stbi_is_hdr_from_memory(stbi_uc const *buffer, int len);

extern int stbi_is_hdr (char const *filename);
extern int stbi_is_hdr_from_file(FILE *f);





extern const char *stbi_failure_reason (void);


extern void stbi_image_free (void *retval_from_stbi_load);


extern int stbi_info_from_memory(stbi_uc const *buffer, int len, int *x, int *y, int *comp);
extern int stbi_info_from_callbacks(stbi_io_callbacks const *clbk, void *user, int *x, int *y, int *comp);
extern int stbi_is_16_bit_from_memory(stbi_uc const *buffer, int len);
extern int stbi_is_16_bit_from_callbacks(stbi_io_callbacks const *clbk, void *user);


extern int stbi_info (char const *filename, int *x, int *y, int *comp);
extern int stbi_info_from_file (FILE *f, int *x, int *y, int *comp);
extern int stbi_is_16_bit (char const *filename);
extern int stbi_is_16_bit_from_file(FILE *f);







extern void stbi_set_unpremultiply_on_load(int flag_true_if_should_unpremultiply);



extern void stbi_convert_iphone_png_to_rgb(int flag_true_if_should_convert);


extern void stbi_set_flip_vertically_on_load(int flag_true_if_should_flip);




extern void stbi_set_unpremultiply_on_load_thread(int flag_true_if_should_unpremultiply);
extern void stbi_convert_iphone_png_to_rgb_thread(int flag_true_if_should_convert);
extern void stbi_set_flip_vertically_on_load_thread(int flag_true_if_should_flip);



extern char *stbi_zlib_decode_malloc_guesssize(const char *buffer, int len, int initial_size, int *outlen);
extern char *stbi_zlib_decode_malloc_guesssize_headerflag(const char *buffer, int len, int initial_size, int *outlen, int parse_header);
extern char *stbi_zlib_decode_malloc(const char *buffer, int len, int *outlen);
extern int stbi_zlib_decode_buffer(char *obuffer, int olen, const char *ibuffer, int ilen);

extern char *stbi_zlib_decode_noheader_malloc(const char *buffer, int len, int *outlen);
extern int stbi_zlib_decode_noheader_buffer(char *obuffer, int olen, const char *ibuffer, int ilen);



}
# 2 "code/game.cpp" 2
# 1 "include/ufbx.h" 1
# 13 "include/ufbx.h"
# 1 "/usr/lib/gcc/x86_64-linux-gnu/10/include/stddef.h" 1 3 4
# 14 "include/ufbx.h" 2
# 1 "/usr/lib/gcc/x86_64-linux-gnu/10/include/stdbool.h" 1 3 4
# 15 "include/ufbx.h" 2
# 75 "include/ufbx.h"
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wpedantic"
#pragma GCC diagnostic ignored "-Wpadded"

#pragma GCC diagnostic ignored "-Wzero-as-null-pointer-constant"
#pragma GCC diagnostic ignored "-Wold-style-cast"
# 105 "include/ufbx.h"
# 1 "/usr/include/assert.h" 1 3 4
# 106 "include/ufbx.h" 2
# 177 "include/ufbx.h"
template <typename T, typename U>
struct ufbxi_type_is { };

template <typename T>
struct ufbxi_type_is<T, T> { using type = int; };

template <typename T>
struct ufbx_converter { };
# 278 "include/ufbx.h"
typedef double ufbx_real;


typedef struct ufbx_string {
 const char *data;
 size_t length;

 template <typename T, typename S=typename ufbxi_type_is<T, decltype(ufbx_converter<T>::from(*(const ufbx_string*)nullptr))>::type> operator T() const { return ufbx_converter<T>::from(*this); }
} ufbx_string;


typedef struct ufbx_blob {
 const void *data;
 size_t size;

 template <typename T, typename S=typename ufbxi_type_is<T, decltype(ufbx_converter<T>::from(*(const ufbx_blob*)nullptr))>::type> operator T() const { return ufbx_converter<T>::from(*this); }
} ufbx_blob;


typedef struct ufbx_vec2 {
 union {
  struct { ufbx_real x, y; };
  ufbx_real v[2];
 };

 template <typename T, typename S=typename ufbxi_type_is<T, decltype(ufbx_converter<T>::from(*(const ufbx_vec2*)nullptr))>::type> operator T() const { return ufbx_converter<T>::from(*this); }
} ufbx_vec2;


typedef struct ufbx_vec3 {
 union {
  struct { ufbx_real x, y, z; };
  ufbx_real v[3];
 };

 template <typename T, typename S=typename ufbxi_type_is<T, decltype(ufbx_converter<T>::from(*(const ufbx_vec3*)nullptr))>::type> operator T() const { return ufbx_converter<T>::from(*this); }
} ufbx_vec3;


typedef struct ufbx_vec4 {
 union {
  struct { ufbx_real x, y, z, w; };
  ufbx_real v[4];
 };

 template <typename T, typename S=typename ufbxi_type_is<T, decltype(ufbx_converter<T>::from(*(const ufbx_vec4*)nullptr))>::type> operator T() const { return ufbx_converter<T>::from(*this); }
} ufbx_vec4;


typedef struct ufbx_quat {
 union {
  struct { ufbx_real x, y, z, w; };
  ufbx_real v[4];
 };

 template <typename T, typename S=typename ufbxi_type_is<T, decltype(ufbx_converter<T>::from(*(const ufbx_quat*)nullptr))>::type> operator T() const { return ufbx_converter<T>::from(*this); }
} ufbx_quat;





typedef enum ufbx_rotation_order {
 UFBX_ROTATION_ORDER_XYZ,
 UFBX_ROTATION_ORDER_XZY,
 UFBX_ROTATION_ORDER_YZX,
 UFBX_ROTATION_ORDER_YXZ,
 UFBX_ROTATION_ORDER_ZXY,
 UFBX_ROTATION_ORDER_ZYX,
 UFBX_ROTATION_ORDER_SPHERIC,

 UFBX_ROTATION_ORDER_FORCE_32BIT = 0x7fffffff
} ufbx_rotation_order;

enum { UFBX_ROTATION_ORDER_COUNT = UFBX_ROTATION_ORDER_SPHERIC + 1 };



typedef struct ufbx_transform {
 ufbx_vec3 translation;
 ufbx_quat rotation;
 ufbx_vec3 scale;

 template <typename T, typename S=typename ufbxi_type_is<T, decltype(ufbx_converter<T>::from(*(const ufbx_transform*)nullptr))>::type> operator T() const { return ufbx_converter<T>::from(*this); }
} ufbx_transform;



typedef struct ufbx_matrix {
 union {
  struct {
   ufbx_real m00, m10, m20;
   ufbx_real m01, m11, m21;
   ufbx_real m02, m12, m22;
   ufbx_real m03, m13, m23;
  };
  ufbx_vec3 cols[4];
  ufbx_real v[12];
 };

 template <typename T, typename S=typename ufbxi_type_is<T, decltype(ufbx_converter<T>::from(*(const ufbx_matrix*)nullptr))>::type> operator T() const { return ufbx_converter<T>::from(*this); }
} ufbx_matrix;

typedef struct ufbx_void_list {
 void *data;
 size_t count;
} ufbx_void_list;

struct ufbx_bool_list { bool *data; size_t count; bool &operator[](size_t index) const { 
# 386 "include/ufbx.h" 3 4
(static_cast <bool> (
# 386 "include/ufbx.h"
index < count
# 386 "include/ufbx.h" 3 4
) ? void (0) : __assert_fail (
# 386 "include/ufbx.h"
"index < count"
# 386 "include/ufbx.h" 3 4
, "include/ufbx.h", 386, __extension__ __PRETTY_FUNCTION__))
# 386 "include/ufbx.h"
; return data[index]; } bool *begin() const { return data; } bool *end() const { return data + count; } template <typename T, typename S=typename ufbxi_type_is<T, decltype(ufbx_converter<T>::from_list((bool*)nullptr, (size_t)0))>::type> operator T() const { return ufbx_converter<T>::from_list(data, count); } };
struct ufbx_uint32_list { uint32_t *data; size_t count; uint32_t &operator[](size_t index) const { 
# 387 "include/ufbx.h" 3 4
(static_cast <bool> (
# 387 "include/ufbx.h"
index < count
# 387 "include/ufbx.h" 3 4
) ? void (0) : __assert_fail (
# 387 "include/ufbx.h"
"index < count"
# 387 "include/ufbx.h" 3 4
, "include/ufbx.h", 387, __extension__ __PRETTY_FUNCTION__))
# 387 "include/ufbx.h"
; return data[index]; } uint32_t *begin() const { return data; } uint32_t *end() const { return data + count; } template <typename T, typename S=typename ufbxi_type_is<T, decltype(ufbx_converter<T>::from_list((uint32_t*)nullptr, (size_t)0))>::type> operator T() const { return ufbx_converter<T>::from_list(data, count); } };
struct ufbx_real_list { ufbx_real *data; size_t count; ufbx_real &operator[](size_t index) const { 
# 388 "include/ufbx.h" 3 4
(static_cast <bool> (
# 388 "include/ufbx.h"
index < count
# 388 "include/ufbx.h" 3 4
) ? void (0) : __assert_fail (
# 388 "include/ufbx.h"
"index < count"
# 388 "include/ufbx.h" 3 4
, "include/ufbx.h", 388, __extension__ __PRETTY_FUNCTION__))
# 388 "include/ufbx.h"
; return data[index]; } ufbx_real *begin() const { return data; } ufbx_real *end() const { return data + count; } template <typename T, typename S=typename ufbxi_type_is<T, decltype(ufbx_converter<T>::from_list((ufbx_real*)nullptr, (size_t)0))>::type> operator T() const { return ufbx_converter<T>::from_list(data, count); } };
struct ufbx_vec2_list { ufbx_vec2 *data; size_t count; ufbx_vec2 &operator[](size_t index) const { 
# 389 "include/ufbx.h" 3 4
(static_cast <bool> (
# 389 "include/ufbx.h"
index < count
# 389 "include/ufbx.h" 3 4
) ? void (0) : __assert_fail (
# 389 "include/ufbx.h"
"index < count"
# 389 "include/ufbx.h" 3 4
, "include/ufbx.h", 389, __extension__ __PRETTY_FUNCTION__))
# 389 "include/ufbx.h"
; return data[index]; } ufbx_vec2 *begin() const { return data; } ufbx_vec2 *end() const { return data + count; } template <typename T, typename S=typename ufbxi_type_is<T, decltype(ufbx_converter<T>::from_list((ufbx_vec2*)nullptr, (size_t)0))>::type> operator T() const { return ufbx_converter<T>::from_list(data, count); } };
struct ufbx_vec3_list { ufbx_vec3 *data; size_t count; ufbx_vec3 &operator[](size_t index) const { 
# 390 "include/ufbx.h" 3 4
(static_cast <bool> (
# 390 "include/ufbx.h"
index < count
# 390 "include/ufbx.h" 3 4
) ? void (0) : __assert_fail (
# 390 "include/ufbx.h"
"index < count"
# 390 "include/ufbx.h" 3 4
, "include/ufbx.h", 390, __extension__ __PRETTY_FUNCTION__))
# 390 "include/ufbx.h"
; return data[index]; } ufbx_vec3 *begin() const { return data; } ufbx_vec3 *end() const { return data + count; } template <typename T, typename S=typename ufbxi_type_is<T, decltype(ufbx_converter<T>::from_list((ufbx_vec3*)nullptr, (size_t)0))>::type> operator T() const { return ufbx_converter<T>::from_list(data, count); } };
struct ufbx_vec4_list { ufbx_vec4 *data; size_t count; ufbx_vec4 &operator[](size_t index) const { 
# 391 "include/ufbx.h" 3 4
(static_cast <bool> (
# 391 "include/ufbx.h"
index < count
# 391 "include/ufbx.h" 3 4
) ? void (0) : __assert_fail (
# 391 "include/ufbx.h"
"index < count"
# 391 "include/ufbx.h" 3 4
, "include/ufbx.h", 391, __extension__ __PRETTY_FUNCTION__))
# 391 "include/ufbx.h"
; return data[index]; } ufbx_vec4 *begin() const { return data; } ufbx_vec4 *end() const { return data + count; } template <typename T, typename S=typename ufbxi_type_is<T, decltype(ufbx_converter<T>::from_list((ufbx_vec4*)nullptr, (size_t)0))>::type> operator T() const { return ufbx_converter<T>::from_list(data, count); } };
struct ufbx_string_list { ufbx_string *data; size_t count; ufbx_string &operator[](size_t index) const { 
# 392 "include/ufbx.h" 3 4
(static_cast <bool> (
# 392 "include/ufbx.h"
index < count
# 392 "include/ufbx.h" 3 4
) ? void (0) : __assert_fail (
# 392 "include/ufbx.h"
"index < count"
# 392 "include/ufbx.h" 3 4
, "include/ufbx.h", 392, __extension__ __PRETTY_FUNCTION__))
# 392 "include/ufbx.h"
; return data[index]; } ufbx_string *begin() const { return data; } ufbx_string *end() const { return data + count; } template <typename T, typename S=typename ufbxi_type_is<T, decltype(ufbx_converter<T>::from_list((ufbx_string*)nullptr, (size_t)0))>::type> operator T() const { return ufbx_converter<T>::from_list(data, count); } };






typedef enum ufbx_dom_value_type {
 UFBX_DOM_VALUE_NUMBER,
 UFBX_DOM_VALUE_STRING,
 UFBX_DOM_VALUE_ARRAY_I8,
 UFBX_DOM_VALUE_ARRAY_I32,
 UFBX_DOM_VALUE_ARRAY_I64,
 UFBX_DOM_VALUE_ARRAY_F32,
 UFBX_DOM_VALUE_ARRAY_F64,
 UFBX_DOM_VALUE_ARRAY_RAW_STRING,
 UFBX_DOM_VALUE_ARRAY_IGNORED,

 UFBX_DOM_VALUE_TYPE_FORCE_32BIT = 0x7fffffff
} ufbx_dom_value_type;

enum { UFBX_DOM_VALUE_TYPE_COUNT = UFBX_DOM_VALUE_ARRAY_IGNORED + 1 };

typedef struct ufbx_dom_node ufbx_dom_node;

typedef struct ufbx_dom_value {
 ufbx_dom_value_type type;
 ufbx_string value_str;
 ufbx_blob value_blob;
 int64_t value_int;
 double value_float;
} ufbx_dom_value;

struct ufbx_dom_node_list { ufbx_dom_node* *data; size_t count; ufbx_dom_node* &operator[](size_t index) const { 
# 425 "include/ufbx.h" 3 4
(static_cast <bool> (
# 425 "include/ufbx.h"
index < count
# 425 "include/ufbx.h" 3 4
) ? void (0) : __assert_fail (
# 425 "include/ufbx.h"
"index < count"
# 425 "include/ufbx.h" 3 4
, "include/ufbx.h", 425, __extension__ __PRETTY_FUNCTION__))
# 425 "include/ufbx.h"
; return data[index]; } ufbx_dom_node* *begin() const { return data; } ufbx_dom_node* *end() const { return data + count; } template <typename T, typename S=typename ufbxi_type_is<T, decltype(ufbx_converter<T>::from_list((ufbx_dom_node**)nullptr, (size_t)0))>::type> operator T() const { return ufbx_converter<T>::from_list(data, count); } };
struct ufbx_dom_value_list { ufbx_dom_value *data; size_t count; ufbx_dom_value &operator[](size_t index) const { 
# 426 "include/ufbx.h" 3 4
(static_cast <bool> (
# 426 "include/ufbx.h"
index < count
# 426 "include/ufbx.h" 3 4
) ? void (0) : __assert_fail (
# 426 "include/ufbx.h"
"index < count"
# 426 "include/ufbx.h" 3 4
, "include/ufbx.h", 426, __extension__ __PRETTY_FUNCTION__))
# 426 "include/ufbx.h"
; return data[index]; } ufbx_dom_value *begin() const { return data; } ufbx_dom_value *end() const { return data + count; } template <typename T, typename S=typename ufbxi_type_is<T, decltype(ufbx_converter<T>::from_list((ufbx_dom_value*)nullptr, (size_t)0))>::type> operator T() const { return ufbx_converter<T>::from_list(data, count); } };

struct ufbx_dom_node {
 ufbx_string name;
 ufbx_dom_node_list children;
 ufbx_dom_value_list values;
};
# 442 "include/ufbx.h"
typedef struct ufbx_prop ufbx_prop;
typedef struct ufbx_props ufbx_props;





typedef enum ufbx_prop_type {
 UFBX_PROP_UNKNOWN,
 UFBX_PROP_BOOLEAN,
 UFBX_PROP_INTEGER,
 UFBX_PROP_NUMBER,
 UFBX_PROP_VECTOR,
 UFBX_PROP_COLOR,
 UFBX_PROP_COLOR_WITH_ALPHA,
 UFBX_PROP_STRING,
 UFBX_PROP_DATE_TIME,
 UFBX_PROP_TRANSLATION,
 UFBX_PROP_ROTATION,
 UFBX_PROP_SCALING,
 UFBX_PROP_DISTANCE,
 UFBX_PROP_COMPOUND,
 UFBX_PROP_BLOB,
 UFBX_PROP_REFERENCE,

 UFBX_PROP_TYPE_FORCE_32BIT = 0x7fffffff
} ufbx_prop_type;

enum { UFBX_PROP_TYPE_COUNT = UFBX_PROP_REFERENCE + 1 };


typedef enum ufbx_prop_flags {


 UFBX_PROP_FLAG_ANIMATABLE = 0x1,


 UFBX_PROP_FLAG_USER_DEFINED = 0x2,


 UFBX_PROP_FLAG_HIDDEN = 0x4,


 UFBX_PROP_FLAG_LOCK_X = 0x10,
 UFBX_PROP_FLAG_LOCK_Y = 0x20,
 UFBX_PROP_FLAG_LOCK_Z = 0x40,
 UFBX_PROP_FLAG_LOCK_W = 0x80,


 UFBX_PROP_FLAG_MUTE_X = 0x100,
 UFBX_PROP_FLAG_MUTE_Y = 0x200,
 UFBX_PROP_FLAG_MUTE_Z = 0x400,
 UFBX_PROP_FLAG_MUTE_W = 0x800,




 UFBX_PROP_FLAG_SYNTHETIC = 0x1000,


 UFBX_PROP_FLAG_ANIMATED = 0x2000,


 UFBX_PROP_FLAG_NOT_FOUND = 0x4000,





 UFBX_PROP_FLAG_CONNECTED = 0x8000,


 UFBX_PROP_FLAG_NO_VALUE = 0x10000,



 UFBX_PROP_FLAG_OVERRIDDEN = 0x20000,




 UFBX_PROP_FLAG_VALUE_REAL = 0x100000,
 UFBX_PROP_FLAG_VALUE_VEC2 = 0x200000,
 UFBX_PROP_FLAG_VALUE_VEC3 = 0x400000,
 UFBX_PROP_FLAG_VALUE_VEC4 = 0x800000,
 UFBX_PROP_FLAG_VALUE_INT = 0x1000000,
 UFBX_PROP_FLAG_VALUE_STR = 0x2000000,
 UFBX_PROP_FLAG_VALUE_BLOB = 0x4000000,

 UFBX_PROP_FLAGS_FORCE_32BIT = 0x7fffffff
} ufbx_prop_flags;


struct ufbx_prop {
 ufbx_string name;

 uint32_t _internal_key;

 ufbx_prop_type type;
 ufbx_prop_flags flags;

 ufbx_string value_str;
 ufbx_blob value_blob;
 int64_t value_int;
 union {
  ufbx_real value_real_arr[4];
  ufbx_real value_real;
  ufbx_vec2 value_vec2;
  ufbx_vec3 value_vec3;
  ufbx_vec4 value_vec4;
 };
};

struct ufbx_prop_list { ufbx_prop *data; size_t count; ufbx_prop &operator[](size_t index) const { 
# 555 "include/ufbx.h" 3 4
(static_cast <bool> (
# 555 "include/ufbx.h"
index < count
# 555 "include/ufbx.h" 3 4
) ? void (0) : __assert_fail (
# 555 "include/ufbx.h"
"index < count"
# 555 "include/ufbx.h" 3 4
, "include/ufbx.h", 555, __extension__ __PRETTY_FUNCTION__))
# 555 "include/ufbx.h"
; return data[index]; } ufbx_prop *begin() const { return data; } ufbx_prop *end() const { return data + count; } template <typename T, typename S=typename ufbxi_type_is<T, decltype(ufbx_converter<T>::from_list((ufbx_prop*)nullptr, (size_t)0))>::type> operator T() const { return ufbx_converter<T>::from_list(data, count); } };




struct ufbx_props {
 ufbx_prop_list props;
 size_t num_animated;

 ufbx_props *defaults;
};

typedef struct ufbx_scene ufbx_scene;







typedef struct ufbx_element ufbx_element;


typedef struct ufbx_unknown ufbx_unknown;


typedef struct ufbx_node ufbx_node;


typedef struct ufbx_mesh ufbx_mesh;
typedef struct ufbx_light ufbx_light;
typedef struct ufbx_camera ufbx_camera;
typedef struct ufbx_bone ufbx_bone;
typedef struct ufbx_empty ufbx_empty;


typedef struct ufbx_line_curve ufbx_line_curve;
typedef struct ufbx_nurbs_curve ufbx_nurbs_curve;
typedef struct ufbx_nurbs_surface ufbx_nurbs_surface;
typedef struct ufbx_nurbs_trim_surface ufbx_nurbs_trim_surface;
typedef struct ufbx_nurbs_trim_boundary ufbx_nurbs_trim_boundary;


typedef struct ufbx_procedural_geometry ufbx_procedural_geometry;
typedef struct ufbx_stereo_camera ufbx_stereo_camera;
typedef struct ufbx_camera_switcher ufbx_camera_switcher;
typedef struct ufbx_marker ufbx_marker;
typedef struct ufbx_lod_group ufbx_lod_group;


typedef struct ufbx_skin_deformer ufbx_skin_deformer;
typedef struct ufbx_skin_cluster ufbx_skin_cluster;
typedef struct ufbx_blend_deformer ufbx_blend_deformer;
typedef struct ufbx_blend_channel ufbx_blend_channel;
typedef struct ufbx_blend_shape ufbx_blend_shape;
typedef struct ufbx_cache_deformer ufbx_cache_deformer;
typedef struct ufbx_cache_file ufbx_cache_file;


typedef struct ufbx_material ufbx_material;
typedef struct ufbx_texture ufbx_texture;
typedef struct ufbx_video ufbx_video;
typedef struct ufbx_shader ufbx_shader;
typedef struct ufbx_shader_binding ufbx_shader_binding;


typedef struct ufbx_anim_stack ufbx_anim_stack;
typedef struct ufbx_anim_layer ufbx_anim_layer;
typedef struct ufbx_anim_value ufbx_anim_value;
typedef struct ufbx_anim_curve ufbx_anim_curve;


typedef struct ufbx_display_layer ufbx_display_layer;
typedef struct ufbx_selection_set ufbx_selection_set;
typedef struct ufbx_selection_node ufbx_selection_node;


typedef struct ufbx_character ufbx_character;
typedef struct ufbx_constraint ufbx_constraint;


typedef struct ufbx_audio_layer ufbx_audio_layer;
typedef struct ufbx_audio_clip ufbx_audio_clip;


typedef struct ufbx_pose ufbx_pose;
typedef struct ufbx_metadata_object ufbx_metadata_object;

struct ufbx_element_list { ufbx_element* *data; size_t count; ufbx_element* &operator[](size_t index) const { 
# 643 "include/ufbx.h" 3 4
(static_cast <bool> (
# 643 "include/ufbx.h"
index < count
# 643 "include/ufbx.h" 3 4
) ? void (0) : __assert_fail (
# 643 "include/ufbx.h"
"index < count"
# 643 "include/ufbx.h" 3 4
, "include/ufbx.h", 643, __extension__ __PRETTY_FUNCTION__))
# 643 "include/ufbx.h"
; return data[index]; } ufbx_element* *begin() const { return data; } ufbx_element* *end() const { return data + count; } template <typename T, typename S=typename ufbxi_type_is<T, decltype(ufbx_converter<T>::from_list((ufbx_element**)nullptr, (size_t)0))>::type> operator T() const { return ufbx_converter<T>::from_list(data, count); } };
struct ufbx_unknown_list { ufbx_unknown* *data; size_t count; ufbx_unknown* &operator[](size_t index) const { 
# 644 "include/ufbx.h" 3 4
(static_cast <bool> (
# 644 "include/ufbx.h"
index < count
# 644 "include/ufbx.h" 3 4
) ? void (0) : __assert_fail (
# 644 "include/ufbx.h"
"index < count"
# 644 "include/ufbx.h" 3 4
, "include/ufbx.h", 644, __extension__ __PRETTY_FUNCTION__))
# 644 "include/ufbx.h"
; return data[index]; } ufbx_unknown* *begin() const { return data; } ufbx_unknown* *end() const { return data + count; } template <typename T, typename S=typename ufbxi_type_is<T, decltype(ufbx_converter<T>::from_list((ufbx_unknown**)nullptr, (size_t)0))>::type> operator T() const { return ufbx_converter<T>::from_list(data, count); } };
struct ufbx_node_list { ufbx_node* *data; size_t count; ufbx_node* &operator[](size_t index) const { 
# 645 "include/ufbx.h" 3 4
(static_cast <bool> (
# 645 "include/ufbx.h"
index < count
# 645 "include/ufbx.h" 3 4
) ? void (0) : __assert_fail (
# 645 "include/ufbx.h"
"index < count"
# 645 "include/ufbx.h" 3 4
, "include/ufbx.h", 645, __extension__ __PRETTY_FUNCTION__))
# 645 "include/ufbx.h"
; return data[index]; } ufbx_node* *begin() const { return data; } ufbx_node* *end() const { return data + count; } template <typename T, typename S=typename ufbxi_type_is<T, decltype(ufbx_converter<T>::from_list((ufbx_node**)nullptr, (size_t)0))>::type> operator T() const { return ufbx_converter<T>::from_list(data, count); } };
struct ufbx_mesh_list { ufbx_mesh* *data; size_t count; ufbx_mesh* &operator[](size_t index) const { 
# 646 "include/ufbx.h" 3 4
(static_cast <bool> (
# 646 "include/ufbx.h"
index < count
# 646 "include/ufbx.h" 3 4
) ? void (0) : __assert_fail (
# 646 "include/ufbx.h"
"index < count"
# 646 "include/ufbx.h" 3 4
, "include/ufbx.h", 646, __extension__ __PRETTY_FUNCTION__))
# 646 "include/ufbx.h"
; return data[index]; } ufbx_mesh* *begin() const { return data; } ufbx_mesh* *end() const { return data + count; } template <typename T, typename S=typename ufbxi_type_is<T, decltype(ufbx_converter<T>::from_list((ufbx_mesh**)nullptr, (size_t)0))>::type> operator T() const { return ufbx_converter<T>::from_list(data, count); } };
struct ufbx_light_list { ufbx_light* *data; size_t count; ufbx_light* &operator[](size_t index) const { 
# 647 "include/ufbx.h" 3 4
(static_cast <bool> (
# 647 "include/ufbx.h"
index < count
# 647 "include/ufbx.h" 3 4
) ? void (0) : __assert_fail (
# 647 "include/ufbx.h"
"index < count"
# 647 "include/ufbx.h" 3 4
, "include/ufbx.h", 647, __extension__ __PRETTY_FUNCTION__))
# 647 "include/ufbx.h"
; return data[index]; } ufbx_light* *begin() const { return data; } ufbx_light* *end() const { return data + count; } template <typename T, typename S=typename ufbxi_type_is<T, decltype(ufbx_converter<T>::from_list((ufbx_light**)nullptr, (size_t)0))>::type> operator T() const { return ufbx_converter<T>::from_list(data, count); } };
struct ufbx_camera_list { ufbx_camera* *data; size_t count; ufbx_camera* &operator[](size_t index) const { 
# 648 "include/ufbx.h" 3 4
(static_cast <bool> (
# 648 "include/ufbx.h"
index < count
# 648 "include/ufbx.h" 3 4
) ? void (0) : __assert_fail (
# 648 "include/ufbx.h"
"index < count"
# 648 "include/ufbx.h" 3 4
, "include/ufbx.h", 648, __extension__ __PRETTY_FUNCTION__))
# 648 "include/ufbx.h"
; return data[index]; } ufbx_camera* *begin() const { return data; } ufbx_camera* *end() const { return data + count; } template <typename T, typename S=typename ufbxi_type_is<T, decltype(ufbx_converter<T>::from_list((ufbx_camera**)nullptr, (size_t)0))>::type> operator T() const { return ufbx_converter<T>::from_list(data, count); } };
struct ufbx_bone_list { ufbx_bone* *data; size_t count; ufbx_bone* &operator[](size_t index) const { 
# 649 "include/ufbx.h" 3 4
(static_cast <bool> (
# 649 "include/ufbx.h"
index < count
# 649 "include/ufbx.h" 3 4
) ? void (0) : __assert_fail (
# 649 "include/ufbx.h"
"index < count"
# 649 "include/ufbx.h" 3 4
, "include/ufbx.h", 649, __extension__ __PRETTY_FUNCTION__))
# 649 "include/ufbx.h"
; return data[index]; } ufbx_bone* *begin() const { return data; } ufbx_bone* *end() const { return data + count; } template <typename T, typename S=typename ufbxi_type_is<T, decltype(ufbx_converter<T>::from_list((ufbx_bone**)nullptr, (size_t)0))>::type> operator T() const { return ufbx_converter<T>::from_list(data, count); } };
struct ufbx_empty_list { ufbx_empty* *data; size_t count; ufbx_empty* &operator[](size_t index) const { 
# 650 "include/ufbx.h" 3 4
(static_cast <bool> (
# 650 "include/ufbx.h"
index < count
# 650 "include/ufbx.h" 3 4
) ? void (0) : __assert_fail (
# 650 "include/ufbx.h"
"index < count"
# 650 "include/ufbx.h" 3 4
, "include/ufbx.h", 650, __extension__ __PRETTY_FUNCTION__))
# 650 "include/ufbx.h"
; return data[index]; } ufbx_empty* *begin() const { return data; } ufbx_empty* *end() const { return data + count; } template <typename T, typename S=typename ufbxi_type_is<T, decltype(ufbx_converter<T>::from_list((ufbx_empty**)nullptr, (size_t)0))>::type> operator T() const { return ufbx_converter<T>::from_list(data, count); } };
struct ufbx_line_curve_list { ufbx_line_curve* *data; size_t count; ufbx_line_curve* &operator[](size_t index) const { 
# 651 "include/ufbx.h" 3 4
(static_cast <bool> (
# 651 "include/ufbx.h"
index < count
# 651 "include/ufbx.h" 3 4
) ? void (0) : __assert_fail (
# 651 "include/ufbx.h"
"index < count"
# 651 "include/ufbx.h" 3 4
, "include/ufbx.h", 651, __extension__ __PRETTY_FUNCTION__))
# 651 "include/ufbx.h"
; return data[index]; } ufbx_line_curve* *begin() const { return data; } ufbx_line_curve* *end() const { return data + count; } template <typename T, typename S=typename ufbxi_type_is<T, decltype(ufbx_converter<T>::from_list((ufbx_line_curve**)nullptr, (size_t)0))>::type> operator T() const { return ufbx_converter<T>::from_list(data, count); } };
struct ufbx_nurbs_curve_list { ufbx_nurbs_curve* *data; size_t count; ufbx_nurbs_curve* &operator[](size_t index) const { 
# 652 "include/ufbx.h" 3 4
(static_cast <bool> (
# 652 "include/ufbx.h"
index < count
# 652 "include/ufbx.h" 3 4
) ? void (0) : __assert_fail (
# 652 "include/ufbx.h"
"index < count"
# 652 "include/ufbx.h" 3 4
, "include/ufbx.h", 652, __extension__ __PRETTY_FUNCTION__))
# 652 "include/ufbx.h"
; return data[index]; } ufbx_nurbs_curve* *begin() const { return data; } ufbx_nurbs_curve* *end() const { return data + count; } template <typename T, typename S=typename ufbxi_type_is<T, decltype(ufbx_converter<T>::from_list((ufbx_nurbs_curve**)nullptr, (size_t)0))>::type> operator T() const { return ufbx_converter<T>::from_list(data, count); } };
struct ufbx_nurbs_surface_list { ufbx_nurbs_surface* *data; size_t count; ufbx_nurbs_surface* &operator[](size_t index) const { 
# 653 "include/ufbx.h" 3 4
(static_cast <bool> (
# 653 "include/ufbx.h"
index < count
# 653 "include/ufbx.h" 3 4
) ? void (0) : __assert_fail (
# 653 "include/ufbx.h"
"index < count"
# 653 "include/ufbx.h" 3 4
, "include/ufbx.h", 653, __extension__ __PRETTY_FUNCTION__))
# 653 "include/ufbx.h"
; return data[index]; } ufbx_nurbs_surface* *begin() const { return data; } ufbx_nurbs_surface* *end() const { return data + count; } template <typename T, typename S=typename ufbxi_type_is<T, decltype(ufbx_converter<T>::from_list((ufbx_nurbs_surface**)nullptr, (size_t)0))>::type> operator T() const { return ufbx_converter<T>::from_list(data, count); } };
struct ufbx_nurbs_trim_surface_list { ufbx_nurbs_trim_surface* *data; size_t count; ufbx_nurbs_trim_surface* &operator[](size_t index) const { 
# 654 "include/ufbx.h" 3 4
(static_cast <bool> (
# 654 "include/ufbx.h"
index < count
# 654 "include/ufbx.h" 3 4
) ? void (0) : __assert_fail (
# 654 "include/ufbx.h"
"index < count"
# 654 "include/ufbx.h" 3 4
, "include/ufbx.h", 654, __extension__ __PRETTY_FUNCTION__))
# 654 "include/ufbx.h"
; return data[index]; } ufbx_nurbs_trim_surface* *begin() const { return data; } ufbx_nurbs_trim_surface* *end() const { return data + count; } template <typename T, typename S=typename ufbxi_type_is<T, decltype(ufbx_converter<T>::from_list((ufbx_nurbs_trim_surface**)nullptr, (size_t)0))>::type> operator T() const { return ufbx_converter<T>::from_list(data, count); } };
struct ufbx_nurbs_trim_boundary_list { ufbx_nurbs_trim_boundary* *data; size_t count; ufbx_nurbs_trim_boundary* &operator[](size_t index) const { 
# 655 "include/ufbx.h" 3 4
(static_cast <bool> (
# 655 "include/ufbx.h"
index < count
# 655 "include/ufbx.h" 3 4
) ? void (0) : __assert_fail (
# 655 "include/ufbx.h"
"index < count"
# 655 "include/ufbx.h" 3 4
, "include/ufbx.h", 655, __extension__ __PRETTY_FUNCTION__))
# 655 "include/ufbx.h"
; return data[index]; } ufbx_nurbs_trim_boundary* *begin() const { return data; } ufbx_nurbs_trim_boundary* *end() const { return data + count; } template <typename T, typename S=typename ufbxi_type_is<T, decltype(ufbx_converter<T>::from_list((ufbx_nurbs_trim_boundary**)nullptr, (size_t)0))>::type> operator T() const { return ufbx_converter<T>::from_list(data, count); } };
struct ufbx_procedural_geometry_list { ufbx_procedural_geometry* *data; size_t count; ufbx_procedural_geometry* &operator[](size_t index) const { 
# 656 "include/ufbx.h" 3 4
(static_cast <bool> (
# 656 "include/ufbx.h"
index < count
# 656 "include/ufbx.h" 3 4
) ? void (0) : __assert_fail (
# 656 "include/ufbx.h"
"index < count"
# 656 "include/ufbx.h" 3 4
, "include/ufbx.h", 656, __extension__ __PRETTY_FUNCTION__))
# 656 "include/ufbx.h"
; return data[index]; } ufbx_procedural_geometry* *begin() const { return data; } ufbx_procedural_geometry* *end() const { return data + count; } template <typename T, typename S=typename ufbxi_type_is<T, decltype(ufbx_converter<T>::from_list((ufbx_procedural_geometry**)nullptr, (size_t)0))>::type> operator T() const { return ufbx_converter<T>::from_list(data, count); } };
struct ufbx_stereo_camera_list { ufbx_stereo_camera* *data; size_t count; ufbx_stereo_camera* &operator[](size_t index) const { 
# 657 "include/ufbx.h" 3 4
(static_cast <bool> (
# 657 "include/ufbx.h"
index < count
# 657 "include/ufbx.h" 3 4
) ? void (0) : __assert_fail (
# 657 "include/ufbx.h"
"index < count"
# 657 "include/ufbx.h" 3 4
, "include/ufbx.h", 657, __extension__ __PRETTY_FUNCTION__))
# 657 "include/ufbx.h"
; return data[index]; } ufbx_stereo_camera* *begin() const { return data; } ufbx_stereo_camera* *end() const { return data + count; } template <typename T, typename S=typename ufbxi_type_is<T, decltype(ufbx_converter<T>::from_list((ufbx_stereo_camera**)nullptr, (size_t)0))>::type> operator T() const { return ufbx_converter<T>::from_list(data, count); } };
struct ufbx_camera_switcher_list { ufbx_camera_switcher* *data; size_t count; ufbx_camera_switcher* &operator[](size_t index) const { 
# 658 "include/ufbx.h" 3 4
(static_cast <bool> (
# 658 "include/ufbx.h"
index < count
# 658 "include/ufbx.h" 3 4
) ? void (0) : __assert_fail (
# 658 "include/ufbx.h"
"index < count"
# 658 "include/ufbx.h" 3 4
, "include/ufbx.h", 658, __extension__ __PRETTY_FUNCTION__))
# 658 "include/ufbx.h"
; return data[index]; } ufbx_camera_switcher* *begin() const { return data; } ufbx_camera_switcher* *end() const { return data + count; } template <typename T, typename S=typename ufbxi_type_is<T, decltype(ufbx_converter<T>::from_list((ufbx_camera_switcher**)nullptr, (size_t)0))>::type> operator T() const { return ufbx_converter<T>::from_list(data, count); } };
struct ufbx_marker_list { ufbx_marker* *data; size_t count; ufbx_marker* &operator[](size_t index) const { 
# 659 "include/ufbx.h" 3 4
(static_cast <bool> (
# 659 "include/ufbx.h"
index < count
# 659 "include/ufbx.h" 3 4
) ? void (0) : __assert_fail (
# 659 "include/ufbx.h"
"index < count"
# 659 "include/ufbx.h" 3 4
, "include/ufbx.h", 659, __extension__ __PRETTY_FUNCTION__))
# 659 "include/ufbx.h"
; return data[index]; } ufbx_marker* *begin() const { return data; } ufbx_marker* *end() const { return data + count; } template <typename T, typename S=typename ufbxi_type_is<T, decltype(ufbx_converter<T>::from_list((ufbx_marker**)nullptr, (size_t)0))>::type> operator T() const { return ufbx_converter<T>::from_list(data, count); } };
struct ufbx_lod_group_list { ufbx_lod_group* *data; size_t count; ufbx_lod_group* &operator[](size_t index) const { 
# 660 "include/ufbx.h" 3 4
(static_cast <bool> (
# 660 "include/ufbx.h"
index < count
# 660 "include/ufbx.h" 3 4
) ? void (0) : __assert_fail (
# 660 "include/ufbx.h"
"index < count"
# 660 "include/ufbx.h" 3 4
, "include/ufbx.h", 660, __extension__ __PRETTY_FUNCTION__))
# 660 "include/ufbx.h"
; return data[index]; } ufbx_lod_group* *begin() const { return data; } ufbx_lod_group* *end() const { return data + count; } template <typename T, typename S=typename ufbxi_type_is<T, decltype(ufbx_converter<T>::from_list((ufbx_lod_group**)nullptr, (size_t)0))>::type> operator T() const { return ufbx_converter<T>::from_list(data, count); } };
struct ufbx_skin_deformer_list { ufbx_skin_deformer* *data; size_t count; ufbx_skin_deformer* &operator[](size_t index) const { 
# 661 "include/ufbx.h" 3 4
(static_cast <bool> (
# 661 "include/ufbx.h"
index < count
# 661 "include/ufbx.h" 3 4
) ? void (0) : __assert_fail (
# 661 "include/ufbx.h"
"index < count"
# 661 "include/ufbx.h" 3 4
, "include/ufbx.h", 661, __extension__ __PRETTY_FUNCTION__))
# 661 "include/ufbx.h"
; return data[index]; } ufbx_skin_deformer* *begin() const { return data; } ufbx_skin_deformer* *end() const { return data + count; } template <typename T, typename S=typename ufbxi_type_is<T, decltype(ufbx_converter<T>::from_list((ufbx_skin_deformer**)nullptr, (size_t)0))>::type> operator T() const { return ufbx_converter<T>::from_list(data, count); } };
struct ufbx_skin_cluster_list { ufbx_skin_cluster* *data; size_t count; ufbx_skin_cluster* &operator[](size_t index) const { 
# 662 "include/ufbx.h" 3 4
(static_cast <bool> (
# 662 "include/ufbx.h"
index < count
# 662 "include/ufbx.h" 3 4
) ? void (0) : __assert_fail (
# 662 "include/ufbx.h"
"index < count"
# 662 "include/ufbx.h" 3 4
, "include/ufbx.h", 662, __extension__ __PRETTY_FUNCTION__))
# 662 "include/ufbx.h"
; return data[index]; } ufbx_skin_cluster* *begin() const { return data; } ufbx_skin_cluster* *end() const { return data + count; } template <typename T, typename S=typename ufbxi_type_is<T, decltype(ufbx_converter<T>::from_list((ufbx_skin_cluster**)nullptr, (size_t)0))>::type> operator T() const { return ufbx_converter<T>::from_list(data, count); } };
struct ufbx_blend_deformer_list { ufbx_blend_deformer* *data; size_t count; ufbx_blend_deformer* &operator[](size_t index) const { 
# 663 "include/ufbx.h" 3 4
(static_cast <bool> (
# 663 "include/ufbx.h"
index < count
# 663 "include/ufbx.h" 3 4
) ? void (0) : __assert_fail (
# 663 "include/ufbx.h"
"index < count"
# 663 "include/ufbx.h" 3 4
, "include/ufbx.h", 663, __extension__ __PRETTY_FUNCTION__))
# 663 "include/ufbx.h"
; return data[index]; } ufbx_blend_deformer* *begin() const { return data; } ufbx_blend_deformer* *end() const { return data + count; } template <typename T, typename S=typename ufbxi_type_is<T, decltype(ufbx_converter<T>::from_list((ufbx_blend_deformer**)nullptr, (size_t)0))>::type> operator T() const { return ufbx_converter<T>::from_list(data, count); } };
struct ufbx_blend_channel_list { ufbx_blend_channel* *data; size_t count; ufbx_blend_channel* &operator[](size_t index) const { 
# 664 "include/ufbx.h" 3 4
(static_cast <bool> (
# 664 "include/ufbx.h"
index < count
# 664 "include/ufbx.h" 3 4
) ? void (0) : __assert_fail (
# 664 "include/ufbx.h"
"index < count"
# 664 "include/ufbx.h" 3 4
, "include/ufbx.h", 664, __extension__ __PRETTY_FUNCTION__))
# 664 "include/ufbx.h"
; return data[index]; } ufbx_blend_channel* *begin() const { return data; } ufbx_blend_channel* *end() const { return data + count; } template <typename T, typename S=typename ufbxi_type_is<T, decltype(ufbx_converter<T>::from_list((ufbx_blend_channel**)nullptr, (size_t)0))>::type> operator T() const { return ufbx_converter<T>::from_list(data, count); } };
struct ufbx_blend_shape_list { ufbx_blend_shape* *data; size_t count; ufbx_blend_shape* &operator[](size_t index) const { 
# 665 "include/ufbx.h" 3 4
(static_cast <bool> (
# 665 "include/ufbx.h"
index < count
# 665 "include/ufbx.h" 3 4
) ? void (0) : __assert_fail (
# 665 "include/ufbx.h"
"index < count"
# 665 "include/ufbx.h" 3 4
, "include/ufbx.h", 665, __extension__ __PRETTY_FUNCTION__))
# 665 "include/ufbx.h"
; return data[index]; } ufbx_blend_shape* *begin() const { return data; } ufbx_blend_shape* *end() const { return data + count; } template <typename T, typename S=typename ufbxi_type_is<T, decltype(ufbx_converter<T>::from_list((ufbx_blend_shape**)nullptr, (size_t)0))>::type> operator T() const { return ufbx_converter<T>::from_list(data, count); } };
struct ufbx_cache_deformer_list { ufbx_cache_deformer* *data; size_t count; ufbx_cache_deformer* &operator[](size_t index) const { 
# 666 "include/ufbx.h" 3 4
(static_cast <bool> (
# 666 "include/ufbx.h"
index < count
# 666 "include/ufbx.h" 3 4
) ? void (0) : __assert_fail (
# 666 "include/ufbx.h"
"index < count"
# 666 "include/ufbx.h" 3 4
, "include/ufbx.h", 666, __extension__ __PRETTY_FUNCTION__))
# 666 "include/ufbx.h"
; return data[index]; } ufbx_cache_deformer* *begin() const { return data; } ufbx_cache_deformer* *end() const { return data + count; } template <typename T, typename S=typename ufbxi_type_is<T, decltype(ufbx_converter<T>::from_list((ufbx_cache_deformer**)nullptr, (size_t)0))>::type> operator T() const { return ufbx_converter<T>::from_list(data, count); } };
struct ufbx_cache_file_list { ufbx_cache_file* *data; size_t count; ufbx_cache_file* &operator[](size_t index) const { 
# 667 "include/ufbx.h" 3 4
(static_cast <bool> (
# 667 "include/ufbx.h"
index < count
# 667 "include/ufbx.h" 3 4
) ? void (0) : __assert_fail (
# 667 "include/ufbx.h"
"index < count"
# 667 "include/ufbx.h" 3 4
, "include/ufbx.h", 667, __extension__ __PRETTY_FUNCTION__))
# 667 "include/ufbx.h"
; return data[index]; } ufbx_cache_file* *begin() const { return data; } ufbx_cache_file* *end() const { return data + count; } template <typename T, typename S=typename ufbxi_type_is<T, decltype(ufbx_converter<T>::from_list((ufbx_cache_file**)nullptr, (size_t)0))>::type> operator T() const { return ufbx_converter<T>::from_list(data, count); } };
struct ufbx_material_list { ufbx_material* *data; size_t count; ufbx_material* &operator[](size_t index) const { 
# 668 "include/ufbx.h" 3 4
(static_cast <bool> (
# 668 "include/ufbx.h"
index < count
# 668 "include/ufbx.h" 3 4
) ? void (0) : __assert_fail (
# 668 "include/ufbx.h"
"index < count"
# 668 "include/ufbx.h" 3 4
, "include/ufbx.h", 668, __extension__ __PRETTY_FUNCTION__))
# 668 "include/ufbx.h"
; return data[index]; } ufbx_material* *begin() const { return data; } ufbx_material* *end() const { return data + count; } template <typename T, typename S=typename ufbxi_type_is<T, decltype(ufbx_converter<T>::from_list((ufbx_material**)nullptr, (size_t)0))>::type> operator T() const { return ufbx_converter<T>::from_list(data, count); } };
struct ufbx_texture_list { ufbx_texture* *data; size_t count; ufbx_texture* &operator[](size_t index) const { 
# 669 "include/ufbx.h" 3 4
(static_cast <bool> (
# 669 "include/ufbx.h"
index < count
# 669 "include/ufbx.h" 3 4
) ? void (0) : __assert_fail (
# 669 "include/ufbx.h"
"index < count"
# 669 "include/ufbx.h" 3 4
, "include/ufbx.h", 669, __extension__ __PRETTY_FUNCTION__))
# 669 "include/ufbx.h"
; return data[index]; } ufbx_texture* *begin() const { return data; } ufbx_texture* *end() const { return data + count; } template <typename T, typename S=typename ufbxi_type_is<T, decltype(ufbx_converter<T>::from_list((ufbx_texture**)nullptr, (size_t)0))>::type> operator T() const { return ufbx_converter<T>::from_list(data, count); } };
struct ufbx_video_list { ufbx_video* *data; size_t count; ufbx_video* &operator[](size_t index) const { 
# 670 "include/ufbx.h" 3 4
(static_cast <bool> (
# 670 "include/ufbx.h"
index < count
# 670 "include/ufbx.h" 3 4
) ? void (0) : __assert_fail (
# 670 "include/ufbx.h"
"index < count"
# 670 "include/ufbx.h" 3 4
, "include/ufbx.h", 670, __extension__ __PRETTY_FUNCTION__))
# 670 "include/ufbx.h"
; return data[index]; } ufbx_video* *begin() const { return data; } ufbx_video* *end() const { return data + count; } template <typename T, typename S=typename ufbxi_type_is<T, decltype(ufbx_converter<T>::from_list((ufbx_video**)nullptr, (size_t)0))>::type> operator T() const { return ufbx_converter<T>::from_list(data, count); } };
struct ufbx_shader_list { ufbx_shader* *data; size_t count; ufbx_shader* &operator[](size_t index) const { 
# 671 "include/ufbx.h" 3 4
(static_cast <bool> (
# 671 "include/ufbx.h"
index < count
# 671 "include/ufbx.h" 3 4
) ? void (0) : __assert_fail (
# 671 "include/ufbx.h"
"index < count"
# 671 "include/ufbx.h" 3 4
, "include/ufbx.h", 671, __extension__ __PRETTY_FUNCTION__))
# 671 "include/ufbx.h"
; return data[index]; } ufbx_shader* *begin() const { return data; } ufbx_shader* *end() const { return data + count; } template <typename T, typename S=typename ufbxi_type_is<T, decltype(ufbx_converter<T>::from_list((ufbx_shader**)nullptr, (size_t)0))>::type> operator T() const { return ufbx_converter<T>::from_list(data, count); } };
struct ufbx_shader_binding_list { ufbx_shader_binding* *data; size_t count; ufbx_shader_binding* &operator[](size_t index) const { 
# 672 "include/ufbx.h" 3 4
(static_cast <bool> (
# 672 "include/ufbx.h"
index < count
# 672 "include/ufbx.h" 3 4
) ? void (0) : __assert_fail (
# 672 "include/ufbx.h"
"index < count"
# 672 "include/ufbx.h" 3 4
, "include/ufbx.h", 672, __extension__ __PRETTY_FUNCTION__))
# 672 "include/ufbx.h"
; return data[index]; } ufbx_shader_binding* *begin() const { return data; } ufbx_shader_binding* *end() const { return data + count; } template <typename T, typename S=typename ufbxi_type_is<T, decltype(ufbx_converter<T>::from_list((ufbx_shader_binding**)nullptr, (size_t)0))>::type> operator T() const { return ufbx_converter<T>::from_list(data, count); } };
struct ufbx_anim_stack_list { ufbx_anim_stack* *data; size_t count; ufbx_anim_stack* &operator[](size_t index) const { 
# 673 "include/ufbx.h" 3 4
(static_cast <bool> (
# 673 "include/ufbx.h"
index < count
# 673 "include/ufbx.h" 3 4
) ? void (0) : __assert_fail (
# 673 "include/ufbx.h"
"index < count"
# 673 "include/ufbx.h" 3 4
, "include/ufbx.h", 673, __extension__ __PRETTY_FUNCTION__))
# 673 "include/ufbx.h"
; return data[index]; } ufbx_anim_stack* *begin() const { return data; } ufbx_anim_stack* *end() const { return data + count; } template <typename T, typename S=typename ufbxi_type_is<T, decltype(ufbx_converter<T>::from_list((ufbx_anim_stack**)nullptr, (size_t)0))>::type> operator T() const { return ufbx_converter<T>::from_list(data, count); } };
struct ufbx_anim_layer_list { ufbx_anim_layer* *data; size_t count; ufbx_anim_layer* &operator[](size_t index) const { 
# 674 "include/ufbx.h" 3 4
(static_cast <bool> (
# 674 "include/ufbx.h"
index < count
# 674 "include/ufbx.h" 3 4
) ? void (0) : __assert_fail (
# 674 "include/ufbx.h"
"index < count"
# 674 "include/ufbx.h" 3 4
, "include/ufbx.h", 674, __extension__ __PRETTY_FUNCTION__))
# 674 "include/ufbx.h"
; return data[index]; } ufbx_anim_layer* *begin() const { return data; } ufbx_anim_layer* *end() const { return data + count; } template <typename T, typename S=typename ufbxi_type_is<T, decltype(ufbx_converter<T>::from_list((ufbx_anim_layer**)nullptr, (size_t)0))>::type> operator T() const { return ufbx_converter<T>::from_list(data, count); } };
struct ufbx_anim_value_list { ufbx_anim_value* *data; size_t count; ufbx_anim_value* &operator[](size_t index) const { 
# 675 "include/ufbx.h" 3 4
(static_cast <bool> (
# 675 "include/ufbx.h"
index < count
# 675 "include/ufbx.h" 3 4
) ? void (0) : __assert_fail (
# 675 "include/ufbx.h"
"index < count"
# 675 "include/ufbx.h" 3 4
, "include/ufbx.h", 675, __extension__ __PRETTY_FUNCTION__))
# 675 "include/ufbx.h"
; return data[index]; } ufbx_anim_value* *begin() const { return data; } ufbx_anim_value* *end() const { return data + count; } template <typename T, typename S=typename ufbxi_type_is<T, decltype(ufbx_converter<T>::from_list((ufbx_anim_value**)nullptr, (size_t)0))>::type> operator T() const { return ufbx_converter<T>::from_list(data, count); } };
struct ufbx_anim_curve_list { ufbx_anim_curve* *data; size_t count; ufbx_anim_curve* &operator[](size_t index) const { 
# 676 "include/ufbx.h" 3 4
(static_cast <bool> (
# 676 "include/ufbx.h"
index < count
# 676 "include/ufbx.h" 3 4
) ? void (0) : __assert_fail (
# 676 "include/ufbx.h"
"index < count"
# 676 "include/ufbx.h" 3 4
, "include/ufbx.h", 676, __extension__ __PRETTY_FUNCTION__))
# 676 "include/ufbx.h"
; return data[index]; } ufbx_anim_curve* *begin() const { return data; } ufbx_anim_curve* *end() const { return data + count; } template <typename T, typename S=typename ufbxi_type_is<T, decltype(ufbx_converter<T>::from_list((ufbx_anim_curve**)nullptr, (size_t)0))>::type> operator T() const { return ufbx_converter<T>::from_list(data, count); } };
struct ufbx_display_layer_list { ufbx_display_layer* *data; size_t count; ufbx_display_layer* &operator[](size_t index) const { 
# 677 "include/ufbx.h" 3 4
(static_cast <bool> (
# 677 "include/ufbx.h"
index < count
# 677 "include/ufbx.h" 3 4
) ? void (0) : __assert_fail (
# 677 "include/ufbx.h"
"index < count"
# 677 "include/ufbx.h" 3 4
, "include/ufbx.h", 677, __extension__ __PRETTY_FUNCTION__))
# 677 "include/ufbx.h"
; return data[index]; } ufbx_display_layer* *begin() const { return data; } ufbx_display_layer* *end() const { return data + count; } template <typename T, typename S=typename ufbxi_type_is<T, decltype(ufbx_converter<T>::from_list((ufbx_display_layer**)nullptr, (size_t)0))>::type> operator T() const { return ufbx_converter<T>::from_list(data, count); } };
struct ufbx_selection_set_list { ufbx_selection_set* *data; size_t count; ufbx_selection_set* &operator[](size_t index) const { 
# 678 "include/ufbx.h" 3 4
(static_cast <bool> (
# 678 "include/ufbx.h"
index < count
# 678 "include/ufbx.h" 3 4
) ? void (0) : __assert_fail (
# 678 "include/ufbx.h"
"index < count"
# 678 "include/ufbx.h" 3 4
, "include/ufbx.h", 678, __extension__ __PRETTY_FUNCTION__))
# 678 "include/ufbx.h"
; return data[index]; } ufbx_selection_set* *begin() const { return data; } ufbx_selection_set* *end() const { return data + count; } template <typename T, typename S=typename ufbxi_type_is<T, decltype(ufbx_converter<T>::from_list((ufbx_selection_set**)nullptr, (size_t)0))>::type> operator T() const { return ufbx_converter<T>::from_list(data, count); } };
struct ufbx_selection_node_list { ufbx_selection_node* *data; size_t count; ufbx_selection_node* &operator[](size_t index) const { 
# 679 "include/ufbx.h" 3 4
(static_cast <bool> (
# 679 "include/ufbx.h"
index < count
# 679 "include/ufbx.h" 3 4
) ? void (0) : __assert_fail (
# 679 "include/ufbx.h"
"index < count"
# 679 "include/ufbx.h" 3 4
, "include/ufbx.h", 679, __extension__ __PRETTY_FUNCTION__))
# 679 "include/ufbx.h"
; return data[index]; } ufbx_selection_node* *begin() const { return data; } ufbx_selection_node* *end() const { return data + count; } template <typename T, typename S=typename ufbxi_type_is<T, decltype(ufbx_converter<T>::from_list((ufbx_selection_node**)nullptr, (size_t)0))>::type> operator T() const { return ufbx_converter<T>::from_list(data, count); } };
struct ufbx_character_list { ufbx_character* *data; size_t count; ufbx_character* &operator[](size_t index) const { 
# 680 "include/ufbx.h" 3 4
(static_cast <bool> (
# 680 "include/ufbx.h"
index < count
# 680 "include/ufbx.h" 3 4
) ? void (0) : __assert_fail (
# 680 "include/ufbx.h"
"index < count"
# 680 "include/ufbx.h" 3 4
, "include/ufbx.h", 680, __extension__ __PRETTY_FUNCTION__))
# 680 "include/ufbx.h"
; return data[index]; } ufbx_character* *begin() const { return data; } ufbx_character* *end() const { return data + count; } template <typename T, typename S=typename ufbxi_type_is<T, decltype(ufbx_converter<T>::from_list((ufbx_character**)nullptr, (size_t)0))>::type> operator T() const { return ufbx_converter<T>::from_list(data, count); } };
struct ufbx_constraint_list { ufbx_constraint* *data; size_t count; ufbx_constraint* &operator[](size_t index) const { 
# 681 "include/ufbx.h" 3 4
(static_cast <bool> (
# 681 "include/ufbx.h"
index < count
# 681 "include/ufbx.h" 3 4
) ? void (0) : __assert_fail (
# 681 "include/ufbx.h"
"index < count"
# 681 "include/ufbx.h" 3 4
, "include/ufbx.h", 681, __extension__ __PRETTY_FUNCTION__))
# 681 "include/ufbx.h"
; return data[index]; } ufbx_constraint* *begin() const { return data; } ufbx_constraint* *end() const { return data + count; } template <typename T, typename S=typename ufbxi_type_is<T, decltype(ufbx_converter<T>::from_list((ufbx_constraint**)nullptr, (size_t)0))>::type> operator T() const { return ufbx_converter<T>::from_list(data, count); } };
struct ufbx_audio_layer_list { ufbx_audio_layer* *data; size_t count; ufbx_audio_layer* &operator[](size_t index) const { 
# 682 "include/ufbx.h" 3 4
(static_cast <bool> (
# 682 "include/ufbx.h"
index < count
# 682 "include/ufbx.h" 3 4
) ? void (0) : __assert_fail (
# 682 "include/ufbx.h"
"index < count"
# 682 "include/ufbx.h" 3 4
, "include/ufbx.h", 682, __extension__ __PRETTY_FUNCTION__))
# 682 "include/ufbx.h"
; return data[index]; } ufbx_audio_layer* *begin() const { return data; } ufbx_audio_layer* *end() const { return data + count; } template <typename T, typename S=typename ufbxi_type_is<T, decltype(ufbx_converter<T>::from_list((ufbx_audio_layer**)nullptr, (size_t)0))>::type> operator T() const { return ufbx_converter<T>::from_list(data, count); } };
struct ufbx_audio_clip_list { ufbx_audio_clip* *data; size_t count; ufbx_audio_clip* &operator[](size_t index) const { 
# 683 "include/ufbx.h" 3 4
(static_cast <bool> (
# 683 "include/ufbx.h"
index < count
# 683 "include/ufbx.h" 3 4
) ? void (0) : __assert_fail (
# 683 "include/ufbx.h"
"index < count"
# 683 "include/ufbx.h" 3 4
, "include/ufbx.h", 683, __extension__ __PRETTY_FUNCTION__))
# 683 "include/ufbx.h"
; return data[index]; } ufbx_audio_clip* *begin() const { return data; } ufbx_audio_clip* *end() const { return data + count; } template <typename T, typename S=typename ufbxi_type_is<T, decltype(ufbx_converter<T>::from_list((ufbx_audio_clip**)nullptr, (size_t)0))>::type> operator T() const { return ufbx_converter<T>::from_list(data, count); } };
struct ufbx_pose_list { ufbx_pose* *data; size_t count; ufbx_pose* &operator[](size_t index) const { 
# 684 "include/ufbx.h" 3 4
(static_cast <bool> (
# 684 "include/ufbx.h"
index < count
# 684 "include/ufbx.h" 3 4
) ? void (0) : __assert_fail (
# 684 "include/ufbx.h"
"index < count"
# 684 "include/ufbx.h" 3 4
, "include/ufbx.h", 684, __extension__ __PRETTY_FUNCTION__))
# 684 "include/ufbx.h"
; return data[index]; } ufbx_pose* *begin() const { return data; } ufbx_pose* *end() const { return data + count; } template <typename T, typename S=typename ufbxi_type_is<T, decltype(ufbx_converter<T>::from_list((ufbx_pose**)nullptr, (size_t)0))>::type> operator T() const { return ufbx_converter<T>::from_list(data, count); } };
struct ufbx_metadata_object_list { ufbx_metadata_object* *data; size_t count; ufbx_metadata_object* &operator[](size_t index) const { 
# 685 "include/ufbx.h" 3 4
(static_cast <bool> (
# 685 "include/ufbx.h"
index < count
# 685 "include/ufbx.h" 3 4
) ? void (0) : __assert_fail (
# 685 "include/ufbx.h"
"index < count"
# 685 "include/ufbx.h" 3 4
, "include/ufbx.h", 685, __extension__ __PRETTY_FUNCTION__))
# 685 "include/ufbx.h"
; return data[index]; } ufbx_metadata_object* *begin() const { return data; } ufbx_metadata_object* *end() const { return data + count; } template <typename T, typename S=typename ufbxi_type_is<T, decltype(ufbx_converter<T>::from_list((ufbx_metadata_object**)nullptr, (size_t)0))>::type> operator T() const { return ufbx_converter<T>::from_list(data, count); } };

typedef enum ufbx_element_type {
 UFBX_ELEMENT_UNKNOWN,
 UFBX_ELEMENT_NODE,
 UFBX_ELEMENT_MESH,
 UFBX_ELEMENT_LIGHT,
 UFBX_ELEMENT_CAMERA,
 UFBX_ELEMENT_BONE,
 UFBX_ELEMENT_EMPTY,
 UFBX_ELEMENT_LINE_CURVE,
 UFBX_ELEMENT_NURBS_CURVE,
 UFBX_ELEMENT_NURBS_SURFACE,
 UFBX_ELEMENT_NURBS_TRIM_SURFACE,
 UFBX_ELEMENT_NURBS_TRIM_BOUNDARY,
 UFBX_ELEMENT_PROCEDURAL_GEOMETRY,
 UFBX_ELEMENT_STEREO_CAMERA,
 UFBX_ELEMENT_CAMERA_SWITCHER,
 UFBX_ELEMENT_MARKER,
 UFBX_ELEMENT_LOD_GROUP,
 UFBX_ELEMENT_SKIN_DEFORMER,
 UFBX_ELEMENT_SKIN_CLUSTER,
 UFBX_ELEMENT_BLEND_DEFORMER,
 UFBX_ELEMENT_BLEND_CHANNEL,
 UFBX_ELEMENT_BLEND_SHAPE,
 UFBX_ELEMENT_CACHE_DEFORMER,
 UFBX_ELEMENT_CACHE_FILE,
 UFBX_ELEMENT_MATERIAL,
 UFBX_ELEMENT_TEXTURE,
 UFBX_ELEMENT_VIDEO,
 UFBX_ELEMENT_SHADER,
 UFBX_ELEMENT_SHADER_BINDING,
 UFBX_ELEMENT_ANIM_STACK,
 UFBX_ELEMENT_ANIM_LAYER,
 UFBX_ELEMENT_ANIM_VALUE,
 UFBX_ELEMENT_ANIM_CURVE,
 UFBX_ELEMENT_DISPLAY_LAYER,
 UFBX_ELEMENT_SELECTION_SET,
 UFBX_ELEMENT_SELECTION_NODE,
 UFBX_ELEMENT_CHARACTER,
 UFBX_ELEMENT_CONSTRAINT,
 UFBX_ELEMENT_AUDIO_LAYER,
 UFBX_ELEMENT_AUDIO_CLIP,
 UFBX_ELEMENT_POSE,
 UFBX_ELEMENT_METADATA_OBJECT,

 UFBX_ELEMENT_TYPE_FIRST_ATTRIB = UFBX_ELEMENT_MESH,
 UFBX_ELEMENT_TYPE_LAST_ATTRIB = UFBX_ELEMENT_LOD_GROUP,

 UFBX_ELEMENT_TYPE_FORCE_32BIT = 0x7fffffff
} ufbx_element_type;

enum { UFBX_ELEMENT_TYPE_COUNT = UFBX_ELEMENT_METADATA_OBJECT + 1 };




typedef struct ufbx_connection {
 ufbx_element *src;
 ufbx_element *dst;
 ufbx_string src_prop;
 ufbx_string dst_prop;
} ufbx_connection;

struct ufbx_connection_list { ufbx_connection *data; size_t count; ufbx_connection &operator[](size_t index) const { 
# 749 "include/ufbx.h" 3 4
(static_cast <bool> (
# 749 "include/ufbx.h"
index < count
# 749 "include/ufbx.h" 3 4
) ? void (0) : __assert_fail (
# 749 "include/ufbx.h"
"index < count"
# 749 "include/ufbx.h" 3 4
, "include/ufbx.h", 749, __extension__ __PRETTY_FUNCTION__))
# 749 "include/ufbx.h"
; return data[index]; } ufbx_connection *begin() const { return data; } ufbx_connection *end() const { return data + count; } template <typename T, typename S=typename ufbxi_type_is<T, decltype(ufbx_converter<T>::from_list((ufbx_connection*)nullptr, (size_t)0))>::type> operator T() const { return ufbx_converter<T>::from_list(data, count); } };






struct ufbx_element {
 ufbx_string name;
 ufbx_props props;
 uint32_t element_id;
 uint32_t typed_id;
 ufbx_node_list instances;
 ufbx_element_type type;
 ufbx_connection_list connections_src;
 ufbx_connection_list connections_dst;
 ufbx_dom_node *dom_node;
 ufbx_scene *scene;
};



struct ufbx_unknown {

 union { ufbx_element element; struct {
  ufbx_string name;
  ufbx_props props;
  uint32_t element_id;
  uint32_t typed_id;
 }; };




 ufbx_string type;
 ufbx_string super_type;
 ufbx_string sub_type;
};
# 795 "include/ufbx.h"
typedef enum ufbx_inherit_mode {



 UFBX_INHERIT_MODE_NORMAL,







 UFBX_INHERIT_MODE_IGNORE_PARENT_SCALE,






 UFBX_INHERIT_MODE_COMPONENTWISE_SCALE,

 UFBX_INHERIT_MODE_FORCE_32BIT = 0x7fffffff
} ufbx_inherit_mode;

enum { UFBX_INHERIT_MODE_COUNT = UFBX_INHERIT_MODE_COMPONENTWISE_SCALE + 1 };


typedef enum ufbx_mirror_axis {

 UFBX_MIRROR_AXIS_NONE,
 UFBX_MIRROR_AXIS_X,
 UFBX_MIRROR_AXIS_Y,
 UFBX_MIRROR_AXIS_Z,

 UFBX_MIRROR_AXIS_FORCE_32BIT = 0x7fffffff
} ufbx_mirror_axis;

enum { UFBX_MIRROR_AXIS_COUNT = UFBX_MIRROR_AXIS_Z + 1 };




struct ufbx_node {
 union { ufbx_element element; struct {
  ufbx_string name;
  ufbx_props props;
  uint32_t element_id;
  uint32_t typed_id;
 }; };







 ufbx_node *parent;


 ufbx_node_list children;







 ufbx_mesh *mesh;
 ufbx_light *light;
 ufbx_camera *camera;
 ufbx_bone *bone;





 ufbx_element *attrib;



 ufbx_node *geometry_transform_helper;



 ufbx_node *scale_helper;


 ufbx_element_type attrib_type;





 ufbx_element_list all_attribs;



 ufbx_inherit_mode inherit_mode;
 ufbx_inherit_mode original_inherit_mode;
 ufbx_transform local_transform;
 ufbx_transform geometry_transform;



 ufbx_vec3 inherit_scale;






 ufbx_node *inherit_scale_node;




 ufbx_rotation_order rotation_order;


 ufbx_vec3 euler_rotation;






 ufbx_matrix node_to_parent;


 ufbx_matrix node_to_world;



 ufbx_matrix geometry_to_node;


 ufbx_matrix geometry_to_world;

 ufbx_matrix unscaled_node_to_world;




 ufbx_vec3 adjust_pre_translation;
 ufbx_quat adjust_pre_rotation;
 ufbx_real adjust_pre_scale;
 ufbx_quat adjust_post_rotation;
 ufbx_real adjust_post_scale;
 ufbx_real adjust_translation_scale;
 ufbx_mirror_axis adjust_mirror_axis;




 ufbx_material_list materials;


 ufbx_pose *bind_pose;


 bool visible;


 bool is_root;


 bool has_geometry_transform;




 bool has_adjust_transform;


 bool has_root_adjust_transform;



 bool is_geometry_transform_helper;



 bool is_scale_helper;


 bool is_scale_compensate_parent;



 uint32_t node_depth;
};
# 996 "include/ufbx.h"
typedef struct ufbx_vertex_attrib {

 bool exists;

 ufbx_void_list values;

 ufbx_uint32_list indices;

 size_t value_reals;

 bool unique_per_vertex;






 ufbx_real_list values_w;
} ufbx_vertex_attrib;


typedef struct ufbx_vertex_real {
 bool exists;
 ufbx_real_list values;
 ufbx_uint32_list indices;
 size_t value_reals;
 bool unique_per_vertex;
 ufbx_real_list values_w;

 ufbx_real &operator[](size_t index) const { 
# 1025 "include/ufbx.h" 3 4
(static_cast <bool> (
# 1025 "include/ufbx.h"
index < indices.count
# 1025 "include/ufbx.h" 3 4
) ? void (0) : __assert_fail (
# 1025 "include/ufbx.h"
"index < indices.count"
# 1025 "include/ufbx.h" 3 4
, "include/ufbx.h", 1025, __extension__ __PRETTY_FUNCTION__))
# 1025 "include/ufbx.h"
; return values.data[indices.data[index]]; }
} ufbx_vertex_real;


typedef struct ufbx_vertex_vec2 {
 bool exists;
 ufbx_vec2_list values;
 ufbx_uint32_list indices;
 size_t value_reals;
 bool unique_per_vertex;
 ufbx_real_list values_w;

 ufbx_vec2 &operator[](size_t index) const { 
# 1037 "include/ufbx.h" 3 4
(static_cast <bool> (
# 1037 "include/ufbx.h"
index < indices.count
# 1037 "include/ufbx.h" 3 4
) ? void (0) : __assert_fail (
# 1037 "include/ufbx.h"
"index < indices.count"
# 1037 "include/ufbx.h" 3 4
, "include/ufbx.h", 1037, __extension__ __PRETTY_FUNCTION__))
# 1037 "include/ufbx.h"
; return values.data[indices.data[index]]; }
} ufbx_vertex_vec2;


typedef struct ufbx_vertex_vec3 {
 bool exists;
 ufbx_vec3_list values;
 ufbx_uint32_list indices;
 size_t value_reals;
 bool unique_per_vertex;
 ufbx_real_list values_w;

 ufbx_vec3 &operator[](size_t index) const { 
# 1049 "include/ufbx.h" 3 4
(static_cast <bool> (
# 1049 "include/ufbx.h"
index < indices.count
# 1049 "include/ufbx.h" 3 4
) ? void (0) : __assert_fail (
# 1049 "include/ufbx.h"
"index < indices.count"
# 1049 "include/ufbx.h" 3 4
, "include/ufbx.h", 1049, __extension__ __PRETTY_FUNCTION__))
# 1049 "include/ufbx.h"
; return values.data[indices.data[index]]; }
} ufbx_vertex_vec3;


typedef struct ufbx_vertex_vec4 {
 bool exists;
 ufbx_vec4_list values;
 ufbx_uint32_list indices;
 size_t value_reals;
 bool unique_per_vertex;
 ufbx_real_list values_w;

 ufbx_vec4 &operator[](size_t index) const { 
# 1061 "include/ufbx.h" 3 4
(static_cast <bool> (
# 1061 "include/ufbx.h"
index < indices.count
# 1061 "include/ufbx.h" 3 4
) ? void (0) : __assert_fail (
# 1061 "include/ufbx.h"
"index < indices.count"
# 1061 "include/ufbx.h" 3 4
, "include/ufbx.h", 1061, __extension__ __PRETTY_FUNCTION__))
# 1061 "include/ufbx.h"
; return values.data[indices.data[index]]; }
} ufbx_vertex_vec4;


typedef struct ufbx_uv_set {
 ufbx_string name;
 uint32_t index;


 ufbx_vertex_vec2 vertex_uv;
 ufbx_vertex_vec3 vertex_tangent;
 ufbx_vertex_vec3 vertex_bitangent;
} ufbx_uv_set;


typedef struct ufbx_color_set {
 ufbx_string name;
 uint32_t index;


 ufbx_vertex_vec4 vertex_color;
} ufbx_color_set;

struct ufbx_uv_set_list { ufbx_uv_set *data; size_t count; ufbx_uv_set &operator[](size_t index) const { 
# 1084 "include/ufbx.h" 3 4
(static_cast <bool> (
# 1084 "include/ufbx.h"
index < count
# 1084 "include/ufbx.h" 3 4
) ? void (0) : __assert_fail (
# 1084 "include/ufbx.h"
"index < count"
# 1084 "include/ufbx.h" 3 4
, "include/ufbx.h", 1084, __extension__ __PRETTY_FUNCTION__))
# 1084 "include/ufbx.h"
; return data[index]; } ufbx_uv_set *begin() const { return data; } ufbx_uv_set *end() const { return data + count; } template <typename T, typename S=typename ufbxi_type_is<T, decltype(ufbx_converter<T>::from_list((ufbx_uv_set*)nullptr, (size_t)0))>::type> operator T() const { return ufbx_converter<T>::from_list(data, count); } };
struct ufbx_color_set_list { ufbx_color_set *data; size_t count; ufbx_color_set &operator[](size_t index) const { 
# 1085 "include/ufbx.h" 3 4
(static_cast <bool> (
# 1085 "include/ufbx.h"
index < count
# 1085 "include/ufbx.h" 3 4
) ? void (0) : __assert_fail (
# 1085 "include/ufbx.h"
"index < count"
# 1085 "include/ufbx.h" 3 4
, "include/ufbx.h", 1085, __extension__ __PRETTY_FUNCTION__))
# 1085 "include/ufbx.h"
; return data[index]; } ufbx_color_set *begin() const { return data; } ufbx_color_set *end() const { return data + count; } template <typename T, typename S=typename ufbxi_type_is<T, decltype(ufbx_converter<T>::from_list((ufbx_color_set*)nullptr, (size_t)0))>::type> operator T() const { return ufbx_converter<T>::from_list(data, count); } };


typedef struct ufbx_edge {
 union {
  struct { uint32_t a, b; };
  uint32_t indices[2];
 };
} ufbx_edge;

struct ufbx_edge_list { ufbx_edge *data; size_t count; ufbx_edge &operator[](size_t index) const { 
# 1095 "include/ufbx.h" 3 4
(static_cast <bool> (
# 1095 "include/ufbx.h"
index < count
# 1095 "include/ufbx.h" 3 4
) ? void (0) : __assert_fail (
# 1095 "include/ufbx.h"
"index < count"
# 1095 "include/ufbx.h" 3 4
, "include/ufbx.h", 1095, __extension__ __PRETTY_FUNCTION__))
# 1095 "include/ufbx.h"
; return data[index]; } ufbx_edge *begin() const { return data; } ufbx_edge *end() const { return data + count; } template <typename T, typename S=typename ufbxi_type_is<T, decltype(ufbx_converter<T>::from_list((ufbx_edge*)nullptr, (size_t)0))>::type> operator T() const { return ufbx_converter<T>::from_list(data, count); } };






typedef struct ufbx_face {
 uint32_t index_begin;
 uint32_t num_indices;
} ufbx_face;

struct ufbx_face_list { ufbx_face *data; size_t count; ufbx_face &operator[](size_t index) const { 
# 1107 "include/ufbx.h" 3 4
(static_cast <bool> (
# 1107 "include/ufbx.h"
index < count
# 1107 "include/ufbx.h" 3 4
) ? void (0) : __assert_fail (
# 1107 "include/ufbx.h"
"index < count"
# 1107 "include/ufbx.h" 3 4
, "include/ufbx.h", 1107, __extension__ __PRETTY_FUNCTION__))
# 1107 "include/ufbx.h"
; return data[index]; } ufbx_face *begin() const { return data; } ufbx_face *end() const { return data + count; } template <typename T, typename S=typename ufbxi_type_is<T, decltype(ufbx_converter<T>::from_list((ufbx_face*)nullptr, (size_t)0))>::type> operator T() const { return ufbx_converter<T>::from_list(data, count); } };


typedef struct ufbx_mesh_part {


 uint32_t index;


 size_t num_faces;
 size_t num_triangles;

 size_t num_empty_faces;
 size_t num_point_faces;
 size_t num_line_faces;



 ufbx_uint32_list face_indices;

} ufbx_mesh_part;

struct ufbx_mesh_part_list { ufbx_mesh_part *data; size_t count; ufbx_mesh_part &operator[](size_t index) const { 
# 1129 "include/ufbx.h" 3 4
(static_cast <bool> (
# 1129 "include/ufbx.h"
index < count
# 1129 "include/ufbx.h" 3 4
) ? void (0) : __assert_fail (
# 1129 "include/ufbx.h"
"index < count"
# 1129 "include/ufbx.h" 3 4
, "include/ufbx.h", 1129, __extension__ __PRETTY_FUNCTION__))
# 1129 "include/ufbx.h"
; return data[index]; } ufbx_mesh_part *begin() const { return data; } ufbx_mesh_part *end() const { return data + count; } template <typename T, typename S=typename ufbxi_type_is<T, decltype(ufbx_converter<T>::from_list((ufbx_mesh_part*)nullptr, (size_t)0))>::type> operator T() const { return ufbx_converter<T>::from_list(data, count); } };

typedef struct ufbx_face_group {
 int32_t id;
 ufbx_string name;
} ufbx_face_group;

struct ufbx_face_group_list { ufbx_face_group *data; size_t count; ufbx_face_group &operator[](size_t index) const { 
# 1136 "include/ufbx.h" 3 4
(static_cast <bool> (
# 1136 "include/ufbx.h"
index < count
# 1136 "include/ufbx.h" 3 4
) ? void (0) : __assert_fail (
# 1136 "include/ufbx.h"
"index < count"
# 1136 "include/ufbx.h" 3 4
, "include/ufbx.h", 1136, __extension__ __PRETTY_FUNCTION__))
# 1136 "include/ufbx.h"
; return data[index]; } ufbx_face_group *begin() const { return data; } ufbx_face_group *end() const { return data + count; } template <typename T, typename S=typename ufbxi_type_is<T, decltype(ufbx_converter<T>::from_list((ufbx_face_group*)nullptr, (size_t)0))>::type> operator T() const { return ufbx_converter<T>::from_list(data, count); } };

typedef struct ufbx_subdivision_weight_range {
 uint32_t weight_begin;
 uint32_t num_weights;
} ufbx_subdivision_weight_range;

struct ufbx_subdivision_weight_range_list { ufbx_subdivision_weight_range *data; size_t count; ufbx_subdivision_weight_range &operator[](size_t index) const { 
# 1143 "include/ufbx.h" 3 4
(static_cast <bool> (
# 1143 "include/ufbx.h"
index < count
# 1143 "include/ufbx.h" 3 4
) ? void (0) : __assert_fail (
# 1143 "include/ufbx.h"
"index < count"
# 1143 "include/ufbx.h" 3 4
, "include/ufbx.h", 1143, __extension__ __PRETTY_FUNCTION__))
# 1143 "include/ufbx.h"
; return data[index]; } ufbx_subdivision_weight_range *begin() const { return data; } ufbx_subdivision_weight_range *end() const { return data + count; } template <typename T, typename S=typename ufbxi_type_is<T, decltype(ufbx_converter<T>::from_list((ufbx_subdivision_weight_range*)nullptr, (size_t)0))>::type> operator T() const { return ufbx_converter<T>::from_list(data, count); } };

typedef struct ufbx_subdivision_weight {
 ufbx_real weight;
 uint32_t index;
} ufbx_subdivision_weight;

struct ufbx_subdivision_weight_list { ufbx_subdivision_weight *data; size_t count; ufbx_subdivision_weight &operator[](size_t index) const { 
# 1150 "include/ufbx.h" 3 4
(static_cast <bool> (
# 1150 "include/ufbx.h"
index < count
# 1150 "include/ufbx.h" 3 4
) ? void (0) : __assert_fail (
# 1150 "include/ufbx.h"
"index < count"
# 1150 "include/ufbx.h" 3 4
, "include/ufbx.h", 1150, __extension__ __PRETTY_FUNCTION__))
# 1150 "include/ufbx.h"
; return data[index]; } ufbx_subdivision_weight *begin() const { return data; } ufbx_subdivision_weight *end() const { return data + count; } template <typename T, typename S=typename ufbxi_type_is<T, decltype(ufbx_converter<T>::from_list((ufbx_subdivision_weight*)nullptr, (size_t)0))>::type> operator T() const { return ufbx_converter<T>::from_list(data, count); } };

typedef struct ufbx_subdivision_result {
 size_t result_memory_used;
 size_t temp_memory_used;
 size_t result_allocs;
 size_t temp_allocs;



 ufbx_subdivision_weight_range_list source_vertex_ranges;
 ufbx_subdivision_weight_list source_vertex_weights;



 ufbx_subdivision_weight_range_list skin_cluster_ranges;
 ufbx_subdivision_weight_list skin_cluster_weights;

} ufbx_subdivision_result;

typedef enum ufbx_subdivision_display_mode {
 UFBX_SUBDIVISION_DISPLAY_DISABLED,
 UFBX_SUBDIVISION_DISPLAY_HULL,
 UFBX_SUBDIVISION_DISPLAY_HULL_AND_SMOOTH,
 UFBX_SUBDIVISION_DISPLAY_SMOOTH,

 UFBX_SUBDIVISION_DISPLAY_MODE_FORCE_32BIT = 0x7fffffff
} ufbx_subdivision_display_mode;

enum { UFBX_SUBDIVISION_DISPLAY_MODE_COUNT = UFBX_SUBDIVISION_DISPLAY_SMOOTH + 1 };

typedef enum ufbx_subdivision_boundary {
 UFBX_SUBDIVISION_BOUNDARY_DEFAULT,
 UFBX_SUBDIVISION_BOUNDARY_LEGACY,

 UFBX_SUBDIVISION_BOUNDARY_SHARP_CORNERS,

 UFBX_SUBDIVISION_BOUNDARY_SHARP_NONE,

 UFBX_SUBDIVISION_BOUNDARY_SHARP_BOUNDARY,

 UFBX_SUBDIVISION_BOUNDARY_SHARP_INTERIOR,

 UFBX_SUBDIVISION_BOUNDARY_FORCE_32BIT = 0x7fffffff
} ufbx_subdivision_boundary;

enum { UFBX_SUBDIVISION_BOUNDARY_COUNT = UFBX_SUBDIVISION_BOUNDARY_SHARP_INTERIOR + 1 };
# 1246 "include/ufbx.h"
struct ufbx_mesh {
 union { ufbx_element element; struct {
  ufbx_string name;
  ufbx_props props;
  uint32_t element_id;
  uint32_t typed_id;
  ufbx_node_list instances;
 }; };



 size_t num_vertices;
 size_t num_indices;
 size_t num_faces;
 size_t num_triangles;



 size_t num_edges;

 size_t max_face_triangles;

 size_t num_empty_faces;
 size_t num_point_faces;
 size_t num_line_faces;


 ufbx_face_list faces;
 ufbx_bool_list face_smoothing;
 ufbx_uint32_list face_material;
 ufbx_uint32_list face_group;
 ufbx_bool_list face_hole;


 ufbx_edge_list edges;
 ufbx_bool_list edge_smoothing;
 ufbx_real_list edge_crease;
 ufbx_bool_list edge_visibility;



 ufbx_uint32_list vertex_indices;
 ufbx_vec3_list vertices;


 ufbx_uint32_list vertex_first_index;







 ufbx_vertex_vec3 vertex_position;
 ufbx_vertex_vec3 vertex_normal;
 ufbx_vertex_vec2 vertex_uv;
 ufbx_vertex_vec3 vertex_tangent;
 ufbx_vertex_vec3 vertex_bitangent;
 ufbx_vertex_vec4 vertex_color;
 ufbx_vertex_real vertex_crease;



 ufbx_uv_set_list uv_sets;
 ufbx_color_set_list color_sets;




 ufbx_material_list materials;


 ufbx_face_group_list face_groups;



 ufbx_mesh_part_list material_parts;


 ufbx_mesh_part_list face_group_parts;




 ufbx_uint32_list material_part_usage_order;





 bool skinned_is_local;
 ufbx_vertex_vec3 skinned_position;
 ufbx_vertex_vec3 skinned_normal;


 ufbx_skin_deformer_list skin_deformers;
 ufbx_blend_deformer_list blend_deformers;
 ufbx_cache_deformer_list cache_deformers;
 ufbx_element_list all_deformers;


 uint32_t subdivision_preview_levels;
 uint32_t subdivision_render_levels;
 ufbx_subdivision_display_mode subdivision_display_mode;
 ufbx_subdivision_boundary subdivision_boundary;
 ufbx_subdivision_boundary subdivision_uv_boundary;


 bool reversed_winding;




 bool generated_normals;


 bool subdivision_evaluated;
 ufbx_subdivision_result *subdivision_result;


 bool from_tessellated_nurbs;
};


typedef enum ufbx_light_type {

 UFBX_LIGHT_POINT,


 UFBX_LIGHT_DIRECTIONAL,


 UFBX_LIGHT_SPOT,


 UFBX_LIGHT_AREA,


 UFBX_LIGHT_VOLUME,

 UFBX_LIGHT_TYPE_FORCE_32BIT = 0x7fffffff
} ufbx_light_type;

enum { UFBX_LIGHT_TYPE_COUNT = UFBX_LIGHT_VOLUME + 1 };


typedef enum ufbx_light_decay {
 UFBX_LIGHT_DECAY_NONE,
 UFBX_LIGHT_DECAY_LINEAR,
 UFBX_LIGHT_DECAY_QUADRATIC,
 UFBX_LIGHT_DECAY_CUBIC,

 UFBX_LIGHT_DECAY_FORCE_32BIT = 0x7fffffff
} ufbx_light_decay;

enum { UFBX_LIGHT_DECAY_COUNT = UFBX_LIGHT_DECAY_CUBIC + 1 };

typedef enum ufbx_light_area_shape {
 UFBX_LIGHT_AREA_SHAPE_RECTANGLE,
 UFBX_LIGHT_AREA_SHAPE_SPHERE,

 UFBX_LIGHT_AREA_SHAPE_FORCE_32BIT = 0x7fffffff
} ufbx_light_area_shape;

enum { UFBX_LIGHT_AREA_SHAPE_COUNT = UFBX_LIGHT_AREA_SHAPE_SPHERE + 1 };


struct ufbx_light {
 union { ufbx_element element; struct {
  ufbx_string name;
  ufbx_props props;
  uint32_t element_id;
  uint32_t typed_id;
  ufbx_node_list instances;
 }; };




 ufbx_vec3 color;
 ufbx_real intensity;


 ufbx_vec3 local_direction;


 ufbx_light_type type;
 ufbx_light_decay decay;
 ufbx_light_area_shape area_shape;
 ufbx_real inner_angle;
 ufbx_real outer_angle;

 bool cast_light;
 bool cast_shadows;
};

typedef enum ufbx_projection_mode {

 UFBX_PROJECTION_MODE_PERSPECTIVE,


 UFBX_PROJECTION_MODE_ORTHOGRAPHIC,

 UFBX_PROJECTION_MODE_FORCE_32BIT = 0x7fffffff
} ufbx_projection_mode;

enum { UFBX_PROJECTION_MODE_COUNT = UFBX_PROJECTION_MODE_ORTHOGRAPHIC + 1 };



typedef enum ufbx_aspect_mode {

 UFBX_ASPECT_MODE_WINDOW_SIZE,

 UFBX_ASPECT_MODE_FIXED_RATIO,

 UFBX_ASPECT_MODE_FIXED_RESOLUTION,

 UFBX_ASPECT_MODE_FIXED_WIDTH,

 UFBX_ASPECT_MODE_FIXED_HEIGHT,

 UFBX_ASPECT_MODE_FORCE_32BIT = 0x7fffffff
} ufbx_aspect_mode;

enum { UFBX_ASPECT_MODE_COUNT = UFBX_ASPECT_MODE_FIXED_HEIGHT + 1 };



typedef enum ufbx_aperture_mode {

 UFBX_APERTURE_MODE_HORIZONTAL_AND_VERTICAL,

 UFBX_APERTURE_MODE_HORIZONTAL,

 UFBX_APERTURE_MODE_VERTICAL,

 UFBX_APERTURE_MODE_FOCAL_LENGTH,

 UFBX_APERTURE_MODE_FORCE_32BIT = 0x7fffffff
} ufbx_aperture_mode;

enum { UFBX_APERTURE_MODE_COUNT = UFBX_APERTURE_MODE_FOCAL_LENGTH + 1 };



typedef enum ufbx_gate_fit {

 UFBX_GATE_FIT_NONE,

 UFBX_GATE_FIT_VERTICAL,

 UFBX_GATE_FIT_HORIZONTAL,

 UFBX_GATE_FIT_FILL,

 UFBX_GATE_FIT_OVERSCAN,


 UFBX_GATE_FIT_STRETCH,

 UFBX_GATE_FIT_FORCE_32BIT = 0x7fffffff
} ufbx_gate_fit;

enum { UFBX_GATE_FIT_COUNT = UFBX_GATE_FIT_STRETCH + 1 };



typedef enum ufbx_aperture_format {
 UFBX_APERTURE_FORMAT_CUSTOM,
 UFBX_APERTURE_FORMAT_16MM_THEATRICAL,
 UFBX_APERTURE_FORMAT_SUPER_16MM,
 UFBX_APERTURE_FORMAT_35MM_ACADEMY,
 UFBX_APERTURE_FORMAT_35MM_TV_PROJECTION,
 UFBX_APERTURE_FORMAT_35MM_FULL_APERTURE,
 UFBX_APERTURE_FORMAT_35MM_185_PROJECTION,
 UFBX_APERTURE_FORMAT_35MM_ANAMORPHIC,
 UFBX_APERTURE_FORMAT_70MM_PROJECTION,
 UFBX_APERTURE_FORMAT_VISTAVISION,
 UFBX_APERTURE_FORMAT_DYNAVISION,
 UFBX_APERTURE_FORMAT_IMAX,

 UFBX_APERTURE_FORMAT_FORCE_32BIT = 0x7fffffff
} ufbx_aperture_format;

enum { UFBX_APERTURE_FORMAT_COUNT = UFBX_APERTURE_FORMAT_IMAX + 1 };

typedef enum ufbx_coordinate_axis {
 UFBX_COORDINATE_AXIS_POSITIVE_X,
 UFBX_COORDINATE_AXIS_NEGATIVE_X,
 UFBX_COORDINATE_AXIS_POSITIVE_Y,
 UFBX_COORDINATE_AXIS_NEGATIVE_Y,
 UFBX_COORDINATE_AXIS_POSITIVE_Z,
 UFBX_COORDINATE_AXIS_NEGATIVE_Z,
 UFBX_COORDINATE_AXIS_UNKNOWN,

 UFBX_COORDINATE_AXIS_FORCE_32BIT = 0x7fffffff
} ufbx_coordinate_axis;

enum { UFBX_COORDINATE_AXIS_COUNT = UFBX_COORDINATE_AXIS_UNKNOWN + 1 };



typedef struct ufbx_coordinate_axes {
 ufbx_coordinate_axis right;
 ufbx_coordinate_axis up;
 ufbx_coordinate_axis front;
} ufbx_coordinate_axes;


struct ufbx_camera {
 union { ufbx_element element; struct {
  ufbx_string name;
  ufbx_props props;
  uint32_t element_id;
  uint32_t typed_id;
  ufbx_node_list instances;
 }; };


 ufbx_projection_mode projection_mode;



 bool resolution_is_pixels;


 ufbx_vec2 resolution;



 ufbx_vec2 field_of_view_deg;




 ufbx_vec2 field_of_view_tan;



 ufbx_real orthographic_extent;



 ufbx_vec2 orthographic_size;



 ufbx_vec2 projection_plane;


 ufbx_real aspect_ratio;


 ufbx_real near_plane;


 ufbx_real far_plane;




 ufbx_coordinate_axes projection_axes;


 ufbx_aspect_mode aspect_mode;
 ufbx_aperture_mode aperture_mode;
 ufbx_gate_fit gate_fit;
 ufbx_aperture_format aperture_format;
 ufbx_real focal_length_mm;
 ufbx_vec2 film_size_inch;
 ufbx_vec2 aperture_size_inch;
 ufbx_real squeeze_ratio;
};



struct ufbx_bone {
 union { ufbx_element element; struct {
  ufbx_string name;
  ufbx_props props;
  uint32_t element_id;
  uint32_t typed_id;
  ufbx_node_list instances;
 }; };


 ufbx_real radius;


 ufbx_real relative_length;


 bool is_root;
};


struct ufbx_empty {
 union { ufbx_element element; struct {
  ufbx_string name;
  ufbx_props props;
  uint32_t element_id;
  uint32_t typed_id;
  ufbx_node_list instances;
 }; };
};




typedef struct ufbx_line_segment {
 uint32_t index_begin;
 uint32_t num_indices;
} ufbx_line_segment;

struct ufbx_line_segment_list { ufbx_line_segment *data; size_t count; ufbx_line_segment &operator[](size_t index) const { 
# 1661 "include/ufbx.h" 3 4
(static_cast <bool> (
# 1661 "include/ufbx.h"
index < count
# 1661 "include/ufbx.h" 3 4
) ? void (0) : __assert_fail (
# 1661 "include/ufbx.h"
"index < count"
# 1661 "include/ufbx.h" 3 4
, "include/ufbx.h", 1661, __extension__ __PRETTY_FUNCTION__))
# 1661 "include/ufbx.h"
; return data[index]; } ufbx_line_segment *begin() const { return data; } ufbx_line_segment *end() const { return data + count; } template <typename T, typename S=typename ufbxi_type_is<T, decltype(ufbx_converter<T>::from_list((ufbx_line_segment*)nullptr, (size_t)0))>::type> operator T() const { return ufbx_converter<T>::from_list(data, count); } };

struct ufbx_line_curve {
 union { ufbx_element element; struct {
  ufbx_string name;
  ufbx_props props;
  uint32_t element_id;
  uint32_t typed_id;
  ufbx_node_list instances;
 }; };

 ufbx_vec3 color;

 ufbx_vec3_list control_points;
 ufbx_uint32_list point_indices;

 ufbx_line_segment_list segments;


 bool from_tessellated_nurbs;
};

typedef enum ufbx_nurbs_topology {

 UFBX_NURBS_TOPOLOGY_OPEN,

 UFBX_NURBS_TOPOLOGY_PERIODIC,

 UFBX_NURBS_TOPOLOGY_CLOSED,

 UFBX_NURBS_TOPOLOGY_FORCE_32BIT = 0x7fffffff
} ufbx_nurbs_topology;

enum { UFBX_NURBS_TOPOLOGY_COUNT = UFBX_NURBS_TOPOLOGY_CLOSED + 1 };


typedef struct ufbx_nurbs_basis {



 uint32_t order;


 ufbx_nurbs_topology topology;


 ufbx_real_list knot_vector;


 ufbx_real t_min;
 ufbx_real t_max;


 ufbx_real_list spans;


 bool is_2d;







 size_t num_wrap_control_points;


 bool valid;

} ufbx_nurbs_basis;

struct ufbx_nurbs_curve {
 union { ufbx_element element; struct {
  ufbx_string name;
  ufbx_props props;
  uint32_t element_id;
  uint32_t typed_id;
  ufbx_node_list instances;
 }; };


 ufbx_nurbs_basis basis;




 ufbx_vec4_list control_points;
};

struct ufbx_nurbs_surface {
 union { ufbx_element element; struct {
  ufbx_string name;
  ufbx_props props;
  uint32_t element_id;
  uint32_t typed_id;
  ufbx_node_list instances;
 }; };


 ufbx_nurbs_basis basis_u;
 ufbx_nurbs_basis basis_v;


 size_t num_control_points_u;
 size_t num_control_points_v;





 ufbx_vec4_list control_points;


 uint32_t span_subdivision_u;
 uint32_t span_subdivision_v;


 bool flip_normals;



 ufbx_material *material;
};

struct ufbx_nurbs_trim_surface {
 union { ufbx_element element; struct {
  ufbx_string name;
  ufbx_props props;
  uint32_t element_id;
  uint32_t typed_id;
  ufbx_node_list instances;
 }; };
};

struct ufbx_nurbs_trim_boundary {
 union { ufbx_element element; struct {
  ufbx_string name;
  ufbx_props props;
  uint32_t element_id;
  uint32_t typed_id;
  ufbx_node_list instances;
 }; };
};



struct ufbx_procedural_geometry {
 union { ufbx_element element; struct {
  ufbx_string name;
  ufbx_props props;
  uint32_t element_id;
  uint32_t typed_id;
  ufbx_node_list instances;
 }; };
};

struct ufbx_stereo_camera {
 union { ufbx_element element; struct {
  ufbx_string name;
  ufbx_props props;
  uint32_t element_id;
  uint32_t typed_id;
  ufbx_node_list instances;
 }; };

 ufbx_camera *left;
 ufbx_camera *right;
};

struct ufbx_camera_switcher {
 union { ufbx_element element; struct {
  ufbx_string name;
  ufbx_props props;
  uint32_t element_id;
  uint32_t typed_id;
  ufbx_node_list instances;
 }; };
};

typedef enum ufbx_marker_type {
 UFBX_MARKER_UNKNOWN,
 UFBX_MARKER_FK_EFFECTOR,
 UFBX_MARKER_IK_EFFECTOR,

 UFBX_MARKER_TYPE_FORCE_32BIT = 0x7fffffff
} ufbx_marker_type;

enum { UFBX_MARKER_TYPE_COUNT = UFBX_MARKER_IK_EFFECTOR + 1 };


struct ufbx_marker {
 union { ufbx_element element; struct {
  ufbx_string name;
  ufbx_props props;
  uint32_t element_id;
  uint32_t typed_id;
  ufbx_node_list instances;
 }; };


 ufbx_marker_type type;
};


typedef enum ufbx_lod_display {
 UFBX_LOD_DISPLAY_USE_LOD,
 UFBX_LOD_DISPLAY_SHOW,
 UFBX_LOD_DISPLAY_HIDE,

 UFBX_LOD_DISPLAY_FORCE_32BIT = 0x7fffffff
} ufbx_lod_display;

enum { UFBX_LOD_DISPLAY_COUNT = UFBX_LOD_DISPLAY_HIDE + 1 };



typedef struct ufbx_lod_level {




 ufbx_real distance;




 ufbx_lod_display display;

} ufbx_lod_level;

struct ufbx_lod_level_list { ufbx_lod_level *data; size_t count; ufbx_lod_level &operator[](size_t index) const { 
# 1891 "include/ufbx.h" 3 4
(static_cast <bool> (
# 1891 "include/ufbx.h"
index < count
# 1891 "include/ufbx.h" 3 4
) ? void (0) : __assert_fail (
# 1891 "include/ufbx.h"
"index < count"
# 1891 "include/ufbx.h" 3 4
, "include/ufbx.h", 1891, __extension__ __PRETTY_FUNCTION__))
# 1891 "include/ufbx.h"
; return data[index]; } ufbx_lod_level *begin() const { return data; } ufbx_lod_level *end() const { return data + count; } template <typename T, typename S=typename ufbxi_type_is<T, decltype(ufbx_converter<T>::from_list((ufbx_lod_level*)nullptr, (size_t)0))>::type> operator T() const { return ufbx_converter<T>::from_list(data, count); } };



struct ufbx_lod_group {
 union { ufbx_element element; struct {
  ufbx_string name;
  ufbx_props props;
  uint32_t element_id;
  uint32_t typed_id;
  ufbx_node_list instances;
 }; };


 bool relative_distances;


 ufbx_lod_level_list lod_levels;


 bool ignore_parent_transform;



 bool use_distance_limit;
 ufbx_real distance_limit_min;
 ufbx_real distance_limit_max;
};




typedef enum ufbx_skinning_method {

 UFBX_SKINNING_METHOD_LINEAR,

 UFBX_SKINNING_METHOD_RIGID,

 UFBX_SKINNING_METHOD_DUAL_QUATERNION,



 UFBX_SKINNING_METHOD_BLENDED_DQ_LINEAR,

 UFBX_SKINNING_METHOD_FORCE_32BIT = 0x7fffffff
} ufbx_skinning_method;

enum { UFBX_SKINNING_METHOD_COUNT = UFBX_SKINNING_METHOD_BLENDED_DQ_LINEAR + 1 };


typedef struct ufbx_skin_vertex {





 uint32_t weight_begin;
 uint32_t num_weights;



 ufbx_real dq_weight;

} ufbx_skin_vertex;

struct ufbx_skin_vertex_list { ufbx_skin_vertex *data; size_t count; ufbx_skin_vertex &operator[](size_t index) const { 
# 1956 "include/ufbx.h" 3 4
(static_cast <bool> (
# 1956 "include/ufbx.h"
index < count
# 1956 "include/ufbx.h" 3 4
) ? void (0) : __assert_fail (
# 1956 "include/ufbx.h"
"index < count"
# 1956 "include/ufbx.h" 3 4
, "include/ufbx.h", 1956, __extension__ __PRETTY_FUNCTION__))
# 1956 "include/ufbx.h"
; return data[index]; } ufbx_skin_vertex *begin() const { return data; } ufbx_skin_vertex *end() const { return data + count; } template <typename T, typename S=typename ufbxi_type_is<T, decltype(ufbx_converter<T>::from_list((ufbx_skin_vertex*)nullptr, (size_t)0))>::type> operator T() const { return ufbx_converter<T>::from_list(data, count); } };


typedef struct ufbx_skin_weight {
 uint32_t cluster_index;
 ufbx_real weight;
} ufbx_skin_weight;

struct ufbx_skin_weight_list { ufbx_skin_weight *data; size_t count; ufbx_skin_weight &operator[](size_t index) const { 
# 1964 "include/ufbx.h" 3 4
(static_cast <bool> (
# 1964 "include/ufbx.h"
index < count
# 1964 "include/ufbx.h" 3 4
) ? void (0) : __assert_fail (
# 1964 "include/ufbx.h"
"index < count"
# 1964 "include/ufbx.h" 3 4
, "include/ufbx.h", 1964, __extension__ __PRETTY_FUNCTION__))
# 1964 "include/ufbx.h"
; return data[index]; } ufbx_skin_weight *begin() const { return data; } ufbx_skin_weight *end() const { return data + count; } template <typename T, typename S=typename ufbxi_type_is<T, decltype(ufbx_converter<T>::from_list((ufbx_skin_weight*)nullptr, (size_t)0))>::type> operator T() const { return ufbx_converter<T>::from_list(data, count); } };




struct ufbx_skin_deformer {
 union { ufbx_element element; struct {
  ufbx_string name;
  ufbx_props props;
  uint32_t element_id;
  uint32_t typed_id;
 }; };

 ufbx_skinning_method skinning_method;


 ufbx_skin_cluster_list clusters;


 ufbx_skin_vertex_list vertices;
 ufbx_skin_weight_list weights;


 size_t max_weights_per_vertex;




 size_t num_dq_weights;
 ufbx_uint32_list dq_vertices;
 ufbx_real_list dq_weights;
};


struct ufbx_skin_cluster {
 union { ufbx_element element; struct {
  ufbx_string name;
  ufbx_props props;
  uint32_t element_id;
  uint32_t typed_id;
 }; };




 ufbx_node *bone_node;


 ufbx_matrix geometry_to_bone;



 ufbx_matrix mesh_node_to_bone;



 ufbx_matrix bind_to_world;



 ufbx_matrix geometry_to_world;
 ufbx_transform geometry_to_world_transform;




 size_t num_weights;
 ufbx_uint32_list vertices;
 ufbx_real_list weights;
};



struct ufbx_blend_deformer {
 union { ufbx_element element; struct {
  ufbx_string name;
  ufbx_props props;
  uint32_t element_id;
  uint32_t typed_id;
 }; };


 ufbx_blend_channel_list channels;
};


typedef struct ufbx_blend_keyframe {

 ufbx_blend_shape *shape;


 ufbx_real target_weight;


 ufbx_real effective_weight;
} ufbx_blend_keyframe;

struct ufbx_blend_keyframe_list { ufbx_blend_keyframe *data; size_t count; ufbx_blend_keyframe &operator[](size_t index) const { 
# 2061 "include/ufbx.h" 3 4
(static_cast <bool> (
# 2061 "include/ufbx.h"
index < count
# 2061 "include/ufbx.h" 3 4
) ? void (0) : __assert_fail (
# 2061 "include/ufbx.h"
"index < count"
# 2061 "include/ufbx.h" 3 4
, "include/ufbx.h", 2061, __extension__ __PRETTY_FUNCTION__))
# 2061 "include/ufbx.h"
; return data[index]; } ufbx_blend_keyframe *begin() const { return data; } ufbx_blend_keyframe *end() const { return data + count; } template <typename T, typename S=typename ufbxi_type_is<T, decltype(ufbx_converter<T>::from_list((ufbx_blend_keyframe*)nullptr, (size_t)0))>::type> operator T() const { return ufbx_converter<T>::from_list(data, count); } };



struct ufbx_blend_channel {
 union { ufbx_element element; struct {
  ufbx_string name;
  ufbx_props props;
  uint32_t element_id;
  uint32_t typed_id;
 }; };


 ufbx_real weight;



 ufbx_blend_keyframe_list keyframes;


 ufbx_blend_shape *target_shape;
};


struct ufbx_blend_shape {
 union { ufbx_element element; struct {
  ufbx_string name;
  ufbx_props props;
  uint32_t element_id;
  uint32_t typed_id;
 }; };



 size_t num_offsets;
 ufbx_uint32_list offset_vertices;
 ufbx_vec3_list position_offsets;
 ufbx_vec3_list normal_offsets;
};

typedef enum ufbx_cache_file_format {
 UFBX_CACHE_FILE_FORMAT_UNKNOWN,
 UFBX_CACHE_FILE_FORMAT_PC2,
 UFBX_CACHE_FILE_FORMAT_MC,

 UFBX_CACHE_FILE_FORMAT_FORCE_32BIT = 0x7fffffff
} ufbx_cache_file_format;

enum { UFBX_CACHE_FILE_FORMAT_COUNT = UFBX_CACHE_FILE_FORMAT_MC + 1 };

typedef enum ufbx_cache_data_format {
 UFBX_CACHE_DATA_FORMAT_UNKNOWN,
 UFBX_CACHE_DATA_FORMAT_REAL_FLOAT,
 UFBX_CACHE_DATA_FORMAT_VEC3_FLOAT,
 UFBX_CACHE_DATA_FORMAT_REAL_DOUBLE,
 UFBX_CACHE_DATA_FORMAT_VEC3_DOUBLE,

 UFBX_CACHE_DATA_FORMAT_FORCE_32BIT = 0x7fffffff
} ufbx_cache_data_format;

enum { UFBX_CACHE_DATA_FORMAT_COUNT = UFBX_CACHE_DATA_FORMAT_VEC3_DOUBLE + 1 };

typedef enum ufbx_cache_data_encoding {
 UFBX_CACHE_DATA_ENCODING_UNKNOWN,
 UFBX_CACHE_DATA_ENCODING_LITTLE_ENDIAN,
 UFBX_CACHE_DATA_ENCODING_BIG_ENDIAN,

 UFBX_CACHE_DATA_ENCODING_FORCE_32BIT = 0x7fffffff
} ufbx_cache_data_encoding;

enum { UFBX_CACHE_DATA_ENCODING_COUNT = UFBX_CACHE_DATA_ENCODING_BIG_ENDIAN + 1 };


typedef enum ufbx_cache_interpretation {

 UFBX_CACHE_INTERPRETATION_UNKNOWN,



 UFBX_CACHE_INTERPRETATION_POINTS,


 UFBX_CACHE_INTERPRETATION_VERTEX_POSITION,


 UFBX_CACHE_INTERPRETATION_VERTEX_NORMAL,

 UFBX_CACHE_INTERPRETATION_FORCE_32BIT = 0x7fffffff
} ufbx_cache_interpretation;

enum { UFBX_CACHE_INTERPRETATION_COUNT = UFBX_CACHE_INTERPRETATION_VERTEX_NORMAL + 1 };

typedef struct ufbx_cache_frame {


 ufbx_string channel;


 double time;




 ufbx_string filename;


 ufbx_cache_file_format file_format;


 ufbx_mirror_axis mirror_axis;


 ufbx_real scale_factor;

 ufbx_cache_data_format data_format;
 ufbx_cache_data_encoding data_encoding;
 uint64_t data_offset;
 uint32_t data_count;
 uint32_t data_element_bytes;
 uint64_t data_total_bytes;
} ufbx_cache_frame;

struct ufbx_cache_frame_list { ufbx_cache_frame *data; size_t count; ufbx_cache_frame &operator[](size_t index) const { 
# 2183 "include/ufbx.h" 3 4
(static_cast <bool> (
# 2183 "include/ufbx.h"
index < count
# 2183 "include/ufbx.h" 3 4
) ? void (0) : __assert_fail (
# 2183 "include/ufbx.h"
"index < count"
# 2183 "include/ufbx.h" 3 4
, "include/ufbx.h", 2183, __extension__ __PRETTY_FUNCTION__))
# 2183 "include/ufbx.h"
; return data[index]; } ufbx_cache_frame *begin() const { return data; } ufbx_cache_frame *end() const { return data + count; } template <typename T, typename S=typename ufbxi_type_is<T, decltype(ufbx_converter<T>::from_list((ufbx_cache_frame*)nullptr, (size_t)0))>::type> operator T() const { return ufbx_converter<T>::from_list(data, count); } };

typedef struct ufbx_cache_channel {


 ufbx_string name;


 ufbx_cache_interpretation interpretation;



 ufbx_string interpretation_name;



 ufbx_cache_frame_list frames;


 ufbx_mirror_axis mirror_axis;


 ufbx_real scale_factor;

} ufbx_cache_channel;

struct ufbx_cache_channel_list { ufbx_cache_channel *data; size_t count; ufbx_cache_channel &operator[](size_t index) const { 
# 2209 "include/ufbx.h" 3 4
(static_cast <bool> (
# 2209 "include/ufbx.h"
index < count
# 2209 "include/ufbx.h" 3 4
) ? void (0) : __assert_fail (
# 2209 "include/ufbx.h"
"index < count"
# 2209 "include/ufbx.h" 3 4
, "include/ufbx.h", 2209, __extension__ __PRETTY_FUNCTION__))
# 2209 "include/ufbx.h"
; return data[index]; } ufbx_cache_channel *begin() const { return data; } ufbx_cache_channel *end() const { return data + count; } template <typename T, typename S=typename ufbxi_type_is<T, decltype(ufbx_converter<T>::from_list((ufbx_cache_channel*)nullptr, (size_t)0))>::type> operator T() const { return ufbx_converter<T>::from_list(data, count); } };

typedef struct ufbx_geometry_cache {
 ufbx_string root_filename;
 ufbx_cache_channel_list channels;
 ufbx_cache_frame_list frames;
 ufbx_string_list extra_info;
} ufbx_geometry_cache;

struct ufbx_cache_deformer {
 union { ufbx_element element; struct {
  ufbx_string name;
  ufbx_props props;
  uint32_t element_id;
  uint32_t typed_id;
 }; };

 ufbx_string channel;
 ufbx_cache_file *file;


 ufbx_geometry_cache *external_cache;
 ufbx_cache_channel *external_channel;
};

struct ufbx_cache_file {
 union { ufbx_element element; struct {
  ufbx_string name;
  ufbx_props props;
  uint32_t element_id;
  uint32_t typed_id;
 }; };




 ufbx_string filename;

 ufbx_string absolute_filename;


 ufbx_string relative_filename;




 ufbx_blob raw_filename;

 ufbx_blob raw_absolute_filename;


 ufbx_blob raw_relative_filename;

 ufbx_cache_file_format format;


 ufbx_geometry_cache *external_cache;
};




typedef struct ufbx_material_map {




 union {
  ufbx_real value_real;
  ufbx_vec2 value_vec2;
  ufbx_vec3 value_vec3;
  ufbx_vec4 value_vec4;
 };
 int64_t value_int;



 ufbx_texture *texture;




 bool has_value;



 bool texture_enabled;


 bool feature_disabled;


 uint8_t value_components;

} ufbx_material_map;


typedef struct ufbx_material_feature_info {



 bool enabled;


 bool is_explicit;

} ufbx_material_feature_info;


typedef struct ufbx_material_texture {
 ufbx_string material_prop;
 ufbx_string shader_prop;


 ufbx_texture *texture;

} ufbx_material_texture;

struct ufbx_material_texture_list { ufbx_material_texture *data; size_t count; ufbx_material_texture &operator[](size_t index) const { 
# 2327 "include/ufbx.h" 3 4
(static_cast <bool> (
# 2327 "include/ufbx.h"
index < count
# 2327 "include/ufbx.h" 3 4
) ? void (0) : __assert_fail (
# 2327 "include/ufbx.h"
"index < count"
# 2327 "include/ufbx.h" 3 4
, "include/ufbx.h", 2327, __extension__ __PRETTY_FUNCTION__))
# 2327 "include/ufbx.h"
; return data[index]; } ufbx_material_texture *begin() const { return data; } ufbx_material_texture *end() const { return data + count; } template <typename T, typename S=typename ufbxi_type_is<T, decltype(ufbx_converter<T>::from_list((ufbx_material_texture*)nullptr, (size_t)0))>::type> operator T() const { return ufbx_converter<T>::from_list(data, count); } };


typedef enum ufbx_shader_type {

 UFBX_SHADER_UNKNOWN,

 UFBX_SHADER_FBX_LAMBERT,

 UFBX_SHADER_FBX_PHONG,


 UFBX_SHADER_OSL_STANDARD_SURFACE,


 UFBX_SHADER_ARNOLD_STANDARD_SURFACE,


 UFBX_SHADER_3DS_MAX_PHYSICAL_MATERIAL,


 UFBX_SHADER_3DS_MAX_PBR_METAL_ROUGH,


 UFBX_SHADER_3DS_MAX_PBR_SPEC_GLOSS,


 UFBX_SHADER_GLTF_MATERIAL,


 UFBX_SHADER_SHADERFX_GRAPH,



 UFBX_SHADER_BLENDER_PHONG,

 UFBX_SHADER_WAVEFRONT_MTL,

 UFBX_SHADER_TYPE_FORCE_32BIT = 0x7fffffff
} ufbx_shader_type;

enum { UFBX_SHADER_TYPE_COUNT = UFBX_SHADER_WAVEFRONT_MTL + 1 };


typedef enum ufbx_material_fbx_map {
 UFBX_MATERIAL_FBX_DIFFUSE_FACTOR,
 UFBX_MATERIAL_FBX_DIFFUSE_COLOR,
 UFBX_MATERIAL_FBX_SPECULAR_FACTOR,
 UFBX_MATERIAL_FBX_SPECULAR_COLOR,
 UFBX_MATERIAL_FBX_SPECULAR_EXPONENT,
 UFBX_MATERIAL_FBX_REFLECTION_FACTOR,
 UFBX_MATERIAL_FBX_REFLECTION_COLOR,
 UFBX_MATERIAL_FBX_TRANSPARENCY_FACTOR,
 UFBX_MATERIAL_FBX_TRANSPARENCY_COLOR,
 UFBX_MATERIAL_FBX_EMISSION_FACTOR,
 UFBX_MATERIAL_FBX_EMISSION_COLOR,
 UFBX_MATERIAL_FBX_AMBIENT_FACTOR,
 UFBX_MATERIAL_FBX_AMBIENT_COLOR,
 UFBX_MATERIAL_FBX_NORMAL_MAP,
 UFBX_MATERIAL_FBX_BUMP,
 UFBX_MATERIAL_FBX_BUMP_FACTOR,
 UFBX_MATERIAL_FBX_DISPLACEMENT_FACTOR,
 UFBX_MATERIAL_FBX_DISPLACEMENT,
 UFBX_MATERIAL_FBX_VECTOR_DISPLACEMENT_FACTOR,
 UFBX_MATERIAL_FBX_VECTOR_DISPLACEMENT,

 UFBX_MATERIAL_FBX_MAP_FORCE_32BIT = 0x7fffffff
} ufbx_material_fbx_map;

enum { UFBX_MATERIAL_FBX_MAP_COUNT = UFBX_MATERIAL_FBX_VECTOR_DISPLACEMENT + 1 };


typedef enum ufbx_material_pbr_map {
 UFBX_MATERIAL_PBR_BASE_FACTOR,
 UFBX_MATERIAL_PBR_BASE_COLOR,
 UFBX_MATERIAL_PBR_ROUGHNESS,
 UFBX_MATERIAL_PBR_METALNESS,
 UFBX_MATERIAL_PBR_DIFFUSE_ROUGHNESS,
 UFBX_MATERIAL_PBR_SPECULAR_FACTOR,
 UFBX_MATERIAL_PBR_SPECULAR_COLOR,
 UFBX_MATERIAL_PBR_SPECULAR_IOR,
 UFBX_MATERIAL_PBR_SPECULAR_ANISOTROPY,
 UFBX_MATERIAL_PBR_SPECULAR_ROTATION,
 UFBX_MATERIAL_PBR_TRANSMISSION_FACTOR,
 UFBX_MATERIAL_PBR_TRANSMISSION_COLOR,
 UFBX_MATERIAL_PBR_TRANSMISSION_DEPTH,
 UFBX_MATERIAL_PBR_TRANSMISSION_SCATTER,
 UFBX_MATERIAL_PBR_TRANSMISSION_SCATTER_ANISOTROPY,
 UFBX_MATERIAL_PBR_TRANSMISSION_DISPERSION,
 UFBX_MATERIAL_PBR_TRANSMISSION_ROUGHNESS,
 UFBX_MATERIAL_PBR_TRANSMISSION_EXTRA_ROUGHNESS,
 UFBX_MATERIAL_PBR_TRANSMISSION_PRIORITY,
 UFBX_MATERIAL_PBR_TRANSMISSION_ENABLE_IN_AOV,
 UFBX_MATERIAL_PBR_SUBSURFACE_FACTOR,
 UFBX_MATERIAL_PBR_SUBSURFACE_COLOR,
 UFBX_MATERIAL_PBR_SUBSURFACE_RADIUS,
 UFBX_MATERIAL_PBR_SUBSURFACE_SCALE,
 UFBX_MATERIAL_PBR_SUBSURFACE_ANISOTROPY,
 UFBX_MATERIAL_PBR_SUBSURFACE_TINT_COLOR,
 UFBX_MATERIAL_PBR_SUBSURFACE_TYPE,
 UFBX_MATERIAL_PBR_SHEEN_FACTOR,
 UFBX_MATERIAL_PBR_SHEEN_COLOR,
 UFBX_MATERIAL_PBR_SHEEN_ROUGHNESS,
 UFBX_MATERIAL_PBR_COAT_FACTOR,
 UFBX_MATERIAL_PBR_COAT_COLOR,
 UFBX_MATERIAL_PBR_COAT_ROUGHNESS,
 UFBX_MATERIAL_PBR_COAT_IOR,
 UFBX_MATERIAL_PBR_COAT_ANISOTROPY,
 UFBX_MATERIAL_PBR_COAT_ROTATION,
 UFBX_MATERIAL_PBR_COAT_NORMAL,
 UFBX_MATERIAL_PBR_COAT_AFFECT_BASE_COLOR,
 UFBX_MATERIAL_PBR_COAT_AFFECT_BASE_ROUGHNESS,
 UFBX_MATERIAL_PBR_THIN_FILM_THICKNESS,
 UFBX_MATERIAL_PBR_THIN_FILM_IOR,
 UFBX_MATERIAL_PBR_EMISSION_FACTOR,
 UFBX_MATERIAL_PBR_EMISSION_COLOR,
 UFBX_MATERIAL_PBR_OPACITY,
 UFBX_MATERIAL_PBR_INDIRECT_DIFFUSE,
 UFBX_MATERIAL_PBR_INDIRECT_SPECULAR,
 UFBX_MATERIAL_PBR_NORMAL_MAP,
 UFBX_MATERIAL_PBR_TANGENT_MAP,
 UFBX_MATERIAL_PBR_DISPLACEMENT_MAP,
 UFBX_MATERIAL_PBR_MATTE_FACTOR,
 UFBX_MATERIAL_PBR_MATTE_COLOR,
 UFBX_MATERIAL_PBR_AMBIENT_OCCLUSION,
 UFBX_MATERIAL_PBR_GLOSSINESS,
 UFBX_MATERIAL_PBR_COAT_GLOSSINESS,
 UFBX_MATERIAL_PBR_TRANSMISSION_GLOSSINESS,

 UFBX_MATERIAL_PBR_MAP_FORCE_32BIT = 0x7fffffff
} ufbx_material_pbr_map;

enum { UFBX_MATERIAL_PBR_MAP_COUNT = UFBX_MATERIAL_PBR_TRANSMISSION_GLOSSINESS + 1 };


typedef enum ufbx_material_feature {
 UFBX_MATERIAL_FEATURE_PBR,
 UFBX_MATERIAL_FEATURE_METALNESS,
 UFBX_MATERIAL_FEATURE_DIFFUSE,
 UFBX_MATERIAL_FEATURE_SPECULAR,
 UFBX_MATERIAL_FEATURE_EMISSION,
 UFBX_MATERIAL_FEATURE_TRANSMISSION,
 UFBX_MATERIAL_FEATURE_COAT,
 UFBX_MATERIAL_FEATURE_SHEEN,
 UFBX_MATERIAL_FEATURE_OPACITY,
 UFBX_MATERIAL_FEATURE_AMBIENT_OCCLUSION,
 UFBX_MATERIAL_FEATURE_MATTE,
 UFBX_MATERIAL_FEATURE_UNLIT,
 UFBX_MATERIAL_FEATURE_IOR,
 UFBX_MATERIAL_FEATURE_DIFFUSE_ROUGHNESS,
 UFBX_MATERIAL_FEATURE_TRANSMISSION_ROUGHNESS,
 UFBX_MATERIAL_FEATURE_THIN_WALLED,
 UFBX_MATERIAL_FEATURE_CAUSTICS,
 UFBX_MATERIAL_FEATURE_EXIT_TO_BACKGROUND,
 UFBX_MATERIAL_FEATURE_INTERNAL_REFLECTIONS,
 UFBX_MATERIAL_FEATURE_DOUBLE_SIDED,
 UFBX_MATERIAL_FEATURE_ROUGHNESS_AS_GLOSSINESS,
 UFBX_MATERIAL_FEATURE_COAT_ROUGHNESS_AS_GLOSSINESS,
 UFBX_MATERIAL_FEATURE_TRANSMISSION_ROUGHNESS_AS_GLOSSINESS,

 UFBX_MATERIAL_FEATURE_FORCE_32BIT = 0x7fffffff
} ufbx_material_feature;

enum { UFBX_MATERIAL_FEATURE_COUNT = UFBX_MATERIAL_FEATURE_TRANSMISSION_ROUGHNESS_AS_GLOSSINESS + 1 };

typedef struct ufbx_material_fbx_maps {
 union {
  ufbx_material_map maps[UFBX_MATERIAL_FBX_MAP_COUNT];
  struct {
   ufbx_material_map diffuse_factor;
   ufbx_material_map diffuse_color;
   ufbx_material_map specular_factor;
   ufbx_material_map specular_color;
   ufbx_material_map specular_exponent;
   ufbx_material_map reflection_factor;
   ufbx_material_map reflection_color;
   ufbx_material_map transparency_factor;
   ufbx_material_map transparency_color;
   ufbx_material_map emission_factor;
   ufbx_material_map emission_color;
   ufbx_material_map ambient_factor;
   ufbx_material_map ambient_color;
   ufbx_material_map normal_map;
   ufbx_material_map bump;
   ufbx_material_map bump_factor;
   ufbx_material_map displacement_factor;
   ufbx_material_map displacement;
   ufbx_material_map vector_displacement_factor;
   ufbx_material_map vector_displacement;
  };
 };
} ufbx_material_fbx_maps;

typedef struct ufbx_material_pbr_maps {
 union {
  ufbx_material_map maps[UFBX_MATERIAL_PBR_MAP_COUNT];
  struct {
   ufbx_material_map base_factor;
   ufbx_material_map base_color;
   ufbx_material_map roughness;
   ufbx_material_map metalness;
   ufbx_material_map diffuse_roughness;
   ufbx_material_map specular_factor;
   ufbx_material_map specular_color;
   ufbx_material_map specular_ior;
   ufbx_material_map specular_anisotropy;
   ufbx_material_map specular_rotation;
   ufbx_material_map transmission_factor;
   ufbx_material_map transmission_color;
   ufbx_material_map transmission_depth;
   ufbx_material_map transmission_scatter;
   ufbx_material_map transmission_scatter_anisotropy;
   ufbx_material_map transmission_dispersion;
   ufbx_material_map transmission_roughness;
   ufbx_material_map transmission_extra_roughness;
   ufbx_material_map transmission_priority;
   ufbx_material_map transmission_enable_in_aov;
   ufbx_material_map subsurface_factor;
   ufbx_material_map subsurface_color;
   ufbx_material_map subsurface_radius;
   ufbx_material_map subsurface_scale;
   ufbx_material_map subsurface_anisotropy;
   ufbx_material_map subsurface_tint_color;
   ufbx_material_map subsurface_type;
   ufbx_material_map sheen_factor;
   ufbx_material_map sheen_color;
   ufbx_material_map sheen_roughness;
   ufbx_material_map coat_factor;
   ufbx_material_map coat_color;
   ufbx_material_map coat_roughness;
   ufbx_material_map coat_ior;
   ufbx_material_map coat_anisotropy;
   ufbx_material_map coat_rotation;
   ufbx_material_map coat_normal;
   ufbx_material_map coat_affect_base_color;
   ufbx_material_map coat_affect_base_roughness;
   ufbx_material_map thin_film_thickness;
   ufbx_material_map thin_film_ior;
   ufbx_material_map emission_factor;
   ufbx_material_map emission_color;
   ufbx_material_map opacity;
   ufbx_material_map indirect_diffuse;
   ufbx_material_map indirect_specular;
   ufbx_material_map normal_map;
   ufbx_material_map tangent_map;
   ufbx_material_map displacement_map;
   ufbx_material_map matte_factor;
   ufbx_material_map matte_color;
   ufbx_material_map ambient_occlusion;
   ufbx_material_map glossiness;
   ufbx_material_map coat_glossiness;
   ufbx_material_map transmission_glossiness;
  };
 };
} ufbx_material_pbr_maps;

typedef struct ufbx_material_features {
 union {
  ufbx_material_feature_info features[UFBX_MATERIAL_FEATURE_COUNT];
  struct {
   ufbx_material_feature_info pbr;
   ufbx_material_feature_info metalness;
   ufbx_material_feature_info diffuse;
   ufbx_material_feature_info specular;
   ufbx_material_feature_info emission;
   ufbx_material_feature_info transmission;
   ufbx_material_feature_info coat;
   ufbx_material_feature_info sheen;
   ufbx_material_feature_info opacity;
   ufbx_material_feature_info ambient_occlusion;
   ufbx_material_feature_info matte;
   ufbx_material_feature_info unlit;
   ufbx_material_feature_info ior;
   ufbx_material_feature_info diffuse_roughness;
   ufbx_material_feature_info transmission_roughness;
   ufbx_material_feature_info thin_walled;
   ufbx_material_feature_info caustics;
   ufbx_material_feature_info exit_to_background;
   ufbx_material_feature_info internal_reflections;
   ufbx_material_feature_info double_sided;
   ufbx_material_feature_info roughness_as_glossiness;
   ufbx_material_feature_info coat_roughness_as_glossiness;
   ufbx_material_feature_info transmission_roughness_as_glossiness;
  };
 };
} ufbx_material_features;



struct ufbx_material {
 union { ufbx_element element; struct {
  ufbx_string name;
  ufbx_props props;
  uint32_t element_id;
  uint32_t typed_id;
 }; };



 ufbx_material_fbx_maps fbx;



 ufbx_material_pbr_maps pbr;


 ufbx_material_features features;


 ufbx_shader_type shader_type;
 ufbx_shader *shader;
 ufbx_string shading_model_name;





 ufbx_string shader_prop_prefix;



 ufbx_material_texture_list textures;
};

typedef enum ufbx_texture_type {





 UFBX_TEXTURE_FILE,


 UFBX_TEXTURE_LAYERED,


 UFBX_TEXTURE_PROCEDURAL,



 UFBX_TEXTURE_SHADER,

 UFBX_TEXTURE_TYPE_FORCE_32BIT = 0x7fffffff
} ufbx_texture_type;

enum { UFBX_TEXTURE_TYPE_COUNT = UFBX_TEXTURE_SHADER + 1 };





typedef enum ufbx_blend_mode {
 UFBX_BLEND_TRANSLUCENT,
 UFBX_BLEND_ADDITIVE,
 UFBX_BLEND_MULTIPLY,
 UFBX_BLEND_MULTIPLY_2X,
 UFBX_BLEND_OVER,
 UFBX_BLEND_REPLACE,
 UFBX_BLEND_DISSOLVE,
 UFBX_BLEND_DARKEN,
 UFBX_BLEND_COLOR_BURN,
 UFBX_BLEND_LINEAR_BURN,
 UFBX_BLEND_DARKER_COLOR,
 UFBX_BLEND_LIGHTEN,
 UFBX_BLEND_SCREEN,
 UFBX_BLEND_COLOR_DODGE,
 UFBX_BLEND_LINEAR_DODGE,
 UFBX_BLEND_LIGHTER_COLOR,
 UFBX_BLEND_SOFT_LIGHT,
 UFBX_BLEND_HARD_LIGHT,
 UFBX_BLEND_VIVID_LIGHT,
 UFBX_BLEND_LINEAR_LIGHT,
 UFBX_BLEND_PIN_LIGHT,
 UFBX_BLEND_HARD_MIX,
 UFBX_BLEND_DIFFERENCE,
 UFBX_BLEND_EXCLUSION,
 UFBX_BLEND_SUBTRACT,
 UFBX_BLEND_DIVIDE,
 UFBX_BLEND_HUE,
 UFBX_BLEND_SATURATION,
 UFBX_BLEND_COLOR,
 UFBX_BLEND_LUMINOSITY,
 UFBX_BLEND_OVERLAY,

 UFBX_BLEND_MODE_FORCE_32BIT = 0x7fffffff
} ufbx_blend_mode;

enum { UFBX_BLEND_MODE_COUNT = UFBX_BLEND_OVERLAY + 1 };


typedef enum ufbx_wrap_mode {
 UFBX_WRAP_REPEAT,
 UFBX_WRAP_CLAMP,

 UFBX_WRAP_MODE_FORCE_32BIT = 0x7fffffff
} ufbx_wrap_mode;

enum { UFBX_WRAP_MODE_COUNT = UFBX_WRAP_CLAMP + 1 };


typedef struct ufbx_texture_layer {
 ufbx_texture *texture;
 ufbx_blend_mode blend_mode;
 ufbx_real alpha;
} ufbx_texture_layer;

struct ufbx_texture_layer_list { ufbx_texture_layer *data; size_t count; ufbx_texture_layer &operator[](size_t index) const { 
# 2733 "include/ufbx.h" 3 4
(static_cast <bool> (
# 2733 "include/ufbx.h"
index < count
# 2733 "include/ufbx.h" 3 4
) ? void (0) : __assert_fail (
# 2733 "include/ufbx.h"
"index < count"
# 2733 "include/ufbx.h" 3 4
, "include/ufbx.h", 2733, __extension__ __PRETTY_FUNCTION__))
# 2733 "include/ufbx.h"
; return data[index]; } ufbx_texture_layer *begin() const { return data; } ufbx_texture_layer *end() const { return data + count; } template <typename T, typename S=typename ufbxi_type_is<T, decltype(ufbx_converter<T>::from_list((ufbx_texture_layer*)nullptr, (size_t)0))>::type> operator T() const { return ufbx_converter<T>::from_list(data, count); } };

typedef enum ufbx_shader_texture_type {
 UFBX_SHADER_TEXTURE_UNKNOWN,




 UFBX_SHADER_TEXTURE_SELECT_OUTPUT,



 UFBX_SHADER_TEXTURE_OSL,

 UFBX_SHADER_TEXTURE_TYPE_FORCE_32BIT = 0x7fffffff
} ufbx_shader_texture_type;

enum { UFBX_SHADER_TEXTURE_TYPE_COUNT = UFBX_SHADER_TEXTURE_OSL + 1 };


typedef struct ufbx_shader_texture_input {


 ufbx_string name;


 union {
  ufbx_real value_real;
  ufbx_vec2 value_vec2;
  ufbx_vec3 value_vec3;
  ufbx_vec4 value_vec4;
 };
 int64_t value_int;
 ufbx_string value_str;
 ufbx_blob value_blob;


 ufbx_texture *texture;


 int64_t texture_output_index;



 bool texture_enabled;


 ufbx_prop *prop;


 ufbx_prop *texture_prop;


 ufbx_prop *texture_enabled_prop;

} ufbx_shader_texture_input;

struct ufbx_shader_texture_input_list { ufbx_shader_texture_input *data; size_t count; ufbx_shader_texture_input &operator[](size_t index) const { 
# 2790 "include/ufbx.h" 3 4
(static_cast <bool> (
# 2790 "include/ufbx.h"
index < count
# 2790 "include/ufbx.h" 3 4
) ? void (0) : __assert_fail (
# 2790 "include/ufbx.h"
"index < count"
# 2790 "include/ufbx.h" 3 4
, "include/ufbx.h", 2790, __extension__ __PRETTY_FUNCTION__))
# 2790 "include/ufbx.h"
; return data[index]; } ufbx_shader_texture_input *begin() const { return data; } ufbx_shader_texture_input *end() const { return data + count; } template <typename T, typename S=typename ufbxi_type_is<T, decltype(ufbx_converter<T>::from_list((ufbx_shader_texture_input*)nullptr, (size_t)0))>::type> operator T() const { return ufbx_converter<T>::from_list(data, count); } };
# 2799 "include/ufbx.h"
typedef struct ufbx_shader_texture {


 ufbx_shader_texture_type type;


 ufbx_string shader_name;


 uint64_t shader_type_id;



 ufbx_shader_texture_input_list inputs;


 ufbx_string shader_source;
 ufbx_blob raw_shader_source;




 ufbx_texture *main_texture;


 int64_t main_texture_output_index;



 ufbx_string prop_prefix;

} ufbx_shader_texture;


typedef struct ufbx_texture_file {


 uint32_t index;






 ufbx_string filename;

 ufbx_string absolute_filename;


 ufbx_string relative_filename;




 ufbx_blob raw_filename;

 ufbx_blob raw_absolute_filename;


 ufbx_blob raw_relative_filename;


 ufbx_blob content;

} ufbx_texture_file;

struct ufbx_texture_file_list { ufbx_texture_file *data; size_t count; ufbx_texture_file &operator[](size_t index) const { 
# 2865 "include/ufbx.h" 3 4
(static_cast <bool> (
# 2865 "include/ufbx.h"
index < count
# 2865 "include/ufbx.h" 3 4
) ? void (0) : __assert_fail (
# 2865 "include/ufbx.h"
"index < count"
# 2865 "include/ufbx.h" 3 4
, "include/ufbx.h", 2865, __extension__ __PRETTY_FUNCTION__))
# 2865 "include/ufbx.h"
; return data[index]; } ufbx_texture_file *begin() const { return data; } ufbx_texture_file *end() const { return data + count; } template <typename T, typename S=typename ufbxi_type_is<T, decltype(ufbx_converter<T>::from_list((ufbx_texture_file*)nullptr, (size_t)0))>::type> operator T() const { return ufbx_converter<T>::from_list(data, count); } };


struct ufbx_texture {
 union { ufbx_element element; struct {
  ufbx_string name;
  ufbx_props props;
  uint32_t element_id;
  uint32_t typed_id;
 }; };


 ufbx_texture_type type;






 ufbx_string filename;

 ufbx_string absolute_filename;


 ufbx_string relative_filename;




 ufbx_blob raw_filename;

 ufbx_blob raw_absolute_filename;


 ufbx_blob raw_relative_filename;


 ufbx_blob content;


 ufbx_video *video;


 uint32_t file_index;


 bool has_file;


 ufbx_texture_layer_list layers;




 ufbx_shader_texture *shader;



 ufbx_texture_list file_textures;


 ufbx_string uv_set;


 ufbx_wrap_mode wrap_u;
 ufbx_wrap_mode wrap_v;


 bool has_uv_transform;
 ufbx_transform uv_transform;
 ufbx_matrix texture_to_uv;
 ufbx_matrix uv_to_texture;
};


struct ufbx_video {
 union { ufbx_element element; struct {
  ufbx_string name;
  ufbx_props props;
  uint32_t element_id;
  uint32_t typed_id;
 }; };






 ufbx_string filename;

 ufbx_string absolute_filename;


 ufbx_string relative_filename;




 ufbx_blob raw_filename;

 ufbx_blob raw_absolute_filename;


 ufbx_blob raw_relative_filename;


 ufbx_blob content;
};



struct ufbx_shader {
 union { ufbx_element element; struct {
  ufbx_string name;
  ufbx_props props;
  uint32_t element_id;
  uint32_t typed_id;
 }; };


 ufbx_shader_type type;





 ufbx_shader_binding_list bindings;
};


typedef struct ufbx_shader_prop_binding {
 ufbx_string shader_prop;
 ufbx_string material_prop;
} ufbx_shader_prop_binding;

struct ufbx_shader_prop_binding_list { ufbx_shader_prop_binding *data; size_t count; ufbx_shader_prop_binding &operator[](size_t index) const { 
# 3000 "include/ufbx.h" 3 4
(static_cast <bool> (
# 3000 "include/ufbx.h"
index < count
# 3000 "include/ufbx.h" 3 4
) ? void (0) : __assert_fail (
# 3000 "include/ufbx.h"
"index < count"
# 3000 "include/ufbx.h" 3 4
, "include/ufbx.h", 3000, __extension__ __PRETTY_FUNCTION__))
# 3000 "include/ufbx.h"
; return data[index]; } ufbx_shader_prop_binding *begin() const { return data; } ufbx_shader_prop_binding *end() const { return data + count; } template <typename T, typename S=typename ufbxi_type_is<T, decltype(ufbx_converter<T>::from_list((ufbx_shader_prop_binding*)nullptr, (size_t)0))>::type> operator T() const { return ufbx_converter<T>::from_list(data, count); } };


struct ufbx_shader_binding {
 union { ufbx_element element; struct {
  ufbx_string name;
  ufbx_props props;
  uint32_t element_id;
  uint32_t typed_id;
 }; };

 ufbx_shader_prop_binding_list prop_bindings;
};



typedef struct ufbx_prop_override {
 uint32_t element_id;

 uint32_t _internal_key;

 ufbx_string prop_name;
 ufbx_vec4 value;
 ufbx_string value_str;
 int64_t value_int;
} ufbx_prop_override;

struct ufbx_prop_override_list { ufbx_prop_override *data; size_t count; ufbx_prop_override &operator[](size_t index) const { 
# 3027 "include/ufbx.h" 3 4
(static_cast <bool> (
# 3027 "include/ufbx.h"
index < count
# 3027 "include/ufbx.h" 3 4
) ? void (0) : __assert_fail (
# 3027 "include/ufbx.h"
"index < count"
# 3027 "include/ufbx.h" 3 4
, "include/ufbx.h", 3027, __extension__ __PRETTY_FUNCTION__))
# 3027 "include/ufbx.h"
; return data[index]; } ufbx_prop_override *begin() const { return data; } ufbx_prop_override *end() const { return data + count; } template <typename T, typename S=typename ufbxi_type_is<T, decltype(ufbx_converter<T>::from_list((ufbx_prop_override*)nullptr, (size_t)0))>::type> operator T() const { return ufbx_converter<T>::from_list(data, count); } };

typedef struct ufbx_transform_override {
 uint32_t node_id;
 ufbx_transform transform;
} ufbx_transform_override;

struct ufbx_transform_override_list { ufbx_transform_override *data; size_t count; ufbx_transform_override &operator[](size_t index) const { 
# 3034 "include/ufbx.h" 3 4
(static_cast <bool> (
# 3034 "include/ufbx.h"
index < count
# 3034 "include/ufbx.h" 3 4
) ? void (0) : __assert_fail (
# 3034 "include/ufbx.h"
"index < count"
# 3034 "include/ufbx.h" 3 4
, "include/ufbx.h", 3034, __extension__ __PRETTY_FUNCTION__))
# 3034 "include/ufbx.h"
; return data[index]; } ufbx_transform_override *begin() const { return data; } ufbx_transform_override *end() const { return data + count; } template <typename T, typename S=typename ufbxi_type_is<T, decltype(ufbx_converter<T>::from_list((ufbx_transform_override*)nullptr, (size_t)0))>::type> operator T() const { return ufbx_converter<T>::from_list(data, count); } };







typedef struct ufbx_anim {


 double time_begin;
 double time_end;


 ufbx_anim_layer_list layers;


 ufbx_real_list override_layer_weights;


 ufbx_prop_override_list prop_overrides;


 ufbx_transform_override_list transform_overrides;


 bool ignore_connections;


 bool custom;

} ufbx_anim;

struct ufbx_anim_stack {
 union { ufbx_element element; struct {
  ufbx_string name;
  ufbx_props props;
  uint32_t element_id;
  uint32_t typed_id;
 }; };

 double time_begin;
 double time_end;

 ufbx_anim_layer_list layers;
 ufbx_anim *anim;
};

typedef struct ufbx_anim_prop {
 ufbx_element *element;

 uint32_t _internal_key;

 ufbx_string prop_name;
 ufbx_anim_value *anim_value;
} ufbx_anim_prop;

struct ufbx_anim_prop_list { ufbx_anim_prop *data; size_t count; ufbx_anim_prop &operator[](size_t index) const { 
# 3092 "include/ufbx.h" 3 4
(static_cast <bool> (
# 3092 "include/ufbx.h"
index < count
# 3092 "include/ufbx.h" 3 4
) ? void (0) : __assert_fail (
# 3092 "include/ufbx.h"
"index < count"
# 3092 "include/ufbx.h" 3 4
, "include/ufbx.h", 3092, __extension__ __PRETTY_FUNCTION__))
# 3092 "include/ufbx.h"
; return data[index]; } ufbx_anim_prop *begin() const { return data; } ufbx_anim_prop *end() const { return data + count; } template <typename T, typename S=typename ufbxi_type_is<T, decltype(ufbx_converter<T>::from_list((ufbx_anim_prop*)nullptr, (size_t)0))>::type> operator T() const { return ufbx_converter<T>::from_list(data, count); } };

struct ufbx_anim_layer {
 union { ufbx_element element; struct {
  ufbx_string name;
  ufbx_props props;
  uint32_t element_id;
  uint32_t typed_id;
 }; };

 ufbx_real weight;
 bool weight_is_animated;
 bool blended;
 bool additive;
 bool compose_rotation;
 bool compose_scale;

 ufbx_anim_value_list anim_values;
 ufbx_anim_prop_list anim_props;

 ufbx_anim *anim;

 uint32_t _min_element_id;
 uint32_t _max_element_id;
 uint32_t _element_id_bitmask[4];
};

struct ufbx_anim_value {
 union { ufbx_element element; struct {
  ufbx_string name;
  ufbx_props props;
  uint32_t element_id;
  uint32_t typed_id;
 }; };

 ufbx_vec3 default_value;
 ufbx_anim_curve *curves[3];
};


typedef enum ufbx_interpolation {
 UFBX_INTERPOLATION_CONSTANT_PREV,
 UFBX_INTERPOLATION_CONSTANT_NEXT,
 UFBX_INTERPOLATION_LINEAR,
 UFBX_INTERPOLATION_CUBIC,

 UFBX_INTERPOLATION_FORCE_32BIT = 0x7fffffff
} ufbx_interpolation;

enum { UFBX_INTERPOLATION_COUNT = UFBX_INTERPOLATION_CUBIC + 1 };


typedef struct ufbx_tangent {
 float dx;
 float dy;
} ufbx_tangent;
# 3161 "include/ufbx.h"
typedef struct ufbx_keyframe {
 double time;
 ufbx_real value;
 ufbx_interpolation interpolation;
 ufbx_tangent left;
 ufbx_tangent right;
} ufbx_keyframe;

struct ufbx_keyframe_list { ufbx_keyframe *data; size_t count; ufbx_keyframe &operator[](size_t index) const { 
# 3169 "include/ufbx.h" 3 4
(static_cast <bool> (
# 3169 "include/ufbx.h"
index < count
# 3169 "include/ufbx.h" 3 4
) ? void (0) : __assert_fail (
# 3169 "include/ufbx.h"
"index < count"
# 3169 "include/ufbx.h" 3 4
, "include/ufbx.h", 3169, __extension__ __PRETTY_FUNCTION__))
# 3169 "include/ufbx.h"
; return data[index]; } ufbx_keyframe *begin() const { return data; } ufbx_keyframe *end() const { return data + count; } template <typename T, typename S=typename ufbxi_type_is<T, decltype(ufbx_converter<T>::from_list((ufbx_keyframe*)nullptr, (size_t)0))>::type> operator T() const { return ufbx_converter<T>::from_list(data, count); } };

struct ufbx_anim_curve {
 union { ufbx_element element; struct {
  ufbx_string name;
  ufbx_props props;
  uint32_t element_id;
  uint32_t typed_id;
 }; };

 ufbx_keyframe_list keyframes;

 ufbx_real min_value;
 ufbx_real max_value;
};




struct ufbx_display_layer {
 union { ufbx_element element; struct {
  ufbx_string name;
  ufbx_props props;
  uint32_t element_id;
  uint32_t typed_id;
 }; };


 ufbx_node_list nodes;


 bool visible;
 bool frozen;

 ufbx_vec3 ui_color;
};


struct ufbx_selection_set {
 union { ufbx_element element; struct {
  ufbx_string name;
  ufbx_props props;
  uint32_t element_id;
  uint32_t typed_id;
 }; };


 ufbx_selection_node_list nodes;
};


struct ufbx_selection_node {
 union { ufbx_element element; struct {
  ufbx_string name;
  ufbx_props props;
  uint32_t element_id;
  uint32_t typed_id;
 }; };


 ufbx_node *target_node;
 ufbx_mesh *target_mesh;
 bool include_node;




 ufbx_uint32_list vertices;
 ufbx_uint32_list edges;
 ufbx_uint32_list faces;
};



struct ufbx_character {
 union { ufbx_element element; struct {
  ufbx_string name;
  ufbx_props props;
  uint32_t element_id;
  uint32_t typed_id;
 }; };
};


typedef enum ufbx_constraint_type {
 UFBX_CONSTRAINT_UNKNOWN,
 UFBX_CONSTRAINT_AIM,
 UFBX_CONSTRAINT_PARENT,
 UFBX_CONSTRAINT_POSITION,
 UFBX_CONSTRAINT_ROTATION,
 UFBX_CONSTRAINT_SCALE,


 UFBX_CONSTRAINT_SINGLE_CHAIN_IK,

 UFBX_CONSTRAINT_TYPE_FORCE_32BIT = 0x7fffffff
} ufbx_constraint_type;

enum { UFBX_CONSTRAINT_TYPE_COUNT = UFBX_CONSTRAINT_SINGLE_CHAIN_IK + 1 };


typedef struct ufbx_constraint_target {
 ufbx_node *node;
 ufbx_real weight;
 ufbx_transform transform;
} ufbx_constraint_target;

struct ufbx_constraint_target_list { ufbx_constraint_target *data; size_t count; ufbx_constraint_target &operator[](size_t index) const { 
# 3276 "include/ufbx.h" 3 4
(static_cast <bool> (
# 3276 "include/ufbx.h"
index < count
# 3276 "include/ufbx.h" 3 4
) ? void (0) : __assert_fail (
# 3276 "include/ufbx.h"
"index < count"
# 3276 "include/ufbx.h" 3 4
, "include/ufbx.h", 3276, __extension__ __PRETTY_FUNCTION__))
# 3276 "include/ufbx.h"
; return data[index]; } ufbx_constraint_target *begin() const { return data; } ufbx_constraint_target *end() const { return data + count; } template <typename T, typename S=typename ufbxi_type_is<T, decltype(ufbx_converter<T>::from_list((ufbx_constraint_target*)nullptr, (size_t)0))>::type> operator T() const { return ufbx_converter<T>::from_list(data, count); } };


typedef enum ufbx_constraint_aim_up_type {
 UFBX_CONSTRAINT_AIM_UP_SCENE,
 UFBX_CONSTRAINT_AIM_UP_TO_NODE,
 UFBX_CONSTRAINT_AIM_UP_ALIGN_NODE,
 UFBX_CONSTRAINT_AIM_UP_VECTOR,
 UFBX_CONSTRAINT_AIM_UP_NONE,

 UFBX_CONSTRAINT_AIM_UP_TYPE_FORCE_32BIT = 0x7fffffff
} ufbx_constraint_aim_up_type;

enum { UFBX_CONSTRAINT_AIM_UP_TYPE_COUNT = UFBX_CONSTRAINT_AIM_UP_NONE + 1 };


typedef enum ufbx_constraint_ik_pole_type {
 UFBX_CONSTRAINT_IK_POLE_VECTOR,
 UFBX_CONSTRAINT_IK_POLE_NODE,

 UFBX_CONSTRAINT_IK_POLE_TYPE_FORCE_32BIT = 0x7fffffff
} ufbx_constraint_ik_pole_type;

enum { UFBX_CONSTRAINT_IK_POLE_TYPE_COUNT = UFBX_CONSTRAINT_IK_POLE_NODE + 1 };

struct ufbx_constraint {
 union { ufbx_element element; struct {
  ufbx_string name;
  ufbx_props props;
  uint32_t element_id;
  uint32_t typed_id;
 }; };


 ufbx_constraint_type type;
 ufbx_string type_name;


 ufbx_node *node;


 ufbx_constraint_target_list targets;


 ufbx_real weight;
 bool active;


 bool constrain_translation[3];
 bool constrain_rotation[3];
 bool constrain_scale[3];


 ufbx_transform transform_offset;


 ufbx_vec3 aim_vector;
 ufbx_constraint_aim_up_type aim_up_type;
 ufbx_node *aim_up_node;
 ufbx_vec3 aim_up_vector;


 ufbx_node *ik_effector;
 ufbx_node *ik_end_node;
 ufbx_vec3 ik_pole_vector;
};



struct ufbx_audio_layer {
 union { ufbx_element element; struct {
  ufbx_string name;
  ufbx_props props;
  uint32_t element_id;
  uint32_t typed_id;
 }; };


 ufbx_audio_clip_list clips;
};

struct ufbx_audio_clip {
 union { ufbx_element element; struct {
  ufbx_string name;
  ufbx_props props;
  uint32_t element_id;
  uint32_t typed_id;
 }; };




 ufbx_string filename;

 ufbx_string absolute_filename;


 ufbx_string relative_filename;




 ufbx_blob raw_filename;

 ufbx_blob raw_absolute_filename;


 ufbx_blob raw_relative_filename;


 ufbx_blob content;
};



typedef struct ufbx_bone_pose {


 ufbx_node *bone_node;


 ufbx_matrix bone_to_world;




 ufbx_matrix bone_to_parent;

} ufbx_bone_pose;

struct ufbx_bone_pose_list { ufbx_bone_pose *data; size_t count; ufbx_bone_pose &operator[](size_t index) const { 
# 3406 "include/ufbx.h" 3 4
(static_cast <bool> (
# 3406 "include/ufbx.h"
index < count
# 3406 "include/ufbx.h" 3 4
) ? void (0) : __assert_fail (
# 3406 "include/ufbx.h"
"index < count"
# 3406 "include/ufbx.h" 3 4
, "include/ufbx.h", 3406, __extension__ __PRETTY_FUNCTION__))
# 3406 "include/ufbx.h"
; return data[index]; } ufbx_bone_pose *begin() const { return data; } ufbx_bone_pose *end() const { return data + count; } template <typename T, typename S=typename ufbxi_type_is<T, decltype(ufbx_converter<T>::from_list((ufbx_bone_pose*)nullptr, (size_t)0))>::type> operator T() const { return ufbx_converter<T>::from_list(data, count); } };

struct ufbx_pose {
 union { ufbx_element element; struct {
  ufbx_string name;
  ufbx_props props;
  uint32_t element_id;
  uint32_t typed_id;
 }; };


 bool is_bind_pose;



 ufbx_bone_pose_list bone_poses;
};

struct ufbx_metadata_object {
 union { ufbx_element element; struct {
  ufbx_string name;
  ufbx_props props;
  uint32_t element_id;
  uint32_t typed_id;
 }; };
};



typedef struct ufbx_name_element {
 ufbx_string name;
 ufbx_element_type type;

 uint32_t _internal_key;

 ufbx_element *element;
} ufbx_name_element;

struct ufbx_name_element_list { ufbx_name_element *data; size_t count; ufbx_name_element &operator[](size_t index) const { 
# 3444 "include/ufbx.h" 3 4
(static_cast <bool> (
# 3444 "include/ufbx.h"
index < count
# 3444 "include/ufbx.h" 3 4
) ? void (0) : __assert_fail (
# 3444 "include/ufbx.h"
"index < count"
# 3444 "include/ufbx.h" 3 4
, "include/ufbx.h", 3444, __extension__ __PRETTY_FUNCTION__))
# 3444 "include/ufbx.h"
; return data[index]; } ufbx_name_element *begin() const { return data; } ufbx_name_element *end() const { return data + count; } template <typename T, typename S=typename ufbxi_type_is<T, decltype(ufbx_converter<T>::from_list((ufbx_name_element*)nullptr, (size_t)0))>::type> operator T() const { return ufbx_converter<T>::from_list(data, count); } };





typedef enum ufbx_exporter {
 UFBX_EXPORTER_UNKNOWN,
 UFBX_EXPORTER_FBX_SDK,
 UFBX_EXPORTER_BLENDER_BINARY,
 UFBX_EXPORTER_BLENDER_ASCII,
 UFBX_EXPORTER_MOTION_BUILDER,

 UFBX_EXPORTER_FORCE_32BIT = 0x7fffffff
} ufbx_exporter;

enum { UFBX_EXPORTER_COUNT = UFBX_EXPORTER_MOTION_BUILDER + 1 };

typedef struct ufbx_application {
 ufbx_string vendor;
 ufbx_string name;
 ufbx_string version;
} ufbx_application;

typedef enum ufbx_file_format {
 UFBX_FILE_FORMAT_UNKNOWN,
 UFBX_FILE_FORMAT_FBX,
 UFBX_FILE_FORMAT_OBJ,
 UFBX_FILE_FORMAT_MTL,

 UFBX_FILE_FORMAT_FORCE_32BIT = 0x7fffffff
} ufbx_file_format;

enum { UFBX_FILE_FORMAT_COUNT = UFBX_FILE_FORMAT_MTL + 1 };

typedef enum ufbx_warning_type {


 UFBX_WARNING_MISSING_EXTERNAL_FILE,



 UFBX_WARNING_IMPLICIT_MTL,


 UFBX_WARNING_TRUNCATED_ARRAY,


 UFBX_WARNING_MISSING_GEOMETRY_DATA,


 UFBX_WARNING_DUPLICATE_CONNECTION,


 UFBX_WARNING_BAD_VERTEX_W_ATTRIBUTE,


 UFBX_WARNING_MISSING_POLYGON_MAPPING,



 UFBX_WARNING_INDEX_CLAMPED,



 UFBX_WARNING_BAD_UNICODE,


 UFBX_WARNING_BAD_ELEMENT_CONNECTED_TO_ROOT,


 UFBX_WARNING_DUPLICATE_OBJECT_ID,



 UFBX_WARNING_EMPTY_FACE_REMOVED,


 UFBX_WARNING_UNKNOWN_OBJ_DIRECTIVE,



 UFBX_WARNING_TYPE_FIRST_DEDUPLICATED = UFBX_WARNING_INDEX_CLAMPED,

 UFBX_WARNING_TYPE_FORCE_32BIT = 0x7fffffff
} ufbx_warning_type;

enum { UFBX_WARNING_TYPE_COUNT = UFBX_WARNING_UNKNOWN_OBJ_DIRECTIVE + 1 };




typedef struct ufbx_warning {

 ufbx_warning_type type;

 ufbx_string description;

 uint32_t element_id;

 size_t count;
} ufbx_warning;

struct ufbx_warning_list { ufbx_warning *data; size_t count; ufbx_warning &operator[](size_t index) const { 
# 3547 "include/ufbx.h" 3 4
(static_cast <bool> (
# 3547 "include/ufbx.h"
index < count
# 3547 "include/ufbx.h" 3 4
) ? void (0) : __assert_fail (
# 3547 "include/ufbx.h"
"index < count"
# 3547 "include/ufbx.h" 3 4
, "include/ufbx.h", 3547, __extension__ __PRETTY_FUNCTION__))
# 3547 "include/ufbx.h"
; return data[index]; } ufbx_warning *begin() const { return data; } ufbx_warning *end() const { return data + count; } template <typename T, typename S=typename ufbxi_type_is<T, decltype(ufbx_converter<T>::from_list((ufbx_warning*)nullptr, (size_t)0))>::type> operator T() const { return ufbx_converter<T>::from_list(data, count); } };

typedef enum ufbx_thumbnail_format {
 UFBX_THUMBNAIL_FORMAT_UNKNOWN,
 UFBX_THUMBNAIL_FORMAT_RGB_24,
 UFBX_THUMBNAIL_FORMAT_RGBA_32,

 UFBX_THUMBNAIL_FORMAT_FORCE_32BIT = 0x7fffffff
} ufbx_thumbnail_format;

enum { UFBX_THUMBNAIL_FORMAT_COUNT = UFBX_THUMBNAIL_FORMAT_RGBA_32 + 1 };




typedef enum ufbx_space_conversion {



 UFBX_SPACE_CONVERSION_TRANSFORM_ROOT,





 UFBX_SPACE_CONVERSION_ADJUST_TRANSFORMS,




 UFBX_SPACE_CONVERSION_MODIFY_GEOMETRY,

 UFBX_SPACE_CONVERSION_FORCE_32BIT = 0x7fffffff
} ufbx_space_conversion;

enum { UFBX_SPACE_CONVERSION_COUNT = UFBX_SPACE_CONVERSION_MODIFY_GEOMETRY + 1 };


typedef struct ufbx_thumbnail {
 ufbx_props props;


 uint32_t width;
 uint32_t height;


 ufbx_thumbnail_format format;



 ufbx_blob data;
} ufbx_thumbnail;


typedef struct ufbx_metadata {




 ufbx_warning_list warnings;


 bool ascii;


 uint32_t version;


 ufbx_file_format file_format;



 bool may_contain_no_index;



 bool may_contain_missing_vertex_position;



 bool may_contain_broken_elements;



 bool is_unsafe;



 bool has_warning[UFBX_WARNING_TYPE_COUNT];

 ufbx_string creator;
 bool big_endian;

 ufbx_string filename;
 ufbx_string relative_root;

 ufbx_blob raw_filename;
 ufbx_blob raw_relative_root;

 ufbx_exporter exporter;
 uint32_t exporter_version;

 ufbx_props scene_props;

 ufbx_application original_application;
 ufbx_application latest_application;

 ufbx_thumbnail thumbnail;

 bool geometry_ignored;
 bool animation_ignored;
 bool embedded_ignored;

 size_t max_face_triangles;

 size_t result_memory_used;
 size_t temp_memory_used;
 size_t result_allocs;
 size_t temp_allocs;

 size_t element_buffer_size;
 size_t num_shader_textures;

 ufbx_real bone_prop_size_unit;
 bool bone_prop_limb_length_relative;

 ufbx_real ortho_size_unit;

 int64_t ktime_second;

 ufbx_string original_file_path;
 ufbx_blob raw_original_file_path;


 ufbx_space_conversion space_conversion;


 ufbx_quat root_rotation;
 ufbx_real root_scale;



 ufbx_mirror_axis mirror_axis;



 ufbx_real geometry_scale;

} ufbx_metadata;

typedef enum ufbx_time_mode {
 UFBX_TIME_MODE_DEFAULT,
 UFBX_TIME_MODE_120_FPS,
 UFBX_TIME_MODE_100_FPS,
 UFBX_TIME_MODE_60_FPS,
 UFBX_TIME_MODE_50_FPS,
 UFBX_TIME_MODE_48_FPS,
 UFBX_TIME_MODE_30_FPS,
 UFBX_TIME_MODE_30_FPS_DROP,
 UFBX_TIME_MODE_NTSC_DROP_FRAME,
 UFBX_TIME_MODE_NTSC_FULL_FRAME,
 UFBX_TIME_MODE_PAL,
 UFBX_TIME_MODE_24_FPS,
 UFBX_TIME_MODE_1000_FPS,
 UFBX_TIME_MODE_FILM_FULL_FRAME,
 UFBX_TIME_MODE_CUSTOM,
 UFBX_TIME_MODE_96_FPS,
 UFBX_TIME_MODE_72_FPS,
 UFBX_TIME_MODE_59_94_FPS,

 UFBX_TIME_MODE_FORCE_32BIT = 0x7fffffff
} ufbx_time_mode;

enum { UFBX_TIME_MODE_COUNT = UFBX_TIME_MODE_59_94_FPS + 1 };

typedef enum ufbx_time_protocol {
 UFBX_TIME_PROTOCOL_SMPTE,
 UFBX_TIME_PROTOCOL_FRAME_COUNT,
 UFBX_TIME_PROTOCOL_DEFAULT,

 UFBX_TIME_PROTOCOL_FORCE_32BIT = 0x7fffffff
} ufbx_time_protocol;

enum { UFBX_TIME_PROTOCOL_COUNT = UFBX_TIME_PROTOCOL_DEFAULT + 1 };

typedef enum ufbx_snap_mode {
 UFBX_SNAP_MODE_NONE,
 UFBX_SNAP_MODE_SNAP,
 UFBX_SNAP_MODE_PLAY,
 UFBX_SNAP_MODE_SNAP_AND_PLAY,

 UFBX_SNAP_MODE_FORCE_32BIT = 0x7fffffff
} ufbx_snap_mode;

enum { UFBX_SNAP_MODE_COUNT = UFBX_SNAP_MODE_SNAP_AND_PLAY + 1 };


typedef struct ufbx_scene_settings {
 ufbx_props props;




 ufbx_coordinate_axes axes;




 ufbx_real unit_meters;


 double frames_per_second;

 ufbx_vec3 ambient_color;
 ufbx_string default_camera;



 ufbx_time_mode time_mode;
 ufbx_time_protocol time_protocol;
 ufbx_snap_mode snap_mode;


 ufbx_coordinate_axis original_axis_up;
 ufbx_real original_unit_meters;
} ufbx_scene_settings;

struct ufbx_scene {
 ufbx_metadata metadata;


 ufbx_scene_settings settings;


 ufbx_node *root_node;


 ufbx_anim *anim;

 union {
  struct {
   ufbx_unknown_list unknowns;


   ufbx_node_list nodes;


   ufbx_mesh_list meshes;
   ufbx_light_list lights;
   ufbx_camera_list cameras;
   ufbx_bone_list bones;
   ufbx_empty_list empties;


   ufbx_line_curve_list line_curves;
   ufbx_nurbs_curve_list nurbs_curves;
   ufbx_nurbs_surface_list nurbs_surfaces;
   ufbx_nurbs_trim_surface_list nurbs_trim_surfaces;
   ufbx_nurbs_trim_boundary_list nurbs_trim_boundaries;


   ufbx_procedural_geometry_list procedural_geometries;
   ufbx_stereo_camera_list stereo_cameras;
   ufbx_camera_switcher_list camera_switchers;
   ufbx_marker_list markers;
   ufbx_lod_group_list lod_groups;


   ufbx_skin_deformer_list skin_deformers;
   ufbx_skin_cluster_list skin_clusters;
   ufbx_blend_deformer_list blend_deformers;
   ufbx_blend_channel_list blend_channels;
   ufbx_blend_shape_list blend_shapes;
   ufbx_cache_deformer_list cache_deformers;
   ufbx_cache_file_list cache_files;


   ufbx_material_list materials;
   ufbx_texture_list textures;
   ufbx_video_list videos;
   ufbx_shader_list shaders;
   ufbx_shader_binding_list shader_bindings;


   ufbx_anim_stack_list anim_stacks;
   ufbx_anim_layer_list anim_layers;
   ufbx_anim_value_list anim_values;
   ufbx_anim_curve_list anim_curves;


   ufbx_display_layer_list display_layers;
   ufbx_selection_set_list selection_sets;
   ufbx_selection_node_list selection_nodes;


   ufbx_character_list characters;
   ufbx_constraint_list constraints;


   ufbx_audio_layer_list audio_layers;
   ufbx_audio_clip_list audio_clips;


   ufbx_pose_list poses;
   ufbx_metadata_object_list metadata_objects;
  };

  ufbx_element_list elements_by_type[UFBX_ELEMENT_TYPE_COUNT];
 };


 ufbx_texture_file_list texture_files;


 ufbx_element_list elements;
 ufbx_connection_list connections_src;
 ufbx_connection_list connections_dst;


 ufbx_name_element_list elements_by_name;


 ufbx_dom_node *dom_root;
};



typedef struct ufbx_curve_point {
 bool valid;
 ufbx_vec3 position;
 ufbx_vec3 derivative;
} ufbx_curve_point;

typedef struct ufbx_surface_point {
 bool valid;
 ufbx_vec3 position;
 ufbx_vec3 derivative_u;
 ufbx_vec3 derivative_v;
} ufbx_surface_point;



typedef enum ufbx_topo_flags {
 UFBX_TOPO_NON_MANIFOLD = 0x1,

 UFBX_TOPO_FLAGS_FORCE_32BIT = 0x7fffffff
} ufbx_topo_flags;

typedef struct ufbx_topo_edge {
 uint32_t index;
 uint32_t next;
 uint32_t prev;
 uint32_t twin;
 uint32_t face;
 uint32_t edge;

 ufbx_topo_flags flags;
} ufbx_topo_edge;




typedef struct ufbx_vertex_stream {
 void *data;
 size_t vertex_count;
 size_t vertex_size;
} ufbx_vertex_stream;







typedef void *ufbx_alloc_fn(void *user, size_t size);





typedef void *ufbx_realloc_fn(void *user, void *old_ptr, size_t old_size, size_t new_size);


typedef void ufbx_free_fn(void *user, void *ptr, size_t size);


typedef void ufbx_free_allocator_fn(void *user);





typedef struct ufbx_allocator {

 ufbx_alloc_fn *alloc_fn;
 ufbx_realloc_fn *realloc_fn;
 ufbx_free_fn *free_fn;
 ufbx_free_allocator_fn *free_allocator_fn;
 void *user;
} ufbx_allocator;

typedef struct ufbx_allocator_opts {

 ufbx_allocator allocator;


 size_t memory_limit;


 size_t allocation_limit;





 size_t huge_threshold;
# 3974 "include/ufbx.h"
 size_t max_chunk_size;

} ufbx_allocator_opts;





typedef size_t ufbx_read_fn(void *user, void *data, size_t size);


typedef bool ufbx_skip_fn(void *user, size_t size);


typedef void ufbx_close_fn(void *user);

typedef struct ufbx_stream {
 ufbx_read_fn *read_fn;
 ufbx_skip_fn *skip_fn;
 ufbx_close_fn *close_fn;


 void *user;
} ufbx_stream;

typedef enum ufbx_open_file_type {
 UFBX_OPEN_FILE_MAIN_MODEL,
 UFBX_OPEN_FILE_GEOMETRY_CACHE,
 UFBX_OPEN_FILE_OBJ_MTL,

 UFBX_OPEN_FILE_TYPE_FORCE_32BIT = 0x7fffffff
} ufbx_open_file_type;

enum { UFBX_OPEN_FILE_TYPE_COUNT = UFBX_OPEN_FILE_OBJ_MTL + 1 };

typedef struct ufbx_open_file_info {

 ufbx_open_file_type type;


 ufbx_allocator temp_allocator;



 ufbx_blob original_filename;
} ufbx_open_file_info;


typedef bool ufbx_open_file_fn(void *user, ufbx_stream *stream, const char *path, size_t path_len, const ufbx_open_file_info *info);

typedef struct ufbx_open_file_cb {
 ufbx_open_file_fn *fn;
 void *user;

 template <typename F> static bool _cpp_adapter (void *user, ufbx_stream *stream, const char *path, size_t path_len, const ufbx_open_file_info *info) { F &f = *static_cast<F*>(user); return f (stream, path, path_len, info); } ufbx_open_file_cb() = default; ufbx_open_file_cb(ufbx_open_file_fn *f) : fn(f), user(nullptr) { } template <typename F> ufbx_open_file_cb(F *f) : fn(&_cpp_adapter<F>), user(static_cast<void*>(f)) { }


} ufbx_open_file_cb;


typedef void ufbx_close_memory_fn(void *user, void *data, size_t data_size);

typedef struct ufbx_close_memory_cb {
 ufbx_close_memory_fn *fn;
 void *user;

 template <typename F> static void _cpp_adapter (void *user, void *data, size_t data_size) { F &f = *static_cast<F*>(user); return f (data, data_size); } ufbx_close_memory_cb() = default; ufbx_close_memory_cb(ufbx_close_memory_fn *f) : fn(f), user(nullptr) { } template <typename F> ufbx_close_memory_cb(F *f) : fn(&_cpp_adapter<F>), user(static_cast<void*>(f)) { }


} ufbx_close_memory_cb;


typedef struct ufbx_open_memory_opts {
 uint32_t _begin_zero;



 ufbx_allocator_opts allocator;





 bool no_copy;


 ufbx_close_memory_cb close_cb;

 uint32_t _end_zero;
} ufbx_open_memory_opts;


typedef struct ufbx_error_frame {
 uint32_t source_line;
 ufbx_string function;
 ufbx_string description;
} ufbx_error_frame;


typedef enum ufbx_error_type {


 UFBX_ERROR_NONE,



 UFBX_ERROR_UNKNOWN,


 UFBX_ERROR_FILE_NOT_FOUND,


 UFBX_ERROR_EMPTY_FILE,



 UFBX_ERROR_EXTERNAL_FILE_NOT_FOUND,


 UFBX_ERROR_OUT_OF_MEMORY,


 UFBX_ERROR_MEMORY_LIMIT,


 UFBX_ERROR_ALLOCATION_LIMIT,


 UFBX_ERROR_TRUNCATED_FILE,



 UFBX_ERROR_IO,


 UFBX_ERROR_CANCELLED,




 UFBX_ERROR_UNRECOGNIZED_FILE_FORMAT,





 UFBX_ERROR_UNINITIALIZED_OPTIONS,


 UFBX_ERROR_ZERO_VERTEX_SIZE,


 UFBX_ERROR_TRUNCATED_VERTEX_STREAM,


 UFBX_ERROR_INVALID_UTF8,


 UFBX_ERROR_FEATURE_DISABLED,



 UFBX_ERROR_BAD_NURBS,


 UFBX_ERROR_BAD_INDEX,


 UFBX_ERROR_NODE_DEPTH_LIMIT,




 UFBX_ERROR_THREADED_ASCII_PARSE,


 UFBX_ERROR_UNSAFE_OPTIONS,


 UFBX_ERROR_DUPLICATE_OVERRIDE,

 UFBX_ERROR_TYPE_FORCE_32BIT = 0x7fffffff
} ufbx_error_type;

enum { UFBX_ERROR_TYPE_COUNT = UFBX_ERROR_DUPLICATE_OVERRIDE + 1 };



typedef struct ufbx_error {
 ufbx_error_type type;
 ufbx_string description;
 uint32_t stack_size;
 ufbx_error_frame stack[8];
 size_t info_length;
 char info[256];
} ufbx_error;



typedef struct ufbx_progress {
 uint64_t bytes_read;
 uint64_t bytes_total;
} ufbx_progress;

typedef enum ufbx_progress_result {
 UFBX_PROGRESS_CONTINUE = 0x100,
 UFBX_PROGRESS_CANCEL = 0x200,

 UFBX_PROGRESS_RESULT_FORCE_32BIT = 0x7fffffff
} ufbx_progress_result;



typedef ufbx_progress_result ufbx_progress_fn(void *user, const ufbx_progress *progress);

typedef struct ufbx_progress_cb {
 ufbx_progress_fn *fn;
 void *user;

 template <typename F> static ufbx_progress_result _cpp_adapter (void *user, const ufbx_progress *progress) { F &f = *static_cast<F*>(user); return f (progress); } ufbx_progress_cb() = default; ufbx_progress_cb(ufbx_progress_fn *f) : fn(f), user(nullptr) { } template <typename F> ufbx_progress_cb(F *f) : fn(&_cpp_adapter<F>), user(static_cast<void*>(f)) { }


} ufbx_progress_cb;



typedef struct ufbx_inflate_input ufbx_inflate_input;
typedef struct ufbx_inflate_retain ufbx_inflate_retain;


struct ufbx_inflate_input {

 size_t total_size;


 const void *data;
 size_t data_size;


 void *buffer;
 size_t buffer_size;


 ufbx_read_fn *read_fn;
 void *read_user;


 ufbx_progress_cb progress_cb;
 uint64_t progress_interval_hint;


 uint64_t progress_size_before;
 uint64_t progress_size_after;


 bool no_header;


 bool no_checksum;


 size_t internal_fast_bits;
};



struct ufbx_inflate_retain {
 bool initialized;
 uint64_t data[1024];
};

typedef enum ufbx_index_error_handling {

 UFBX_INDEX_ERROR_HANDLING_CLAMP,




 UFBX_INDEX_ERROR_HANDLING_NO_INDEX,

 UFBX_INDEX_ERROR_HANDLING_ABORT_LOADING,




 UFBX_INDEX_ERROR_HANDLING_UNSAFE_IGNORE,

 UFBX_INDEX_ERROR_HANDLING_FORCE_32BIT = 0x7fffffff
} ufbx_index_error_handling;

enum { UFBX_INDEX_ERROR_HANDLING_COUNT = UFBX_INDEX_ERROR_HANDLING_UNSAFE_IGNORE + 1 };

typedef enum ufbx_unicode_error_handling {

 UFBX_UNICODE_ERROR_HANDLING_REPLACEMENT_CHARACTER,

 UFBX_UNICODE_ERROR_HANDLING_UNDERSCORE,

 UFBX_UNICODE_ERROR_HANDLING_QUESTION_MARK,

 UFBX_UNICODE_ERROR_HANDLING_REMOVE,

 UFBX_UNICODE_ERROR_HANDLING_ABORT_LOADING,



 UFBX_UNICODE_ERROR_HANDLING_UNSAFE_IGNORE,

 UFBX_UNICODE_ERROR_HANDLING_FORCE_32BIT = 0x7fffffff
} ufbx_unicode_error_handling;

enum { UFBX_UNICODE_ERROR_HANDLING_COUNT = UFBX_UNICODE_ERROR_HANDLING_UNSAFE_IGNORE + 1 };







typedef enum ufbx_geometry_transform_handling {





 UFBX_GEOMETRY_TRANSFORM_HANDLING_PRESERVE,




 UFBX_GEOMETRY_TRANSFORM_HANDLING_HELPER_NODES,





 UFBX_GEOMETRY_TRANSFORM_HANDLING_MODIFY_GEOMETRY,



 UFBX_GEOMETRY_TRANSFORM_HANDLING_MODIFY_GEOMETRY_NO_FALLBACK,

 UFBX_GEOMETRY_TRANSFORM_HANDLING_FORCE_32BIT = 0x7fffffff
} ufbx_geometry_transform_handling;

enum { UFBX_GEOMETRY_TRANSFORM_HANDLING_COUNT = UFBX_GEOMETRY_TRANSFORM_HANDLING_MODIFY_GEOMETRY_NO_FALLBACK + 1 };


typedef enum ufbx_inherit_mode_handling {




 UFBX_INHERIT_MODE_HANDLING_PRESERVE,




 UFBX_INHERIT_MODE_HANDLING_HELPER_NODES,





 UFBX_INHERIT_MODE_HANDLING_COMPENSATE,



 UFBX_INHERIT_MODE_HANDLING_COMPENSATE_NO_FALLBACK,





 UFBX_INHERIT_MODE_HANDLING_IGNORE,

 UFBX_INHERIT_MODE_HANDLING_FORCE_32BIT = 0x7fffffff
} ufbx_inherit_mode_handling;

enum { UFBX_INHERIT_MODE_HANDLING_COUNT = UFBX_INHERIT_MODE_HANDLING_IGNORE + 1 };


typedef enum ufbx_pivot_handling {


 UFBX_PIVOT_HANDLING_RETAIN,





 UFBX_PIVOT_HANDLING_ADJUST_TO_PIVOT,

 UFBX_PIVOT_HANDLING_FORCE_32BIT = 0x7fffffff
} ufbx_pivot_handling;

enum { UFBX_PIVOT_HANDLING_COUNT = UFBX_PIVOT_HANDLING_ADJUST_TO_PIVOT + 1 };

typedef enum ufbx_baked_key_flags {

 UFBX_BAKED_KEY_STEP_LEFT = 0x1,

 UFBX_BAKED_KEY_STEP_RIGHT = 0x2,


 UFBX_BAKED_KEY_STEP_KEY = 0x4,

 UFBX_BAKED_KEY_KEYFRAME = 0x8,


 UFBX_BAKED_KEY_REDUCED = 0x10,

 UFBX_BAKED_KEY_FORCE_32BIT = 0x7fffffff
} ufbx_baked_key_flags;

typedef struct ufbx_baked_vec3 {
 double time;
 ufbx_vec3 value;
 ufbx_baked_key_flags flags;
} ufbx_baked_vec3;

struct ufbx_baked_vec3_list { ufbx_baked_vec3 *data; size_t count; ufbx_baked_vec3 &operator[](size_t index) const { 
# 4395 "include/ufbx.h" 3 4
(static_cast <bool> (
# 4395 "include/ufbx.h"
index < count
# 4395 "include/ufbx.h" 3 4
) ? void (0) : __assert_fail (
# 4395 "include/ufbx.h"
"index < count"
# 4395 "include/ufbx.h" 3 4
, "include/ufbx.h", 4395, __extension__ __PRETTY_FUNCTION__))
# 4395 "include/ufbx.h"
; return data[index]; } ufbx_baked_vec3 *begin() const { return data; } ufbx_baked_vec3 *end() const { return data + count; } template <typename T, typename S=typename ufbxi_type_is<T, decltype(ufbx_converter<T>::from_list((ufbx_baked_vec3*)nullptr, (size_t)0))>::type> operator T() const { return ufbx_converter<T>::from_list(data, count); } };

typedef struct ufbx_baked_quat {
 double time;
 ufbx_quat value;
 ufbx_baked_key_flags flags;
} ufbx_baked_quat;

struct ufbx_baked_quat_list { ufbx_baked_quat *data; size_t count; ufbx_baked_quat &operator[](size_t index) const { 
# 4403 "include/ufbx.h" 3 4
(static_cast <bool> (
# 4403 "include/ufbx.h"
index < count
# 4403 "include/ufbx.h" 3 4
) ? void (0) : __assert_fail (
# 4403 "include/ufbx.h"
"index < count"
# 4403 "include/ufbx.h" 3 4
, "include/ufbx.h", 4403, __extension__ __PRETTY_FUNCTION__))
# 4403 "include/ufbx.h"
; return data[index]; } ufbx_baked_quat *begin() const { return data; } ufbx_baked_quat *end() const { return data + count; } template <typename T, typename S=typename ufbxi_type_is<T, decltype(ufbx_converter<T>::from_list((ufbx_baked_quat*)nullptr, (size_t)0))>::type> operator T() const { return ufbx_converter<T>::from_list(data, count); } };


typedef struct ufbx_baked_node {


 uint32_t typed_id;

 uint32_t element_id;


 bool constant_translation;

 bool constant_rotation;

 bool constant_scale;


 ufbx_baked_vec3_list translation_keys;

 ufbx_baked_quat_list rotation_keys;

 ufbx_baked_vec3_list scale_keys;

} ufbx_baked_node;

struct ufbx_baked_node_list { ufbx_baked_node *data; size_t count; ufbx_baked_node &operator[](size_t index) const { 
# 4429 "include/ufbx.h" 3 4
(static_cast <bool> (
# 4429 "include/ufbx.h"
index < count
# 4429 "include/ufbx.h" 3 4
) ? void (0) : __assert_fail (
# 4429 "include/ufbx.h"
"index < count"
# 4429 "include/ufbx.h" 3 4
, "include/ufbx.h", 4429, __extension__ __PRETTY_FUNCTION__))
# 4429 "include/ufbx.h"
; return data[index]; } ufbx_baked_node *begin() const { return data; } ufbx_baked_node *end() const { return data + count; } template <typename T, typename S=typename ufbxi_type_is<T, decltype(ufbx_converter<T>::from_list((ufbx_baked_node*)nullptr, (size_t)0))>::type> operator T() const { return ufbx_converter<T>::from_list(data, count); } };


typedef struct ufbx_baked_prop {

 ufbx_string name;

 bool constant_value;

 ufbx_baked_vec3_list keys;
} ufbx_baked_prop;

struct ufbx_baked_prop_list { ufbx_baked_prop *data; size_t count; ufbx_baked_prop &operator[](size_t index) const { 
# 4441 "include/ufbx.h" 3 4
(static_cast <bool> (
# 4441 "include/ufbx.h"
index < count
# 4441 "include/ufbx.h" 3 4
) ? void (0) : __assert_fail (
# 4441 "include/ufbx.h"
"index < count"
# 4441 "include/ufbx.h" 3 4
, "include/ufbx.h", 4441, __extension__ __PRETTY_FUNCTION__))
# 4441 "include/ufbx.h"
; return data[index]; } ufbx_baked_prop *begin() const { return data; } ufbx_baked_prop *end() const { return data + count; } template <typename T, typename S=typename ufbxi_type_is<T, decltype(ufbx_converter<T>::from_list((ufbx_baked_prop*)nullptr, (size_t)0))>::type> operator T() const { return ufbx_converter<T>::from_list(data, count); } };


typedef struct ufbx_baked_element {

 uint32_t element_id;

 ufbx_baked_prop_list props;
} ufbx_baked_element;

struct ufbx_baked_element_list { ufbx_baked_element *data; size_t count; ufbx_baked_element &operator[](size_t index) const { 
# 4451 "include/ufbx.h" 3 4
(static_cast <bool> (
# 4451 "include/ufbx.h"
index < count
# 4451 "include/ufbx.h" 3 4
) ? void (0) : __assert_fail (
# 4451 "include/ufbx.h"
"index < count"
# 4451 "include/ufbx.h" 3 4
, "include/ufbx.h", 4451, __extension__ __PRETTY_FUNCTION__))
# 4451 "include/ufbx.h"
; return data[index]; } ufbx_baked_element *begin() const { return data; } ufbx_baked_element *end() const { return data + count; } template <typename T, typename S=typename ufbxi_type_is<T, decltype(ufbx_converter<T>::from_list((ufbx_baked_element*)nullptr, (size_t)0))>::type> operator T() const { return ufbx_converter<T>::from_list(data, count); } };

typedef struct ufbx_baked_anim_metadata {

 size_t result_memory_used;
 size_t temp_memory_used;
 size_t result_allocs;
 size_t temp_allocs;
} ufbx_baked_anim_metadata;



typedef struct ufbx_baked_anim {





 ufbx_baked_node_list nodes;


 ufbx_baked_element_list elements;


 double playback_time_begin;
 double playback_time_end;
 double playback_duration;


 double key_time_min;
 double key_time_max;


 ufbx_baked_anim_metadata metadata;

} ufbx_baked_anim;






typedef uintptr_t ufbx_thread_pool_context;

typedef struct ufbx_thread_pool_info {
 uint32_t max_concurrent_tasks;
} ufbx_thread_pool_info;

typedef bool ufbx_thread_pool_init_fn(void *user, ufbx_thread_pool_context ctx, const ufbx_thread_pool_info *info);
typedef bool ufbx_thread_pool_run_fn(void *user, ufbx_thread_pool_context ctx, uint32_t group, uint32_t start_index, uint32_t count);
typedef bool ufbx_thread_pool_wait_fn(void *user, ufbx_thread_pool_context ctx, uint32_t group, uint32_t max_index);
typedef void ufbx_thread_pool_free_fn(void *user, ufbx_thread_pool_context ctx);

typedef struct ufbx_thread_pool {
 ufbx_thread_pool_init_fn *init_fn;
 ufbx_thread_pool_run_fn *run_fn;
 ufbx_thread_pool_wait_fn *wait_fn;
 ufbx_thread_pool_free_fn *free_fn;
 void *user;
} ufbx_thread_pool;

typedef struct ufbx_thread_opts {
 ufbx_thread_pool pool;
 size_t num_tasks;
 size_t memory_limit;
} ufbx_thread_opts;





typedef struct ufbx_load_opts {
 uint32_t _begin_zero;

 ufbx_allocator_opts temp_allocator;
 ufbx_allocator_opts result_allocator;
 ufbx_thread_opts thread_opts;


 bool ignore_geometry;
 bool ignore_animation;
 bool ignore_embedded;
 bool ignore_all_content;

 bool evaluate_skinning;
 bool evaluate_caches;
# 4548 "include/ufbx.h"
 bool load_external_files;


 bool ignore_missing_external_files;



 bool skip_skin_vertices;


 bool skip_mesh_parts;


 bool clean_skin_weights;





 bool use_blender_pbr_material;


 bool disable_quirks;


 bool strict;




 bool force_single_thread_ascii_parsing;



 bool allow_unsafe;


 ufbx_index_error_handling index_error_handling;




 bool connect_broken_elements;



 bool allow_nodes_out_of_root;



 bool allow_missing_vertex_position;


 bool allow_empty_faces;



 bool generate_missing_normals;


 bool open_main_file_with_default;


 char path_separator;





 uint32_t node_depth_limit;


 uint64_t file_size_estimate;


 size_t read_buffer_size;




 ufbx_string filename;



 ufbx_blob raw_filename;


 ufbx_progress_cb progress_cb;
 uint64_t progress_interval_hint;


 ufbx_open_file_cb open_file_cb;



 ufbx_geometry_transform_handling geometry_transform_handling;



 ufbx_inherit_mode_handling inherit_mode_handling;



 ufbx_pivot_handling pivot_handling;



 ufbx_space_conversion space_conversion;


 ufbx_mirror_axis handedness_conversion_axis;


 bool handedness_conversion_retain_winding;




 bool reverse_winding;



 ufbx_coordinate_axes target_axes;



 ufbx_real target_unit_meters;




 ufbx_coordinate_axes target_camera_axes;




 ufbx_coordinate_axes target_light_axes;



 ufbx_string geometry_transform_helper_name;



 ufbx_string scale_helper_name;


 bool normalize_normals;


 bool normalize_tangents;


 bool use_root_transform;
 ufbx_transform root_transform;


 double key_clamp_threshold;


 ufbx_unicode_error_handling unicode_error_handling;



 bool retain_vertex_attrib_w;


 bool retain_dom;


 ufbx_file_format file_format;



 size_t file_format_lookahead;


 bool no_format_from_content;




 bool no_format_from_extension;





 bool obj_search_mtl_by_filename;


 bool obj_merge_objects;


 bool obj_merge_groups;


 bool obj_split_groups;





 ufbx_string obj_mtl_path;


 ufbx_blob obj_mtl_data;




 ufbx_real obj_unit_meters;




 ufbx_coordinate_axes obj_axes;

 uint32_t _end_zero;
} ufbx_load_opts;



typedef struct ufbx_evaluate_opts {
 uint32_t _begin_zero;

 ufbx_allocator_opts temp_allocator;
 ufbx_allocator_opts result_allocator;

 bool evaluate_skinning;
 bool evaluate_caches;


 bool load_external_files;


 ufbx_open_file_cb open_file_cb;

 uint32_t _end_zero;
} ufbx_evaluate_opts;

struct ufbx_const_uint32_list { const uint32_t *data; size_t count; const uint32_t &operator[](size_t index) const { 
# 4789 "include/ufbx.h" 3 4
(static_cast <bool> (
# 4789 "include/ufbx.h"
index < count
# 4789 "include/ufbx.h" 3 4
) ? void (0) : __assert_fail (
# 4789 "include/ufbx.h"
"index < count"
# 4789 "include/ufbx.h" 3 4
, "include/ufbx.h", 4789, __extension__ __PRETTY_FUNCTION__))
# 4789 "include/ufbx.h"
; return data[index]; } const uint32_t *begin() const { return data; } const uint32_t *end() const { return data + count; } template <typename T, typename S=typename ufbxi_type_is<T, decltype(ufbx_converter<T>::from_list((const uint32_t*)nullptr, (size_t)0))>::type> operator T() const { return ufbx_converter<T>::from_list(data, count); } };
struct ufbx_const_real_list { const ufbx_real *data; size_t count; const ufbx_real &operator[](size_t index) const { 
# 4790 "include/ufbx.h" 3 4
(static_cast <bool> (
# 4790 "include/ufbx.h"
index < count
# 4790 "include/ufbx.h" 3 4
) ? void (0) : __assert_fail (
# 4790 "include/ufbx.h"
"index < count"
# 4790 "include/ufbx.h" 3 4
, "include/ufbx.h", 4790, __extension__ __PRETTY_FUNCTION__))
# 4790 "include/ufbx.h"
; return data[index]; } const ufbx_real *begin() const { return data; } const ufbx_real *end() const { return data + count; } template <typename T, typename S=typename ufbxi_type_is<T, decltype(ufbx_converter<T>::from_list((const ufbx_real*)nullptr, (size_t)0))>::type> operator T() const { return ufbx_converter<T>::from_list(data, count); } };

typedef struct ufbx_prop_override_desc {

 uint32_t element_id;


 ufbx_string prop_name;



 ufbx_vec4 value;
 ufbx_string value_str;
 int64_t value_int;
} ufbx_prop_override_desc;

struct ufbx_const_prop_override_desc_list { const ufbx_prop_override_desc *data; size_t count; const ufbx_prop_override_desc &operator[](size_t index) const { 
# 4806 "include/ufbx.h" 3 4
(static_cast <bool> (
# 4806 "include/ufbx.h"
index < count
# 4806 "include/ufbx.h" 3 4
) ? void (0) : __assert_fail (
# 4806 "include/ufbx.h"
"index < count"
# 4806 "include/ufbx.h" 3 4
, "include/ufbx.h", 4806, __extension__ __PRETTY_FUNCTION__))
# 4806 "include/ufbx.h"
; return data[index]; } const ufbx_prop_override_desc *begin() const { return data; } const ufbx_prop_override_desc *end() const { return data + count; } template <typename T, typename S=typename ufbxi_type_is<T, decltype(ufbx_converter<T>::from_list((const ufbx_prop_override_desc*)nullptr, (size_t)0))>::type> operator T() const { return ufbx_converter<T>::from_list(data, count); } };

struct ufbx_const_transform_override_list { const ufbx_transform_override *data; size_t count; const ufbx_transform_override &operator[](size_t index) const { 
# 4808 "include/ufbx.h" 3 4
(static_cast <bool> (
# 4808 "include/ufbx.h"
index < count
# 4808 "include/ufbx.h" 3 4
) ? void (0) : __assert_fail (
# 4808 "include/ufbx.h"
"index < count"
# 4808 "include/ufbx.h" 3 4
, "include/ufbx.h", 4808, __extension__ __PRETTY_FUNCTION__))
# 4808 "include/ufbx.h"
; return data[index]; } const ufbx_transform_override *begin() const { return data; } const ufbx_transform_override *end() const { return data + count; } template <typename T, typename S=typename ufbxi_type_is<T, decltype(ufbx_converter<T>::from_list((const ufbx_transform_override*)nullptr, (size_t)0))>::type> operator T() const { return ufbx_converter<T>::from_list(data, count); } };

typedef struct ufbx_anim_opts {
 uint32_t _begin_zero;



 ufbx_const_uint32_list layer_ids;


 ufbx_const_real_list override_layer_weights;



 ufbx_const_prop_override_desc_list prop_overrides;



 ufbx_const_transform_override_list transform_overrides;


 bool ignore_connections;

 ufbx_allocator_opts result_allocator;

 uint32_t _end_zero;
} ufbx_anim_opts;


typedef enum ufbx_bake_step_handling {


 UFBX_BAKE_STEP_HANDLING_DEFAULT,



 UFBX_BAKE_STEP_HANDLING_CUSTOM_DURATION,




 UFBX_BAKE_STEP_HANDLING_IDENTICAL_TIME,






 UFBX_BAKE_STEP_HANDLING_ADJACENT_DOUBLE,


 UFBX_BAKE_STEP_HANDLING_IGNORE,

 ufbx_bake_step_handling_FORCE_32BIT = 0x7fffffff
} ufbx_bake_step_handling;

enum { UFBX_BAKE_STEP_HANDLING_COUNT = UFBX_BAKE_STEP_HANDLING_IGNORE + 1 };

typedef struct ufbx_bake_opts {
 uint32_t _begin_zero;

 ufbx_allocator_opts temp_allocator;
 ufbx_allocator_opts result_allocator;






 bool trim_start_time;



 double resample_rate;





 double minimum_sample_rate;



 double maximum_sample_rate;


 bool bake_transform_props;


 bool skip_node_transforms;



 bool no_resample_rotation;


 bool ignore_layer_weight_animation;



 size_t max_keyframe_segments;


 ufbx_bake_step_handling step_handling;


 double step_custom_duration;




 double step_custom_epsilon;


 bool key_reduction_enabled;



 bool key_reduction_rotation;



 double key_reduction_threshold;




 size_t key_reduction_passes;

 uint32_t _end_zero;
} ufbx_bake_opts;



typedef struct ufbx_tessellate_curve_opts {
 uint32_t _begin_zero;

 ufbx_allocator_opts temp_allocator;
 ufbx_allocator_opts result_allocator;


 size_t span_subdivision;

 uint32_t _end_zero;
} ufbx_tessellate_curve_opts;



typedef struct ufbx_tessellate_surface_opts {
 uint32_t _begin_zero;

 ufbx_allocator_opts temp_allocator;
 ufbx_allocator_opts result_allocator;






 size_t span_subdivision_u;
 size_t span_subdivision_v;


 bool skip_mesh_parts;

 uint32_t _end_zero;
} ufbx_tessellate_surface_opts;



typedef struct ufbx_subdivide_opts {
 uint32_t _begin_zero;

 ufbx_allocator_opts temp_allocator;
 ufbx_allocator_opts result_allocator;

 ufbx_subdivision_boundary boundary;
 ufbx_subdivision_boundary uv_boundary;


 bool ignore_normals;



 bool interpolate_normals;


 bool interpolate_tangents;



 bool evaluate_source_vertices;


 size_t max_source_vertices;



 bool evaluate_skin_weights;


 size_t max_skin_weights;


 size_t skin_deformer_index;

 uint32_t _end_zero;
} ufbx_subdivide_opts;



typedef struct ufbx_geometry_cache_opts {
 uint32_t _begin_zero;

 ufbx_allocator_opts temp_allocator;
 ufbx_allocator_opts result_allocator;


 ufbx_open_file_cb open_file_cb;


 double frames_per_second;


 ufbx_mirror_axis mirror_axis;


 bool use_scale_factor;


 ufbx_real scale_factor;

 uint32_t _end_zero;
} ufbx_geometry_cache_opts;



typedef struct ufbx_geometry_cache_data_opts {
 uint32_t _begin_zero;


 ufbx_open_file_cb open_file_cb;

 bool additive;
 bool use_weight;
 ufbx_real weight;


 bool ignore_transform;

 uint32_t _end_zero;
} ufbx_geometry_cache_data_opts;

typedef struct ufbx_panic {
 bool did_panic;
 size_t message_length;
 char message[128];
} ufbx_panic;




extern "C" {



extern const ufbx_string ufbx_empty_string;
extern const ufbx_blob ufbx_empty_blob;
extern const ufbx_matrix ufbx_identity_matrix;
extern const ufbx_transform ufbx_identity_transform;
extern const ufbx_vec2 ufbx_zero_vec2;
extern const ufbx_vec3 ufbx_zero_vec3;
extern const ufbx_vec4 ufbx_zero_vec4;
extern const ufbx_quat ufbx_identity_quat;


extern const ufbx_coordinate_axes ufbx_axes_right_handed_y_up;
extern const ufbx_coordinate_axes ufbx_axes_right_handed_z_up;
extern const ufbx_coordinate_axes ufbx_axes_left_handed_y_up;
extern const ufbx_coordinate_axes ufbx_axes_left_handed_z_up;


extern const size_t ufbx_element_type_size[UFBX_ELEMENT_TYPE_COUNT];


extern const uint32_t ufbx_source_version;
# 5108 "include/ufbx.h"
 bool ufbx_is_thread_safe(void);


 ufbx_scene *ufbx_load_memory(
 const void *data, size_t data_size,
 const ufbx_load_opts *opts, ufbx_error *error);


 ufbx_scene *ufbx_load_file(
 const char *filename,
 const ufbx_load_opts *opts, ufbx_error *error);
 ufbx_scene *ufbx_load_file_len(
 const char *filename, size_t filename_len,
 const ufbx_load_opts *opts, ufbx_error *error);



 ufbx_scene *ufbx_load_stdio(
 void *file,
 const ufbx_load_opts *opts, ufbx_error *error);



 ufbx_scene *ufbx_load_stdio_prefix(
 void *file,
 const void *prefix, size_t prefix_size,
 const ufbx_load_opts *opts, ufbx_error *error);


 ufbx_scene *ufbx_load_stream(
 const ufbx_stream *stream,
 const ufbx_load_opts *opts, ufbx_error *error);


 ufbx_scene *ufbx_load_stream_prefix(
 const ufbx_stream *stream,
 const void *prefix, size_t prefix_size,
 const ufbx_load_opts *opts, ufbx_error *error);


 void ufbx_free_scene(ufbx_scene *scene);


 void ufbx_retain_scene(ufbx_scene *scene);




 size_t ufbx_format_error(char *dst, size_t dst_size, const ufbx_error *error);





 ufbx_prop *ufbx_find_prop_len(const ufbx_props *props, const char *name, size_t name_len);
static inline __attribute__((always_inline, unused)) ufbx_prop *ufbx_find_prop(const ufbx_props *props, const char *name) { return ufbx_find_prop_len(props, name, strlen(name));}




 ufbx_real ufbx_find_real_len(const ufbx_props *props, const char *name, size_t name_len, ufbx_real def);
static inline __attribute__((always_inline, unused)) ufbx_real ufbx_find_real(const ufbx_props *props, const char *name, ufbx_real def) { return ufbx_find_real_len(props, name, strlen(name), def); }
 ufbx_vec3 ufbx_find_vec3_len(const ufbx_props *props, const char *name, size_t name_len, ufbx_vec3 def);
static inline __attribute__((always_inline, unused)) ufbx_vec3 ufbx_find_vec3(const ufbx_props *props, const char *name, ufbx_vec3 def) { return ufbx_find_vec3_len(props, name, strlen(name), def); }
 int64_t ufbx_find_int_len(const ufbx_props *props, const char *name, size_t name_len, int64_t def);
static inline __attribute__((always_inline, unused)) int64_t ufbx_find_int(const ufbx_props *props, const char *name, int64_t def) { return ufbx_find_int_len(props, name, strlen(name), def); }
 bool ufbx_find_bool_len(const ufbx_props *props, const char *name, size_t name_len, bool def);
static inline __attribute__((always_inline, unused)) bool ufbx_find_bool(const ufbx_props *props, const char *name, bool def) { return ufbx_find_bool_len(props, name, strlen(name), def); }
 ufbx_string ufbx_find_string_len(const ufbx_props *props, const char *name, size_t name_len, ufbx_string def);
static inline __attribute__((always_inline, unused)) ufbx_string ufbx_find_string(const ufbx_props *props, const char *name, ufbx_string def) { return ufbx_find_string_len(props, name, strlen(name), def); }
 ufbx_blob ufbx_find_blob_len(const ufbx_props *props, const char *name, size_t name_len, ufbx_blob def);
static inline __attribute__((always_inline, unused)) ufbx_blob ufbx_find_blob(const ufbx_props *props, const char *name, ufbx_blob def) { return ufbx_find_blob_len(props, name, strlen(name), def); }


 ufbx_prop *ufbx_find_prop_concat(const ufbx_props *props, const ufbx_string *parts, size_t num_parts);


 ufbx_element *ufbx_get_prop_element(const ufbx_element *element, const ufbx_prop *prop, ufbx_element_type type);


 ufbx_element *ufbx_find_prop_element_len(const ufbx_element *element, const char *name, size_t name_len, ufbx_element_type type);
static inline __attribute__((always_inline, unused)) ufbx_element *ufbx_find_prop_element(const ufbx_element *element, const char *name, ufbx_element_type type) { return ufbx_find_prop_element_len(element, name, strlen(name), type); }




 ufbx_element *ufbx_find_element_len(const ufbx_scene *scene, ufbx_element_type type, const char *name, size_t name_len);
static inline __attribute__((always_inline, unused)) ufbx_element *ufbx_find_element(const ufbx_scene *scene, ufbx_element_type type, const char *name) { return ufbx_find_element_len(scene, type, name, strlen(name)); }


 ufbx_node *ufbx_find_node_len(const ufbx_scene *scene, const char *name, size_t name_len);
static inline __attribute__((always_inline, unused)) ufbx_node *ufbx_find_node(const ufbx_scene *scene, const char *name) { return ufbx_find_node_len(scene, name, strlen(name)); }


 ufbx_anim_stack *ufbx_find_anim_stack_len(const ufbx_scene *scene, const char *name, size_t name_len);
static inline __attribute__((always_inline, unused)) ufbx_anim_stack *ufbx_find_anim_stack(const ufbx_scene *scene, const char *name) { return ufbx_find_anim_stack_len(scene, name, strlen(name)); }


 ufbx_material *ufbx_find_material_len(const ufbx_scene *scene, const char *name, size_t name_len);
static inline __attribute__((always_inline, unused)) ufbx_material *ufbx_find_material(const ufbx_scene *scene, const char *name) { return ufbx_find_material_len(scene, name, strlen(name)); }



 ufbx_anim_prop *ufbx_find_anim_prop_len(const ufbx_anim_layer *layer, const ufbx_element *element, const char *prop, size_t prop_len);
static inline __attribute__((always_inline, unused)) ufbx_anim_prop *ufbx_find_anim_prop(const ufbx_anim_layer *layer, const ufbx_element *element, const char *prop) { return ufbx_find_anim_prop_len(layer, element, prop, strlen(prop)); }


 ufbx_anim_prop_list ufbx_find_anim_props(const ufbx_anim_layer *layer, const ufbx_element *element);





 ufbx_matrix ufbx_get_compatible_matrix_for_normals(const ufbx_node *node);







 ptrdiff_t ufbx_inflate(void *dst, size_t dst_size, const ufbx_inflate_input *input, ufbx_inflate_retain *retain);



 bool ufbx_open_file(ufbx_stream *stream, const char *path, size_t path_len);



 bool ufbx_default_open_file(void *user, ufbx_stream *stream, const char *path, size_t path_len, const ufbx_open_file_info *info);


 bool ufbx_open_memory(ufbx_stream *stream, const void *data, size_t data_size, const ufbx_open_memory_opts *opts, ufbx_error *error);





 ufbx_real ufbx_evaluate_curve(const ufbx_anim_curve *curve, double time, ufbx_real default_value);


 ufbx_real ufbx_evaluate_anim_value_real(const ufbx_anim_value *anim_value, double time);
 ufbx_vec3 ufbx_evaluate_anim_value_vec3(const ufbx_anim_value *anim_value, double time);



 ufbx_prop ufbx_evaluate_prop_len(const ufbx_anim *anim, const ufbx_element *element, const char *name, size_t name_len, double time);
static inline __attribute__((always_inline, unused)) ufbx_prop ufbx_evaluate_prop(const ufbx_anim *anim, const ufbx_element *element, const char *name, double time) {
 return ufbx_evaluate_prop_len(anim, element, name, strlen(name), time);
}




 ufbx_props ufbx_evaluate_props(const ufbx_anim *anim, const ufbx_element *element, double time, ufbx_prop *buffer, size_t buffer_size);


typedef enum ufbx_transform_flags {


 UFBX_TRANSFORM_FLAG_IGNORE_SCALE_HELPER = 0x1,




 UFBX_TRANSFORM_FLAG_IGNORE_COMPONENTWISE_SCALE = 0x2,


 UFBX_TRANSFORM_FLAG_EXPLICIT_INCLUDES = 0x4,


 UFBX_TRANSFORM_FLAG_INCLUDE_TRANSLATION = 0x10,

 UFBX_TRANSFORM_FLAG_INCLUDE_ROTATION = 0x20,

 UFBX_TRANSFORM_FLAG_INCLUDE_SCALE = 0x40,

 UFBX_TRANSFORM_FLAGS_FORCE_32BIT = 0x7fffffff
} ufbx_transform_flags;




 ufbx_transform ufbx_evaluate_transform(const ufbx_anim *anim, const ufbx_node *node, double time);
 ufbx_transform ufbx_evaluate_transform_flags(const ufbx_anim *anim, const ufbx_node *node, double time, uint32_t flags);



 ufbx_real ufbx_evaluate_blend_weight(const ufbx_anim *anim, const ufbx_blend_channel *channel, double time);
# 5305 "include/ufbx.h"
 ufbx_scene *ufbx_evaluate_scene(const ufbx_scene *scene, const ufbx_anim *anim, double time, const ufbx_evaluate_opts *opts, ufbx_error *error);





 ufbx_anim *ufbx_create_anim(const ufbx_scene *scene, const ufbx_anim_opts *opts, ufbx_error *error);


 void ufbx_free_anim(ufbx_anim *anim);


 void ufbx_retain_anim(ufbx_anim *anim);





 ufbx_baked_anim *ufbx_bake_anim(const ufbx_scene *scene, const ufbx_anim *anim, const ufbx_bake_opts *opts, ufbx_error *error);

 void ufbx_retain_baked_anim(ufbx_baked_anim *bake);
 void ufbx_free_baked_anim(ufbx_baked_anim *bake);

 ufbx_baked_node *ufbx_find_baked_node_by_typed_id(ufbx_baked_anim *bake, uint32_t typed_id);
 ufbx_baked_node *ufbx_find_baked_node(ufbx_baked_anim *bake, ufbx_node *node);

 ufbx_baked_element *ufbx_find_baked_element_by_element_id(ufbx_baked_anim *bake, uint32_t element_id);
 ufbx_baked_element *ufbx_find_baked_element(ufbx_baked_anim *bake, ufbx_element *element);




 ufbx_vec3 ufbx_evaluate_baked_vec3(ufbx_baked_vec3_list keyframes, double time);




 ufbx_quat ufbx_evaluate_baked_quat(ufbx_baked_quat_list keyframes, double time);





 ufbx_bone_pose *ufbx_get_bone_pose(const ufbx_pose *pose, const ufbx_node *node);




 ufbx_texture *ufbx_find_prop_texture_len(const ufbx_material *material, const char *name, size_t name_len);
static inline __attribute__((always_inline, unused)) ufbx_texture *ufbx_find_prop_texture(const ufbx_material *material, const char *name) {
 return ufbx_find_prop_texture_len(material, name, strlen(name));
}


 ufbx_string ufbx_find_shader_prop_len(const ufbx_shader *shader, const char *name, size_t name_len);
static inline __attribute__((always_inline, unused)) ufbx_string ufbx_find_shader_prop(const ufbx_shader *shader, const char *name) {
 return ufbx_find_shader_prop_len(shader, name, strlen(name));
}


 ufbx_shader_prop_binding_list ufbx_find_shader_prop_bindings_len(const ufbx_shader *shader, const char *name, size_t name_len);
static inline __attribute__((always_inline, unused)) ufbx_shader_prop_binding_list ufbx_find_shader_prop_bindings(const ufbx_shader *shader, const char *name) {
 return ufbx_find_shader_prop_bindings_len(shader, name, strlen(name));
}


 ufbx_shader_texture_input *ufbx_find_shader_texture_input_len(const ufbx_shader_texture *shader, const char *name, size_t name_len);
static inline __attribute__((always_inline, unused)) ufbx_shader_texture_input *ufbx_find_shader_texture_input(const ufbx_shader_texture *shader, const char *name) {
 return ufbx_find_shader_texture_input_len(shader, name, strlen(name));
}




 bool ufbx_coordinate_axes_valid(ufbx_coordinate_axes axes);


 ufbx_vec3 ufbx_vec3_normalize(ufbx_vec3 v);


 ufbx_real ufbx_quat_dot(ufbx_quat a, ufbx_quat b);
 ufbx_quat ufbx_quat_mul(ufbx_quat a, ufbx_quat b);
 ufbx_quat ufbx_quat_normalize(ufbx_quat q);
 ufbx_quat ufbx_quat_fix_antipodal(ufbx_quat q, ufbx_quat reference);
 ufbx_quat ufbx_quat_slerp(ufbx_quat a, ufbx_quat b, ufbx_real t);
 ufbx_vec3 ufbx_quat_rotate_vec3(ufbx_quat q, ufbx_vec3 v);
 ufbx_vec3 ufbx_quat_to_euler(ufbx_quat q, ufbx_rotation_order order);
 ufbx_quat ufbx_euler_to_quat(ufbx_vec3 v, ufbx_rotation_order order);


 ufbx_matrix ufbx_matrix_mul(const ufbx_matrix *a, const ufbx_matrix *b);
 ufbx_real ufbx_matrix_determinant(const ufbx_matrix *m);
 ufbx_matrix ufbx_matrix_invert(const ufbx_matrix *m);





 ufbx_matrix ufbx_matrix_for_normals(const ufbx_matrix *m);


 ufbx_vec3 ufbx_transform_position(const ufbx_matrix *m, ufbx_vec3 v);
 ufbx_vec3 ufbx_transform_direction(const ufbx_matrix *m, ufbx_vec3 v);


 ufbx_matrix ufbx_transform_to_matrix(const ufbx_transform *t);
 ufbx_transform ufbx_matrix_to_transform(const ufbx_matrix *m);





 ufbx_matrix ufbx_catch_get_skin_vertex_matrix(ufbx_panic *panic, const ufbx_skin_deformer *skin, size_t vertex, const ufbx_matrix *fallback);
static inline __attribute__((always_inline, unused)) ufbx_matrix ufbx_get_skin_vertex_matrix(const ufbx_skin_deformer *skin, size_t vertex, const ufbx_matrix *fallback) {
 return ufbx_catch_get_skin_vertex_matrix(
# 5419 "include/ufbx.h" 3 4
                                         __null
# 5419 "include/ufbx.h"
                                             , skin, vertex, fallback);
}



 uint32_t ufbx_get_blend_shape_offset_index(const ufbx_blend_shape *shape, size_t vertex);



 ufbx_vec3 ufbx_get_blend_shape_vertex_offset(const ufbx_blend_shape *shape, size_t vertex);



 ufbx_vec3 ufbx_get_blend_vertex_offset(const ufbx_blend_deformer *blend, size_t vertex);


 void ufbx_add_blend_shape_vertex_offsets(const ufbx_blend_shape *shape, ufbx_vec3 *vertices, size_t num_vertices, ufbx_real weight);



 void ufbx_add_blend_vertex_offsets(const ufbx_blend_deformer *blend, ufbx_vec3 *vertices, size_t num_vertices, ufbx_real weight);




 size_t ufbx_evaluate_nurbs_basis(const ufbx_nurbs_basis *basis, ufbx_real u, ufbx_real *weights, size_t num_weights, ufbx_real *derivatives, size_t num_derivatives);


 ufbx_curve_point ufbx_evaluate_nurbs_curve(const ufbx_nurbs_curve *curve, ufbx_real u);


 ufbx_surface_point ufbx_evaluate_nurbs_surface(const ufbx_nurbs_surface *surface, ufbx_real u, ufbx_real v);


 ufbx_line_curve *ufbx_tessellate_nurbs_curve(const ufbx_nurbs_curve *curve, const ufbx_tessellate_curve_opts *opts, ufbx_error *error);


 ufbx_mesh *ufbx_tessellate_nurbs_surface(const ufbx_nurbs_surface *surface, const ufbx_tessellate_surface_opts *opts, ufbx_error *error);


 void ufbx_free_line_curve(ufbx_line_curve *curve);


 void ufbx_retain_line_curve(ufbx_line_curve *curve);





 uint32_t ufbx_find_face_index(ufbx_mesh *mesh, size_t index);




 uint32_t ufbx_catch_triangulate_face(ufbx_panic *panic, uint32_t *indices, size_t num_indices, const ufbx_mesh *mesh, ufbx_face face);
static inline __attribute__((always_inline, unused)) uint32_t ufbx_triangulate_face(uint32_t *indices, size_t num_indices, const ufbx_mesh *mesh, ufbx_face face) {
 return ufbx_catch_triangulate_face(
# 5475 "include/ufbx.h" 3 4
                                   __null
# 5475 "include/ufbx.h"
                                       , indices, num_indices, mesh, face);
}


 void ufbx_catch_compute_topology(ufbx_panic *panic, const ufbx_mesh *mesh, ufbx_topo_edge *topo, size_t num_topo);
static inline __attribute__((always_inline, unused)) void ufbx_compute_topology(const ufbx_mesh *mesh, ufbx_topo_edge *topo, size_t num_topo) {
 ufbx_catch_compute_topology(
# 5481 "include/ufbx.h" 3 4
                            __null
# 5481 "include/ufbx.h"
                                , mesh, topo, num_topo);
}





 uint32_t ufbx_catch_topo_next_vertex_edge(ufbx_panic *panic, const ufbx_topo_edge *topo, size_t num_topo, uint32_t index);
static inline __attribute__((always_inline, unused)) uint32_t ufbx_topo_next_vertex_edge(const ufbx_topo_edge *topo, size_t num_topo, uint32_t index) {
 return ufbx_catch_topo_next_vertex_edge(
# 5490 "include/ufbx.h" 3 4
                                        __null
# 5490 "include/ufbx.h"
                                            , topo, num_topo, index);
}


 uint32_t ufbx_catch_topo_prev_vertex_edge(ufbx_panic *panic, const ufbx_topo_edge *topo, size_t num_topo, uint32_t index);
static inline __attribute__((always_inline, unused)) uint32_t ufbx_topo_prev_vertex_edge(const ufbx_topo_edge *topo, size_t num_topo, uint32_t index) {
 return ufbx_catch_topo_prev_vertex_edge(
# 5496 "include/ufbx.h" 3 4
                                        __null
# 5496 "include/ufbx.h"
                                            , topo, num_topo, index);
}



 ufbx_vec3 ufbx_catch_get_weighted_face_normal(ufbx_panic *panic, const ufbx_vertex_vec3 *positions, ufbx_face face);
static inline __attribute__((always_inline, unused)) ufbx_vec3 ufbx_get_weighted_face_normal(const ufbx_vertex_vec3 *positions, ufbx_face face) {
 return ufbx_catch_get_weighted_face_normal(
# 5503 "include/ufbx.h" 3 4
                                           __null
# 5503 "include/ufbx.h"
                                               , positions, face);
}



 size_t ufbx_catch_generate_normal_mapping(ufbx_panic *panic, const ufbx_mesh *mesh,
 const ufbx_topo_edge *topo, size_t num_topo,
 uint32_t *normal_indices, size_t num_normal_indices, bool assume_smooth);
 size_t ufbx_generate_normal_mapping(const ufbx_mesh *mesh,
 const ufbx_topo_edge *topo, size_t num_topo,
 uint32_t *normal_indices, size_t num_normal_indices, bool assume_smooth);



 void ufbx_catch_compute_normals(ufbx_panic *panic, const ufbx_mesh *mesh, const ufbx_vertex_vec3 *positions,
 const uint32_t *normal_indices, size_t num_normal_indices,
 ufbx_vec3 *normals, size_t num_normals);
 void ufbx_compute_normals(const ufbx_mesh *mesh, const ufbx_vertex_vec3 *positions,
 const uint32_t *normal_indices, size_t num_normal_indices,
 ufbx_vec3 *normals, size_t num_normals);


 ufbx_mesh *ufbx_subdivide_mesh(const ufbx_mesh *mesh, size_t level, const ufbx_subdivide_opts *opts, ufbx_error *error);


 void ufbx_free_mesh(ufbx_mesh *mesh);


 void ufbx_retain_mesh(ufbx_mesh *mesh);






 ufbx_geometry_cache *ufbx_load_geometry_cache(
 const char *filename,
 const ufbx_geometry_cache_opts *opts, ufbx_error *error);
 ufbx_geometry_cache *ufbx_load_geometry_cache_len(
 const char *filename, size_t filename_len,
 const ufbx_geometry_cache_opts *opts, ufbx_error *error);


 void ufbx_free_geometry_cache(ufbx_geometry_cache *cache);

 void ufbx_retain_geometry_cache(ufbx_geometry_cache *cache);


 size_t ufbx_read_geometry_cache_real(const ufbx_cache_frame *frame, ufbx_real *data, size_t num_data, const ufbx_geometry_cache_data_opts *opts);
 size_t ufbx_read_geometry_cache_vec3(const ufbx_cache_frame *frame, ufbx_vec3 *data, size_t num_data, const ufbx_geometry_cache_data_opts *opts);

 size_t ufbx_sample_geometry_cache_real(const ufbx_cache_channel *channel, double time, ufbx_real *data, size_t num_data, const ufbx_geometry_cache_data_opts *opts);
 size_t ufbx_sample_geometry_cache_vec3(const ufbx_cache_channel *channel, double time, ufbx_vec3 *data, size_t num_data, const ufbx_geometry_cache_data_opts *opts);




 ufbx_dom_node *ufbx_dom_find_len(const ufbx_dom_node *parent, const char *name, size_t name_len);
static inline __attribute__((always_inline, unused)) ufbx_dom_node *ufbx_dom_find(const ufbx_dom_node *parent, const char *name) { return ufbx_dom_find_len(parent, name, strlen(name)); }






 size_t ufbx_generate_indices(const ufbx_vertex_stream *streams, size_t num_streams, uint32_t *indices, size_t num_indices, const ufbx_allocator_opts *allocator, ufbx_error *error);





 void ufbx_thread_pool_run_task(ufbx_thread_pool_context ctx, uint32_t index);



 void ufbx_thread_pool_set_user_ptr(ufbx_thread_pool_context ctx, void *user_ptr);
 void *ufbx_thread_pool_get_user_ptr(ufbx_thread_pool_context ctx);




 ufbx_real ufbx_catch_get_vertex_real(ufbx_panic *panic, const ufbx_vertex_real *v, size_t index);
 ufbx_vec2 ufbx_catch_get_vertex_vec2(ufbx_panic *panic, const ufbx_vertex_vec2 *v, size_t index);
 ufbx_vec3 ufbx_catch_get_vertex_vec3(ufbx_panic *panic, const ufbx_vertex_vec3 *v, size_t index);
 ufbx_vec4 ufbx_catch_get_vertex_vec4(ufbx_panic *panic, const ufbx_vertex_vec4 *v, size_t index);


static inline __attribute__((always_inline, unused)) ufbx_real ufbx_get_vertex_real(const ufbx_vertex_real *v, size_t index) { 
# 5590 "include/ufbx.h" 3 4
                                                                                     (static_cast <bool> (
# 5590 "include/ufbx.h"
                                                                                     index < v->indices.count
# 5590 "include/ufbx.h" 3 4
                                                                                     ) ? void (0) : __assert_fail (
# 5590 "include/ufbx.h"
                                                                                     "index < v->indices.count"
# 5590 "include/ufbx.h" 3 4
                                                                                     , "include/ufbx.h", 5590, __extension__ __PRETTY_FUNCTION__))
# 5590 "include/ufbx.h"
                                                                                                                          ; return v->values.data[(int32_t)v->indices.data[index]]; }
static inline __attribute__((always_inline, unused)) ufbx_vec2 ufbx_get_vertex_vec2(const ufbx_vertex_vec2 *v, size_t index) { 
# 5591 "include/ufbx.h" 3 4
                                                                                     (static_cast <bool> (
# 5591 "include/ufbx.h"
                                                                                     index < v->indices.count
# 5591 "include/ufbx.h" 3 4
                                                                                     ) ? void (0) : __assert_fail (
# 5591 "include/ufbx.h"
                                                                                     "index < v->indices.count"
# 5591 "include/ufbx.h" 3 4
                                                                                     , "include/ufbx.h", 5591, __extension__ __PRETTY_FUNCTION__))
# 5591 "include/ufbx.h"
                                                                                                                          ; return v->values.data[(int32_t)v->indices.data[index]]; }
static inline __attribute__((always_inline, unused)) ufbx_vec3 ufbx_get_vertex_vec3(const ufbx_vertex_vec3 *v, size_t index) { 
# 5592 "include/ufbx.h" 3 4
                                                                                     (static_cast <bool> (
# 5592 "include/ufbx.h"
                                                                                     index < v->indices.count
# 5592 "include/ufbx.h" 3 4
                                                                                     ) ? void (0) : __assert_fail (
# 5592 "include/ufbx.h"
                                                                                     "index < v->indices.count"
# 5592 "include/ufbx.h" 3 4
                                                                                     , "include/ufbx.h", 5592, __extension__ __PRETTY_FUNCTION__))
# 5592 "include/ufbx.h"
                                                                                                                          ; return v->values.data[(int32_t)v->indices.data[index]]; }
static inline __attribute__((always_inline, unused)) ufbx_vec4 ufbx_get_vertex_vec4(const ufbx_vertex_vec4 *v, size_t index) { 
# 5593 "include/ufbx.h" 3 4
                                                                                     (static_cast <bool> (
# 5593 "include/ufbx.h"
                                                                                     index < v->indices.count
# 5593 "include/ufbx.h" 3 4
                                                                                     ) ? void (0) : __assert_fail (
# 5593 "include/ufbx.h"
                                                                                     "index < v->indices.count"
# 5593 "include/ufbx.h" 3 4
                                                                                     , "include/ufbx.h", 5593, __extension__ __PRETTY_FUNCTION__))
# 5593 "include/ufbx.h"
                                                                                                                          ; return v->values.data[(int32_t)v->indices.data[index]]; }

 ufbx_real ufbx_catch_get_vertex_w_vec3(ufbx_panic *panic, const ufbx_vertex_vec3 *v, size_t index);
static inline __attribute__((always_inline, unused)) ufbx_real ufbx_get_vertex_w_vec3(const ufbx_vertex_vec3 *v, size_t index) { 
# 5596 "include/ufbx.h" 3 4
                                                                                       (static_cast <bool> (
# 5596 "include/ufbx.h"
                                                                                       index < v->indices.count
# 5596 "include/ufbx.h" 3 4
                                                                                       ) ? void (0) : __assert_fail (
# 5596 "include/ufbx.h"
                                                                                       "index < v->indices.count"
# 5596 "include/ufbx.h" 3 4
                                                                                       , "include/ufbx.h", 5596, __extension__ __PRETTY_FUNCTION__))
# 5596 "include/ufbx.h"
                                                                                                                            ; return v->values_w.count > 0 ? v->values_w.data[(int32_t)v->indices.data[index]] : 0.0f; }



 ufbx_unknown *ufbx_as_unknown(const ufbx_element *element);
 ufbx_node *ufbx_as_node(const ufbx_element *element);
 ufbx_mesh *ufbx_as_mesh(const ufbx_element *element);
 ufbx_light *ufbx_as_light(const ufbx_element *element);
 ufbx_camera *ufbx_as_camera(const ufbx_element *element);
 ufbx_bone *ufbx_as_bone(const ufbx_element *element);
 ufbx_empty *ufbx_as_empty(const ufbx_element *element);
 ufbx_line_curve *ufbx_as_line_curve(const ufbx_element *element);
 ufbx_nurbs_curve *ufbx_as_nurbs_curve(const ufbx_element *element);
 ufbx_nurbs_surface *ufbx_as_nurbs_surface(const ufbx_element *element);
 ufbx_nurbs_trim_surface *ufbx_as_nurbs_trim_surface(const ufbx_element *element);
 ufbx_nurbs_trim_boundary *ufbx_as_nurbs_trim_boundary(const ufbx_element *element);
 ufbx_procedural_geometry *ufbx_as_procedural_geometry(const ufbx_element *element);
 ufbx_stereo_camera *ufbx_as_stereo_camera(const ufbx_element *element);
 ufbx_camera_switcher *ufbx_as_camera_switcher(const ufbx_element *element);
 ufbx_marker *ufbx_as_marker(const ufbx_element *element);
 ufbx_lod_group *ufbx_as_lod_group(const ufbx_element *element);
 ufbx_skin_deformer *ufbx_as_skin_deformer(const ufbx_element *element);
 ufbx_skin_cluster *ufbx_as_skin_cluster(const ufbx_element *element);
 ufbx_blend_deformer *ufbx_as_blend_deformer(const ufbx_element *element);
 ufbx_blend_channel *ufbx_as_blend_channel(const ufbx_element *element);
 ufbx_blend_shape *ufbx_as_blend_shape(const ufbx_element *element);
 ufbx_cache_deformer *ufbx_as_cache_deformer(const ufbx_element *element);
 ufbx_cache_file *ufbx_as_cache_file(const ufbx_element *element);
 ufbx_material *ufbx_as_material(const ufbx_element *element);
 ufbx_texture *ufbx_as_texture(const ufbx_element *element);
 ufbx_video *ufbx_as_video(const ufbx_element *element);
 ufbx_shader *ufbx_as_shader(const ufbx_element *element);
 ufbx_shader_binding *ufbx_as_shader_binding(const ufbx_element *element);
 ufbx_anim_stack *ufbx_as_anim_stack(const ufbx_element *element);
 ufbx_anim_layer *ufbx_as_anim_layer(const ufbx_element *element);
 ufbx_anim_value *ufbx_as_anim_value(const ufbx_element *element);
 ufbx_anim_curve *ufbx_as_anim_curve(const ufbx_element *element);
 ufbx_display_layer *ufbx_as_display_layer(const ufbx_element *element);
 ufbx_selection_set *ufbx_as_selection_set(const ufbx_element *element);
 ufbx_selection_node *ufbx_as_selection_node(const ufbx_element *element);
 ufbx_character *ufbx_as_character(const ufbx_element *element);
 ufbx_constraint *ufbx_as_constraint(const ufbx_element *element);
 ufbx_audio_layer *ufbx_as_audio_layer(const ufbx_element *element);
 ufbx_audio_clip *ufbx_as_audio_clip(const ufbx_element *element);
 ufbx_pose *ufbx_as_pose(const ufbx_element *element);
 ufbx_metadata_object *ufbx_as_metadata_object(const ufbx_element *element);


}






struct ufbx_string_view {
 const char *data;
 size_t length;

 ufbx_string_view() : data(nullptr), length(0) { }
 ufbx_string_view(const char *data_, size_t length_) : data(data_), length(length_) { }
 template <typename T, typename S=typename ufbxi_type_is<ufbx_string_view, decltype(ufbx_converter<T>::to(*(const T*)nullptr))>::type> ufbx_string_view(const T &t) { *this = ufbx_converter<T>::to(t); }
};

static inline __attribute__((always_inline, unused)) ufbx_scene *ufbx_load_file(ufbx_string_view filename, const ufbx_load_opts *opts, ufbx_error *error) { return ufbx_load_file_len(filename.data, filename.length, opts, error); }
static inline __attribute__((always_inline, unused)) ufbx_prop *ufbx_find_prop(const ufbx_props *props, ufbx_string_view name) { return ufbx_find_prop_len(props, name.data, name.length); }
static inline __attribute__((always_inline, unused)) ufbx_real ufbx_find_real(const ufbx_props *props, ufbx_string_view name, ufbx_real def) { return ufbx_find_real_len(props, name.data, name.length, def); }
static inline __attribute__((always_inline, unused)) ufbx_vec3 ufbx_find_vec3(const ufbx_props *props, ufbx_string_view name, ufbx_vec3 def) { return ufbx_find_vec3_len(props, name.data, name.length, def); }
static inline __attribute__((always_inline, unused)) int64_t ufbx_find_int(const ufbx_props *props, ufbx_string_view name, int64_t def) { return ufbx_find_int_len(props, name.data, name.length, def); }
static inline __attribute__((always_inline, unused)) bool ufbx_find_bool(const ufbx_props *props, ufbx_string_view name, bool def) { return ufbx_find_bool_len(props, name.data, name.length, def); }
static inline __attribute__((always_inline, unused)) ufbx_string ufbx_find_string(const ufbx_props *props, ufbx_string_view name, ufbx_string def) { return ufbx_find_string_len(props, name.data, name.length, def); }
static inline __attribute__((always_inline, unused)) ufbx_blob ufbx_find_blob(const ufbx_props *props, ufbx_string_view name, ufbx_blob def) { return ufbx_find_blob_len(props, name.data, name.length, def); }
static inline __attribute__((always_inline, unused)) ufbx_element *ufbx_find_prop_element(const ufbx_element *element, ufbx_string_view name, ufbx_element_type type) { return ufbx_find_prop_element_len(element, name.data, name.length, type); }
static inline __attribute__((always_inline, unused)) ufbx_element *ufbx_find_element(const ufbx_scene *scene, ufbx_element_type type, ufbx_string_view name) { return ufbx_find_element_len(scene, type, name.data, name.length); }
static inline __attribute__((always_inline, unused)) ufbx_node *ufbx_find_node(const ufbx_scene *scene, ufbx_string_view name) { return ufbx_find_node_len(scene, name.data, name.length); }
static inline __attribute__((always_inline, unused)) ufbx_anim_stack *ufbx_find_anim_stack(const ufbx_scene *scene, ufbx_string_view name) { return ufbx_find_anim_stack_len(scene, name.data, name.length); }
static inline __attribute__((always_inline, unused)) ufbx_material *ufbx_find_material(const ufbx_scene *scene, ufbx_string_view name) { return ufbx_find_material_len(scene, name.data, name.length); }
static inline __attribute__((always_inline, unused)) ufbx_anim_prop *ufbx_find_anim_prop(const ufbx_anim_layer *layer, const ufbx_element *element, ufbx_string_view prop) { return ufbx_find_anim_prop_len(layer, element, prop.data, prop.length); }
static inline __attribute__((always_inline, unused)) ufbx_prop ufbx_evaluate_prop(const ufbx_anim *anim, const ufbx_element *element, ufbx_string_view name, double time) { return ufbx_evaluate_prop_len(anim, element, name.data, name.length, time); }
static inline __attribute__((always_inline, unused)) ufbx_texture *ufbx_find_prop_texture(const ufbx_material *material, ufbx_string_view name) { return ufbx_find_prop_texture_len(material, name.data, name.length); }
static inline __attribute__((always_inline, unused)) ufbx_string ufbx_find_shader_prop(const ufbx_shader *shader, ufbx_string_view name) { return ufbx_find_shader_prop_len(shader, name.data, name.length); }
static inline __attribute__((always_inline, unused)) ufbx_shader_prop_binding_list ufbx_find_shader_prop_bindings(const ufbx_shader *shader, ufbx_string_view name) { return ufbx_find_shader_prop_bindings_len(shader, name.data, name.length); }
static inline __attribute__((always_inline, unused)) ufbx_shader_texture_input *ufbx_find_shader_texture_input(const ufbx_shader_texture *shader, ufbx_string_view name) { return ufbx_find_shader_texture_input_len(shader, name.data, name.length); }
static inline __attribute__((always_inline, unused)) ufbx_geometry_cache *ufbx_load_geometry_cache(ufbx_string_view filename, const ufbx_geometry_cache_opts *opts, ufbx_error *error) { return ufbx_load_geometry_cache_len(filename.data, filename.length, opts, error); }
static inline __attribute__((always_inline, unused)) ufbx_dom_node *ufbx_dom_find(const ufbx_dom_node *parent, ufbx_string_view name) { return ufbx_dom_find_len(parent, name.data, name.length); }





template <typename T>
struct ufbx_type_traits { enum { valid = 0 }; };

template<> struct ufbx_type_traits<ufbx_scene> {
 enum { valid = 1 };
 static void retain(ufbx_scene *ptr) { ufbx_retain_scene(ptr); }
 static void free(ufbx_scene *ptr) { ufbx_free_scene(ptr); }
};

template<> struct ufbx_type_traits<ufbx_mesh> {
 enum { valid = 1 };
 static void retain(ufbx_mesh *ptr) { ufbx_retain_mesh(ptr); }
 static void free(ufbx_mesh *ptr) { ufbx_free_mesh(ptr); }
};

template<> struct ufbx_type_traits<ufbx_line_curve> {
 enum { valid = 1 };
 static void retain(ufbx_line_curve *ptr) { ufbx_retain_line_curve(ptr); }
 static void free(ufbx_line_curve *ptr) { ufbx_free_line_curve(ptr); }
};

template<> struct ufbx_type_traits<ufbx_geometry_cache> {
 enum { valid = 1 };
 static void retain(ufbx_geometry_cache *ptr) { ufbx_retain_geometry_cache(ptr); }
 static void free(ufbx_geometry_cache *ptr) { ufbx_free_geometry_cache(ptr); }
};

template<> struct ufbx_type_traits<ufbx_anim> {
 enum { valid = 1 };
 static void retain(ufbx_anim *ptr) { ufbx_retain_anim(ptr); }
 static void free(ufbx_anim *ptr) { ufbx_free_anim(ptr); }
};

template<> struct ufbx_type_traits<ufbx_baked_anim> {
 enum { valid = 1 };
 static void retain(ufbx_baked_anim *ptr) { ufbx_retain_baked_anim(ptr); }
 static void free(ufbx_baked_anim *ptr) { ufbx_free_baked_anim(ptr); }
};

class ufbx_deleter {
public:
 template <typename T>
 void operator()(T *ptr) const {
  static_assert(ufbx_type_traits<T>::valid, "ufbx_deleter() unsupported for type");
  ufbx_type_traits<T>::free(ptr);
 }
};




template <typename T>
class ufbx_unique_ptr {
 T *ptr;
 using traits = ufbx_type_traits<T>;
 static_assert(ufbx_type_traits<T>::valid, "ufbx_unique_ptr unsupported for type");
public:
 ufbx_unique_ptr() noexcept : ptr(nullptr) { }
 explicit ufbx_unique_ptr(T *ptr_) noexcept : ptr(ptr_) { }
 ufbx_unique_ptr(ufbx_unique_ptr &&ref) noexcept : ptr(ref.ptr) { ref.ptr = nullptr; }
 ~ufbx_unique_ptr() { traits::free(ptr); }

 ufbx_unique_ptr &operator=(ufbx_unique_ptr &&ref) noexcept {
  if (&ref == this) return *this;
  ptr = ref.ptr;
  ref.ptr = nullptr;
  return *this;
 }

 void reset(T *new_ptr=nullptr) noexcept {
  traits::free(ptr);
  ptr = new_ptr;
 }

 void swap(ufbx_unique_ptr &ref) noexcept {
  T *tmp = ptr;
  ptr = ref.ptr;
  ref.ptr = tmp;
 }

 T &operator*() const noexcept { return *ptr; }
 T *operator->() const noexcept { return ptr; }
 T *get() const noexcept { return ptr; }
 explicit operator bool() const noexcept { return ptr != nullptr; }
};



template <typename T>
class ufbx_shared_ptr {
 T *ptr;
 using traits = ufbx_type_traits<T>;
 static_assert(ufbx_type_traits<T>::valid, "ufbx_shared_ptr unsupported for type");
public:

 ufbx_shared_ptr() noexcept : ptr(nullptr) { }
 explicit ufbx_shared_ptr(T *ptr_) noexcept : ptr(ptr_) { }
 ufbx_shared_ptr(const ufbx_shared_ptr &ref) noexcept : ptr(ref.ptr) { traits::retain(ref.ptr); }
 ufbx_shared_ptr(ufbx_shared_ptr &&ref) noexcept : ptr(ref.ptr) { ref.ptr = nullptr; }
 ~ufbx_shared_ptr() { traits::free(ptr); }

 ufbx_shared_ptr &operator=(const ufbx_shared_ptr &ref) noexcept {
  if (&ref == this) return *this;
  traits::free(ptr);
  traits::retain(ref.ptr);
  ptr = ref.ptr;
  return *this;
 }

 ufbx_shared_ptr &operator=(ufbx_shared_ptr &&ref) noexcept {
  if (&ref == this) return *this;
  ptr = ref.ptr;
  ref.ptr = nullptr;
  return *this;
 }

 void reset(T *new_ptr=nullptr) noexcept {
  traits::free(ptr);
  ptr = new_ptr;
 }

 void swap(ufbx_shared_ptr &ref) noexcept {
  T *tmp = ptr;
  ptr = ref.ptr;
  ref.ptr = tmp;
 }

 T &operator*() const noexcept { return *ptr; }
 T *operator->() const noexcept { return ptr; }
 T *get() const noexcept { return ptr; }
 explicit operator bool() const noexcept { return ptr != nullptr; }
};
# 5887 "include/ufbx.h"
#pragma GCC diagnostic pop
# 3 "code/game.cpp" 2




# 1 "/usr/include/c++/10/cassert" 1 3
# 41 "/usr/include/c++/10/cassert" 3
       
# 42 "/usr/include/c++/10/cassert" 3


# 1 "/usr/include/assert.h" 1 3 4
# 45 "/usr/include/c++/10/cassert" 2 3
# 8 "code/game.cpp" 2

# 1 "/usr/include/c++/10/cstdio" 1 3
# 39 "/usr/include/c++/10/cstdio" 3
       
# 40 "/usr/include/c++/10/cstdio" 3
# 96 "/usr/include/c++/10/cstdio" 3

# 96 "/usr/include/c++/10/cstdio" 3
namespace std
{
  using ::FILE;
  using ::fpos_t;

  using ::clearerr;
  using ::fclose;
  using ::feof;
  using ::ferror;
  using ::fflush;
  using ::fgetc;
  using ::fgetpos;
  using ::fgets;
  using ::fopen;
  using ::fprintf;
  using ::fputc;
  using ::fputs;
  using ::fread;
  using ::freopen;
  using ::fscanf;
  using ::fseek;
  using ::fsetpos;
  using ::ftell;
  using ::fwrite;
  using ::getc;
  using ::getchar;




  using ::perror;
  using ::printf;
  using ::putc;
  using ::putchar;
  using ::puts;
  using ::remove;
  using ::rename;
  using ::rewind;
  using ::scanf;
  using ::setbuf;
  using ::setvbuf;
  using ::sprintf;
  using ::sscanf;
  using ::tmpfile;

  using ::tmpnam;

  using ::ungetc;
  using ::vfprintf;
  using ::vprintf;
  using ::vsprintf;
}
# 157 "/usr/include/c++/10/cstdio" 3
namespace __gnu_cxx
{
# 175 "/usr/include/c++/10/cstdio" 3
  using ::snprintf;
  using ::vfscanf;
  using ::vscanf;
  using ::vsnprintf;
  using ::vsscanf;

}

namespace std
{
  using ::__gnu_cxx::snprintf;
  using ::__gnu_cxx::vfscanf;
  using ::__gnu_cxx::vscanf;
  using ::__gnu_cxx::vsnprintf;
  using ::__gnu_cxx::vsscanf;
}
# 10 "code/game.cpp" 2

# 1 "code/common.h" 1
       






# 7 "code/common.h"
typedef uint8_t u8;
typedef uint16_t u16;
typedef uint32_t u32;
typedef uint64_t u64;
typedef int8_t i8;
typedef int16_t i16;
typedef int32_t i32;
typedef int64_t i64;
typedef float f32;
typedef double f64;
typedef i32 b32;
typedef size_t usize;
# 12 "code/game.cpp" 2
# 1 "code/arena.h" 1
       

struct Arena
{
 void *data;
 usize used;
 usize size;
};

static Arena make_arena(void *memory, usize size)
{
 Arena arena = {};

 arena.data = memory;
 arena.size = size;
 return arena;
}



static void *_arena_alloc(const char *filename, const char *func, int line, Arena *arena, usize size)
{
 if (!size)
  return 0;
 int alignement = 16;

 int misalign = ((uintptr_t)((char *)arena->data + arena->used)) & (alignement - 1);
 misalign = misalign ? alignement - misalign : 0;

 if (arena->used + size + misalign > arena->size) {
  printf("%s: %s:%d: failed to allocate %zd bytes (used: %zd, size: %zd, left: %zd, misalign: %d)\n", filename, func, line, size,
   arena->used, arena->size, arena->size - arena->used, misalign);
  
# 33 "code/arena.h" 3 4
 (static_cast <bool> (
# 33 "code/arena.h"
 0
# 33 "code/arena.h" 3 4
 ) ? void (0) : __assert_fail (
# 33 "code/arena.h"
 "0"
# 33 "code/arena.h" 3 4
 , "code/arena.h", 33, __extension__ __PRETTY_FUNCTION__))
# 33 "code/arena.h"
          ;
  return 0;
 }


 void *ptr = (char *)arena->data + arena->used + misalign;
 arena->used += size + misalign;
 return ptr;
}

static void *arena_alloc_zero(Arena *arena, usize size)
{
 void *mem = _arena_alloc("code/arena.h", __func__, 45, arena, size);
 memset(mem, 0, size);
 return mem;
}

struct TempArena {
 Arena arena;
 usize last_used[16];
 int last_used_count;
};

static TempArena *g_temp_arena;

static Arena *begin_temp_memory()
{
 
# 60 "code/arena.h" 3 4
(static_cast <bool> (
# 60 "code/arena.h"
g_temp_arena->last_used_count < (sizeof(g_temp_arena->last_used) / sizeof(*g_temp_arena->last_used))
# 60 "code/arena.h" 3 4
) ? void (0) : __assert_fail (
# 60 "code/arena.h"
"g_temp_arena->last_used_count < ARRAY_SIZE(g_temp_arena->last_used)"
# 60 "code/arena.h" 3 4
, "code/arena.h", 60, __extension__ __PRETTY_FUNCTION__))
# 60 "code/arena.h"
                                                                           ;
 g_temp_arena->last_used[g_temp_arena->last_used_count++] = g_temp_arena->arena.used;
 return &g_temp_arena->arena;
}

static void end_temp_memory()
{
 
# 67 "code/arena.h" 3 4
(static_cast <bool> (
# 67 "code/arena.h"
g_temp_arena->last_used_count > 0
# 67 "code/arena.h" 3 4
) ? void (0) : __assert_fail (
# 67 "code/arena.h"
"g_temp_arena->last_used_count > 0"
# 67 "code/arena.h" 3 4
, "code/arena.h", 67, __extension__ __PRETTY_FUNCTION__))
# 67 "code/arena.h"
                                         ;
 g_temp_arena->arena.used = g_temp_arena->last_used[--g_temp_arena->last_used_count];
}
# 13 "code/game.cpp" 2
# 1 "code/utils.h" 1




template<typename T>
T min(T a, T b)
{
 return (a < b ? a : b);
}

template<typename T>
T max(T a, T b)
{
 return (a > b ? a : b);
}

template<typename T>
void swap(T &a, T &b)
{
 T tmp = a;

 a = b;
 b = tmp;
}

template<typename T>
struct Array
{
 T *data;
 usize count;
 usize capacity;

 Array()
 {
  data = 0;
  count = capacity = 0;
 }

 T &operator[](int index)
 {
  
# 41 "code/utils.h" 3 4
 (static_cast <bool> (
# 41 "code/utils.h"
 index >= 0 && index < count
# 41 "code/utils.h" 3 4
 ) ? void (0) : __assert_fail (
# 41 "code/utils.h"
 "index >= 0 && index < count"
# 41 "code/utils.h" 3 4
 , "code/utils.h", 41, __extension__ __PRETTY_FUNCTION__))
# 41 "code/utils.h"
                                    ;
  return data[index];
 }

 T &operator[](usize index)
 {
  
# 47 "code/utils.h" 3 4
 (static_cast <bool> (
# 47 "code/utils.h"
 index < count
# 47 "code/utils.h" 3 4
 ) ? void (0) : __assert_fail (
# 47 "code/utils.h"
 "index < count"
# 47 "code/utils.h" 3 4
 , "code/utils.h", 47, __extension__ __PRETTY_FUNCTION__))
# 47 "code/utils.h"
                      ;
  return data[index];
 }

 void push(const T &value)
 {
  
# 53 "code/utils.h" 3 4
 (static_cast <bool> (
# 53 "code/utils.h"
 count < capacity
# 53 "code/utils.h" 3 4
 ) ? void (0) : __assert_fail (
# 53 "code/utils.h"
 "count < capacity"
# 53 "code/utils.h" 3 4
 , "code/utils.h", 53, __extension__ __PRETTY_FUNCTION__))
# 53 "code/utils.h"
                         ;
  data[count++] = value;
 }

 T &back()
 {
  
# 59 "code/utils.h" 3 4
 (static_cast <bool> (
# 59 "code/utils.h"
 count
# 59 "code/utils.h" 3 4
 ) ? void (0) : __assert_fail (
# 59 "code/utils.h"
 "count"
# 59 "code/utils.h" 3 4
 , "code/utils.h", 59, __extension__ __PRETTY_FUNCTION__))
# 59 "code/utils.h"
              ;
  return data[count - 1];
 }

 ~Array()
 {

 }
};


template<typename T>
Array<T> make_array_max(Arena *arena, usize capacity)
{
 Array<T> result;

 result.count = 0;
 result.capacity = capacity;
 result.data = (T *)_arena_alloc("code/utils.h", __func__, 77, arena, capacity * sizeof(T));
 return result;
}

template<typename T>
Array<T> make_array(Arena *arena, usize count, const T *data = 0)
{
 Array<T> result = make_array_max<T>(arena, count);

 result.count = count;
 if (data && count)
  memcpy(result.data, data, count * sizeof(T));
 return result;
}

template<typename T>
Array<T> make_zero_array(Arena *arena, usize count)
{
 Array<T> result = make_array<T>(arena, count);
 memset(result.data, 0, sizeof(T) * count);

 return result;
}

template<typename T>
Array<T> make_array(T *data, usize count)
{
 Array<T> result;

 result.capacity = result.count = count;
 result.data = data;
 return result;
}


template<typename T>
Array<T> clone_array(Arena *arena, Array<T> &array)
{
 Array<T> result;

 result.data = (T *)_arena_alloc("code/utils.h", __func__, 117, arena, array.capacity * sizeof(T));
 memcpy(result.data, array.data, sizeof(T) * array.count);
 result.count = array.count;
 result.capacity = array.capacity;
 return result;
}
# 132 "code/utils.h"
using String = Array<char>;
String make_string(Arena *arena, usize count, const char *data = 0) {return make_array<char>(arena, count, data);}
b32 strings_equal(const String &a, const String &b)
{
 if (a.count != b.count)
  return false;
 for (usize i = 0; i < a.count; i++)
  if (a.data[i] != b.data[i])
   return false;
 return true;
}

String make_cstring(const char *cstr)
{
 usize len = 0;
 while (cstr[len])
  len++;
 String s;
 s.data = (char *)cstr;
 s.capacity = len + 1;
 s.count = len;
 return s;
}

String concact_string(Arena *arena, String a, String b)
{
 String result = make_string(arena, a.count + b.count);

 memcpy(result.data, a.data, a.count);
 memcpy(result.data + a.count, b.data, b.count);
 return result;
}


# 1 "/usr/include/c++/10/cstdio" 1 3
# 39 "/usr/include/c++/10/cstdio" 3
       
# 40 "/usr/include/c++/10/cstdio" 3
# 167 "code/utils.h" 2

String load_entire_file(Arena *arena, String filename)
{
 
# 170 "code/utils.h" 3 4
(static_cast <bool> (
# 170 "code/utils.h"
filename.count < filename.capacity && filename.data[filename.count] == 0
# 170 "code/utils.h" 3 4
) ? void (0) : __assert_fail (
# 170 "code/utils.h"
"filename.count < filename.capacity && filename.data[filename.count] == 0"
# 170 "code/utils.h" 3 4
, "code/utils.h", 170, __extension__ __PRETTY_FUNCTION__))

                                     
# 172 "code/utils.h"
                                    ;
 String result = {};

 FILE *file = fopen(filename.data, "rb");
 if (!file) {
  printf("failed to open file %.*s\n", (int)filename.count, filename.data);
  
# 178 "code/utils.h" 3 4
 (static_cast <bool> (
# 178 "code/utils.h"
 0
# 178 "code/utils.h" 3 4
 ) ? void (0) : __assert_fail (
# 178 "code/utils.h"
 "0"
# 178 "code/utils.h" 3 4
 , "code/utils.h", 178, __extension__ __PRETTY_FUNCTION__))
# 178 "code/utils.h"
          ;
  return result;
 }
 fseek(file, 0, 
# 181 "code/utils.h" 3 4
               2
# 181 "code/utils.h"
                       );
 usize size = ftell(file);
 fseek(file, 0, 
# 183 "code/utils.h" 3 4
               0
# 183 "code/utils.h"
                       );

 result = make_string(arena, size);

 while (size > 0)
 {
  size_t bytes_read = fread(result.data, 1, size, file);
  if (bytes_read <= 0)
   
# 191 "code/utils.h" 3 4
  (static_cast <bool> (
# 191 "code/utils.h"
  0
# 191 "code/utils.h" 3 4
  ) ? void (0) : __assert_fail (
# 191 "code/utils.h"
  "0"
# 191 "code/utils.h" 3 4
  , "code/utils.h", 191, __extension__ __PRETTY_FUNCTION__))
# 191 "code/utils.h"
           ;
  size -= bytes_read;
 }
 return result;
}


int align_to(int x, int alignement)
{
 return alignement * ((x + alignement - 1) / alignement);
}
# 14 "code/game.cpp" 2
# 1 "code/math.h" 1
       

# 1 "/usr/include/c++/10/cmath" 1 3
# 39 "/usr/include/c++/10/cmath" 3
       
# 40 "/usr/include/c++/10/cmath" 3


# 1 "/usr/include/c++/10/bits/cpp_type_traits.h" 1 3
# 35 "/usr/include/c++/10/bits/cpp_type_traits.h" 3
       
# 36 "/usr/include/c++/10/bits/cpp_type_traits.h" 3
# 67 "/usr/include/c++/10/bits/cpp_type_traits.h" 3

# 67 "/usr/include/c++/10/bits/cpp_type_traits.h" 3
extern "C++" {

namespace std __attribute__ ((__visibility__ ("default")))
{


  struct __true_type { };
  struct __false_type { };

  template<bool>
    struct __truth_type
    { typedef __false_type __type; };

  template<>
    struct __truth_type<true>
    { typedef __true_type __type; };



  template<class _Sp, class _Tp>
    struct __traitor
    {
      enum { __value = bool(_Sp::__value) || bool(_Tp::__value) };
      typedef typename __truth_type<__value>::__type __type;
    };


  template<typename, typename>
    struct __are_same
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };

  template<typename _Tp>
    struct __are_same<_Tp, _Tp>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };


  template<typename _Tp>
    struct __is_void
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };

  template<>
    struct __is_void<void>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };




  template<typename _Tp>
    struct __is_integer
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };





  template<>
    struct __is_integer<bool>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<signed char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<unsigned char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };


  template<>
    struct __is_integer<wchar_t>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };
# 184 "/usr/include/c++/10/bits/cpp_type_traits.h" 3
  template<>
    struct __is_integer<char16_t>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<char32_t>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };


  template<>
    struct __is_integer<short>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<unsigned short>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<int>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<unsigned int>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<long>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<unsigned long>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<long long>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<unsigned long long>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };
# 270 "/usr/include/c++/10/bits/cpp_type_traits.h" 3
template<> struct __is_integer<__int128> { enum { __value = 1 }; typedef __true_type __type; }; template<> struct __is_integer<unsigned __int128> { enum { __value = 1 }; typedef __true_type __type; };
# 287 "/usr/include/c++/10/bits/cpp_type_traits.h" 3
  template<typename _Tp>
    struct __is_floating
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };


  template<>
    struct __is_floating<float>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_floating<double>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_floating<long double>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };




  template<typename _Tp>
    struct __is_pointer
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };

  template<typename _Tp>
    struct __is_pointer<_Tp*>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };




  template<typename _Tp>
    struct __is_arithmetic
    : public __traitor<__is_integer<_Tp>, __is_floating<_Tp> >
    { };




  template<typename _Tp>
    struct __is_scalar
    : public __traitor<__is_arithmetic<_Tp>, __is_pointer<_Tp> >
    { };




  template<typename _Tp>
    struct __is_char
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };

  template<>
    struct __is_char<char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };


  template<>
    struct __is_char<wchar_t>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };


  template<typename _Tp>
    struct __is_byte
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };

  template<>
    struct __is_byte<char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_byte<signed char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_byte<unsigned char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };
# 423 "/usr/include/c++/10/bits/cpp_type_traits.h" 3
  template<typename> struct iterator_traits;


  template<typename _Tp>
    struct __is_nonvolatile_trivially_copyable
    {
      enum { __value = __is_trivially_copyable(_Tp) };
    };




  template<typename _Tp>
    struct __is_nonvolatile_trivially_copyable<volatile _Tp>
    {
      enum { __value = 0 };
    };


  template<typename _OutputIter, typename _InputIter>
    struct __memcpyable
    {
      enum { __value = 0 };
    };

  template<typename _Tp>
    struct __memcpyable<_Tp*, _Tp*>
    : __is_nonvolatile_trivially_copyable<_Tp>
    { };

  template<typename _Tp>
    struct __memcpyable<_Tp*, const _Tp*>
    : __is_nonvolatile_trivially_copyable<_Tp>
    { };






  template<typename _Iter1, typename _Iter2>
    struct __memcmpable
    {
      enum { __value = 0 };
    };


  template<typename _Tp>
    struct __memcmpable<_Tp*, _Tp*>
    : __is_nonvolatile_trivially_copyable<_Tp>
    { };

  template<typename _Tp>
    struct __memcmpable<const _Tp*, _Tp*>
    : __is_nonvolatile_trivially_copyable<_Tp>
    { };

  template<typename _Tp>
    struct __memcmpable<_Tp*, const _Tp*>
    : __is_nonvolatile_trivially_copyable<_Tp>
    { };




  template<typename _Tp, bool _TreatAsBytes = __is_byte<_Tp>::__value>
    struct __is_memcmp_ordered
    {
      static const bool __value = _Tp(-1) > _Tp(1);
    };

  template<typename _Tp>
    struct __is_memcmp_ordered<_Tp, false>
    {
      static const bool __value = false;
    };


  template<typename _Tp, typename _Up, bool = sizeof(_Tp) == sizeof(_Up)>
    struct __is_memcmp_ordered_with
    {
      static const bool __value = __is_memcmp_ordered<_Tp>::__value
 && __is_memcmp_ordered<_Up>::__value;
    };

  template<typename _Tp, typename _Up>
    struct __is_memcmp_ordered_with<_Tp, _Up, false>
    {
      static const bool __value = false;
    };
# 532 "/usr/include/c++/10/bits/cpp_type_traits.h" 3
  template<typename _Tp>
    struct __is_move_iterator
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };



  template<typename _Iterator>
   
    inline _Iterator
    __miter_base(_Iterator __it)
    { return __it; }


}
}
# 43 "/usr/include/c++/10/cmath" 2 3
# 1 "/usr/include/c++/10/ext/type_traits.h" 1 3
# 32 "/usr/include/c++/10/ext/type_traits.h" 3
       
# 33 "/usr/include/c++/10/ext/type_traits.h" 3




extern "C++" {

namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{



  template<bool, typename>
    struct __enable_if
    { };

  template<typename _Tp>
    struct __enable_if<true, _Tp>
    { typedef _Tp __type; };



  template<bool _Cond, typename _Iftrue, typename _Iffalse>
    struct __conditional_type
    { typedef _Iftrue __type; };

  template<typename _Iftrue, typename _Iffalse>
    struct __conditional_type<false, _Iftrue, _Iffalse>
    { typedef _Iffalse __type; };



  template<typename _Tp>
    struct __add_unsigned
    {
    private:
      typedef __enable_if<std::__is_integer<_Tp>::__value, _Tp> __if_type;

    public:
      typedef typename __if_type::__type __type;
    };

  template<>
    struct __add_unsigned<char>
    { typedef unsigned char __type; };

  template<>
    struct __add_unsigned<signed char>
    { typedef unsigned char __type; };

  template<>
    struct __add_unsigned<short>
    { typedef unsigned short __type; };

  template<>
    struct __add_unsigned<int>
    { typedef unsigned int __type; };

  template<>
    struct __add_unsigned<long>
    { typedef unsigned long __type; };

  template<>
    struct __add_unsigned<long long>
    { typedef unsigned long long __type; };


  template<>
    struct __add_unsigned<bool>;

  template<>
    struct __add_unsigned<wchar_t>;



  template<typename _Tp>
    struct __remove_unsigned
    {
    private:
      typedef __enable_if<std::__is_integer<_Tp>::__value, _Tp> __if_type;

    public:
      typedef typename __if_type::__type __type;
    };

  template<>
    struct __remove_unsigned<char>
    { typedef signed char __type; };

  template<>
    struct __remove_unsigned<unsigned char>
    { typedef signed char __type; };

  template<>
    struct __remove_unsigned<unsigned short>
    { typedef short __type; };

  template<>
    struct __remove_unsigned<unsigned int>
    { typedef int __type; };

  template<>
    struct __remove_unsigned<unsigned long>
    { typedef long __type; };

  template<>
    struct __remove_unsigned<unsigned long long>
    { typedef long long __type; };


  template<>
    struct __remove_unsigned<bool>;

  template<>
    struct __remove_unsigned<wchar_t>;



  template<typename _Type>
    inline bool
    __is_null_pointer(_Type* __ptr)
    { return __ptr == 0; }

  template<typename _Type>
    inline bool
    __is_null_pointer(_Type)
    { return false; }


  inline bool
  __is_null_pointer(std::nullptr_t)
  { return true; }




  template<typename _Tp, bool = std::__is_integer<_Tp>::__value>
    struct __promote
    { typedef double __type; };




  template<typename _Tp>
    struct __promote<_Tp, false>
    { };

  template<>
    struct __promote<long double>
    { typedef long double __type; };

  template<>
    struct __promote<double>
    { typedef double __type; };

  template<>
    struct __promote<float>
    { typedef float __type; };






  template<typename _Tp, typename _Up,
           typename _Tp2 = typename __promote<_Tp>::__type,
           typename _Up2 = typename __promote<_Up>::__type>
    struct __promote_2
    {
      typedef __typeof__(_Tp2() + _Up2()) __type;
    };

  template<typename _Tp, typename _Up, typename _Vp,
           typename _Tp2 = typename __promote<_Tp>::__type,
           typename _Up2 = typename __promote<_Up>::__type,
           typename _Vp2 = typename __promote<_Vp>::__type>
    struct __promote_3
    {
      typedef __typeof__(_Tp2() + _Up2() + _Vp2()) __type;
    };

  template<typename _Tp, typename _Up, typename _Vp, typename _Wp,
           typename _Tp2 = typename __promote<_Tp>::__type,
           typename _Up2 = typename __promote<_Up>::__type,
           typename _Vp2 = typename __promote<_Vp>::__type,
           typename _Wp2 = typename __promote<_Wp>::__type>
    struct __promote_4
    {
      typedef __typeof__(_Tp2() + _Up2() + _Vp2() + _Wp2()) __type;
    };


}
}
# 44 "/usr/include/c++/10/cmath" 2 3

# 1 "/usr/include/math.h" 1 3 4
# 27 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/libc-header-start.h" 1 3 4
# 28 "/usr/include/math.h" 2 3 4






extern "C" {





# 1 "/usr/include/x86_64-linux-gnu/bits/math-vector.h" 1 3 4
# 25 "/usr/include/x86_64-linux-gnu/bits/math-vector.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/libm-simd-decl-stubs.h" 1 3 4
# 26 "/usr/include/x86_64-linux-gnu/bits/math-vector.h" 2 3 4
# 41 "/usr/include/math.h" 2 3 4
# 152 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/flt-eval-method.h" 1 3 4
# 153 "/usr/include/math.h" 2 3 4
# 163 "/usr/include/math.h" 3 4
typedef float float_t;
typedef double double_t;
# 204 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/fp-logb.h" 1 3 4
# 205 "/usr/include/math.h" 2 3 4
# 247 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/fp-fast.h" 1 3 4
# 248 "/usr/include/math.h" 2 3 4



enum
  {
    FP_INT_UPWARD =

      0,
    FP_INT_DOWNWARD =

      1,
    FP_INT_TOWARDZERO =

      2,
    FP_INT_TONEARESTFROMZERO =

      3,
    FP_INT_TONEAREST =

      4,
  };
# 312 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/mathcalls-helper-functions.h" 1 3 4
# 20 "/usr/include/x86_64-linux-gnu/bits/mathcalls-helper-functions.h" 3 4
extern int __fpclassify (double __value) noexcept (true)
     __attribute__ ((__const__));


extern int __signbit (double __value) noexcept (true)
     __attribute__ ((__const__));



extern int __isinf (double __value) noexcept (true)
  __attribute__ ((__const__));


extern int __finite (double __value) noexcept (true)
  __attribute__ ((__const__));


extern int __isnan (double __value) noexcept (true)
  __attribute__ ((__const__));


extern int __iseqsig (double __x, double __y) noexcept (true);


extern int __issignaling (double __value) noexcept (true)
     __attribute__ ((__const__));
# 313 "/usr/include/math.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 1 3 4
# 53 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
 extern double acos (double __x) noexcept (true); extern double __acos (double __x) noexcept (true);

 extern double asin (double __x) noexcept (true); extern double __asin (double __x) noexcept (true);

 extern double atan (double __x) noexcept (true); extern double __atan (double __x) noexcept (true);

 extern double atan2 (double __y, double __x) noexcept (true); extern double __atan2 (double __y, double __x) noexcept (true);


 extern double cos (double __x) noexcept (true); extern double __cos (double __x) noexcept (true);

 extern double sin (double __x) noexcept (true); extern double __sin (double __x) noexcept (true);

 extern double tan (double __x) noexcept (true); extern double __tan (double __x) noexcept (true);




 extern double cosh (double __x) noexcept (true); extern double __cosh (double __x) noexcept (true);

 extern double sinh (double __x) noexcept (true); extern double __sinh (double __x) noexcept (true);

 extern double tanh (double __x) noexcept (true); extern double __tanh (double __x) noexcept (true);



 extern void sincos (double __x, double *__sinx, double *__cosx) noexcept (true); extern void __sincos (double __x, double *__sinx, double *__cosx) noexcept (true)
                                                        ;




 extern double acosh (double __x) noexcept (true); extern double __acosh (double __x) noexcept (true);

 extern double asinh (double __x) noexcept (true); extern double __asinh (double __x) noexcept (true);

 extern double atanh (double __x) noexcept (true); extern double __atanh (double __x) noexcept (true);





 extern double exp (double __x) noexcept (true); extern double __exp (double __x) noexcept (true);


extern double frexp (double __x, int *__exponent) noexcept (true); extern double __frexp (double __x, int *__exponent) noexcept (true);


extern double ldexp (double __x, int __exponent) noexcept (true); extern double __ldexp (double __x, int __exponent) noexcept (true);


 extern double log (double __x) noexcept (true); extern double __log (double __x) noexcept (true);


 extern double log10 (double __x) noexcept (true); extern double __log10 (double __x) noexcept (true);


extern double modf (double __x, double *__iptr) noexcept (true); extern double __modf (double __x, double *__iptr) noexcept (true) __attribute__ ((__nonnull__ (2)));



 extern double exp10 (double __x) noexcept (true); extern double __exp10 (double __x) noexcept (true);




 extern double expm1 (double __x) noexcept (true); extern double __expm1 (double __x) noexcept (true);


 extern double log1p (double __x) noexcept (true); extern double __log1p (double __x) noexcept (true);


extern double logb (double __x) noexcept (true); extern double __logb (double __x) noexcept (true);




 extern double exp2 (double __x) noexcept (true); extern double __exp2 (double __x) noexcept (true);


 extern double log2 (double __x) noexcept (true); extern double __log2 (double __x) noexcept (true);






 extern double pow (double __x, double __y) noexcept (true); extern double __pow (double __x, double __y) noexcept (true);


extern double sqrt (double __x) noexcept (true); extern double __sqrt (double __x) noexcept (true);



 extern double hypot (double __x, double __y) noexcept (true); extern double __hypot (double __x, double __y) noexcept (true);




 extern double cbrt (double __x) noexcept (true); extern double __cbrt (double __x) noexcept (true);






extern double ceil (double __x) noexcept (true) __attribute__ ((__const__)); extern double __ceil (double __x) noexcept (true) __attribute__ ((__const__));


extern double fabs (double __x) noexcept (true) __attribute__ ((__const__)); extern double __fabs (double __x) noexcept (true) __attribute__ ((__const__));


extern double floor (double __x) noexcept (true) __attribute__ ((__const__)); extern double __floor (double __x) noexcept (true) __attribute__ ((__const__));


extern double fmod (double __x, double __y) noexcept (true); extern double __fmod (double __x, double __y) noexcept (true);
# 183 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern int finite (double __value) noexcept (true)
  __attribute__ ((__const__));


extern double drem (double __x, double __y) noexcept (true); extern double __drem (double __x, double __y) noexcept (true);



extern double significand (double __x) noexcept (true); extern double __significand (double __x) noexcept (true);






extern double copysign (double __x, double __y) noexcept (true) __attribute__ ((__const__)); extern double __copysign (double __x, double __y) noexcept (true) __attribute__ ((__const__));




extern double nan (const char *__tagb) noexcept (true); extern double __nan (const char *__tagb) noexcept (true);
# 220 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern double j0 (double) noexcept (true); extern double __j0 (double) noexcept (true);
extern double j1 (double) noexcept (true); extern double __j1 (double) noexcept (true);
extern double jn (int, double) noexcept (true); extern double __jn (int, double) noexcept (true);
extern double y0 (double) noexcept (true); extern double __y0 (double) noexcept (true);
extern double y1 (double) noexcept (true); extern double __y1 (double) noexcept (true);
extern double yn (int, double) noexcept (true); extern double __yn (int, double) noexcept (true);





 extern double erf (double) noexcept (true); extern double __erf (double) noexcept (true);
 extern double erfc (double) noexcept (true); extern double __erfc (double) noexcept (true);
extern double lgamma (double) noexcept (true); extern double __lgamma (double) noexcept (true);




extern double tgamma (double) noexcept (true); extern double __tgamma (double) noexcept (true);





extern double gamma (double) noexcept (true); extern double __gamma (double) noexcept (true);







extern double lgamma_r (double, int *__signgamp) noexcept (true); extern double __lgamma_r (double, int *__signgamp) noexcept (true);






extern double rint (double __x) noexcept (true); extern double __rint (double __x) noexcept (true);


extern double nextafter (double __x, double __y) noexcept (true); extern double __nextafter (double __x, double __y) noexcept (true);

extern double nexttoward (double __x, long double __y) noexcept (true); extern double __nexttoward (double __x, long double __y) noexcept (true);




extern double nextdown (double __x) noexcept (true); extern double __nextdown (double __x) noexcept (true);

extern double nextup (double __x) noexcept (true); extern double __nextup (double __x) noexcept (true);



extern double remainder (double __x, double __y) noexcept (true); extern double __remainder (double __x, double __y) noexcept (true);



extern double scalbn (double __x, int __n) noexcept (true); extern double __scalbn (double __x, int __n) noexcept (true);



extern int ilogb (double __x) noexcept (true); extern int __ilogb (double __x) noexcept (true);




extern long int llogb (double __x) noexcept (true); extern long int __llogb (double __x) noexcept (true);




extern double scalbln (double __x, long int __n) noexcept (true); extern double __scalbln (double __x, long int __n) noexcept (true);



extern double nearbyint (double __x) noexcept (true); extern double __nearbyint (double __x) noexcept (true);



extern double round (double __x) noexcept (true) __attribute__ ((__const__)); extern double __round (double __x) noexcept (true) __attribute__ ((__const__));



extern double trunc (double __x) noexcept (true) __attribute__ ((__const__)); extern double __trunc (double __x) noexcept (true) __attribute__ ((__const__));




extern double remquo (double __x, double __y, int *__quo) noexcept (true); extern double __remquo (double __x, double __y, int *__quo) noexcept (true);






extern long int lrint (double __x) noexcept (true); extern long int __lrint (double __x) noexcept (true);
__extension__
extern long long int llrint (double __x) noexcept (true); extern long long int __llrint (double __x) noexcept (true);



extern long int lround (double __x) noexcept (true); extern long int __lround (double __x) noexcept (true);
__extension__
extern long long int llround (double __x) noexcept (true); extern long long int __llround (double __x) noexcept (true);



extern double fdim (double __x, double __y) noexcept (true); extern double __fdim (double __x, double __y) noexcept (true);



extern double fmax (double __x, double __y) noexcept (true) __attribute__ ((__const__)); extern double __fmax (double __x, double __y) noexcept (true) __attribute__ ((__const__));


extern double fmin (double __x, double __y) noexcept (true) __attribute__ ((__const__)); extern double __fmin (double __x, double __y) noexcept (true) __attribute__ ((__const__));



extern double fma (double __x, double __y, double __z) noexcept (true); extern double __fma (double __x, double __y, double __z) noexcept (true);




extern double roundeven (double __x) noexcept (true) __attribute__ ((__const__)); extern double __roundeven (double __x) noexcept (true) __attribute__ ((__const__));



extern __intmax_t fromfp (double __x, int __round, unsigned int __width) noexcept (true); extern __intmax_t __fromfp (double __x, int __round, unsigned int __width) noexcept (true)
                            ;



extern __uintmax_t ufromfp (double __x, int __round, unsigned int __width) noexcept (true); extern __uintmax_t __ufromfp (double __x, int __round, unsigned int __width) noexcept (true)
                              ;




extern __intmax_t fromfpx (double __x, int __round, unsigned int __width) noexcept (true); extern __intmax_t __fromfpx (double __x, int __round, unsigned int __width) noexcept (true)
                             ;




extern __uintmax_t ufromfpx (double __x, int __round, unsigned int __width) noexcept (true); extern __uintmax_t __ufromfpx (double __x, int __round, unsigned int __width) noexcept (true)
                               ;


extern int canonicalize (double *__cx, const double *__x) noexcept (true);






extern double fmaxmag (double __x, double __y) noexcept (true) __attribute__ ((__const__)); extern double __fmaxmag (double __x, double __y) noexcept (true) __attribute__ ((__const__));


extern double fminmag (double __x, double __y) noexcept (true) __attribute__ ((__const__)); extern double __fminmag (double __x, double __y) noexcept (true) __attribute__ ((__const__));




extern double fmaximum (double __x, double __y) noexcept (true) __attribute__ ((__const__)); extern double __fmaximum (double __x, double __y) noexcept (true) __attribute__ ((__const__));


extern double fminimum (double __x, double __y) noexcept (true) __attribute__ ((__const__)); extern double __fminimum (double __x, double __y) noexcept (true) __attribute__ ((__const__));


extern double fmaximum_num (double __x, double __y) noexcept (true) __attribute__ ((__const__)); extern double __fmaximum_num (double __x, double __y) noexcept (true) __attribute__ ((__const__));


extern double fminimum_num (double __x, double __y) noexcept (true) __attribute__ ((__const__)); extern double __fminimum_num (double __x, double __y) noexcept (true) __attribute__ ((__const__));


extern double fmaximum_mag (double __x, double __y) noexcept (true) __attribute__ ((__const__)); extern double __fmaximum_mag (double __x, double __y) noexcept (true) __attribute__ ((__const__));


extern double fminimum_mag (double __x, double __y) noexcept (true) __attribute__ ((__const__)); extern double __fminimum_mag (double __x, double __y) noexcept (true) __attribute__ ((__const__));


extern double fmaximum_mag_num (double __x, double __y) noexcept (true) __attribute__ ((__const__)); extern double __fmaximum_mag_num (double __x, double __y) noexcept (true) __attribute__ ((__const__));


extern double fminimum_mag_num (double __x, double __y) noexcept (true) __attribute__ ((__const__)); extern double __fminimum_mag_num (double __x, double __y) noexcept (true) __attribute__ ((__const__));




extern int totalorder (const double *__x, const double *__y) noexcept (true)

     __attribute__ ((__pure__));


extern int totalordermag (const double *__x, const double *__y) noexcept (true)

     __attribute__ ((__pure__));


extern double getpayload (const double *__x) noexcept (true); extern double __getpayload (const double *__x) noexcept (true);


extern int setpayload (double *__x, double __payload) noexcept (true);


extern int setpayloadsig (double *__x, double __payload) noexcept (true);







extern double scalb (double __x, double __n) noexcept (true); extern double __scalb (double __x, double __n) noexcept (true);
# 314 "/usr/include/math.h" 2 3 4
# 329 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/mathcalls-helper-functions.h" 1 3 4
# 20 "/usr/include/x86_64-linux-gnu/bits/mathcalls-helper-functions.h" 3 4
extern int __fpclassifyf (float __value) noexcept (true)
     __attribute__ ((__const__));


extern int __signbitf (float __value) noexcept (true)
     __attribute__ ((__const__));



extern int __isinff (float __value) noexcept (true)
  __attribute__ ((__const__));


extern int __finitef (float __value) noexcept (true)
  __attribute__ ((__const__));


extern int __isnanf (float __value) noexcept (true)
  __attribute__ ((__const__));


extern int __iseqsigf (float __x, float __y) noexcept (true);


extern int __issignalingf (float __value) noexcept (true)
     __attribute__ ((__const__));
# 330 "/usr/include/math.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 1 3 4
# 53 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
 extern float acosf (float __x) noexcept (true); extern float __acosf (float __x) noexcept (true);

 extern float asinf (float __x) noexcept (true); extern float __asinf (float __x) noexcept (true);

 extern float atanf (float __x) noexcept (true); extern float __atanf (float __x) noexcept (true);

 extern float atan2f (float __y, float __x) noexcept (true); extern float __atan2f (float __y, float __x) noexcept (true);


 extern float cosf (float __x) noexcept (true); extern float __cosf (float __x) noexcept (true);

 extern float sinf (float __x) noexcept (true); extern float __sinf (float __x) noexcept (true);

 extern float tanf (float __x) noexcept (true); extern float __tanf (float __x) noexcept (true);




 extern float coshf (float __x) noexcept (true); extern float __coshf (float __x) noexcept (true);

 extern float sinhf (float __x) noexcept (true); extern float __sinhf (float __x) noexcept (true);

 extern float tanhf (float __x) noexcept (true); extern float __tanhf (float __x) noexcept (true);



 extern void sincosf (float __x, float *__sinx, float *__cosx) noexcept (true); extern void __sincosf (float __x, float *__sinx, float *__cosx) noexcept (true)
                                                        ;




 extern float acoshf (float __x) noexcept (true); extern float __acoshf (float __x) noexcept (true);

 extern float asinhf (float __x) noexcept (true); extern float __asinhf (float __x) noexcept (true);

 extern float atanhf (float __x) noexcept (true); extern float __atanhf (float __x) noexcept (true);





 extern float expf (float __x) noexcept (true); extern float __expf (float __x) noexcept (true);


extern float frexpf (float __x, int *__exponent) noexcept (true); extern float __frexpf (float __x, int *__exponent) noexcept (true);


extern float ldexpf (float __x, int __exponent) noexcept (true); extern float __ldexpf (float __x, int __exponent) noexcept (true);


 extern float logf (float __x) noexcept (true); extern float __logf (float __x) noexcept (true);


 extern float log10f (float __x) noexcept (true); extern float __log10f (float __x) noexcept (true);


extern float modff (float __x, float *__iptr) noexcept (true); extern float __modff (float __x, float *__iptr) noexcept (true) __attribute__ ((__nonnull__ (2)));



 extern float exp10f (float __x) noexcept (true); extern float __exp10f (float __x) noexcept (true);




 extern float expm1f (float __x) noexcept (true); extern float __expm1f (float __x) noexcept (true);


 extern float log1pf (float __x) noexcept (true); extern float __log1pf (float __x) noexcept (true);


extern float logbf (float __x) noexcept (true); extern float __logbf (float __x) noexcept (true);




 extern float exp2f (float __x) noexcept (true); extern float __exp2f (float __x) noexcept (true);


 extern float log2f (float __x) noexcept (true); extern float __log2f (float __x) noexcept (true);






 extern float powf (float __x, float __y) noexcept (true); extern float __powf (float __x, float __y) noexcept (true);


extern float sqrtf (float __x) noexcept (true); extern float __sqrtf (float __x) noexcept (true);



 extern float hypotf (float __x, float __y) noexcept (true); extern float __hypotf (float __x, float __y) noexcept (true);




 extern float cbrtf (float __x) noexcept (true); extern float __cbrtf (float __x) noexcept (true);






extern float ceilf (float __x) noexcept (true) __attribute__ ((__const__)); extern float __ceilf (float __x) noexcept (true) __attribute__ ((__const__));


extern float fabsf (float __x) noexcept (true) __attribute__ ((__const__)); extern float __fabsf (float __x) noexcept (true) __attribute__ ((__const__));


extern float floorf (float __x) noexcept (true) __attribute__ ((__const__)); extern float __floorf (float __x) noexcept (true) __attribute__ ((__const__));


extern float fmodf (float __x, float __y) noexcept (true); extern float __fmodf (float __x, float __y) noexcept (true);
# 177 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern int isinff (float __value) noexcept (true)
  __attribute__ ((__const__));




extern int finitef (float __value) noexcept (true)
  __attribute__ ((__const__));


extern float dremf (float __x, float __y) noexcept (true); extern float __dremf (float __x, float __y) noexcept (true);



extern float significandf (float __x) noexcept (true); extern float __significandf (float __x) noexcept (true);






extern float copysignf (float __x, float __y) noexcept (true) __attribute__ ((__const__)); extern float __copysignf (float __x, float __y) noexcept (true) __attribute__ ((__const__));




extern float nanf (const char *__tagb) noexcept (true); extern float __nanf (const char *__tagb) noexcept (true);
# 213 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern int isnanf (float __value) noexcept (true)
  __attribute__ ((__const__));





extern float j0f (float) noexcept (true); extern float __j0f (float) noexcept (true);
extern float j1f (float) noexcept (true); extern float __j1f (float) noexcept (true);
extern float jnf (int, float) noexcept (true); extern float __jnf (int, float) noexcept (true);
extern float y0f (float) noexcept (true); extern float __y0f (float) noexcept (true);
extern float y1f (float) noexcept (true); extern float __y1f (float) noexcept (true);
extern float ynf (int, float) noexcept (true); extern float __ynf (int, float) noexcept (true);





 extern float erff (float) noexcept (true); extern float __erff (float) noexcept (true);
 extern float erfcf (float) noexcept (true); extern float __erfcf (float) noexcept (true);
extern float lgammaf (float) noexcept (true); extern float __lgammaf (float) noexcept (true);




extern float tgammaf (float) noexcept (true); extern float __tgammaf (float) noexcept (true);





extern float gammaf (float) noexcept (true); extern float __gammaf (float) noexcept (true);







extern float lgammaf_r (float, int *__signgamp) noexcept (true); extern float __lgammaf_r (float, int *__signgamp) noexcept (true);






extern float rintf (float __x) noexcept (true); extern float __rintf (float __x) noexcept (true);


extern float nextafterf (float __x, float __y) noexcept (true); extern float __nextafterf (float __x, float __y) noexcept (true);

extern float nexttowardf (float __x, long double __y) noexcept (true); extern float __nexttowardf (float __x, long double __y) noexcept (true);




extern float nextdownf (float __x) noexcept (true); extern float __nextdownf (float __x) noexcept (true);

extern float nextupf (float __x) noexcept (true); extern float __nextupf (float __x) noexcept (true);



extern float remainderf (float __x, float __y) noexcept (true); extern float __remainderf (float __x, float __y) noexcept (true);



extern float scalbnf (float __x, int __n) noexcept (true); extern float __scalbnf (float __x, int __n) noexcept (true);



extern int ilogbf (float __x) noexcept (true); extern int __ilogbf (float __x) noexcept (true);




extern long int llogbf (float __x) noexcept (true); extern long int __llogbf (float __x) noexcept (true);




extern float scalblnf (float __x, long int __n) noexcept (true); extern float __scalblnf (float __x, long int __n) noexcept (true);



extern float nearbyintf (float __x) noexcept (true); extern float __nearbyintf (float __x) noexcept (true);



extern float roundf (float __x) noexcept (true) __attribute__ ((__const__)); extern float __roundf (float __x) noexcept (true) __attribute__ ((__const__));



extern float truncf (float __x) noexcept (true) __attribute__ ((__const__)); extern float __truncf (float __x) noexcept (true) __attribute__ ((__const__));




extern float remquof (float __x, float __y, int *__quo) noexcept (true); extern float __remquof (float __x, float __y, int *__quo) noexcept (true);






extern long int lrintf (float __x) noexcept (true); extern long int __lrintf (float __x) noexcept (true);
__extension__
extern long long int llrintf (float __x) noexcept (true); extern long long int __llrintf (float __x) noexcept (true);



extern long int lroundf (float __x) noexcept (true); extern long int __lroundf (float __x) noexcept (true);
__extension__
extern long long int llroundf (float __x) noexcept (true); extern long long int __llroundf (float __x) noexcept (true);



extern float fdimf (float __x, float __y) noexcept (true); extern float __fdimf (float __x, float __y) noexcept (true);



extern float fmaxf (float __x, float __y) noexcept (true) __attribute__ ((__const__)); extern float __fmaxf (float __x, float __y) noexcept (true) __attribute__ ((__const__));


extern float fminf (float __x, float __y) noexcept (true) __attribute__ ((__const__)); extern float __fminf (float __x, float __y) noexcept (true) __attribute__ ((__const__));



extern float fmaf (float __x, float __y, float __z) noexcept (true); extern float __fmaf (float __x, float __y, float __z) noexcept (true);




extern float roundevenf (float __x) noexcept (true) __attribute__ ((__const__)); extern float __roundevenf (float __x) noexcept (true) __attribute__ ((__const__));



extern __intmax_t fromfpf (float __x, int __round, unsigned int __width) noexcept (true); extern __intmax_t __fromfpf (float __x, int __round, unsigned int __width) noexcept (true)
                            ;



extern __uintmax_t ufromfpf (float __x, int __round, unsigned int __width) noexcept (true); extern __uintmax_t __ufromfpf (float __x, int __round, unsigned int __width) noexcept (true)
                              ;




extern __intmax_t fromfpxf (float __x, int __round, unsigned int __width) noexcept (true); extern __intmax_t __fromfpxf (float __x, int __round, unsigned int __width) noexcept (true)
                             ;




extern __uintmax_t ufromfpxf (float __x, int __round, unsigned int __width) noexcept (true); extern __uintmax_t __ufromfpxf (float __x, int __round, unsigned int __width) noexcept (true)
                               ;


extern int canonicalizef (float *__cx, const float *__x) noexcept (true);






extern float fmaxmagf (float __x, float __y) noexcept (true) __attribute__ ((__const__)); extern float __fmaxmagf (float __x, float __y) noexcept (true) __attribute__ ((__const__));


extern float fminmagf (float __x, float __y) noexcept (true) __attribute__ ((__const__)); extern float __fminmagf (float __x, float __y) noexcept (true) __attribute__ ((__const__));




extern float fmaximumf (float __x, float __y) noexcept (true) __attribute__ ((__const__)); extern float __fmaximumf (float __x, float __y) noexcept (true) __attribute__ ((__const__));


extern float fminimumf (float __x, float __y) noexcept (true) __attribute__ ((__const__)); extern float __fminimumf (float __x, float __y) noexcept (true) __attribute__ ((__const__));


extern float fmaximum_numf (float __x, float __y) noexcept (true) __attribute__ ((__const__)); extern float __fmaximum_numf (float __x, float __y) noexcept (true) __attribute__ ((__const__));


extern float fminimum_numf (float __x, float __y) noexcept (true) __attribute__ ((__const__)); extern float __fminimum_numf (float __x, float __y) noexcept (true) __attribute__ ((__const__));


extern float fmaximum_magf (float __x, float __y) noexcept (true) __attribute__ ((__const__)); extern float __fmaximum_magf (float __x, float __y) noexcept (true) __attribute__ ((__const__));


extern float fminimum_magf (float __x, float __y) noexcept (true) __attribute__ ((__const__)); extern float __fminimum_magf (float __x, float __y) noexcept (true) __attribute__ ((__const__));


extern float fmaximum_mag_numf (float __x, float __y) noexcept (true) __attribute__ ((__const__)); extern float __fmaximum_mag_numf (float __x, float __y) noexcept (true) __attribute__ ((__const__));


extern float fminimum_mag_numf (float __x, float __y) noexcept (true) __attribute__ ((__const__)); extern float __fminimum_mag_numf (float __x, float __y) noexcept (true) __attribute__ ((__const__));




extern int totalorderf (const float *__x, const float *__y) noexcept (true)

     __attribute__ ((__pure__));


extern int totalordermagf (const float *__x, const float *__y) noexcept (true)

     __attribute__ ((__pure__));


extern float getpayloadf (const float *__x) noexcept (true); extern float __getpayloadf (const float *__x) noexcept (true);


extern int setpayloadf (float *__x, float __payload) noexcept (true);


extern int setpayloadsigf (float *__x, float __payload) noexcept (true);







extern float scalbf (float __x, float __n) noexcept (true); extern float __scalbf (float __x, float __n) noexcept (true);
# 331 "/usr/include/math.h" 2 3 4
# 398 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/mathcalls-helper-functions.h" 1 3 4
# 20 "/usr/include/x86_64-linux-gnu/bits/mathcalls-helper-functions.h" 3 4
extern int __fpclassifyl (long double __value) noexcept (true)
     __attribute__ ((__const__));


extern int __signbitl (long double __value) noexcept (true)
     __attribute__ ((__const__));



extern int __isinfl (long double __value) noexcept (true)
  __attribute__ ((__const__));


extern int __finitel (long double __value) noexcept (true)
  __attribute__ ((__const__));


extern int __isnanl (long double __value) noexcept (true)
  __attribute__ ((__const__));


extern int __iseqsigl (long double __x, long double __y) noexcept (true);


extern int __issignalingl (long double __value) noexcept (true)
     __attribute__ ((__const__));
# 399 "/usr/include/math.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 1 3 4
# 53 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
 extern long double acosl (long double __x) noexcept (true); extern long double __acosl (long double __x) noexcept (true);

 extern long double asinl (long double __x) noexcept (true); extern long double __asinl (long double __x) noexcept (true);

 extern long double atanl (long double __x) noexcept (true); extern long double __atanl (long double __x) noexcept (true);

 extern long double atan2l (long double __y, long double __x) noexcept (true); extern long double __atan2l (long double __y, long double __x) noexcept (true);


 extern long double cosl (long double __x) noexcept (true); extern long double __cosl (long double __x) noexcept (true);

 extern long double sinl (long double __x) noexcept (true); extern long double __sinl (long double __x) noexcept (true);

 extern long double tanl (long double __x) noexcept (true); extern long double __tanl (long double __x) noexcept (true);




 extern long double coshl (long double __x) noexcept (true); extern long double __coshl (long double __x) noexcept (true);

 extern long double sinhl (long double __x) noexcept (true); extern long double __sinhl (long double __x) noexcept (true);

 extern long double tanhl (long double __x) noexcept (true); extern long double __tanhl (long double __x) noexcept (true);



 extern void sincosl (long double __x, long double *__sinx, long double *__cosx) noexcept (true); extern void __sincosl (long double __x, long double *__sinx, long double *__cosx) noexcept (true)
                                                        ;




 extern long double acoshl (long double __x) noexcept (true); extern long double __acoshl (long double __x) noexcept (true);

 extern long double asinhl (long double __x) noexcept (true); extern long double __asinhl (long double __x) noexcept (true);

 extern long double atanhl (long double __x) noexcept (true); extern long double __atanhl (long double __x) noexcept (true);





 extern long double expl (long double __x) noexcept (true); extern long double __expl (long double __x) noexcept (true);


extern long double frexpl (long double __x, int *__exponent) noexcept (true); extern long double __frexpl (long double __x, int *__exponent) noexcept (true);


extern long double ldexpl (long double __x, int __exponent) noexcept (true); extern long double __ldexpl (long double __x, int __exponent) noexcept (true);


 extern long double logl (long double __x) noexcept (true); extern long double __logl (long double __x) noexcept (true);


 extern long double log10l (long double __x) noexcept (true); extern long double __log10l (long double __x) noexcept (true);


extern long double modfl (long double __x, long double *__iptr) noexcept (true); extern long double __modfl (long double __x, long double *__iptr) noexcept (true) __attribute__ ((__nonnull__ (2)));



 extern long double exp10l (long double __x) noexcept (true); extern long double __exp10l (long double __x) noexcept (true);




 extern long double expm1l (long double __x) noexcept (true); extern long double __expm1l (long double __x) noexcept (true);


 extern long double log1pl (long double __x) noexcept (true); extern long double __log1pl (long double __x) noexcept (true);


extern long double logbl (long double __x) noexcept (true); extern long double __logbl (long double __x) noexcept (true);




 extern long double exp2l (long double __x) noexcept (true); extern long double __exp2l (long double __x) noexcept (true);


 extern long double log2l (long double __x) noexcept (true); extern long double __log2l (long double __x) noexcept (true);






 extern long double powl (long double __x, long double __y) noexcept (true); extern long double __powl (long double __x, long double __y) noexcept (true);


extern long double sqrtl (long double __x) noexcept (true); extern long double __sqrtl (long double __x) noexcept (true);



 extern long double hypotl (long double __x, long double __y) noexcept (true); extern long double __hypotl (long double __x, long double __y) noexcept (true);




 extern long double cbrtl (long double __x) noexcept (true); extern long double __cbrtl (long double __x) noexcept (true);






extern long double ceill (long double __x) noexcept (true) __attribute__ ((__const__)); extern long double __ceill (long double __x) noexcept (true) __attribute__ ((__const__));


extern long double fabsl (long double __x) noexcept (true) __attribute__ ((__const__)); extern long double __fabsl (long double __x) noexcept (true) __attribute__ ((__const__));


extern long double floorl (long double __x) noexcept (true) __attribute__ ((__const__)); extern long double __floorl (long double __x) noexcept (true) __attribute__ ((__const__));


extern long double fmodl (long double __x, long double __y) noexcept (true); extern long double __fmodl (long double __x, long double __y) noexcept (true);
# 177 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern int isinfl (long double __value) noexcept (true)
  __attribute__ ((__const__));




extern int finitel (long double __value) noexcept (true)
  __attribute__ ((__const__));


extern long double dreml (long double __x, long double __y) noexcept (true); extern long double __dreml (long double __x, long double __y) noexcept (true);



extern long double significandl (long double __x) noexcept (true); extern long double __significandl (long double __x) noexcept (true);






extern long double copysignl (long double __x, long double __y) noexcept (true) __attribute__ ((__const__)); extern long double __copysignl (long double __x, long double __y) noexcept (true) __attribute__ ((__const__));




extern long double nanl (const char *__tagb) noexcept (true); extern long double __nanl (const char *__tagb) noexcept (true);
# 213 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern int isnanl (long double __value) noexcept (true)
  __attribute__ ((__const__));





extern long double j0l (long double) noexcept (true); extern long double __j0l (long double) noexcept (true);
extern long double j1l (long double) noexcept (true); extern long double __j1l (long double) noexcept (true);
extern long double jnl (int, long double) noexcept (true); extern long double __jnl (int, long double) noexcept (true);
extern long double y0l (long double) noexcept (true); extern long double __y0l (long double) noexcept (true);
extern long double y1l (long double) noexcept (true); extern long double __y1l (long double) noexcept (true);
extern long double ynl (int, long double) noexcept (true); extern long double __ynl (int, long double) noexcept (true);





 extern long double erfl (long double) noexcept (true); extern long double __erfl (long double) noexcept (true);
 extern long double erfcl (long double) noexcept (true); extern long double __erfcl (long double) noexcept (true);
extern long double lgammal (long double) noexcept (true); extern long double __lgammal (long double) noexcept (true);




extern long double tgammal (long double) noexcept (true); extern long double __tgammal (long double) noexcept (true);





extern long double gammal (long double) noexcept (true); extern long double __gammal (long double) noexcept (true);







extern long double lgammal_r (long double, int *__signgamp) noexcept (true); extern long double __lgammal_r (long double, int *__signgamp) noexcept (true);






extern long double rintl (long double __x) noexcept (true); extern long double __rintl (long double __x) noexcept (true);


extern long double nextafterl (long double __x, long double __y) noexcept (true); extern long double __nextafterl (long double __x, long double __y) noexcept (true);

extern long double nexttowardl (long double __x, long double __y) noexcept (true); extern long double __nexttowardl (long double __x, long double __y) noexcept (true);




extern long double nextdownl (long double __x) noexcept (true); extern long double __nextdownl (long double __x) noexcept (true);

extern long double nextupl (long double __x) noexcept (true); extern long double __nextupl (long double __x) noexcept (true);



extern long double remainderl (long double __x, long double __y) noexcept (true); extern long double __remainderl (long double __x, long double __y) noexcept (true);



extern long double scalbnl (long double __x, int __n) noexcept (true); extern long double __scalbnl (long double __x, int __n) noexcept (true);



extern int ilogbl (long double __x) noexcept (true); extern int __ilogbl (long double __x) noexcept (true);




extern long int llogbl (long double __x) noexcept (true); extern long int __llogbl (long double __x) noexcept (true);




extern long double scalblnl (long double __x, long int __n) noexcept (true); extern long double __scalblnl (long double __x, long int __n) noexcept (true);



extern long double nearbyintl (long double __x) noexcept (true); extern long double __nearbyintl (long double __x) noexcept (true);



extern long double roundl (long double __x) noexcept (true) __attribute__ ((__const__)); extern long double __roundl (long double __x) noexcept (true) __attribute__ ((__const__));



extern long double truncl (long double __x) noexcept (true) __attribute__ ((__const__)); extern long double __truncl (long double __x) noexcept (true) __attribute__ ((__const__));




extern long double remquol (long double __x, long double __y, int *__quo) noexcept (true); extern long double __remquol (long double __x, long double __y, int *__quo) noexcept (true);






extern long int lrintl (long double __x) noexcept (true); extern long int __lrintl (long double __x) noexcept (true);
__extension__
extern long long int llrintl (long double __x) noexcept (true); extern long long int __llrintl (long double __x) noexcept (true);



extern long int lroundl (long double __x) noexcept (true); extern long int __lroundl (long double __x) noexcept (true);
__extension__
extern long long int llroundl (long double __x) noexcept (true); extern long long int __llroundl (long double __x) noexcept (true);



extern long double fdiml (long double __x, long double __y) noexcept (true); extern long double __fdiml (long double __x, long double __y) noexcept (true);



extern long double fmaxl (long double __x, long double __y) noexcept (true) __attribute__ ((__const__)); extern long double __fmaxl (long double __x, long double __y) noexcept (true) __attribute__ ((__const__));


extern long double fminl (long double __x, long double __y) noexcept (true) __attribute__ ((__const__)); extern long double __fminl (long double __x, long double __y) noexcept (true) __attribute__ ((__const__));



extern long double fmal (long double __x, long double __y, long double __z) noexcept (true); extern long double __fmal (long double __x, long double __y, long double __z) noexcept (true);




extern long double roundevenl (long double __x) noexcept (true) __attribute__ ((__const__)); extern long double __roundevenl (long double __x) noexcept (true) __attribute__ ((__const__));



extern __intmax_t fromfpl (long double __x, int __round, unsigned int __width) noexcept (true); extern __intmax_t __fromfpl (long double __x, int __round, unsigned int __width) noexcept (true)
                            ;



extern __uintmax_t ufromfpl (long double __x, int __round, unsigned int __width) noexcept (true); extern __uintmax_t __ufromfpl (long double __x, int __round, unsigned int __width) noexcept (true)
                              ;




extern __intmax_t fromfpxl (long double __x, int __round, unsigned int __width) noexcept (true); extern __intmax_t __fromfpxl (long double __x, int __round, unsigned int __width) noexcept (true)
                             ;




extern __uintmax_t ufromfpxl (long double __x, int __round, unsigned int __width) noexcept (true); extern __uintmax_t __ufromfpxl (long double __x, int __round, unsigned int __width) noexcept (true)
                               ;


extern int canonicalizel (long double *__cx, const long double *__x) noexcept (true);






extern long double fmaxmagl (long double __x, long double __y) noexcept (true) __attribute__ ((__const__)); extern long double __fmaxmagl (long double __x, long double __y) noexcept (true) __attribute__ ((__const__));


extern long double fminmagl (long double __x, long double __y) noexcept (true) __attribute__ ((__const__)); extern long double __fminmagl (long double __x, long double __y) noexcept (true) __attribute__ ((__const__));




extern long double fmaximuml (long double __x, long double __y) noexcept (true) __attribute__ ((__const__)); extern long double __fmaximuml (long double __x, long double __y) noexcept (true) __attribute__ ((__const__));


extern long double fminimuml (long double __x, long double __y) noexcept (true) __attribute__ ((__const__)); extern long double __fminimuml (long double __x, long double __y) noexcept (true) __attribute__ ((__const__));


extern long double fmaximum_numl (long double __x, long double __y) noexcept (true) __attribute__ ((__const__)); extern long double __fmaximum_numl (long double __x, long double __y) noexcept (true) __attribute__ ((__const__));


extern long double fminimum_numl (long double __x, long double __y) noexcept (true) __attribute__ ((__const__)); extern long double __fminimum_numl (long double __x, long double __y) noexcept (true) __attribute__ ((__const__));


extern long double fmaximum_magl (long double __x, long double __y) noexcept (true) __attribute__ ((__const__)); extern long double __fmaximum_magl (long double __x, long double __y) noexcept (true) __attribute__ ((__const__));


extern long double fminimum_magl (long double __x, long double __y) noexcept (true) __attribute__ ((__const__)); extern long double __fminimum_magl (long double __x, long double __y) noexcept (true) __attribute__ ((__const__));


extern long double fmaximum_mag_numl (long double __x, long double __y) noexcept (true) __attribute__ ((__const__)); extern long double __fmaximum_mag_numl (long double __x, long double __y) noexcept (true) __attribute__ ((__const__));


extern long double fminimum_mag_numl (long double __x, long double __y) noexcept (true) __attribute__ ((__const__)); extern long double __fminimum_mag_numl (long double __x, long double __y) noexcept (true) __attribute__ ((__const__));




extern int totalorderl (const long double *__x, const long double *__y) noexcept (true)

     __attribute__ ((__pure__));


extern int totalordermagl (const long double *__x, const long double *__y) noexcept (true)

     __attribute__ ((__pure__));


extern long double getpayloadl (const long double *__x) noexcept (true); extern long double __getpayloadl (const long double *__x) noexcept (true);


extern int setpayloadl (long double *__x, long double __payload) noexcept (true);


extern int setpayloadsigl (long double *__x, long double __payload) noexcept (true);







extern long double scalbl (long double __x, long double __n) noexcept (true); extern long double __scalbl (long double __x, long double __n) noexcept (true);
# 400 "/usr/include/math.h" 2 3 4
# 450 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 1 3 4
# 53 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
 extern _Float32 acosf32 (_Float32 __x) noexcept (true); extern _Float32 __acosf32 (_Float32 __x) noexcept (true);

 extern _Float32 asinf32 (_Float32 __x) noexcept (true); extern _Float32 __asinf32 (_Float32 __x) noexcept (true);

 extern _Float32 atanf32 (_Float32 __x) noexcept (true); extern _Float32 __atanf32 (_Float32 __x) noexcept (true);

 extern _Float32 atan2f32 (_Float32 __y, _Float32 __x) noexcept (true); extern _Float32 __atan2f32 (_Float32 __y, _Float32 __x) noexcept (true);


 extern _Float32 cosf32 (_Float32 __x) noexcept (true); extern _Float32 __cosf32 (_Float32 __x) noexcept (true);

 extern _Float32 sinf32 (_Float32 __x) noexcept (true); extern _Float32 __sinf32 (_Float32 __x) noexcept (true);

 extern _Float32 tanf32 (_Float32 __x) noexcept (true); extern _Float32 __tanf32 (_Float32 __x) noexcept (true);




 extern _Float32 coshf32 (_Float32 __x) noexcept (true); extern _Float32 __coshf32 (_Float32 __x) noexcept (true);

 extern _Float32 sinhf32 (_Float32 __x) noexcept (true); extern _Float32 __sinhf32 (_Float32 __x) noexcept (true);

 extern _Float32 tanhf32 (_Float32 __x) noexcept (true); extern _Float32 __tanhf32 (_Float32 __x) noexcept (true);



 extern void sincosf32 (_Float32 __x, _Float32 *__sinx, _Float32 *__cosx) noexcept (true); extern void __sincosf32 (_Float32 __x, _Float32 *__sinx, _Float32 *__cosx) noexcept (true)
                                                        ;




 extern _Float32 acoshf32 (_Float32 __x) noexcept (true); extern _Float32 __acoshf32 (_Float32 __x) noexcept (true);

 extern _Float32 asinhf32 (_Float32 __x) noexcept (true); extern _Float32 __asinhf32 (_Float32 __x) noexcept (true);

 extern _Float32 atanhf32 (_Float32 __x) noexcept (true); extern _Float32 __atanhf32 (_Float32 __x) noexcept (true);





 extern _Float32 expf32 (_Float32 __x) noexcept (true); extern _Float32 __expf32 (_Float32 __x) noexcept (true);


extern _Float32 frexpf32 (_Float32 __x, int *__exponent) noexcept (true); extern _Float32 __frexpf32 (_Float32 __x, int *__exponent) noexcept (true);


extern _Float32 ldexpf32 (_Float32 __x, int __exponent) noexcept (true); extern _Float32 __ldexpf32 (_Float32 __x, int __exponent) noexcept (true);


 extern _Float32 logf32 (_Float32 __x) noexcept (true); extern _Float32 __logf32 (_Float32 __x) noexcept (true);


 extern _Float32 log10f32 (_Float32 __x) noexcept (true); extern _Float32 __log10f32 (_Float32 __x) noexcept (true);


extern _Float32 modff32 (_Float32 __x, _Float32 *__iptr) noexcept (true); extern _Float32 __modff32 (_Float32 __x, _Float32 *__iptr) noexcept (true) __attribute__ ((__nonnull__ (2)));



 extern _Float32 exp10f32 (_Float32 __x) noexcept (true); extern _Float32 __exp10f32 (_Float32 __x) noexcept (true);




 extern _Float32 expm1f32 (_Float32 __x) noexcept (true); extern _Float32 __expm1f32 (_Float32 __x) noexcept (true);


 extern _Float32 log1pf32 (_Float32 __x) noexcept (true); extern _Float32 __log1pf32 (_Float32 __x) noexcept (true);


extern _Float32 logbf32 (_Float32 __x) noexcept (true); extern _Float32 __logbf32 (_Float32 __x) noexcept (true);




 extern _Float32 exp2f32 (_Float32 __x) noexcept (true); extern _Float32 __exp2f32 (_Float32 __x) noexcept (true);


 extern _Float32 log2f32 (_Float32 __x) noexcept (true); extern _Float32 __log2f32 (_Float32 __x) noexcept (true);






 extern _Float32 powf32 (_Float32 __x, _Float32 __y) noexcept (true); extern _Float32 __powf32 (_Float32 __x, _Float32 __y) noexcept (true);


extern _Float32 sqrtf32 (_Float32 __x) noexcept (true); extern _Float32 __sqrtf32 (_Float32 __x) noexcept (true);



 extern _Float32 hypotf32 (_Float32 __x, _Float32 __y) noexcept (true); extern _Float32 __hypotf32 (_Float32 __x, _Float32 __y) noexcept (true);




 extern _Float32 cbrtf32 (_Float32 __x) noexcept (true); extern _Float32 __cbrtf32 (_Float32 __x) noexcept (true);






extern _Float32 ceilf32 (_Float32 __x) noexcept (true) __attribute__ ((__const__)); extern _Float32 __ceilf32 (_Float32 __x) noexcept (true) __attribute__ ((__const__));


extern _Float32 fabsf32 (_Float32 __x) noexcept (true) __attribute__ ((__const__)); extern _Float32 __fabsf32 (_Float32 __x) noexcept (true) __attribute__ ((__const__));


extern _Float32 floorf32 (_Float32 __x) noexcept (true) __attribute__ ((__const__)); extern _Float32 __floorf32 (_Float32 __x) noexcept (true) __attribute__ ((__const__));


extern _Float32 fmodf32 (_Float32 __x, _Float32 __y) noexcept (true); extern _Float32 __fmodf32 (_Float32 __x, _Float32 __y) noexcept (true);
# 198 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern _Float32 copysignf32 (_Float32 __x, _Float32 __y) noexcept (true) __attribute__ ((__const__)); extern _Float32 __copysignf32 (_Float32 __x, _Float32 __y) noexcept (true) __attribute__ ((__const__));




extern _Float32 nanf32 (const char *__tagb) noexcept (true); extern _Float32 __nanf32 (const char *__tagb) noexcept (true);
# 220 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern _Float32 j0f32 (_Float32) noexcept (true); extern _Float32 __j0f32 (_Float32) noexcept (true);
extern _Float32 j1f32 (_Float32) noexcept (true); extern _Float32 __j1f32 (_Float32) noexcept (true);
extern _Float32 jnf32 (int, _Float32) noexcept (true); extern _Float32 __jnf32 (int, _Float32) noexcept (true);
extern _Float32 y0f32 (_Float32) noexcept (true); extern _Float32 __y0f32 (_Float32) noexcept (true);
extern _Float32 y1f32 (_Float32) noexcept (true); extern _Float32 __y1f32 (_Float32) noexcept (true);
extern _Float32 ynf32 (int, _Float32) noexcept (true); extern _Float32 __ynf32 (int, _Float32) noexcept (true);





 extern _Float32 erff32 (_Float32) noexcept (true); extern _Float32 __erff32 (_Float32) noexcept (true);
 extern _Float32 erfcf32 (_Float32) noexcept (true); extern _Float32 __erfcf32 (_Float32) noexcept (true);
extern _Float32 lgammaf32 (_Float32) noexcept (true); extern _Float32 __lgammaf32 (_Float32) noexcept (true);




extern _Float32 tgammaf32 (_Float32) noexcept (true); extern _Float32 __tgammaf32 (_Float32) noexcept (true);
# 252 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern _Float32 lgammaf32_r (_Float32, int *__signgamp) noexcept (true); extern _Float32 __lgammaf32_r (_Float32, int *__signgamp) noexcept (true);






extern _Float32 rintf32 (_Float32 __x) noexcept (true); extern _Float32 __rintf32 (_Float32 __x) noexcept (true);


extern _Float32 nextafterf32 (_Float32 __x, _Float32 __y) noexcept (true); extern _Float32 __nextafterf32 (_Float32 __x, _Float32 __y) noexcept (true);






extern _Float32 nextdownf32 (_Float32 __x) noexcept (true); extern _Float32 __nextdownf32 (_Float32 __x) noexcept (true);

extern _Float32 nextupf32 (_Float32 __x) noexcept (true); extern _Float32 __nextupf32 (_Float32 __x) noexcept (true);



extern _Float32 remainderf32 (_Float32 __x, _Float32 __y) noexcept (true); extern _Float32 __remainderf32 (_Float32 __x, _Float32 __y) noexcept (true);



extern _Float32 scalbnf32 (_Float32 __x, int __n) noexcept (true); extern _Float32 __scalbnf32 (_Float32 __x, int __n) noexcept (true);



extern int ilogbf32 (_Float32 __x) noexcept (true); extern int __ilogbf32 (_Float32 __x) noexcept (true);




extern long int llogbf32 (_Float32 __x) noexcept (true); extern long int __llogbf32 (_Float32 __x) noexcept (true);




extern _Float32 scalblnf32 (_Float32 __x, long int __n) noexcept (true); extern _Float32 __scalblnf32 (_Float32 __x, long int __n) noexcept (true);



extern _Float32 nearbyintf32 (_Float32 __x) noexcept (true); extern _Float32 __nearbyintf32 (_Float32 __x) noexcept (true);



extern _Float32 roundf32 (_Float32 __x) noexcept (true) __attribute__ ((__const__)); extern _Float32 __roundf32 (_Float32 __x) noexcept (true) __attribute__ ((__const__));



extern _Float32 truncf32 (_Float32 __x) noexcept (true) __attribute__ ((__const__)); extern _Float32 __truncf32 (_Float32 __x) noexcept (true) __attribute__ ((__const__));




extern _Float32 remquof32 (_Float32 __x, _Float32 __y, int *__quo) noexcept (true); extern _Float32 __remquof32 (_Float32 __x, _Float32 __y, int *__quo) noexcept (true);






extern long int lrintf32 (_Float32 __x) noexcept (true); extern long int __lrintf32 (_Float32 __x) noexcept (true);
__extension__
extern long long int llrintf32 (_Float32 __x) noexcept (true); extern long long int __llrintf32 (_Float32 __x) noexcept (true);



extern long int lroundf32 (_Float32 __x) noexcept (true); extern long int __lroundf32 (_Float32 __x) noexcept (true);
__extension__
extern long long int llroundf32 (_Float32 __x) noexcept (true); extern long long int __llroundf32 (_Float32 __x) noexcept (true);



extern _Float32 fdimf32 (_Float32 __x, _Float32 __y) noexcept (true); extern _Float32 __fdimf32 (_Float32 __x, _Float32 __y) noexcept (true);



extern _Float32 fmaxf32 (_Float32 __x, _Float32 __y) noexcept (true) __attribute__ ((__const__)); extern _Float32 __fmaxf32 (_Float32 __x, _Float32 __y) noexcept (true) __attribute__ ((__const__));


extern _Float32 fminf32 (_Float32 __x, _Float32 __y) noexcept (true) __attribute__ ((__const__)); extern _Float32 __fminf32 (_Float32 __x, _Float32 __y) noexcept (true) __attribute__ ((__const__));



extern _Float32 fmaf32 (_Float32 __x, _Float32 __y, _Float32 __z) noexcept (true); extern _Float32 __fmaf32 (_Float32 __x, _Float32 __y, _Float32 __z) noexcept (true);




extern _Float32 roundevenf32 (_Float32 __x) noexcept (true) __attribute__ ((__const__)); extern _Float32 __roundevenf32 (_Float32 __x) noexcept (true) __attribute__ ((__const__));



extern __intmax_t fromfpf32 (_Float32 __x, int __round, unsigned int __width) noexcept (true); extern __intmax_t __fromfpf32 (_Float32 __x, int __round, unsigned int __width) noexcept (true)
                            ;



extern __uintmax_t ufromfpf32 (_Float32 __x, int __round, unsigned int __width) noexcept (true); extern __uintmax_t __ufromfpf32 (_Float32 __x, int __round, unsigned int __width) noexcept (true)
                              ;




extern __intmax_t fromfpxf32 (_Float32 __x, int __round, unsigned int __width) noexcept (true); extern __intmax_t __fromfpxf32 (_Float32 __x, int __round, unsigned int __width) noexcept (true)
                             ;




extern __uintmax_t ufromfpxf32 (_Float32 __x, int __round, unsigned int __width) noexcept (true); extern __uintmax_t __ufromfpxf32 (_Float32 __x, int __round, unsigned int __width) noexcept (true)
                               ;


extern int canonicalizef32 (_Float32 *__cx, const _Float32 *__x) noexcept (true);






extern _Float32 fmaxmagf32 (_Float32 __x, _Float32 __y) noexcept (true) __attribute__ ((__const__)); extern _Float32 __fmaxmagf32 (_Float32 __x, _Float32 __y) noexcept (true) __attribute__ ((__const__));


extern _Float32 fminmagf32 (_Float32 __x, _Float32 __y) noexcept (true) __attribute__ ((__const__)); extern _Float32 __fminmagf32 (_Float32 __x, _Float32 __y) noexcept (true) __attribute__ ((__const__));




extern _Float32 fmaximumf32 (_Float32 __x, _Float32 __y) noexcept (true) __attribute__ ((__const__)); extern _Float32 __fmaximumf32 (_Float32 __x, _Float32 __y) noexcept (true) __attribute__ ((__const__));


extern _Float32 fminimumf32 (_Float32 __x, _Float32 __y) noexcept (true) __attribute__ ((__const__)); extern _Float32 __fminimumf32 (_Float32 __x, _Float32 __y) noexcept (true) __attribute__ ((__const__));


extern _Float32 fmaximum_numf32 (_Float32 __x, _Float32 __y) noexcept (true) __attribute__ ((__const__)); extern _Float32 __fmaximum_numf32 (_Float32 __x, _Float32 __y) noexcept (true) __attribute__ ((__const__));


extern _Float32 fminimum_numf32 (_Float32 __x, _Float32 __y) noexcept (true) __attribute__ ((__const__)); extern _Float32 __fminimum_numf32 (_Float32 __x, _Float32 __y) noexcept (true) __attribute__ ((__const__));


extern _Float32 fmaximum_magf32 (_Float32 __x, _Float32 __y) noexcept (true) __attribute__ ((__const__)); extern _Float32 __fmaximum_magf32 (_Float32 __x, _Float32 __y) noexcept (true) __attribute__ ((__const__));


extern _Float32 fminimum_magf32 (_Float32 __x, _Float32 __y) noexcept (true) __attribute__ ((__const__)); extern _Float32 __fminimum_magf32 (_Float32 __x, _Float32 __y) noexcept (true) __attribute__ ((__const__));


extern _Float32 fmaximum_mag_numf32 (_Float32 __x, _Float32 __y) noexcept (true) __attribute__ ((__const__)); extern _Float32 __fmaximum_mag_numf32 (_Float32 __x, _Float32 __y) noexcept (true) __attribute__ ((__const__));


extern _Float32 fminimum_mag_numf32 (_Float32 __x, _Float32 __y) noexcept (true) __attribute__ ((__const__)); extern _Float32 __fminimum_mag_numf32 (_Float32 __x, _Float32 __y) noexcept (true) __attribute__ ((__const__));




extern int totalorderf32 (const _Float32 *__x, const _Float32 *__y) noexcept (true)

     __attribute__ ((__pure__));


extern int totalordermagf32 (const _Float32 *__x, const _Float32 *__y) noexcept (true)

     __attribute__ ((__pure__));


extern _Float32 getpayloadf32 (const _Float32 *__x) noexcept (true); extern _Float32 __getpayloadf32 (const _Float32 *__x) noexcept (true);


extern int setpayloadf32 (_Float32 *__x, _Float32 __payload) noexcept (true);


extern int setpayloadsigf32 (_Float32 *__x, _Float32 __payload) noexcept (true);
# 451 "/usr/include/math.h" 2 3 4
# 467 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 1 3 4
# 53 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
 extern _Float64 acosf64 (_Float64 __x) noexcept (true); extern _Float64 __acosf64 (_Float64 __x) noexcept (true);

 extern _Float64 asinf64 (_Float64 __x) noexcept (true); extern _Float64 __asinf64 (_Float64 __x) noexcept (true);

 extern _Float64 atanf64 (_Float64 __x) noexcept (true); extern _Float64 __atanf64 (_Float64 __x) noexcept (true);

 extern _Float64 atan2f64 (_Float64 __y, _Float64 __x) noexcept (true); extern _Float64 __atan2f64 (_Float64 __y, _Float64 __x) noexcept (true);


 extern _Float64 cosf64 (_Float64 __x) noexcept (true); extern _Float64 __cosf64 (_Float64 __x) noexcept (true);

 extern _Float64 sinf64 (_Float64 __x) noexcept (true); extern _Float64 __sinf64 (_Float64 __x) noexcept (true);

 extern _Float64 tanf64 (_Float64 __x) noexcept (true); extern _Float64 __tanf64 (_Float64 __x) noexcept (true);




 extern _Float64 coshf64 (_Float64 __x) noexcept (true); extern _Float64 __coshf64 (_Float64 __x) noexcept (true);

 extern _Float64 sinhf64 (_Float64 __x) noexcept (true); extern _Float64 __sinhf64 (_Float64 __x) noexcept (true);

 extern _Float64 tanhf64 (_Float64 __x) noexcept (true); extern _Float64 __tanhf64 (_Float64 __x) noexcept (true);



 extern void sincosf64 (_Float64 __x, _Float64 *__sinx, _Float64 *__cosx) noexcept (true); extern void __sincosf64 (_Float64 __x, _Float64 *__sinx, _Float64 *__cosx) noexcept (true)
                                                        ;




 extern _Float64 acoshf64 (_Float64 __x) noexcept (true); extern _Float64 __acoshf64 (_Float64 __x) noexcept (true);

 extern _Float64 asinhf64 (_Float64 __x) noexcept (true); extern _Float64 __asinhf64 (_Float64 __x) noexcept (true);

 extern _Float64 atanhf64 (_Float64 __x) noexcept (true); extern _Float64 __atanhf64 (_Float64 __x) noexcept (true);





 extern _Float64 expf64 (_Float64 __x) noexcept (true); extern _Float64 __expf64 (_Float64 __x) noexcept (true);


extern _Float64 frexpf64 (_Float64 __x, int *__exponent) noexcept (true); extern _Float64 __frexpf64 (_Float64 __x, int *__exponent) noexcept (true);


extern _Float64 ldexpf64 (_Float64 __x, int __exponent) noexcept (true); extern _Float64 __ldexpf64 (_Float64 __x, int __exponent) noexcept (true);


 extern _Float64 logf64 (_Float64 __x) noexcept (true); extern _Float64 __logf64 (_Float64 __x) noexcept (true);


 extern _Float64 log10f64 (_Float64 __x) noexcept (true); extern _Float64 __log10f64 (_Float64 __x) noexcept (true);


extern _Float64 modff64 (_Float64 __x, _Float64 *__iptr) noexcept (true); extern _Float64 __modff64 (_Float64 __x, _Float64 *__iptr) noexcept (true) __attribute__ ((__nonnull__ (2)));



 extern _Float64 exp10f64 (_Float64 __x) noexcept (true); extern _Float64 __exp10f64 (_Float64 __x) noexcept (true);




 extern _Float64 expm1f64 (_Float64 __x) noexcept (true); extern _Float64 __expm1f64 (_Float64 __x) noexcept (true);


 extern _Float64 log1pf64 (_Float64 __x) noexcept (true); extern _Float64 __log1pf64 (_Float64 __x) noexcept (true);


extern _Float64 logbf64 (_Float64 __x) noexcept (true); extern _Float64 __logbf64 (_Float64 __x) noexcept (true);




 extern _Float64 exp2f64 (_Float64 __x) noexcept (true); extern _Float64 __exp2f64 (_Float64 __x) noexcept (true);


 extern _Float64 log2f64 (_Float64 __x) noexcept (true); extern _Float64 __log2f64 (_Float64 __x) noexcept (true);






 extern _Float64 powf64 (_Float64 __x, _Float64 __y) noexcept (true); extern _Float64 __powf64 (_Float64 __x, _Float64 __y) noexcept (true);


extern _Float64 sqrtf64 (_Float64 __x) noexcept (true); extern _Float64 __sqrtf64 (_Float64 __x) noexcept (true);



 extern _Float64 hypotf64 (_Float64 __x, _Float64 __y) noexcept (true); extern _Float64 __hypotf64 (_Float64 __x, _Float64 __y) noexcept (true);




 extern _Float64 cbrtf64 (_Float64 __x) noexcept (true); extern _Float64 __cbrtf64 (_Float64 __x) noexcept (true);






extern _Float64 ceilf64 (_Float64 __x) noexcept (true) __attribute__ ((__const__)); extern _Float64 __ceilf64 (_Float64 __x) noexcept (true) __attribute__ ((__const__));


extern _Float64 fabsf64 (_Float64 __x) noexcept (true) __attribute__ ((__const__)); extern _Float64 __fabsf64 (_Float64 __x) noexcept (true) __attribute__ ((__const__));


extern _Float64 floorf64 (_Float64 __x) noexcept (true) __attribute__ ((__const__)); extern _Float64 __floorf64 (_Float64 __x) noexcept (true) __attribute__ ((__const__));


extern _Float64 fmodf64 (_Float64 __x, _Float64 __y) noexcept (true); extern _Float64 __fmodf64 (_Float64 __x, _Float64 __y) noexcept (true);
# 198 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern _Float64 copysignf64 (_Float64 __x, _Float64 __y) noexcept (true) __attribute__ ((__const__)); extern _Float64 __copysignf64 (_Float64 __x, _Float64 __y) noexcept (true) __attribute__ ((__const__));




extern _Float64 nanf64 (const char *__tagb) noexcept (true); extern _Float64 __nanf64 (const char *__tagb) noexcept (true);
# 220 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern _Float64 j0f64 (_Float64) noexcept (true); extern _Float64 __j0f64 (_Float64) noexcept (true);
extern _Float64 j1f64 (_Float64) noexcept (true); extern _Float64 __j1f64 (_Float64) noexcept (true);
extern _Float64 jnf64 (int, _Float64) noexcept (true); extern _Float64 __jnf64 (int, _Float64) noexcept (true);
extern _Float64 y0f64 (_Float64) noexcept (true); extern _Float64 __y0f64 (_Float64) noexcept (true);
extern _Float64 y1f64 (_Float64) noexcept (true); extern _Float64 __y1f64 (_Float64) noexcept (true);
extern _Float64 ynf64 (int, _Float64) noexcept (true); extern _Float64 __ynf64 (int, _Float64) noexcept (true);





 extern _Float64 erff64 (_Float64) noexcept (true); extern _Float64 __erff64 (_Float64) noexcept (true);
 extern _Float64 erfcf64 (_Float64) noexcept (true); extern _Float64 __erfcf64 (_Float64) noexcept (true);
extern _Float64 lgammaf64 (_Float64) noexcept (true); extern _Float64 __lgammaf64 (_Float64) noexcept (true);




extern _Float64 tgammaf64 (_Float64) noexcept (true); extern _Float64 __tgammaf64 (_Float64) noexcept (true);
# 252 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern _Float64 lgammaf64_r (_Float64, int *__signgamp) noexcept (true); extern _Float64 __lgammaf64_r (_Float64, int *__signgamp) noexcept (true);






extern _Float64 rintf64 (_Float64 __x) noexcept (true); extern _Float64 __rintf64 (_Float64 __x) noexcept (true);


extern _Float64 nextafterf64 (_Float64 __x, _Float64 __y) noexcept (true); extern _Float64 __nextafterf64 (_Float64 __x, _Float64 __y) noexcept (true);






extern _Float64 nextdownf64 (_Float64 __x) noexcept (true); extern _Float64 __nextdownf64 (_Float64 __x) noexcept (true);

extern _Float64 nextupf64 (_Float64 __x) noexcept (true); extern _Float64 __nextupf64 (_Float64 __x) noexcept (true);



extern _Float64 remainderf64 (_Float64 __x, _Float64 __y) noexcept (true); extern _Float64 __remainderf64 (_Float64 __x, _Float64 __y) noexcept (true);



extern _Float64 scalbnf64 (_Float64 __x, int __n) noexcept (true); extern _Float64 __scalbnf64 (_Float64 __x, int __n) noexcept (true);



extern int ilogbf64 (_Float64 __x) noexcept (true); extern int __ilogbf64 (_Float64 __x) noexcept (true);




extern long int llogbf64 (_Float64 __x) noexcept (true); extern long int __llogbf64 (_Float64 __x) noexcept (true);




extern _Float64 scalblnf64 (_Float64 __x, long int __n) noexcept (true); extern _Float64 __scalblnf64 (_Float64 __x, long int __n) noexcept (true);



extern _Float64 nearbyintf64 (_Float64 __x) noexcept (true); extern _Float64 __nearbyintf64 (_Float64 __x) noexcept (true);



extern _Float64 roundf64 (_Float64 __x) noexcept (true) __attribute__ ((__const__)); extern _Float64 __roundf64 (_Float64 __x) noexcept (true) __attribute__ ((__const__));



extern _Float64 truncf64 (_Float64 __x) noexcept (true) __attribute__ ((__const__)); extern _Float64 __truncf64 (_Float64 __x) noexcept (true) __attribute__ ((__const__));




extern _Float64 remquof64 (_Float64 __x, _Float64 __y, int *__quo) noexcept (true); extern _Float64 __remquof64 (_Float64 __x, _Float64 __y, int *__quo) noexcept (true);






extern long int lrintf64 (_Float64 __x) noexcept (true); extern long int __lrintf64 (_Float64 __x) noexcept (true);
__extension__
extern long long int llrintf64 (_Float64 __x) noexcept (true); extern long long int __llrintf64 (_Float64 __x) noexcept (true);



extern long int lroundf64 (_Float64 __x) noexcept (true); extern long int __lroundf64 (_Float64 __x) noexcept (true);
__extension__
extern long long int llroundf64 (_Float64 __x) noexcept (true); extern long long int __llroundf64 (_Float64 __x) noexcept (true);



extern _Float64 fdimf64 (_Float64 __x, _Float64 __y) noexcept (true); extern _Float64 __fdimf64 (_Float64 __x, _Float64 __y) noexcept (true);



extern _Float64 fmaxf64 (_Float64 __x, _Float64 __y) noexcept (true) __attribute__ ((__const__)); extern _Float64 __fmaxf64 (_Float64 __x, _Float64 __y) noexcept (true) __attribute__ ((__const__));


extern _Float64 fminf64 (_Float64 __x, _Float64 __y) noexcept (true) __attribute__ ((__const__)); extern _Float64 __fminf64 (_Float64 __x, _Float64 __y) noexcept (true) __attribute__ ((__const__));



extern _Float64 fmaf64 (_Float64 __x, _Float64 __y, _Float64 __z) noexcept (true); extern _Float64 __fmaf64 (_Float64 __x, _Float64 __y, _Float64 __z) noexcept (true);




extern _Float64 roundevenf64 (_Float64 __x) noexcept (true) __attribute__ ((__const__)); extern _Float64 __roundevenf64 (_Float64 __x) noexcept (true) __attribute__ ((__const__));



extern __intmax_t fromfpf64 (_Float64 __x, int __round, unsigned int __width) noexcept (true); extern __intmax_t __fromfpf64 (_Float64 __x, int __round, unsigned int __width) noexcept (true)
                            ;



extern __uintmax_t ufromfpf64 (_Float64 __x, int __round, unsigned int __width) noexcept (true); extern __uintmax_t __ufromfpf64 (_Float64 __x, int __round, unsigned int __width) noexcept (true)
                              ;




extern __intmax_t fromfpxf64 (_Float64 __x, int __round, unsigned int __width) noexcept (true); extern __intmax_t __fromfpxf64 (_Float64 __x, int __round, unsigned int __width) noexcept (true)
                             ;




extern __uintmax_t ufromfpxf64 (_Float64 __x, int __round, unsigned int __width) noexcept (true); extern __uintmax_t __ufromfpxf64 (_Float64 __x, int __round, unsigned int __width) noexcept (true)
                               ;


extern int canonicalizef64 (_Float64 *__cx, const _Float64 *__x) noexcept (true);






extern _Float64 fmaxmagf64 (_Float64 __x, _Float64 __y) noexcept (true) __attribute__ ((__const__)); extern _Float64 __fmaxmagf64 (_Float64 __x, _Float64 __y) noexcept (true) __attribute__ ((__const__));


extern _Float64 fminmagf64 (_Float64 __x, _Float64 __y) noexcept (true) __attribute__ ((__const__)); extern _Float64 __fminmagf64 (_Float64 __x, _Float64 __y) noexcept (true) __attribute__ ((__const__));




extern _Float64 fmaximumf64 (_Float64 __x, _Float64 __y) noexcept (true) __attribute__ ((__const__)); extern _Float64 __fmaximumf64 (_Float64 __x, _Float64 __y) noexcept (true) __attribute__ ((__const__));


extern _Float64 fminimumf64 (_Float64 __x, _Float64 __y) noexcept (true) __attribute__ ((__const__)); extern _Float64 __fminimumf64 (_Float64 __x, _Float64 __y) noexcept (true) __attribute__ ((__const__));


extern _Float64 fmaximum_numf64 (_Float64 __x, _Float64 __y) noexcept (true) __attribute__ ((__const__)); extern _Float64 __fmaximum_numf64 (_Float64 __x, _Float64 __y) noexcept (true) __attribute__ ((__const__));


extern _Float64 fminimum_numf64 (_Float64 __x, _Float64 __y) noexcept (true) __attribute__ ((__const__)); extern _Float64 __fminimum_numf64 (_Float64 __x, _Float64 __y) noexcept (true) __attribute__ ((__const__));


extern _Float64 fmaximum_magf64 (_Float64 __x, _Float64 __y) noexcept (true) __attribute__ ((__const__)); extern _Float64 __fmaximum_magf64 (_Float64 __x, _Float64 __y) noexcept (true) __attribute__ ((__const__));


extern _Float64 fminimum_magf64 (_Float64 __x, _Float64 __y) noexcept (true) __attribute__ ((__const__)); extern _Float64 __fminimum_magf64 (_Float64 __x, _Float64 __y) noexcept (true) __attribute__ ((__const__));


extern _Float64 fmaximum_mag_numf64 (_Float64 __x, _Float64 __y) noexcept (true) __attribute__ ((__const__)); extern _Float64 __fmaximum_mag_numf64 (_Float64 __x, _Float64 __y) noexcept (true) __attribute__ ((__const__));


extern _Float64 fminimum_mag_numf64 (_Float64 __x, _Float64 __y) noexcept (true) __attribute__ ((__const__)); extern _Float64 __fminimum_mag_numf64 (_Float64 __x, _Float64 __y) noexcept (true) __attribute__ ((__const__));




extern int totalorderf64 (const _Float64 *__x, const _Float64 *__y) noexcept (true)

     __attribute__ ((__pure__));


extern int totalordermagf64 (const _Float64 *__x, const _Float64 *__y) noexcept (true)

     __attribute__ ((__pure__));


extern _Float64 getpayloadf64 (const _Float64 *__x) noexcept (true); extern _Float64 __getpayloadf64 (const _Float64 *__x) noexcept (true);


extern int setpayloadf64 (_Float64 *__x, _Float64 __payload) noexcept (true);


extern int setpayloadsigf64 (_Float64 *__x, _Float64 __payload) noexcept (true);
# 468 "/usr/include/math.h" 2 3 4
# 481 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/mathcalls-helper-functions.h" 1 3 4
# 20 "/usr/include/x86_64-linux-gnu/bits/mathcalls-helper-functions.h" 3 4
extern int __fpclassifyf128 (_Float128 __value) noexcept (true)
     __attribute__ ((__const__));


extern int __signbitf128 (_Float128 __value) noexcept (true)
     __attribute__ ((__const__));



extern int __isinff128 (_Float128 __value) noexcept (true)
  __attribute__ ((__const__));


extern int __finitef128 (_Float128 __value) noexcept (true)
  __attribute__ ((__const__));


extern int __isnanf128 (_Float128 __value) noexcept (true)
  __attribute__ ((__const__));


extern int __iseqsigf128 (_Float128 __x, _Float128 __y) noexcept (true);


extern int __issignalingf128 (_Float128 __value) noexcept (true)
     __attribute__ ((__const__));
# 482 "/usr/include/math.h" 2 3 4


# 1 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 1 3 4
# 53 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
 extern _Float128 acosf128 (_Float128 __x) noexcept (true); extern _Float128 __acosf128 (_Float128 __x) noexcept (true);

 extern _Float128 asinf128 (_Float128 __x) noexcept (true); extern _Float128 __asinf128 (_Float128 __x) noexcept (true);

 extern _Float128 atanf128 (_Float128 __x) noexcept (true); extern _Float128 __atanf128 (_Float128 __x) noexcept (true);

 extern _Float128 atan2f128 (_Float128 __y, _Float128 __x) noexcept (true); extern _Float128 __atan2f128 (_Float128 __y, _Float128 __x) noexcept (true);


 extern _Float128 cosf128 (_Float128 __x) noexcept (true); extern _Float128 __cosf128 (_Float128 __x) noexcept (true);

 extern _Float128 sinf128 (_Float128 __x) noexcept (true); extern _Float128 __sinf128 (_Float128 __x) noexcept (true);

 extern _Float128 tanf128 (_Float128 __x) noexcept (true); extern _Float128 __tanf128 (_Float128 __x) noexcept (true);




 extern _Float128 coshf128 (_Float128 __x) noexcept (true); extern _Float128 __coshf128 (_Float128 __x) noexcept (true);

 extern _Float128 sinhf128 (_Float128 __x) noexcept (true); extern _Float128 __sinhf128 (_Float128 __x) noexcept (true);

 extern _Float128 tanhf128 (_Float128 __x) noexcept (true); extern _Float128 __tanhf128 (_Float128 __x) noexcept (true);



 extern void sincosf128 (_Float128 __x, _Float128 *__sinx, _Float128 *__cosx) noexcept (true); extern void __sincosf128 (_Float128 __x, _Float128 *__sinx, _Float128 *__cosx) noexcept (true)
                                                        ;




 extern _Float128 acoshf128 (_Float128 __x) noexcept (true); extern _Float128 __acoshf128 (_Float128 __x) noexcept (true);

 extern _Float128 asinhf128 (_Float128 __x) noexcept (true); extern _Float128 __asinhf128 (_Float128 __x) noexcept (true);

 extern _Float128 atanhf128 (_Float128 __x) noexcept (true); extern _Float128 __atanhf128 (_Float128 __x) noexcept (true);





 extern _Float128 expf128 (_Float128 __x) noexcept (true); extern _Float128 __expf128 (_Float128 __x) noexcept (true);


extern _Float128 frexpf128 (_Float128 __x, int *__exponent) noexcept (true); extern _Float128 __frexpf128 (_Float128 __x, int *__exponent) noexcept (true);


extern _Float128 ldexpf128 (_Float128 __x, int __exponent) noexcept (true); extern _Float128 __ldexpf128 (_Float128 __x, int __exponent) noexcept (true);


 extern _Float128 logf128 (_Float128 __x) noexcept (true); extern _Float128 __logf128 (_Float128 __x) noexcept (true);


 extern _Float128 log10f128 (_Float128 __x) noexcept (true); extern _Float128 __log10f128 (_Float128 __x) noexcept (true);


extern _Float128 modff128 (_Float128 __x, _Float128 *__iptr) noexcept (true); extern _Float128 __modff128 (_Float128 __x, _Float128 *__iptr) noexcept (true) __attribute__ ((__nonnull__ (2)));



 extern _Float128 exp10f128 (_Float128 __x) noexcept (true); extern _Float128 __exp10f128 (_Float128 __x) noexcept (true);




 extern _Float128 expm1f128 (_Float128 __x) noexcept (true); extern _Float128 __expm1f128 (_Float128 __x) noexcept (true);


 extern _Float128 log1pf128 (_Float128 __x) noexcept (true); extern _Float128 __log1pf128 (_Float128 __x) noexcept (true);


extern _Float128 logbf128 (_Float128 __x) noexcept (true); extern _Float128 __logbf128 (_Float128 __x) noexcept (true);




 extern _Float128 exp2f128 (_Float128 __x) noexcept (true); extern _Float128 __exp2f128 (_Float128 __x) noexcept (true);


 extern _Float128 log2f128 (_Float128 __x) noexcept (true); extern _Float128 __log2f128 (_Float128 __x) noexcept (true);






 extern _Float128 powf128 (_Float128 __x, _Float128 __y) noexcept (true); extern _Float128 __powf128 (_Float128 __x, _Float128 __y) noexcept (true);


extern _Float128 sqrtf128 (_Float128 __x) noexcept (true); extern _Float128 __sqrtf128 (_Float128 __x) noexcept (true);



 extern _Float128 hypotf128 (_Float128 __x, _Float128 __y) noexcept (true); extern _Float128 __hypotf128 (_Float128 __x, _Float128 __y) noexcept (true);




 extern _Float128 cbrtf128 (_Float128 __x) noexcept (true); extern _Float128 __cbrtf128 (_Float128 __x) noexcept (true);






extern _Float128 ceilf128 (_Float128 __x) noexcept (true) __attribute__ ((__const__)); extern _Float128 __ceilf128 (_Float128 __x) noexcept (true) __attribute__ ((__const__));


extern _Float128 fabsf128 (_Float128 __x) noexcept (true) __attribute__ ((__const__)); extern _Float128 __fabsf128 (_Float128 __x) noexcept (true) __attribute__ ((__const__));


extern _Float128 floorf128 (_Float128 __x) noexcept (true) __attribute__ ((__const__)); extern _Float128 __floorf128 (_Float128 __x) noexcept (true) __attribute__ ((__const__));


extern _Float128 fmodf128 (_Float128 __x, _Float128 __y) noexcept (true); extern _Float128 __fmodf128 (_Float128 __x, _Float128 __y) noexcept (true);
# 198 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern _Float128 copysignf128 (_Float128 __x, _Float128 __y) noexcept (true) __attribute__ ((__const__)); extern _Float128 __copysignf128 (_Float128 __x, _Float128 __y) noexcept (true) __attribute__ ((__const__));




extern _Float128 nanf128 (const char *__tagb) noexcept (true); extern _Float128 __nanf128 (const char *__tagb) noexcept (true);
# 220 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern _Float128 j0f128 (_Float128) noexcept (true); extern _Float128 __j0f128 (_Float128) noexcept (true);
extern _Float128 j1f128 (_Float128) noexcept (true); extern _Float128 __j1f128 (_Float128) noexcept (true);
extern _Float128 jnf128 (int, _Float128) noexcept (true); extern _Float128 __jnf128 (int, _Float128) noexcept (true);
extern _Float128 y0f128 (_Float128) noexcept (true); extern _Float128 __y0f128 (_Float128) noexcept (true);
extern _Float128 y1f128 (_Float128) noexcept (true); extern _Float128 __y1f128 (_Float128) noexcept (true);
extern _Float128 ynf128 (int, _Float128) noexcept (true); extern _Float128 __ynf128 (int, _Float128) noexcept (true);





 extern _Float128 erff128 (_Float128) noexcept (true); extern _Float128 __erff128 (_Float128) noexcept (true);
 extern _Float128 erfcf128 (_Float128) noexcept (true); extern _Float128 __erfcf128 (_Float128) noexcept (true);
extern _Float128 lgammaf128 (_Float128) noexcept (true); extern _Float128 __lgammaf128 (_Float128) noexcept (true);




extern _Float128 tgammaf128 (_Float128) noexcept (true); extern _Float128 __tgammaf128 (_Float128) noexcept (true);
# 252 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern _Float128 lgammaf128_r (_Float128, int *__signgamp) noexcept (true); extern _Float128 __lgammaf128_r (_Float128, int *__signgamp) noexcept (true);






extern _Float128 rintf128 (_Float128 __x) noexcept (true); extern _Float128 __rintf128 (_Float128 __x) noexcept (true);


extern _Float128 nextafterf128 (_Float128 __x, _Float128 __y) noexcept (true); extern _Float128 __nextafterf128 (_Float128 __x, _Float128 __y) noexcept (true);






extern _Float128 nextdownf128 (_Float128 __x) noexcept (true); extern _Float128 __nextdownf128 (_Float128 __x) noexcept (true);

extern _Float128 nextupf128 (_Float128 __x) noexcept (true); extern _Float128 __nextupf128 (_Float128 __x) noexcept (true);



extern _Float128 remainderf128 (_Float128 __x, _Float128 __y) noexcept (true); extern _Float128 __remainderf128 (_Float128 __x, _Float128 __y) noexcept (true);



extern _Float128 scalbnf128 (_Float128 __x, int __n) noexcept (true); extern _Float128 __scalbnf128 (_Float128 __x, int __n) noexcept (true);



extern int ilogbf128 (_Float128 __x) noexcept (true); extern int __ilogbf128 (_Float128 __x) noexcept (true);




extern long int llogbf128 (_Float128 __x) noexcept (true); extern long int __llogbf128 (_Float128 __x) noexcept (true);




extern _Float128 scalblnf128 (_Float128 __x, long int __n) noexcept (true); extern _Float128 __scalblnf128 (_Float128 __x, long int __n) noexcept (true);



extern _Float128 nearbyintf128 (_Float128 __x) noexcept (true); extern _Float128 __nearbyintf128 (_Float128 __x) noexcept (true);



extern _Float128 roundf128 (_Float128 __x) noexcept (true) __attribute__ ((__const__)); extern _Float128 __roundf128 (_Float128 __x) noexcept (true) __attribute__ ((__const__));



extern _Float128 truncf128 (_Float128 __x) noexcept (true) __attribute__ ((__const__)); extern _Float128 __truncf128 (_Float128 __x) noexcept (true) __attribute__ ((__const__));




extern _Float128 remquof128 (_Float128 __x, _Float128 __y, int *__quo) noexcept (true); extern _Float128 __remquof128 (_Float128 __x, _Float128 __y, int *__quo) noexcept (true);






extern long int lrintf128 (_Float128 __x) noexcept (true); extern long int __lrintf128 (_Float128 __x) noexcept (true);
__extension__
extern long long int llrintf128 (_Float128 __x) noexcept (true); extern long long int __llrintf128 (_Float128 __x) noexcept (true);



extern long int lroundf128 (_Float128 __x) noexcept (true); extern long int __lroundf128 (_Float128 __x) noexcept (true);
__extension__
extern long long int llroundf128 (_Float128 __x) noexcept (true); extern long long int __llroundf128 (_Float128 __x) noexcept (true);



extern _Float128 fdimf128 (_Float128 __x, _Float128 __y) noexcept (true); extern _Float128 __fdimf128 (_Float128 __x, _Float128 __y) noexcept (true);



extern _Float128 fmaxf128 (_Float128 __x, _Float128 __y) noexcept (true) __attribute__ ((__const__)); extern _Float128 __fmaxf128 (_Float128 __x, _Float128 __y) noexcept (true) __attribute__ ((__const__));


extern _Float128 fminf128 (_Float128 __x, _Float128 __y) noexcept (true) __attribute__ ((__const__)); extern _Float128 __fminf128 (_Float128 __x, _Float128 __y) noexcept (true) __attribute__ ((__const__));



extern _Float128 fmaf128 (_Float128 __x, _Float128 __y, _Float128 __z) noexcept (true); extern _Float128 __fmaf128 (_Float128 __x, _Float128 __y, _Float128 __z) noexcept (true);




extern _Float128 roundevenf128 (_Float128 __x) noexcept (true) __attribute__ ((__const__)); extern _Float128 __roundevenf128 (_Float128 __x) noexcept (true) __attribute__ ((__const__));



extern __intmax_t fromfpf128 (_Float128 __x, int __round, unsigned int __width) noexcept (true); extern __intmax_t __fromfpf128 (_Float128 __x, int __round, unsigned int __width) noexcept (true)
                            ;



extern __uintmax_t ufromfpf128 (_Float128 __x, int __round, unsigned int __width) noexcept (true); extern __uintmax_t __ufromfpf128 (_Float128 __x, int __round, unsigned int __width) noexcept (true)
                              ;




extern __intmax_t fromfpxf128 (_Float128 __x, int __round, unsigned int __width) noexcept (true); extern __intmax_t __fromfpxf128 (_Float128 __x, int __round, unsigned int __width) noexcept (true)
                             ;




extern __uintmax_t ufromfpxf128 (_Float128 __x, int __round, unsigned int __width) noexcept (true); extern __uintmax_t __ufromfpxf128 (_Float128 __x, int __round, unsigned int __width) noexcept (true)
                               ;


extern int canonicalizef128 (_Float128 *__cx, const _Float128 *__x) noexcept (true);






extern _Float128 fmaxmagf128 (_Float128 __x, _Float128 __y) noexcept (true) __attribute__ ((__const__)); extern _Float128 __fmaxmagf128 (_Float128 __x, _Float128 __y) noexcept (true) __attribute__ ((__const__));


extern _Float128 fminmagf128 (_Float128 __x, _Float128 __y) noexcept (true) __attribute__ ((__const__)); extern _Float128 __fminmagf128 (_Float128 __x, _Float128 __y) noexcept (true) __attribute__ ((__const__));




extern _Float128 fmaximumf128 (_Float128 __x, _Float128 __y) noexcept (true) __attribute__ ((__const__)); extern _Float128 __fmaximumf128 (_Float128 __x, _Float128 __y) noexcept (true) __attribute__ ((__const__));


extern _Float128 fminimumf128 (_Float128 __x, _Float128 __y) noexcept (true) __attribute__ ((__const__)); extern _Float128 __fminimumf128 (_Float128 __x, _Float128 __y) noexcept (true) __attribute__ ((__const__));


extern _Float128 fmaximum_numf128 (_Float128 __x, _Float128 __y) noexcept (true) __attribute__ ((__const__)); extern _Float128 __fmaximum_numf128 (_Float128 __x, _Float128 __y) noexcept (true) __attribute__ ((__const__));


extern _Float128 fminimum_numf128 (_Float128 __x, _Float128 __y) noexcept (true) __attribute__ ((__const__)); extern _Float128 __fminimum_numf128 (_Float128 __x, _Float128 __y) noexcept (true) __attribute__ ((__const__));


extern _Float128 fmaximum_magf128 (_Float128 __x, _Float128 __y) noexcept (true) __attribute__ ((__const__)); extern _Float128 __fmaximum_magf128 (_Float128 __x, _Float128 __y) noexcept (true) __attribute__ ((__const__));


extern _Float128 fminimum_magf128 (_Float128 __x, _Float128 __y) noexcept (true) __attribute__ ((__const__)); extern _Float128 __fminimum_magf128 (_Float128 __x, _Float128 __y) noexcept (true) __attribute__ ((__const__));


extern _Float128 fmaximum_mag_numf128 (_Float128 __x, _Float128 __y) noexcept (true) __attribute__ ((__const__)); extern _Float128 __fmaximum_mag_numf128 (_Float128 __x, _Float128 __y) noexcept (true) __attribute__ ((__const__));


extern _Float128 fminimum_mag_numf128 (_Float128 __x, _Float128 __y) noexcept (true) __attribute__ ((__const__)); extern _Float128 __fminimum_mag_numf128 (_Float128 __x, _Float128 __y) noexcept (true) __attribute__ ((__const__));




extern int totalorderf128 (const _Float128 *__x, const _Float128 *__y) noexcept (true)

     __attribute__ ((__pure__));


extern int totalordermagf128 (const _Float128 *__x, const _Float128 *__y) noexcept (true)

     __attribute__ ((__pure__));


extern _Float128 getpayloadf128 (const _Float128 *__x) noexcept (true); extern _Float128 __getpayloadf128 (const _Float128 *__x) noexcept (true);


extern int setpayloadf128 (_Float128 *__x, _Float128 __payload) noexcept (true);


extern int setpayloadsigf128 (_Float128 *__x, _Float128 __payload) noexcept (true);
# 485 "/usr/include/math.h" 2 3 4
# 501 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 1 3 4
# 53 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
 extern _Float32x acosf32x (_Float32x __x) noexcept (true); extern _Float32x __acosf32x (_Float32x __x) noexcept (true);

 extern _Float32x asinf32x (_Float32x __x) noexcept (true); extern _Float32x __asinf32x (_Float32x __x) noexcept (true);

 extern _Float32x atanf32x (_Float32x __x) noexcept (true); extern _Float32x __atanf32x (_Float32x __x) noexcept (true);

 extern _Float32x atan2f32x (_Float32x __y, _Float32x __x) noexcept (true); extern _Float32x __atan2f32x (_Float32x __y, _Float32x __x) noexcept (true);


 extern _Float32x cosf32x (_Float32x __x) noexcept (true); extern _Float32x __cosf32x (_Float32x __x) noexcept (true);

 extern _Float32x sinf32x (_Float32x __x) noexcept (true); extern _Float32x __sinf32x (_Float32x __x) noexcept (true);

 extern _Float32x tanf32x (_Float32x __x) noexcept (true); extern _Float32x __tanf32x (_Float32x __x) noexcept (true);




 extern _Float32x coshf32x (_Float32x __x) noexcept (true); extern _Float32x __coshf32x (_Float32x __x) noexcept (true);

 extern _Float32x sinhf32x (_Float32x __x) noexcept (true); extern _Float32x __sinhf32x (_Float32x __x) noexcept (true);

 extern _Float32x tanhf32x (_Float32x __x) noexcept (true); extern _Float32x __tanhf32x (_Float32x __x) noexcept (true);



 extern void sincosf32x (_Float32x __x, _Float32x *__sinx, _Float32x *__cosx) noexcept (true); extern void __sincosf32x (_Float32x __x, _Float32x *__sinx, _Float32x *__cosx) noexcept (true)
                                                        ;




 extern _Float32x acoshf32x (_Float32x __x) noexcept (true); extern _Float32x __acoshf32x (_Float32x __x) noexcept (true);

 extern _Float32x asinhf32x (_Float32x __x) noexcept (true); extern _Float32x __asinhf32x (_Float32x __x) noexcept (true);

 extern _Float32x atanhf32x (_Float32x __x) noexcept (true); extern _Float32x __atanhf32x (_Float32x __x) noexcept (true);





 extern _Float32x expf32x (_Float32x __x) noexcept (true); extern _Float32x __expf32x (_Float32x __x) noexcept (true);


extern _Float32x frexpf32x (_Float32x __x, int *__exponent) noexcept (true); extern _Float32x __frexpf32x (_Float32x __x, int *__exponent) noexcept (true);


extern _Float32x ldexpf32x (_Float32x __x, int __exponent) noexcept (true); extern _Float32x __ldexpf32x (_Float32x __x, int __exponent) noexcept (true);


 extern _Float32x logf32x (_Float32x __x) noexcept (true); extern _Float32x __logf32x (_Float32x __x) noexcept (true);


 extern _Float32x log10f32x (_Float32x __x) noexcept (true); extern _Float32x __log10f32x (_Float32x __x) noexcept (true);


extern _Float32x modff32x (_Float32x __x, _Float32x *__iptr) noexcept (true); extern _Float32x __modff32x (_Float32x __x, _Float32x *__iptr) noexcept (true) __attribute__ ((__nonnull__ (2)));



 extern _Float32x exp10f32x (_Float32x __x) noexcept (true); extern _Float32x __exp10f32x (_Float32x __x) noexcept (true);




 extern _Float32x expm1f32x (_Float32x __x) noexcept (true); extern _Float32x __expm1f32x (_Float32x __x) noexcept (true);


 extern _Float32x log1pf32x (_Float32x __x) noexcept (true); extern _Float32x __log1pf32x (_Float32x __x) noexcept (true);


extern _Float32x logbf32x (_Float32x __x) noexcept (true); extern _Float32x __logbf32x (_Float32x __x) noexcept (true);




 extern _Float32x exp2f32x (_Float32x __x) noexcept (true); extern _Float32x __exp2f32x (_Float32x __x) noexcept (true);


 extern _Float32x log2f32x (_Float32x __x) noexcept (true); extern _Float32x __log2f32x (_Float32x __x) noexcept (true);






 extern _Float32x powf32x (_Float32x __x, _Float32x __y) noexcept (true); extern _Float32x __powf32x (_Float32x __x, _Float32x __y) noexcept (true);


extern _Float32x sqrtf32x (_Float32x __x) noexcept (true); extern _Float32x __sqrtf32x (_Float32x __x) noexcept (true);



 extern _Float32x hypotf32x (_Float32x __x, _Float32x __y) noexcept (true); extern _Float32x __hypotf32x (_Float32x __x, _Float32x __y) noexcept (true);




 extern _Float32x cbrtf32x (_Float32x __x) noexcept (true); extern _Float32x __cbrtf32x (_Float32x __x) noexcept (true);






extern _Float32x ceilf32x (_Float32x __x) noexcept (true) __attribute__ ((__const__)); extern _Float32x __ceilf32x (_Float32x __x) noexcept (true) __attribute__ ((__const__));


extern _Float32x fabsf32x (_Float32x __x) noexcept (true) __attribute__ ((__const__)); extern _Float32x __fabsf32x (_Float32x __x) noexcept (true) __attribute__ ((__const__));


extern _Float32x floorf32x (_Float32x __x) noexcept (true) __attribute__ ((__const__)); extern _Float32x __floorf32x (_Float32x __x) noexcept (true) __attribute__ ((__const__));


extern _Float32x fmodf32x (_Float32x __x, _Float32x __y) noexcept (true); extern _Float32x __fmodf32x (_Float32x __x, _Float32x __y) noexcept (true);
# 198 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern _Float32x copysignf32x (_Float32x __x, _Float32x __y) noexcept (true) __attribute__ ((__const__)); extern _Float32x __copysignf32x (_Float32x __x, _Float32x __y) noexcept (true) __attribute__ ((__const__));




extern _Float32x nanf32x (const char *__tagb) noexcept (true); extern _Float32x __nanf32x (const char *__tagb) noexcept (true);
# 220 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern _Float32x j0f32x (_Float32x) noexcept (true); extern _Float32x __j0f32x (_Float32x) noexcept (true);
extern _Float32x j1f32x (_Float32x) noexcept (true); extern _Float32x __j1f32x (_Float32x) noexcept (true);
extern _Float32x jnf32x (int, _Float32x) noexcept (true); extern _Float32x __jnf32x (int, _Float32x) noexcept (true);
extern _Float32x y0f32x (_Float32x) noexcept (true); extern _Float32x __y0f32x (_Float32x) noexcept (true);
extern _Float32x y1f32x (_Float32x) noexcept (true); extern _Float32x __y1f32x (_Float32x) noexcept (true);
extern _Float32x ynf32x (int, _Float32x) noexcept (true); extern _Float32x __ynf32x (int, _Float32x) noexcept (true);





 extern _Float32x erff32x (_Float32x) noexcept (true); extern _Float32x __erff32x (_Float32x) noexcept (true);
 extern _Float32x erfcf32x (_Float32x) noexcept (true); extern _Float32x __erfcf32x (_Float32x) noexcept (true);
extern _Float32x lgammaf32x (_Float32x) noexcept (true); extern _Float32x __lgammaf32x (_Float32x) noexcept (true);




extern _Float32x tgammaf32x (_Float32x) noexcept (true); extern _Float32x __tgammaf32x (_Float32x) noexcept (true);
# 252 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern _Float32x lgammaf32x_r (_Float32x, int *__signgamp) noexcept (true); extern _Float32x __lgammaf32x_r (_Float32x, int *__signgamp) noexcept (true);






extern _Float32x rintf32x (_Float32x __x) noexcept (true); extern _Float32x __rintf32x (_Float32x __x) noexcept (true);


extern _Float32x nextafterf32x (_Float32x __x, _Float32x __y) noexcept (true); extern _Float32x __nextafterf32x (_Float32x __x, _Float32x __y) noexcept (true);






extern _Float32x nextdownf32x (_Float32x __x) noexcept (true); extern _Float32x __nextdownf32x (_Float32x __x) noexcept (true);

extern _Float32x nextupf32x (_Float32x __x) noexcept (true); extern _Float32x __nextupf32x (_Float32x __x) noexcept (true);



extern _Float32x remainderf32x (_Float32x __x, _Float32x __y) noexcept (true); extern _Float32x __remainderf32x (_Float32x __x, _Float32x __y) noexcept (true);



extern _Float32x scalbnf32x (_Float32x __x, int __n) noexcept (true); extern _Float32x __scalbnf32x (_Float32x __x, int __n) noexcept (true);



extern int ilogbf32x (_Float32x __x) noexcept (true); extern int __ilogbf32x (_Float32x __x) noexcept (true);




extern long int llogbf32x (_Float32x __x) noexcept (true); extern long int __llogbf32x (_Float32x __x) noexcept (true);




extern _Float32x scalblnf32x (_Float32x __x, long int __n) noexcept (true); extern _Float32x __scalblnf32x (_Float32x __x, long int __n) noexcept (true);



extern _Float32x nearbyintf32x (_Float32x __x) noexcept (true); extern _Float32x __nearbyintf32x (_Float32x __x) noexcept (true);



extern _Float32x roundf32x (_Float32x __x) noexcept (true) __attribute__ ((__const__)); extern _Float32x __roundf32x (_Float32x __x) noexcept (true) __attribute__ ((__const__));



extern _Float32x truncf32x (_Float32x __x) noexcept (true) __attribute__ ((__const__)); extern _Float32x __truncf32x (_Float32x __x) noexcept (true) __attribute__ ((__const__));




extern _Float32x remquof32x (_Float32x __x, _Float32x __y, int *__quo) noexcept (true); extern _Float32x __remquof32x (_Float32x __x, _Float32x __y, int *__quo) noexcept (true);






extern long int lrintf32x (_Float32x __x) noexcept (true); extern long int __lrintf32x (_Float32x __x) noexcept (true);
__extension__
extern long long int llrintf32x (_Float32x __x) noexcept (true); extern long long int __llrintf32x (_Float32x __x) noexcept (true);



extern long int lroundf32x (_Float32x __x) noexcept (true); extern long int __lroundf32x (_Float32x __x) noexcept (true);
__extension__
extern long long int llroundf32x (_Float32x __x) noexcept (true); extern long long int __llroundf32x (_Float32x __x) noexcept (true);



extern _Float32x fdimf32x (_Float32x __x, _Float32x __y) noexcept (true); extern _Float32x __fdimf32x (_Float32x __x, _Float32x __y) noexcept (true);



extern _Float32x fmaxf32x (_Float32x __x, _Float32x __y) noexcept (true) __attribute__ ((__const__)); extern _Float32x __fmaxf32x (_Float32x __x, _Float32x __y) noexcept (true) __attribute__ ((__const__));


extern _Float32x fminf32x (_Float32x __x, _Float32x __y) noexcept (true) __attribute__ ((__const__)); extern _Float32x __fminf32x (_Float32x __x, _Float32x __y) noexcept (true) __attribute__ ((__const__));



extern _Float32x fmaf32x (_Float32x __x, _Float32x __y, _Float32x __z) noexcept (true); extern _Float32x __fmaf32x (_Float32x __x, _Float32x __y, _Float32x __z) noexcept (true);




extern _Float32x roundevenf32x (_Float32x __x) noexcept (true) __attribute__ ((__const__)); extern _Float32x __roundevenf32x (_Float32x __x) noexcept (true) __attribute__ ((__const__));



extern __intmax_t fromfpf32x (_Float32x __x, int __round, unsigned int __width) noexcept (true); extern __intmax_t __fromfpf32x (_Float32x __x, int __round, unsigned int __width) noexcept (true)
                            ;



extern __uintmax_t ufromfpf32x (_Float32x __x, int __round, unsigned int __width) noexcept (true); extern __uintmax_t __ufromfpf32x (_Float32x __x, int __round, unsigned int __width) noexcept (true)
                              ;




extern __intmax_t fromfpxf32x (_Float32x __x, int __round, unsigned int __width) noexcept (true); extern __intmax_t __fromfpxf32x (_Float32x __x, int __round, unsigned int __width) noexcept (true)
                             ;




extern __uintmax_t ufromfpxf32x (_Float32x __x, int __round, unsigned int __width) noexcept (true); extern __uintmax_t __ufromfpxf32x (_Float32x __x, int __round, unsigned int __width) noexcept (true)
                               ;


extern int canonicalizef32x (_Float32x *__cx, const _Float32x *__x) noexcept (true);






extern _Float32x fmaxmagf32x (_Float32x __x, _Float32x __y) noexcept (true) __attribute__ ((__const__)); extern _Float32x __fmaxmagf32x (_Float32x __x, _Float32x __y) noexcept (true) __attribute__ ((__const__));


extern _Float32x fminmagf32x (_Float32x __x, _Float32x __y) noexcept (true) __attribute__ ((__const__)); extern _Float32x __fminmagf32x (_Float32x __x, _Float32x __y) noexcept (true) __attribute__ ((__const__));




extern _Float32x fmaximumf32x (_Float32x __x, _Float32x __y) noexcept (true) __attribute__ ((__const__)); extern _Float32x __fmaximumf32x (_Float32x __x, _Float32x __y) noexcept (true) __attribute__ ((__const__));


extern _Float32x fminimumf32x (_Float32x __x, _Float32x __y) noexcept (true) __attribute__ ((__const__)); extern _Float32x __fminimumf32x (_Float32x __x, _Float32x __y) noexcept (true) __attribute__ ((__const__));


extern _Float32x fmaximum_numf32x (_Float32x __x, _Float32x __y) noexcept (true) __attribute__ ((__const__)); extern _Float32x __fmaximum_numf32x (_Float32x __x, _Float32x __y) noexcept (true) __attribute__ ((__const__));


extern _Float32x fminimum_numf32x (_Float32x __x, _Float32x __y) noexcept (true) __attribute__ ((__const__)); extern _Float32x __fminimum_numf32x (_Float32x __x, _Float32x __y) noexcept (true) __attribute__ ((__const__));


extern _Float32x fmaximum_magf32x (_Float32x __x, _Float32x __y) noexcept (true) __attribute__ ((__const__)); extern _Float32x __fmaximum_magf32x (_Float32x __x, _Float32x __y) noexcept (true) __attribute__ ((__const__));


extern _Float32x fminimum_magf32x (_Float32x __x, _Float32x __y) noexcept (true) __attribute__ ((__const__)); extern _Float32x __fminimum_magf32x (_Float32x __x, _Float32x __y) noexcept (true) __attribute__ ((__const__));


extern _Float32x fmaximum_mag_numf32x (_Float32x __x, _Float32x __y) noexcept (true) __attribute__ ((__const__)); extern _Float32x __fmaximum_mag_numf32x (_Float32x __x, _Float32x __y) noexcept (true) __attribute__ ((__const__));


extern _Float32x fminimum_mag_numf32x (_Float32x __x, _Float32x __y) noexcept (true) __attribute__ ((__const__)); extern _Float32x __fminimum_mag_numf32x (_Float32x __x, _Float32x __y) noexcept (true) __attribute__ ((__const__));




extern int totalorderf32x (const _Float32x *__x, const _Float32x *__y) noexcept (true)

     __attribute__ ((__pure__));


extern int totalordermagf32x (const _Float32x *__x, const _Float32x *__y) noexcept (true)

     __attribute__ ((__pure__));


extern _Float32x getpayloadf32x (const _Float32x *__x) noexcept (true); extern _Float32x __getpayloadf32x (const _Float32x *__x) noexcept (true);


extern int setpayloadf32x (_Float32x *__x, _Float32x __payload) noexcept (true);


extern int setpayloadsigf32x (_Float32x *__x, _Float32x __payload) noexcept (true);
# 502 "/usr/include/math.h" 2 3 4
# 518 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 1 3 4
# 53 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
 extern _Float64x acosf64x (_Float64x __x) noexcept (true); extern _Float64x __acosf64x (_Float64x __x) noexcept (true);

 extern _Float64x asinf64x (_Float64x __x) noexcept (true); extern _Float64x __asinf64x (_Float64x __x) noexcept (true);

 extern _Float64x atanf64x (_Float64x __x) noexcept (true); extern _Float64x __atanf64x (_Float64x __x) noexcept (true);

 extern _Float64x atan2f64x (_Float64x __y, _Float64x __x) noexcept (true); extern _Float64x __atan2f64x (_Float64x __y, _Float64x __x) noexcept (true);


 extern _Float64x cosf64x (_Float64x __x) noexcept (true); extern _Float64x __cosf64x (_Float64x __x) noexcept (true);

 extern _Float64x sinf64x (_Float64x __x) noexcept (true); extern _Float64x __sinf64x (_Float64x __x) noexcept (true);

 extern _Float64x tanf64x (_Float64x __x) noexcept (true); extern _Float64x __tanf64x (_Float64x __x) noexcept (true);




 extern _Float64x coshf64x (_Float64x __x) noexcept (true); extern _Float64x __coshf64x (_Float64x __x) noexcept (true);

 extern _Float64x sinhf64x (_Float64x __x) noexcept (true); extern _Float64x __sinhf64x (_Float64x __x) noexcept (true);

 extern _Float64x tanhf64x (_Float64x __x) noexcept (true); extern _Float64x __tanhf64x (_Float64x __x) noexcept (true);



 extern void sincosf64x (_Float64x __x, _Float64x *__sinx, _Float64x *__cosx) noexcept (true); extern void __sincosf64x (_Float64x __x, _Float64x *__sinx, _Float64x *__cosx) noexcept (true)
                                                        ;




 extern _Float64x acoshf64x (_Float64x __x) noexcept (true); extern _Float64x __acoshf64x (_Float64x __x) noexcept (true);

 extern _Float64x asinhf64x (_Float64x __x) noexcept (true); extern _Float64x __asinhf64x (_Float64x __x) noexcept (true);

 extern _Float64x atanhf64x (_Float64x __x) noexcept (true); extern _Float64x __atanhf64x (_Float64x __x) noexcept (true);





 extern _Float64x expf64x (_Float64x __x) noexcept (true); extern _Float64x __expf64x (_Float64x __x) noexcept (true);


extern _Float64x frexpf64x (_Float64x __x, int *__exponent) noexcept (true); extern _Float64x __frexpf64x (_Float64x __x, int *__exponent) noexcept (true);


extern _Float64x ldexpf64x (_Float64x __x, int __exponent) noexcept (true); extern _Float64x __ldexpf64x (_Float64x __x, int __exponent) noexcept (true);


 extern _Float64x logf64x (_Float64x __x) noexcept (true); extern _Float64x __logf64x (_Float64x __x) noexcept (true);


 extern _Float64x log10f64x (_Float64x __x) noexcept (true); extern _Float64x __log10f64x (_Float64x __x) noexcept (true);


extern _Float64x modff64x (_Float64x __x, _Float64x *__iptr) noexcept (true); extern _Float64x __modff64x (_Float64x __x, _Float64x *__iptr) noexcept (true) __attribute__ ((__nonnull__ (2)));



 extern _Float64x exp10f64x (_Float64x __x) noexcept (true); extern _Float64x __exp10f64x (_Float64x __x) noexcept (true);




 extern _Float64x expm1f64x (_Float64x __x) noexcept (true); extern _Float64x __expm1f64x (_Float64x __x) noexcept (true);


 extern _Float64x log1pf64x (_Float64x __x) noexcept (true); extern _Float64x __log1pf64x (_Float64x __x) noexcept (true);


extern _Float64x logbf64x (_Float64x __x) noexcept (true); extern _Float64x __logbf64x (_Float64x __x) noexcept (true);




 extern _Float64x exp2f64x (_Float64x __x) noexcept (true); extern _Float64x __exp2f64x (_Float64x __x) noexcept (true);


 extern _Float64x log2f64x (_Float64x __x) noexcept (true); extern _Float64x __log2f64x (_Float64x __x) noexcept (true);






 extern _Float64x powf64x (_Float64x __x, _Float64x __y) noexcept (true); extern _Float64x __powf64x (_Float64x __x, _Float64x __y) noexcept (true);


extern _Float64x sqrtf64x (_Float64x __x) noexcept (true); extern _Float64x __sqrtf64x (_Float64x __x) noexcept (true);



 extern _Float64x hypotf64x (_Float64x __x, _Float64x __y) noexcept (true); extern _Float64x __hypotf64x (_Float64x __x, _Float64x __y) noexcept (true);




 extern _Float64x cbrtf64x (_Float64x __x) noexcept (true); extern _Float64x __cbrtf64x (_Float64x __x) noexcept (true);






extern _Float64x ceilf64x (_Float64x __x) noexcept (true) __attribute__ ((__const__)); extern _Float64x __ceilf64x (_Float64x __x) noexcept (true) __attribute__ ((__const__));


extern _Float64x fabsf64x (_Float64x __x) noexcept (true) __attribute__ ((__const__)); extern _Float64x __fabsf64x (_Float64x __x) noexcept (true) __attribute__ ((__const__));


extern _Float64x floorf64x (_Float64x __x) noexcept (true) __attribute__ ((__const__)); extern _Float64x __floorf64x (_Float64x __x) noexcept (true) __attribute__ ((__const__));


extern _Float64x fmodf64x (_Float64x __x, _Float64x __y) noexcept (true); extern _Float64x __fmodf64x (_Float64x __x, _Float64x __y) noexcept (true);
# 198 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern _Float64x copysignf64x (_Float64x __x, _Float64x __y) noexcept (true) __attribute__ ((__const__)); extern _Float64x __copysignf64x (_Float64x __x, _Float64x __y) noexcept (true) __attribute__ ((__const__));




extern _Float64x nanf64x (const char *__tagb) noexcept (true); extern _Float64x __nanf64x (const char *__tagb) noexcept (true);
# 220 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern _Float64x j0f64x (_Float64x) noexcept (true); extern _Float64x __j0f64x (_Float64x) noexcept (true);
extern _Float64x j1f64x (_Float64x) noexcept (true); extern _Float64x __j1f64x (_Float64x) noexcept (true);
extern _Float64x jnf64x (int, _Float64x) noexcept (true); extern _Float64x __jnf64x (int, _Float64x) noexcept (true);
extern _Float64x y0f64x (_Float64x) noexcept (true); extern _Float64x __y0f64x (_Float64x) noexcept (true);
extern _Float64x y1f64x (_Float64x) noexcept (true); extern _Float64x __y1f64x (_Float64x) noexcept (true);
extern _Float64x ynf64x (int, _Float64x) noexcept (true); extern _Float64x __ynf64x (int, _Float64x) noexcept (true);





 extern _Float64x erff64x (_Float64x) noexcept (true); extern _Float64x __erff64x (_Float64x) noexcept (true);
 extern _Float64x erfcf64x (_Float64x) noexcept (true); extern _Float64x __erfcf64x (_Float64x) noexcept (true);
extern _Float64x lgammaf64x (_Float64x) noexcept (true); extern _Float64x __lgammaf64x (_Float64x) noexcept (true);




extern _Float64x tgammaf64x (_Float64x) noexcept (true); extern _Float64x __tgammaf64x (_Float64x) noexcept (true);
# 252 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern _Float64x lgammaf64x_r (_Float64x, int *__signgamp) noexcept (true); extern _Float64x __lgammaf64x_r (_Float64x, int *__signgamp) noexcept (true);






extern _Float64x rintf64x (_Float64x __x) noexcept (true); extern _Float64x __rintf64x (_Float64x __x) noexcept (true);


extern _Float64x nextafterf64x (_Float64x __x, _Float64x __y) noexcept (true); extern _Float64x __nextafterf64x (_Float64x __x, _Float64x __y) noexcept (true);






extern _Float64x nextdownf64x (_Float64x __x) noexcept (true); extern _Float64x __nextdownf64x (_Float64x __x) noexcept (true);

extern _Float64x nextupf64x (_Float64x __x) noexcept (true); extern _Float64x __nextupf64x (_Float64x __x) noexcept (true);



extern _Float64x remainderf64x (_Float64x __x, _Float64x __y) noexcept (true); extern _Float64x __remainderf64x (_Float64x __x, _Float64x __y) noexcept (true);



extern _Float64x scalbnf64x (_Float64x __x, int __n) noexcept (true); extern _Float64x __scalbnf64x (_Float64x __x, int __n) noexcept (true);



extern int ilogbf64x (_Float64x __x) noexcept (true); extern int __ilogbf64x (_Float64x __x) noexcept (true);




extern long int llogbf64x (_Float64x __x) noexcept (true); extern long int __llogbf64x (_Float64x __x) noexcept (true);




extern _Float64x scalblnf64x (_Float64x __x, long int __n) noexcept (true); extern _Float64x __scalblnf64x (_Float64x __x, long int __n) noexcept (true);



extern _Float64x nearbyintf64x (_Float64x __x) noexcept (true); extern _Float64x __nearbyintf64x (_Float64x __x) noexcept (true);



extern _Float64x roundf64x (_Float64x __x) noexcept (true) __attribute__ ((__const__)); extern _Float64x __roundf64x (_Float64x __x) noexcept (true) __attribute__ ((__const__));



extern _Float64x truncf64x (_Float64x __x) noexcept (true) __attribute__ ((__const__)); extern _Float64x __truncf64x (_Float64x __x) noexcept (true) __attribute__ ((__const__));




extern _Float64x remquof64x (_Float64x __x, _Float64x __y, int *__quo) noexcept (true); extern _Float64x __remquof64x (_Float64x __x, _Float64x __y, int *__quo) noexcept (true);






extern long int lrintf64x (_Float64x __x) noexcept (true); extern long int __lrintf64x (_Float64x __x) noexcept (true);
__extension__
extern long long int llrintf64x (_Float64x __x) noexcept (true); extern long long int __llrintf64x (_Float64x __x) noexcept (true);



extern long int lroundf64x (_Float64x __x) noexcept (true); extern long int __lroundf64x (_Float64x __x) noexcept (true);
__extension__
extern long long int llroundf64x (_Float64x __x) noexcept (true); extern long long int __llroundf64x (_Float64x __x) noexcept (true);



extern _Float64x fdimf64x (_Float64x __x, _Float64x __y) noexcept (true); extern _Float64x __fdimf64x (_Float64x __x, _Float64x __y) noexcept (true);



extern _Float64x fmaxf64x (_Float64x __x, _Float64x __y) noexcept (true) __attribute__ ((__const__)); extern _Float64x __fmaxf64x (_Float64x __x, _Float64x __y) noexcept (true) __attribute__ ((__const__));


extern _Float64x fminf64x (_Float64x __x, _Float64x __y) noexcept (true) __attribute__ ((__const__)); extern _Float64x __fminf64x (_Float64x __x, _Float64x __y) noexcept (true) __attribute__ ((__const__));



extern _Float64x fmaf64x (_Float64x __x, _Float64x __y, _Float64x __z) noexcept (true); extern _Float64x __fmaf64x (_Float64x __x, _Float64x __y, _Float64x __z) noexcept (true);




extern _Float64x roundevenf64x (_Float64x __x) noexcept (true) __attribute__ ((__const__)); extern _Float64x __roundevenf64x (_Float64x __x) noexcept (true) __attribute__ ((__const__));



extern __intmax_t fromfpf64x (_Float64x __x, int __round, unsigned int __width) noexcept (true); extern __intmax_t __fromfpf64x (_Float64x __x, int __round, unsigned int __width) noexcept (true)
                            ;



extern __uintmax_t ufromfpf64x (_Float64x __x, int __round, unsigned int __width) noexcept (true); extern __uintmax_t __ufromfpf64x (_Float64x __x, int __round, unsigned int __width) noexcept (true)
                              ;




extern __intmax_t fromfpxf64x (_Float64x __x, int __round, unsigned int __width) noexcept (true); extern __intmax_t __fromfpxf64x (_Float64x __x, int __round, unsigned int __width) noexcept (true)
                             ;




extern __uintmax_t ufromfpxf64x (_Float64x __x, int __round, unsigned int __width) noexcept (true); extern __uintmax_t __ufromfpxf64x (_Float64x __x, int __round, unsigned int __width) noexcept (true)
                               ;


extern int canonicalizef64x (_Float64x *__cx, const _Float64x *__x) noexcept (true);






extern _Float64x fmaxmagf64x (_Float64x __x, _Float64x __y) noexcept (true) __attribute__ ((__const__)); extern _Float64x __fmaxmagf64x (_Float64x __x, _Float64x __y) noexcept (true) __attribute__ ((__const__));


extern _Float64x fminmagf64x (_Float64x __x, _Float64x __y) noexcept (true) __attribute__ ((__const__)); extern _Float64x __fminmagf64x (_Float64x __x, _Float64x __y) noexcept (true) __attribute__ ((__const__));




extern _Float64x fmaximumf64x (_Float64x __x, _Float64x __y) noexcept (true) __attribute__ ((__const__)); extern _Float64x __fmaximumf64x (_Float64x __x, _Float64x __y) noexcept (true) __attribute__ ((__const__));


extern _Float64x fminimumf64x (_Float64x __x, _Float64x __y) noexcept (true) __attribute__ ((__const__)); extern _Float64x __fminimumf64x (_Float64x __x, _Float64x __y) noexcept (true) __attribute__ ((__const__));


extern _Float64x fmaximum_numf64x (_Float64x __x, _Float64x __y) noexcept (true) __attribute__ ((__const__)); extern _Float64x __fmaximum_numf64x (_Float64x __x, _Float64x __y) noexcept (true) __attribute__ ((__const__));


extern _Float64x fminimum_numf64x (_Float64x __x, _Float64x __y) noexcept (true) __attribute__ ((__const__)); extern _Float64x __fminimum_numf64x (_Float64x __x, _Float64x __y) noexcept (true) __attribute__ ((__const__));


extern _Float64x fmaximum_magf64x (_Float64x __x, _Float64x __y) noexcept (true) __attribute__ ((__const__)); extern _Float64x __fmaximum_magf64x (_Float64x __x, _Float64x __y) noexcept (true) __attribute__ ((__const__));


extern _Float64x fminimum_magf64x (_Float64x __x, _Float64x __y) noexcept (true) __attribute__ ((__const__)); extern _Float64x __fminimum_magf64x (_Float64x __x, _Float64x __y) noexcept (true) __attribute__ ((__const__));


extern _Float64x fmaximum_mag_numf64x (_Float64x __x, _Float64x __y) noexcept (true) __attribute__ ((__const__)); extern _Float64x __fmaximum_mag_numf64x (_Float64x __x, _Float64x __y) noexcept (true) __attribute__ ((__const__));


extern _Float64x fminimum_mag_numf64x (_Float64x __x, _Float64x __y) noexcept (true) __attribute__ ((__const__)); extern _Float64x __fminimum_mag_numf64x (_Float64x __x, _Float64x __y) noexcept (true) __attribute__ ((__const__));




extern int totalorderf64x (const _Float64x *__x, const _Float64x *__y) noexcept (true)

     __attribute__ ((__pure__));


extern int totalordermagf64x (const _Float64x *__x, const _Float64x *__y) noexcept (true)

     __attribute__ ((__pure__));


extern _Float64x getpayloadf64x (const _Float64x *__x) noexcept (true); extern _Float64x __getpayloadf64x (const _Float64x *__x) noexcept (true);


extern int setpayloadf64x (_Float64x *__x, _Float64x __payload) noexcept (true);


extern int setpayloadsigf64x (_Float64x *__x, _Float64x __payload) noexcept (true);
# 519 "/usr/include/math.h" 2 3 4
# 566 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/mathcalls-narrow.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/mathcalls-narrow.h" 3 4
extern float fadd (double __x, double __y) noexcept (true);


extern float fdiv (double __x, double __y) noexcept (true);


extern float ffma (double __x, double __y, double __z) noexcept (true);


extern float fmul (double __x, double __y) noexcept (true);


extern float fsqrt (double __x) noexcept (true);


extern float fsub (double __x, double __y) noexcept (true);
# 567 "/usr/include/math.h" 2 3 4
# 587 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/mathcalls-narrow.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/mathcalls-narrow.h" 3 4
extern float faddl (long double __x, long double __y) noexcept (true);


extern float fdivl (long double __x, long double __y) noexcept (true);


extern float ffmal (long double __x, long double __y, long double __z) noexcept (true);


extern float fmull (long double __x, long double __y) noexcept (true);


extern float fsqrtl (long double __x) noexcept (true);


extern float fsubl (long double __x, long double __y) noexcept (true);
# 588 "/usr/include/math.h" 2 3 4
# 616 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/mathcalls-narrow.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/mathcalls-narrow.h" 3 4
extern double daddl (long double __x, long double __y) noexcept (true);


extern double ddivl (long double __x, long double __y) noexcept (true);


extern double dfmal (long double __x, long double __y, long double __z) noexcept (true);


extern double dmull (long double __x, long double __y) noexcept (true);


extern double dsqrtl (long double __x) noexcept (true);


extern double dsubl (long double __x, long double __y) noexcept (true);
# 617 "/usr/include/math.h" 2 3 4
# 697 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/mathcalls-narrow.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/mathcalls-narrow.h" 3 4
extern _Float32 f32addf32x (_Float32x __x, _Float32x __y) noexcept (true);


extern _Float32 f32divf32x (_Float32x __x, _Float32x __y) noexcept (true);


extern _Float32 f32fmaf32x (_Float32x __x, _Float32x __y, _Float32x __z) noexcept (true);


extern _Float32 f32mulf32x (_Float32x __x, _Float32x __y) noexcept (true);


extern _Float32 f32sqrtf32x (_Float32x __x) noexcept (true);


extern _Float32 f32subf32x (_Float32x __x, _Float32x __y) noexcept (true);
# 698 "/usr/include/math.h" 2 3 4
# 707 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/mathcalls-narrow.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/mathcalls-narrow.h" 3 4
extern _Float32 f32addf64 (_Float64 __x, _Float64 __y) noexcept (true);


extern _Float32 f32divf64 (_Float64 __x, _Float64 __y) noexcept (true);


extern _Float32 f32fmaf64 (_Float64 __x, _Float64 __y, _Float64 __z) noexcept (true);


extern _Float32 f32mulf64 (_Float64 __x, _Float64 __y) noexcept (true);


extern _Float32 f32sqrtf64 (_Float64 __x) noexcept (true);


extern _Float32 f32subf64 (_Float64 __x, _Float64 __y) noexcept (true);
# 708 "/usr/include/math.h" 2 3 4
# 717 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/mathcalls-narrow.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/mathcalls-narrow.h" 3 4
extern _Float32 f32addf64x (_Float64x __x, _Float64x __y) noexcept (true);


extern _Float32 f32divf64x (_Float64x __x, _Float64x __y) noexcept (true);


extern _Float32 f32fmaf64x (_Float64x __x, _Float64x __y, _Float64x __z) noexcept (true);


extern _Float32 f32mulf64x (_Float64x __x, _Float64x __y) noexcept (true);


extern _Float32 f32sqrtf64x (_Float64x __x) noexcept (true);


extern _Float32 f32subf64x (_Float64x __x, _Float64x __y) noexcept (true);
# 718 "/usr/include/math.h" 2 3 4
# 727 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/mathcalls-narrow.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/mathcalls-narrow.h" 3 4
extern _Float32 f32addf128 (_Float128 __x, _Float128 __y) noexcept (true);


extern _Float32 f32divf128 (_Float128 __x, _Float128 __y) noexcept (true);


extern _Float32 f32fmaf128 (_Float128 __x, _Float128 __y, _Float128 __z) noexcept (true);


extern _Float32 f32mulf128 (_Float128 __x, _Float128 __y) noexcept (true);


extern _Float32 f32sqrtf128 (_Float128 __x) noexcept (true);


extern _Float32 f32subf128 (_Float128 __x, _Float128 __y) noexcept (true);
# 728 "/usr/include/math.h" 2 3 4
# 747 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/mathcalls-narrow.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/mathcalls-narrow.h" 3 4
extern _Float32x f32xaddf64 (_Float64 __x, _Float64 __y) noexcept (true);


extern _Float32x f32xdivf64 (_Float64 __x, _Float64 __y) noexcept (true);


extern _Float32x f32xfmaf64 (_Float64 __x, _Float64 __y, _Float64 __z) noexcept (true);


extern _Float32x f32xmulf64 (_Float64 __x, _Float64 __y) noexcept (true);


extern _Float32x f32xsqrtf64 (_Float64 __x) noexcept (true);


extern _Float32x f32xsubf64 (_Float64 __x, _Float64 __y) noexcept (true);
# 748 "/usr/include/math.h" 2 3 4
# 757 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/mathcalls-narrow.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/mathcalls-narrow.h" 3 4
extern _Float32x f32xaddf64x (_Float64x __x, _Float64x __y) noexcept (true);


extern _Float32x f32xdivf64x (_Float64x __x, _Float64x __y) noexcept (true);


extern _Float32x f32xfmaf64x (_Float64x __x, _Float64x __y, _Float64x __z) noexcept (true);


extern _Float32x f32xmulf64x (_Float64x __x, _Float64x __y) noexcept (true);


extern _Float32x f32xsqrtf64x (_Float64x __x) noexcept (true);


extern _Float32x f32xsubf64x (_Float64x __x, _Float64x __y) noexcept (true);
# 758 "/usr/include/math.h" 2 3 4
# 767 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/mathcalls-narrow.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/mathcalls-narrow.h" 3 4
extern _Float32x f32xaddf128 (_Float128 __x, _Float128 __y) noexcept (true);


extern _Float32x f32xdivf128 (_Float128 __x, _Float128 __y) noexcept (true);


extern _Float32x f32xfmaf128 (_Float128 __x, _Float128 __y, _Float128 __z) noexcept (true);


extern _Float32x f32xmulf128 (_Float128 __x, _Float128 __y) noexcept (true);


extern _Float32x f32xsqrtf128 (_Float128 __x) noexcept (true);


extern _Float32x f32xsubf128 (_Float128 __x, _Float128 __y) noexcept (true);
# 768 "/usr/include/math.h" 2 3 4
# 787 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/mathcalls-narrow.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/mathcalls-narrow.h" 3 4
extern _Float64 f64addf64x (_Float64x __x, _Float64x __y) noexcept (true);


extern _Float64 f64divf64x (_Float64x __x, _Float64x __y) noexcept (true);


extern _Float64 f64fmaf64x (_Float64x __x, _Float64x __y, _Float64x __z) noexcept (true);


extern _Float64 f64mulf64x (_Float64x __x, _Float64x __y) noexcept (true);


extern _Float64 f64sqrtf64x (_Float64x __x) noexcept (true);


extern _Float64 f64subf64x (_Float64x __x, _Float64x __y) noexcept (true);
# 788 "/usr/include/math.h" 2 3 4
# 797 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/mathcalls-narrow.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/mathcalls-narrow.h" 3 4
extern _Float64 f64addf128 (_Float128 __x, _Float128 __y) noexcept (true);


extern _Float64 f64divf128 (_Float128 __x, _Float128 __y) noexcept (true);


extern _Float64 f64fmaf128 (_Float128 __x, _Float128 __y, _Float128 __z) noexcept (true);


extern _Float64 f64mulf128 (_Float128 __x, _Float128 __y) noexcept (true);


extern _Float64 f64sqrtf128 (_Float128 __x) noexcept (true);


extern _Float64 f64subf128 (_Float128 __x, _Float128 __y) noexcept (true);
# 798 "/usr/include/math.h" 2 3 4
# 817 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/mathcalls-narrow.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/mathcalls-narrow.h" 3 4
extern _Float64x f64xaddf128 (_Float128 __x, _Float128 __y) noexcept (true);


extern _Float64x f64xdivf128 (_Float128 __x, _Float128 __y) noexcept (true);


extern _Float64x f64xfmaf128 (_Float128 __x, _Float128 __y, _Float128 __z) noexcept (true);


extern _Float64x f64xmulf128 (_Float128 __x, _Float128 __y) noexcept (true);


extern _Float64x f64xsqrtf128 (_Float128 __x) noexcept (true);


extern _Float64x f64xsubf128 (_Float128 __x, _Float128 __y) noexcept (true);
# 818 "/usr/include/math.h" 2 3 4
# 854 "/usr/include/math.h" 3 4
extern int signgam;
# 934 "/usr/include/math.h" 3 4
enum
  {
    FP_NAN =

      0,
    FP_INFINITE =

      1,
    FP_ZERO =

      2,
    FP_SUBNORMAL =

      3,
    FP_NORMAL =

      4
  };
# 1054 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/iscanonical.h" 1 3 4
# 23 "/usr/include/x86_64-linux-gnu/bits/iscanonical.h" 3 4
extern int __iscanonicall (long double __x)
     noexcept (true) __attribute__ ((__const__));
# 46 "/usr/include/x86_64-linux-gnu/bits/iscanonical.h" 3 4
extern "C++" {
inline int iscanonical (float __val) { return ((void) (__typeof (__val)) (__val), 1); }
inline int iscanonical (double __val) { return ((void) (__typeof (__val)) (__val), 1); }
inline int iscanonical (long double __val) { return __iscanonicall (__val); }

inline int iscanonical (_Float128 __val) { return ((void) (__typeof (__val)) (__val), 1); }

}
# 1055 "/usr/include/math.h" 2 3 4
# 1066 "/usr/include/math.h" 3 4
extern "C++" {
inline int issignaling (float __val) { return __issignalingf (__val); }
inline int issignaling (double __val) { return __issignaling (__val); }
inline int
issignaling (long double __val)
{



  return __issignalingl (__val);

}



inline int issignaling (_Float128 __val) { return __issignalingf128 (__val); }

}
# 1097 "/usr/include/math.h" 3 4
extern "C++" {
# 1128 "/usr/include/math.h" 3 4
template <class __T> inline bool
iszero (__T __val)
{
  return __val == 0;
}

}
# 1363 "/usr/include/math.h" 3 4
extern "C++" {
template<typename> struct __iseqsig_type;

template<> struct __iseqsig_type<float>
{
  static int __call (float __x, float __y) throw ()
  {
    return __iseqsigf (__x, __y);
  }
};

template<> struct __iseqsig_type<double>
{
  static int __call (double __x, double __y) throw ()
  {
    return __iseqsig (__x, __y);
  }
};

template<> struct __iseqsig_type<long double>
{
  static int __call (long double __x, long double __y) throw ()
  {

    return __iseqsigl (__x, __y);



  }
};




template<> struct __iseqsig_type<_Float128>
{
  static int __call (_Float128 __x, _Float128 __y) throw ()
  {
    return __iseqsigf128 (__x, __y);
  }
};


template<typename _T1, typename _T2>
inline int
iseqsig (_T1 __x, _T2 __y) throw ()
{

  typedef decltype (((__x) + (__y) + 0.0f)) _T3;



  return __iseqsig_type<_T3>::__call (__x, __y);
}

}




}
# 46 "/usr/include/c++/10/cmath" 2 3
# 77 "/usr/include/c++/10/cmath" 3
extern "C++"
{
namespace std __attribute__ ((__visibility__ ("default")))
{


  using ::acos;


  inline constexpr float
  acos(float __x)
  { return __builtin_acosf(__x); }

  inline constexpr long double
  acos(long double __x)
  { return __builtin_acosl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    acos(_Tp __x)
    { return __builtin_acos(__x); }

  using ::asin;


  inline constexpr float
  asin(float __x)
  { return __builtin_asinf(__x); }

  inline constexpr long double
  asin(long double __x)
  { return __builtin_asinl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    asin(_Tp __x)
    { return __builtin_asin(__x); }

  using ::atan;


  inline constexpr float
  atan(float __x)
  { return __builtin_atanf(__x); }

  inline constexpr long double
  atan(long double __x)
  { return __builtin_atanl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    atan(_Tp __x)
    { return __builtin_atan(__x); }

  using ::atan2;


  inline constexpr float
  atan2(float __y, float __x)
  { return __builtin_atan2f(__y, __x); }

  inline constexpr long double
  atan2(long double __y, long double __x)
  { return __builtin_atan2l(__y, __x); }


  template<typename _Tp, typename _Up>
    inline constexpr
    typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    atan2(_Tp __y, _Up __x)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return atan2(__type(__y), __type(__x));
    }

  using ::ceil;


  inline constexpr float
  ceil(float __x)
  { return __builtin_ceilf(__x); }

  inline constexpr long double
  ceil(long double __x)
  { return __builtin_ceill(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    ceil(_Tp __x)
    { return __builtin_ceil(__x); }

  using ::cos;


  inline constexpr float
  cos(float __x)
  { return __builtin_cosf(__x); }

  inline constexpr long double
  cos(long double __x)
  { return __builtin_cosl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    cos(_Tp __x)
    { return __builtin_cos(__x); }

  using ::cosh;


  inline constexpr float
  cosh(float __x)
  { return __builtin_coshf(__x); }

  inline constexpr long double
  cosh(long double __x)
  { return __builtin_coshl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    cosh(_Tp __x)
    { return __builtin_cosh(__x); }

  using ::exp;


  inline constexpr float
  exp(float __x)
  { return __builtin_expf(__x); }

  inline constexpr long double
  exp(long double __x)
  { return __builtin_expl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    exp(_Tp __x)
    { return __builtin_exp(__x); }

  using ::fabs;


  inline constexpr float
  fabs(float __x)
  { return __builtin_fabsf(__x); }

  inline constexpr long double
  fabs(long double __x)
  { return __builtin_fabsl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    fabs(_Tp __x)
    { return __builtin_fabs(__x); }

  using ::floor;


  inline constexpr float
  floor(float __x)
  { return __builtin_floorf(__x); }

  inline constexpr long double
  floor(long double __x)
  { return __builtin_floorl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    floor(_Tp __x)
    { return __builtin_floor(__x); }

  using ::fmod;


  inline constexpr float
  fmod(float __x, float __y)
  { return __builtin_fmodf(__x, __y); }

  inline constexpr long double
  fmod(long double __x, long double __y)
  { return __builtin_fmodl(__x, __y); }


  template<typename _Tp, typename _Up>
    inline constexpr
    typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    fmod(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return fmod(__type(__x), __type(__y));
    }

  using ::frexp;


  inline float
  frexp(float __x, int* __exp)
  { return __builtin_frexpf(__x, __exp); }

  inline long double
  frexp(long double __x, int* __exp)
  { return __builtin_frexpl(__x, __exp); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    frexp(_Tp __x, int* __exp)
    { return __builtin_frexp(__x, __exp); }

  using ::ldexp;


  inline constexpr float
  ldexp(float __x, int __exp)
  { return __builtin_ldexpf(__x, __exp); }

  inline constexpr long double
  ldexp(long double __x, int __exp)
  { return __builtin_ldexpl(__x, __exp); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    ldexp(_Tp __x, int __exp)
    { return __builtin_ldexp(__x, __exp); }

  using ::log;


  inline constexpr float
  log(float __x)
  { return __builtin_logf(__x); }

  inline constexpr long double
  log(long double __x)
  { return __builtin_logl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    log(_Tp __x)
    { return __builtin_log(__x); }

  using ::log10;


  inline constexpr float
  log10(float __x)
  { return __builtin_log10f(__x); }

  inline constexpr long double
  log10(long double __x)
  { return __builtin_log10l(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    log10(_Tp __x)
    { return __builtin_log10(__x); }

  using ::modf;


  inline float
  modf(float __x, float* __iptr)
  { return __builtin_modff(__x, __iptr); }

  inline long double
  modf(long double __x, long double* __iptr)
  { return __builtin_modfl(__x, __iptr); }


  using ::pow;


  inline constexpr float
  pow(float __x, float __y)
  { return __builtin_powf(__x, __y); }

  inline constexpr long double
  pow(long double __x, long double __y)
  { return __builtin_powl(__x, __y); }
# 412 "/usr/include/c++/10/cmath" 3
  template<typename _Tp, typename _Up>
    inline constexpr
    typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    pow(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return pow(__type(__x), __type(__y));
    }

  using ::sin;


  inline constexpr float
  sin(float __x)
  { return __builtin_sinf(__x); }

  inline constexpr long double
  sin(long double __x)
  { return __builtin_sinl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    sin(_Tp __x)
    { return __builtin_sin(__x); }

  using ::sinh;


  inline constexpr float
  sinh(float __x)
  { return __builtin_sinhf(__x); }

  inline constexpr long double
  sinh(long double __x)
  { return __builtin_sinhl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    sinh(_Tp __x)
    { return __builtin_sinh(__x); }

  using ::sqrt;


  inline constexpr float
  sqrt(float __x)
  { return __builtin_sqrtf(__x); }

  inline constexpr long double
  sqrt(long double __x)
  { return __builtin_sqrtl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    sqrt(_Tp __x)
    { return __builtin_sqrt(__x); }

  using ::tan;


  inline constexpr float
  tan(float __x)
  { return __builtin_tanf(__x); }

  inline constexpr long double
  tan(long double __x)
  { return __builtin_tanl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    tan(_Tp __x)
    { return __builtin_tan(__x); }

  using ::tanh;


  inline constexpr float
  tanh(float __x)
  { return __builtin_tanhf(__x); }

  inline constexpr long double
  tanh(long double __x)
  { return __builtin_tanhl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    tanh(_Tp __x)
    { return __builtin_tanh(__x); }
# 536 "/usr/include/c++/10/cmath" 3
  constexpr int
  fpclassify(float __x)
  { return __builtin_fpclassify(0, 1, 4,
    3, 2, __x); }

  constexpr int
  fpclassify(double __x)
  { return __builtin_fpclassify(0, 1, 4,
    3, 2, __x); }

  constexpr int
  fpclassify(long double __x)
  { return __builtin_fpclassify(0, 1, 4,
    3, 2, __x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              int>::__type
    fpclassify(_Tp __x)
    { return __x != 0 ? 4 : 2; }



  constexpr bool
  isfinite(float __x)
  { return __builtin_isfinite(__x); }

  constexpr bool
  isfinite(double __x)
  { return __builtin_isfinite(__x); }

  constexpr bool
  isfinite(long double __x)
  { return __builtin_isfinite(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              bool>::__type
    isfinite(_Tp __x)
    { return true; }



  constexpr bool
  isinf(float __x)
  { return __builtin_isinf(__x); }





  constexpr bool
  isinf(double __x)
  { return __builtin_isinf(__x); }


  constexpr bool
  isinf(long double __x)
  { return __builtin_isinf(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              bool>::__type
    isinf(_Tp __x)
    { return false; }



  constexpr bool
  isnan(float __x)
  { return __builtin_isnan(__x); }





  constexpr bool
  isnan(double __x)
  { return __builtin_isnan(__x); }


  constexpr bool
  isnan(long double __x)
  { return __builtin_isnan(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              bool>::__type
    isnan(_Tp __x)
    { return false; }



  constexpr bool
  isnormal(float __x)
  { return __builtin_isnormal(__x); }

  constexpr bool
  isnormal(double __x)
  { return __builtin_isnormal(__x); }

  constexpr bool
  isnormal(long double __x)
  { return __builtin_isnormal(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              bool>::__type
    isnormal(_Tp __x)
    { return __x != 0 ? true : false; }




  constexpr bool
  signbit(float __x)
  { return __builtin_signbit(__x); }

  constexpr bool
  signbit(double __x)
  { return __builtin_signbit(__x); }

  constexpr bool
  signbit(long double __x)
  { return __builtin_signbit(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              bool>::__type
    signbit(_Tp __x)
    { return __x < 0 ? true : false; }



  constexpr bool
  isgreater(float __x, float __y)
  { return __builtin_isgreater(__x, __y); }

  constexpr bool
  isgreater(double __x, double __y)
  { return __builtin_isgreater(__x, __y); }

  constexpr bool
  isgreater(long double __x, long double __y)
  { return __builtin_isgreater(__x, __y); }



  template<typename _Tp, typename _Up>
    constexpr typename
    __gnu_cxx::__enable_if<(__is_arithmetic<_Tp>::__value
       && __is_arithmetic<_Up>::__value), bool>::__type
    isgreater(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return __builtin_isgreater(__type(__x), __type(__y));
    }



  constexpr bool
  isgreaterequal(float __x, float __y)
  { return __builtin_isgreaterequal(__x, __y); }

  constexpr bool
  isgreaterequal(double __x, double __y)
  { return __builtin_isgreaterequal(__x, __y); }

  constexpr bool
  isgreaterequal(long double __x, long double __y)
  { return __builtin_isgreaterequal(__x, __y); }



  template<typename _Tp, typename _Up>
    constexpr typename
    __gnu_cxx::__enable_if<(__is_arithmetic<_Tp>::__value
       && __is_arithmetic<_Up>::__value), bool>::__type
    isgreaterequal(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return __builtin_isgreaterequal(__type(__x), __type(__y));
    }



  constexpr bool
  isless(float __x, float __y)
  { return __builtin_isless(__x, __y); }

  constexpr bool
  isless(double __x, double __y)
  { return __builtin_isless(__x, __y); }

  constexpr bool
  isless(long double __x, long double __y)
  { return __builtin_isless(__x, __y); }



  template<typename _Tp, typename _Up>
    constexpr typename
    __gnu_cxx::__enable_if<(__is_arithmetic<_Tp>::__value
       && __is_arithmetic<_Up>::__value), bool>::__type
    isless(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return __builtin_isless(__type(__x), __type(__y));
    }



  constexpr bool
  islessequal(float __x, float __y)
  { return __builtin_islessequal(__x, __y); }

  constexpr bool
  islessequal(double __x, double __y)
  { return __builtin_islessequal(__x, __y); }

  constexpr bool
  islessequal(long double __x, long double __y)
  { return __builtin_islessequal(__x, __y); }



  template<typename _Tp, typename _Up>
    constexpr typename
    __gnu_cxx::__enable_if<(__is_arithmetic<_Tp>::__value
       && __is_arithmetic<_Up>::__value), bool>::__type
    islessequal(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return __builtin_islessequal(__type(__x), __type(__y));
    }



  constexpr bool
  islessgreater(float __x, float __y)
  { return __builtin_islessgreater(__x, __y); }

  constexpr bool
  islessgreater(double __x, double __y)
  { return __builtin_islessgreater(__x, __y); }

  constexpr bool
  islessgreater(long double __x, long double __y)
  { return __builtin_islessgreater(__x, __y); }



  template<typename _Tp, typename _Up>
    constexpr typename
    __gnu_cxx::__enable_if<(__is_arithmetic<_Tp>::__value
       && __is_arithmetic<_Up>::__value), bool>::__type
    islessgreater(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return __builtin_islessgreater(__type(__x), __type(__y));
    }



  constexpr bool
  isunordered(float __x, float __y)
  { return __builtin_isunordered(__x, __y); }

  constexpr bool
  isunordered(double __x, double __y)
  { return __builtin_isunordered(__x, __y); }

  constexpr bool
  isunordered(long double __x, long double __y)
  { return __builtin_isunordered(__x, __y); }



  template<typename _Tp, typename _Up>
    constexpr typename
    __gnu_cxx::__enable_if<(__is_arithmetic<_Tp>::__value
       && __is_arithmetic<_Up>::__value), bool>::__type
    isunordered(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return __builtin_isunordered(__type(__x), __type(__y));
    }
# 1065 "/usr/include/c++/10/cmath" 3
  using ::double_t;
  using ::float_t;


  using ::acosh;
  using ::acoshf;
  using ::acoshl;

  using ::asinh;
  using ::asinhf;
  using ::asinhl;

  using ::atanh;
  using ::atanhf;
  using ::atanhl;

  using ::cbrt;
  using ::cbrtf;
  using ::cbrtl;

  using ::copysign;
  using ::copysignf;
  using ::copysignl;

  using ::erf;
  using ::erff;
  using ::erfl;

  using ::erfc;
  using ::erfcf;
  using ::erfcl;

  using ::exp2;
  using ::exp2f;
  using ::exp2l;

  using ::expm1;
  using ::expm1f;
  using ::expm1l;

  using ::fdim;
  using ::fdimf;
  using ::fdiml;

  using ::fma;
  using ::fmaf;
  using ::fmal;

  using ::fmax;
  using ::fmaxf;
  using ::fmaxl;

  using ::fmin;
  using ::fminf;
  using ::fminl;

  using ::hypot;
  using ::hypotf;
  using ::hypotl;

  using ::ilogb;
  using ::ilogbf;
  using ::ilogbl;

  using ::lgamma;
  using ::lgammaf;
  using ::lgammal;


  using ::llrint;
  using ::llrintf;
  using ::llrintl;

  using ::llround;
  using ::llroundf;
  using ::llroundl;


  using ::log1p;
  using ::log1pf;
  using ::log1pl;

  using ::log2;
  using ::log2f;
  using ::log2l;

  using ::logb;
  using ::logbf;
  using ::logbl;

  using ::lrint;
  using ::lrintf;
  using ::lrintl;

  using ::lround;
  using ::lroundf;
  using ::lroundl;

  using ::nan;
  using ::nanf;
  using ::nanl;

  using ::nearbyint;
  using ::nearbyintf;
  using ::nearbyintl;

  using ::nextafter;
  using ::nextafterf;
  using ::nextafterl;

  using ::nexttoward;
  using ::nexttowardf;
  using ::nexttowardl;

  using ::remainder;
  using ::remainderf;
  using ::remainderl;

  using ::remquo;
  using ::remquof;
  using ::remquol;

  using ::rint;
  using ::rintf;
  using ::rintl;

  using ::round;
  using ::roundf;
  using ::roundl;

  using ::scalbln;
  using ::scalblnf;
  using ::scalblnl;

  using ::scalbn;
  using ::scalbnf;
  using ::scalbnl;

  using ::tgamma;
  using ::tgammaf;
  using ::tgammal;

  using ::trunc;
  using ::truncf;
  using ::truncl;



  constexpr float
  acosh(float __x)
  { return __builtin_acoshf(__x); }

  constexpr long double
  acosh(long double __x)
  { return __builtin_acoshl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    acosh(_Tp __x)
    { return __builtin_acosh(__x); }



  constexpr float
  asinh(float __x)
  { return __builtin_asinhf(__x); }

  constexpr long double
  asinh(long double __x)
  { return __builtin_asinhl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    asinh(_Tp __x)
    { return __builtin_asinh(__x); }



  constexpr float
  atanh(float __x)
  { return __builtin_atanhf(__x); }

  constexpr long double
  atanh(long double __x)
  { return __builtin_atanhl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    atanh(_Tp __x)
    { return __builtin_atanh(__x); }



  constexpr float
  cbrt(float __x)
  { return __builtin_cbrtf(__x); }

  constexpr long double
  cbrt(long double __x)
  { return __builtin_cbrtl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    cbrt(_Tp __x)
    { return __builtin_cbrt(__x); }



  constexpr float
  copysign(float __x, float __y)
  { return __builtin_copysignf(__x, __y); }

  constexpr long double
  copysign(long double __x, long double __y)
  { return __builtin_copysignl(__x, __y); }



  template<typename _Tp, typename _Up>
    constexpr typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    copysign(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return copysign(__type(__x), __type(__y));
    }



  constexpr float
  erf(float __x)
  { return __builtin_erff(__x); }

  constexpr long double
  erf(long double __x)
  { return __builtin_erfl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    erf(_Tp __x)
    { return __builtin_erf(__x); }



  constexpr float
  erfc(float __x)
  { return __builtin_erfcf(__x); }

  constexpr long double
  erfc(long double __x)
  { return __builtin_erfcl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    erfc(_Tp __x)
    { return __builtin_erfc(__x); }



  constexpr float
  exp2(float __x)
  { return __builtin_exp2f(__x); }

  constexpr long double
  exp2(long double __x)
  { return __builtin_exp2l(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    exp2(_Tp __x)
    { return __builtin_exp2(__x); }



  constexpr float
  expm1(float __x)
  { return __builtin_expm1f(__x); }

  constexpr long double
  expm1(long double __x)
  { return __builtin_expm1l(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    expm1(_Tp __x)
    { return __builtin_expm1(__x); }



  constexpr float
  fdim(float __x, float __y)
  { return __builtin_fdimf(__x, __y); }

  constexpr long double
  fdim(long double __x, long double __y)
  { return __builtin_fdiml(__x, __y); }



  template<typename _Tp, typename _Up>
    constexpr typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    fdim(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return fdim(__type(__x), __type(__y));
    }



  constexpr float
  fma(float __x, float __y, float __z)
  { return __builtin_fmaf(__x, __y, __z); }

  constexpr long double
  fma(long double __x, long double __y, long double __z)
  { return __builtin_fmal(__x, __y, __z); }



  template<typename _Tp, typename _Up, typename _Vp>
    constexpr typename __gnu_cxx::__promote_3<_Tp, _Up, _Vp>::__type
    fma(_Tp __x, _Up __y, _Vp __z)
    {
      typedef typename __gnu_cxx::__promote_3<_Tp, _Up, _Vp>::__type __type;
      return fma(__type(__x), __type(__y), __type(__z));
    }



  constexpr float
  fmax(float __x, float __y)
  { return __builtin_fmaxf(__x, __y); }

  constexpr long double
  fmax(long double __x, long double __y)
  { return __builtin_fmaxl(__x, __y); }



  template<typename _Tp, typename _Up>
    constexpr typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    fmax(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return fmax(__type(__x), __type(__y));
    }



  constexpr float
  fmin(float __x, float __y)
  { return __builtin_fminf(__x, __y); }

  constexpr long double
  fmin(long double __x, long double __y)
  { return __builtin_fminl(__x, __y); }



  template<typename _Tp, typename _Up>
    constexpr typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    fmin(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return fmin(__type(__x), __type(__y));
    }



  constexpr float
  hypot(float __x, float __y)
  { return __builtin_hypotf(__x, __y); }

  constexpr long double
  hypot(long double __x, long double __y)
  { return __builtin_hypotl(__x, __y); }



  template<typename _Tp, typename _Up>
    constexpr typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    hypot(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return hypot(__type(__x), __type(__y));
    }



  constexpr int
  ilogb(float __x)
  { return __builtin_ilogbf(__x); }

  constexpr int
  ilogb(long double __x)
  { return __builtin_ilogbl(__x); }



  template<typename _Tp>
    constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    int>::__type
    ilogb(_Tp __x)
    { return __builtin_ilogb(__x); }



  constexpr float
  lgamma(float __x)
  { return __builtin_lgammaf(__x); }

  constexpr long double
  lgamma(long double __x)
  { return __builtin_lgammal(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    lgamma(_Tp __x)
    { return __builtin_lgamma(__x); }



  constexpr long long
  llrint(float __x)
  { return __builtin_llrintf(__x); }

  constexpr long long
  llrint(long double __x)
  { return __builtin_llrintl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              long long>::__type
    llrint(_Tp __x)
    { return __builtin_llrint(__x); }



  constexpr long long
  llround(float __x)
  { return __builtin_llroundf(__x); }

  constexpr long long
  llround(long double __x)
  { return __builtin_llroundl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              long long>::__type
    llround(_Tp __x)
    { return __builtin_llround(__x); }



  constexpr float
  log1p(float __x)
  { return __builtin_log1pf(__x); }

  constexpr long double
  log1p(long double __x)
  { return __builtin_log1pl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    log1p(_Tp __x)
    { return __builtin_log1p(__x); }




  constexpr float
  log2(float __x)
  { return __builtin_log2f(__x); }

  constexpr long double
  log2(long double __x)
  { return __builtin_log2l(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    log2(_Tp __x)
    { return __builtin_log2(__x); }



  constexpr float
  logb(float __x)
  { return __builtin_logbf(__x); }

  constexpr long double
  logb(long double __x)
  { return __builtin_logbl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    logb(_Tp __x)
    { return __builtin_logb(__x); }



  constexpr long
  lrint(float __x)
  { return __builtin_lrintf(__x); }

  constexpr long
  lrint(long double __x)
  { return __builtin_lrintl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              long>::__type
    lrint(_Tp __x)
    { return __builtin_lrint(__x); }



  constexpr long
  lround(float __x)
  { return __builtin_lroundf(__x); }

  constexpr long
  lround(long double __x)
  { return __builtin_lroundl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              long>::__type
    lround(_Tp __x)
    { return __builtin_lround(__x); }



  constexpr float
  nearbyint(float __x)
  { return __builtin_nearbyintf(__x); }

  constexpr long double
  nearbyint(long double __x)
  { return __builtin_nearbyintl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    nearbyint(_Tp __x)
    { return __builtin_nearbyint(__x); }



  constexpr float
  nextafter(float __x, float __y)
  { return __builtin_nextafterf(__x, __y); }

  constexpr long double
  nextafter(long double __x, long double __y)
  { return __builtin_nextafterl(__x, __y); }



  template<typename _Tp, typename _Up>
    constexpr typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    nextafter(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return nextafter(__type(__x), __type(__y));
    }



  constexpr float
  nexttoward(float __x, long double __y)
  { return __builtin_nexttowardf(__x, __y); }

  constexpr long double
  nexttoward(long double __x, long double __y)
  { return __builtin_nexttowardl(__x, __y); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    nexttoward(_Tp __x, long double __y)
    { return __builtin_nexttoward(__x, __y); }



  constexpr float
  remainder(float __x, float __y)
  { return __builtin_remainderf(__x, __y); }

  constexpr long double
  remainder(long double __x, long double __y)
  { return __builtin_remainderl(__x, __y); }



  template<typename _Tp, typename _Up>
    constexpr typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    remainder(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return remainder(__type(__x), __type(__y));
    }



  inline float
  remquo(float __x, float __y, int* __pquo)
  { return __builtin_remquof(__x, __y, __pquo); }

  inline long double
  remquo(long double __x, long double __y, int* __pquo)
  { return __builtin_remquol(__x, __y, __pquo); }



  template<typename _Tp, typename _Up>
    inline typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    remquo(_Tp __x, _Up __y, int* __pquo)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return remquo(__type(__x), __type(__y), __pquo);
    }



  constexpr float
  rint(float __x)
  { return __builtin_rintf(__x); }

  constexpr long double
  rint(long double __x)
  { return __builtin_rintl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    rint(_Tp __x)
    { return __builtin_rint(__x); }



  constexpr float
  round(float __x)
  { return __builtin_roundf(__x); }

  constexpr long double
  round(long double __x)
  { return __builtin_roundl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    round(_Tp __x)
    { return __builtin_round(__x); }



  constexpr float
  scalbln(float __x, long __ex)
  { return __builtin_scalblnf(__x, __ex); }

  constexpr long double
  scalbln(long double __x, long __ex)
  { return __builtin_scalblnl(__x, __ex); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    scalbln(_Tp __x, long __ex)
    { return __builtin_scalbln(__x, __ex); }



  constexpr float
  scalbn(float __x, int __ex)
  { return __builtin_scalbnf(__x, __ex); }

  constexpr long double
  scalbn(long double __x, int __ex)
  { return __builtin_scalbnl(__x, __ex); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    scalbn(_Tp __x, int __ex)
    { return __builtin_scalbn(__x, __ex); }



  constexpr float
  tgamma(float __x)
  { return __builtin_tgammaf(__x); }

  constexpr long double
  tgamma(long double __x)
  { return __builtin_tgammal(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    tgamma(_Tp __x)
    { return __builtin_tgamma(__x); }



  constexpr float
  trunc(float __x)
  { return __builtin_truncf(__x); }

  constexpr long double
  trunc(long double __x)
  { return __builtin_truncl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    trunc(_Tp __x)
    { return __builtin_trunc(__x); }
# 1931 "/usr/include/c++/10/cmath" 3

}





}
# 4 "code/math.h" 2






# 9 "code/math.h"
int sign(float x)
{
 if (x < 0) return -1;
 else if (x > 0) return 1;
 return 0;
}


union v2 {
 struct {
  float x, y;
 };
 struct {
  float u, v;
 };
 float e[2];
};

v2 V2(float x)
{
 return v2{x, x};
}
v2 V2(float x, float y)
{
 return v2{x, y};
}

v2 operator+(v2 a, v2 b)
{
 return v2{a.x + b.x, a.y + b.y};
}

v2 operator-(v2 a, v2 b)
{
 return v2{a.x - b.x, a.y - b.y};
}

v2 operator*(v2 a, float b)
{
 return v2{a.x * b, a.y * b};
}

v2 operator*(float a, v2 b)
{
 return v2{a * b.x, a * b.y};
}

v2 operator*(v2 a, v2 b)
{
 return v2{a.x * b.x, a.y * b.y};
}

v2 operator/(v2 a, float b)
{
 float inv = 1.f / b;
 return v2{a.x * inv, a.y * inv};
}

v2 &operator+=(v2 &a, v2 b)
{
 return a = a + b;
}

v2 &operator-=(v2 &a, v2 b)
{
 return a = a - b;
}

v2 &operator*=(v2 &a, v2 b)
{
 return a = a * b;
}

v2 &operator*=(v2 &a, float b)
{
 return a = a * b;
}

v2 &operator/=(v2 &a, float b)
{
 return a = a / b;
}

float dot(v2 a, v2 b)
{
 return a.x * b.x + a.y * b.y;
}

float length_sq(v2 a)
{
 return dot(a, a);
}

float length(v2 a)
{
 return sqrtf(dot(a, a));
}

v2 normalize(v2 a)
{
 float len = length_sq(a);


 if (len < 1e-9)
  return {};
 else
  return a / sqrtf(len);
}


union v3 {
 struct {
  float x, y, z;
 };
 struct {
  float r, g, b;
 };
 struct {
  float u, v, w;
 };
 v2 xy;
 float e[3];
};

v3 V3(float x)
{
 return v3{x, x, x};
}

v3 V3(float x, float y, float z)
{
 v3 result;

 result.x = x;
 result.y = y;
 result.z = z;
 return result;
}

v3 operator+(v3 a, v3 b)
{
 return v3{a.x + b.x, a.y + b.y, a.z + b.z};
}

v3 operator-(v3 a, v3 b)
{
 return v3{a.x - b.x, a.y - b.y, a.z - b.z};
}

v3 operator*(v3 a, float b)
{
 return v3{a.x * b, a.y * b, a.z * b};
}

v3 operator*(float a, v3 b)
{
 return v3{a * b.x, a * b.y, a * b.z};
}

v3 operator/(v3 a, float b)
{
 float inv = 1.f / b;
 return v3{a.x * inv, a.y * inv, a.z * inv};
}

v3 operator*(v3 a, v3 b)
{
 return v3{a.x * b.x, a.y * b.y, a.z * b.z};
}

v3 operator-(v3 a)
{
 return v3{-a.x, -a.y, -a.z};
}

v3 &operator+=(v3 &a, v3 b)
{
 return a = a + b;
}

v3 &operator-=(v3 &a, v3 b)
{
 return a = a - b;
}

v3 &operator*=(v3 &a, v3 b)
{
 return a = a * b;
}

v3 &operator*=(v3 &a, float b)
{
 return a = a * b;
}

v3 &operator/=(v3 &a, float b)
{
 return a = a / b;
}

v3 operator/(float a, v3 b)
{
 return v3{a / b.x, a / b.y, a / b.z};
}

float dot(v3 a, v3 b)
{
 return a.x * b.x + a.y * b.y + a.z * b.z;
}

float length_sq(v3 a)
{
 return dot(a, a);
}

float length(v3 a)
{
 return sqrtf(dot(a, a));
}

v3 normalize(v3 a)
{
 float len = length_sq(a);

 if (len < 1e-9)
  return {};
 else
  return a / sqrtf(len);
}

v3 cross(v3 a, v3 b)
{
 return v3 {
  a.y * b.z - a.z * b.y,
  a.z * b.x - a.x * b.z,
  a.x * b.y - a.y * b.x
 };
}

v3 min(v3 a, v3 b)
{
 return V3(min(a.x, b.x), min(a.y, b.y), min(a.z, b.z));
}

v3 max(v3 a, v3 b)
{
 return V3(max(a.x, b.x), max(a.y, b.y), max(a.z, b.z));
}

bool v3_equal(v3 a, v3 b, float eps = 1e-6)
{
 return fabsf(a.x - b.x) < eps &&
     fabsf(a.y - b.y) < eps &&
     fabsf(a.z - b.z) < eps;
}

union v3i
{
 struct {
  int x, y, z;
 };
 int e[3];
};

v3i V3i(int x, int y, int z)
{
 return v3i{x, y, z};
}

v3i V3i(int x)
{
 return v3i{x, x, x};
}

v3 V3(v3i v)
{
 return v3{(float)v.x, (float)v.y, (float)v.z};
}

v3i operator+(v3i a, v3i b)
{
 return v3i{a.x + b.x, a.y + b.y, a.z + b.z};
}

v3i operator-(v3i a, v3i b)
{
 return v3i{a.x - b.x, a.y - b.y, a.z - b.z};
}

v3i operator-(v3i a)
{
 return v3i{-a.x, -a.y, -a.z};
}

v3i max(v3i a, v3i b)
{
 return V3i(max(a.x, b.x), max(a.y, b.y), max(a.z, b.z));
}

v3i min(v3i a, v3i b)
{
 return V3i(min(a.x, b.x), min(a.y, b.y), min(a.z, b.z));
}


union v4 {
 struct {
  float x, y, z, w;
 };
 struct {
  float r, g, b, a;
 };
 v3 xyz;
 float e[4];
};

v4 V4(float x, float y, float z, float w)
{
 v4 v;

 v.x = x, v.y = y, v.z = z, v.w = w;
 return v;
}

v4 V4(v3 xyz, float w)
{
 v4 v;

 v.xyz = xyz;
 v.w = w;
 return v;
}

v4 operator+(v4 a, v4 b)
{
 return v4{a.x + b.x, a.y + b.y, a.z + b.z, a.w + b.w};
}

v4 operator-(v4 a, v4 b)
{
 return v4{a.x - b.x, a.y - b.y, a.z - b.z, a.w - b.w};
}

v4 operator*(v4 a, float b)
{
 return v4{a.x * b, a.y * b, a.z * b, a.w * b};
}

float dot(v4 a, v4 b)
{
 return a.x * b.x + a.y * b.y + a.z * b.z + a.w * b.w;
}

v4 operator-(v4 a)
{
 return v4{-a.x, -a.y, -a.z, -a.w};
}

float length(v4 a)
{
 return sqrtf(dot(a, a));
}


union mat4
{
 float e[4][4];
 float v[16];
};

mat4 mat4_rows(v4 r0, v4 r1, v4 r2, v4 r3)
{
 mat4 m;

 m.e[0][0] = r0.e[0], m.e[0][1] = r0.e[1], m.e[0][2] = r0.e[2], m.e[0][3] = r0.e[3];
 m.e[1][0] = r1.e[0], m.e[3][1] = r1.e[1], m.e[1][2] = r1.e[2], m.e[1][3] = r1.e[3];
 m.e[2][0] = r2.e[0], m.e[2][1] = r2.e[1], m.e[2][2] = r2.e[2], m.e[2][3] = r2.e[3];
 m.e[3][0] = r3.e[0], m.e[1][1] = r3.e[1], m.e[3][2] = r3.e[2], m.e[3][3] = r3.e[3];
 return m;
}

mat4 mat4_cols(v4 c0, v4 c1, v4 c2, v4 c3)
{
 mat4 m;

 m.e[0][0] = c0.e[0], m.e[1][0] = c0.e[1], m.e[2][0] = c0.e[2], m.e[3][0] = c0.e[3];
 m.e[0][1] = c1.e[0], m.e[1][1] = c1.e[1], m.e[2][1] = c1.e[2], m.e[3][1] = c1.e[3];
 m.e[0][2] = c2.e[0], m.e[1][2] = c2.e[1], m.e[2][2] = c2.e[2], m.e[3][2] = c2.e[3];
 m.e[0][3] = c3.e[0], m.e[1][3] = c3.e[1], m.e[2][3] = c3.e[2], m.e[3][3] = c3.e[3];
 return m;
}

mat4 transpose(mat4 a)
{
 mat4 b;

 for (int i = 0; i < 4; i++)
  for (int j = 0; j < 4; j++)
   b.e[i][j] = a.e[j][i];
 return b;
}

mat4 operator*(mat4 a, mat4 b)
{
 mat4 c = {};

 for (int i = 0; i < 4; i++)
  for (int j = 0; j < 4; j++)
   for (int k = 0; k < 4; k++)
    c.e[i][j] += a.e[i][k] * b.e[k][j];
 return c;
}

v4 operator*(mat4 a, v4 b)
{
 v4 c;

 c.e[0] = a.e[0][0] * b.e[0] + a.e[0][1] * b.e[1] + a.e[0][2] * b.e[2] + a.e[0][3] * b.e[3];
 c.e[1] = a.e[1][0] * b.e[0] + a.e[1][1] * b.e[1] + a.e[1][2] * b.e[2] + a.e[1][3] * b.e[3];
 c.e[2] = a.e[2][0] * b.e[0] + a.e[2][1] * b.e[1] + a.e[2][2] * b.e[2] + a.e[2][3] * b.e[3];
 c.e[3] = a.e[3][0] * b.e[0] + a.e[3][1] * b.e[1] + a.e[3][2] * b.e[2] + a.e[3][3] * b.e[3];

 return c;
}

mat4 scale(float a)
{
 mat4 S = {};

 S.e[0][0] = S.e[1][1] = S.e[2][2] = a;
 S.e[3][3] = 1;
  return S;
}

mat4 scale(float x, float y, float z)
{
 mat4 S = {};

 S.e[0][0] = x;
 S.e[1][1] = y;
 S.e[2][2] = z;
 S.e[3][3] = 1;
 return S;
}

mat4 scale(v3 v)
{
 return scale(v.x, v.y, v.z);
}

mat4 identity()
{
 return scale(1);
}

mat4 translate(float x, float y, float z)
{
 mat4 T = identity();

 T.e[0][3] = x;
 T.e[1][3] = y;
 T.e[2][3] = z;
 return T;
}

mat4 translate(v3 t)
{
 return translate(t.x, t.y, t.z);
}

mat4 operator*(float a, mat4 b)
{
 mat4 c;

 for (int i = 0; i < 4; i++)
  for (int j = 0; j < 4; j++)
   c.e[i][j] = a * b.e[i][j];
 return c;
}

mat4 zrotation(float a)
{
 float c = cosf(a);
 float s = sinf(a);

 return {
  c, -s, 0, 0,
  s, c, 0, 0,
  0, 0, 1, 0,
  0, 0, 0, 1
 };
}

mat4 xrotation(float a)
{
 float c = cosf(a);
 float s = sinf(a);

 return {
  1, 0, 0, 0,
  0, c, -s, 0,
  0, s, c, 0,
  0, 0, 0, 1
 };
}

mat4 yrotation(float a)
{
 float c = cosf(a);
 float s = sinf(a);

 return {
  c, 0, s, 0,
  0, 1, 0, 0,
  -s, 0, c, 0,
  0, 0, 0, 1
 };
}

mat4 rotate_around_axis(v3 u, float a)
{
 u = normalize(u);
 float c = cosf(a);
 float s = sinf(a);

 return {
  c+u.x*u.x*(1-c), u.x*u.y*(1-c)-u.z*s, u.x*u.z*(1-c)+u.y*s, 0,
  u.y*u.x*(1-c)+u.z*s, c+u.y*u.y*(1-c), u.y*u.z*(1-c)-u.x*s, 0,
  u.z*u.x*(1-c)-u.y*s, u.z*u.y*(1-c)+u.x*s, c+u.z*u.z*(1-c), 0,
  0, 0, 0, 1
 };
}

mat4 perspective_projection(float znear, float zfar, float width_fov_degree, float height_over_width)
{
 float width = 2 * znear * tanf((3.14159265359f / 180.f) * (width_fov_degree / 2));
 float height = width * height_over_width;

 return {
  znear * 2 / width, 0, 0, 0,
  0, znear * 2 / height, 0, 0,



  0, 0, (zfar + znear) / (znear - zfar), 2 * znear * zfar / (znear - zfar),

  0, 0, -1, 0
 };
}

mat4 orthographic_projection(float znear, float zfar, float width, float height)
{
 return {
  2.f / width, 0, 0, 0,
  0, 2.f / height, 0, 0,



  0, 0, -2.f / (zfar-znear), (-znear-zfar) / (zfar-znear),

  0, 0, 0, 1
 };
}

mat4 lookat(v3 position, v3 dir, v3 up)
{
 v3 z_axis = normalize(-dir);


 v3 x_axis = normalize(cross(up, z_axis));
 v3 y_axis = normalize(cross(z_axis, x_axis));

 mat4 transform = {
  x_axis.x, x_axis.y, x_axis.z, 0,
  y_axis.x, y_axis.y, y_axis.z, 0,
  z_axis.x, z_axis.y, z_axis.z, 0,
  0, 0, 0, 1
 };

 return transform * translate(-position);
}

using quat = v4;

mat4 quat_to_mat(quat a)
{
 float x = a.x;
 float y = a.y;
 float z = a.z;
 float w = a.w;

 mat4 matrix;

 float wx, wy, wz, xx, yy, yz, xy, xz, zz;

 xx = x * x;
 xy = x * y;
 xz = x * z;
 yy = y * y;
 zz = z * z;
 yz = y * z;

 wx = w * x;
 wy = w * y;
 wz = w * z;

 matrix.v[0] = 1.0f - 2.0f*(yy + zz);
 matrix.v[4] = 2.0f*(xy - wz);
 matrix.v[8] = 2.0f*(xz + wy);
 matrix.v[12] = 0.0;

 matrix.v[1] = 2.0f*(xy + wz);
 matrix.v[5] = 1.0f - 2.0f*(xx + zz);
 matrix.v[9] = 2.0f*(yz - wx);
 matrix.v[13] = 0.0;

 matrix.v[2] = 2.0f*(xz - wy);
 matrix.v[6] = 2.0f*(yz + wx);
 matrix.v[10] = 1.0f - 2.0f*(xx + yy);
 matrix.v[14] = 0.0;

 matrix.v[3] = 0;
 matrix.v[7] = 0;
 matrix.v[11] = 0;
 matrix.v[15] = 1;

 return transpose(matrix);
}

quat quat_lerp(quat a, quat b, float t)
{
 float l2 = dot(a, b);
 if(l2 < 0.0f)
  b = -b;
 v4 c;


 c.x = a.x - t*(a.x - b.x);
 c.y = a.y - t*(a.y - b.y);
 c.z = a.z - t*(a.z - b.z);
 c.w = a.w - t*(a.w - b.w);
 return c * (1.f / length(c));
}

mat4 inverse(mat4 matrix) {
    const float *m = (float *)matrix.e;

    float t0 = m[10] * m[15];
    float t1 = m[14] * m[11];
    float t2 = m[6] * m[15];
    float t3 = m[14] * m[7];
    float t4 = m[6] * m[11];
    float t5 = m[10] * m[7];
    float t6 = m[2] * m[15];
    float t7 = m[14] * m[3];
    float t8 = m[2] * m[11];
    float t9 = m[10] * m[3];
    float t10 = m[2] * m[7];
    float t11 = m[6] * m[3];
    float t12 = m[8] * m[13];
    float t13 = m[12] * m[9];
    float t14 = m[4] * m[13];
    float t15 = m[12] * m[5];
    float t16 = m[4] * m[9];
    float t17 = m[8] * m[5];
    float t18 = m[0] * m[13];
    float t19 = m[12] * m[1];
    float t20 = m[0] * m[9];
    float t21 = m[8] * m[1];
    float t22 = m[0] * m[5];
    float t23 = m[4] * m[1];

    mat4 out_matrix;
    float *o = (float *)out_matrix.e;

    o[0] = (t0 * m[5] + t3 * m[9] + t4 * m[13]) -
           (t1 * m[5] + t2 * m[9] + t5 * m[13]);
    o[1] = (t1 * m[1] + t6 * m[9] + t9 * m[13]) -
           (t0 * m[1] + t7 * m[9] + t8 * m[13]);
    o[2] = (t2 * m[1] + t7 * m[5] + t10 * m[13]) -
           (t3 * m[1] + t6 * m[5] + t11 * m[13]);
    o[3] = (t5 * m[1] + t8 * m[5] + t11 * m[9]) -
           (t4 * m[1] + t9 * m[5] + t10 * m[9]);

    float d = 1.0f / (m[0] * o[0] + m[4] * o[1] + m[8] * o[2] + m[12] * o[3]);

    o[0] = d * o[0];
    o[1] = d * o[1];
    o[2] = d * o[2];
    o[3] = d * o[3];
    o[4] = d * ((t1 * m[4] + t2 * m[8] + t5 * m[12]) -
                (t0 * m[4] + t3 * m[8] + t4 * m[12]));
    o[5] = d * ((t0 * m[0] + t7 * m[8] + t8 * m[12]) -
                (t1 * m[0] + t6 * m[8] + t9 * m[12]));
    o[6] = d * ((t3 * m[0] + t6 * m[4] + t11 * m[12]) -
                (t2 * m[0] + t7 * m[4] + t10 * m[12]));
    o[7] = d * ((t4 * m[0] + t9 * m[4] + t10 * m[8]) -
                (t5 * m[0] + t8 * m[4] + t11 * m[8]));
    o[8] = d * ((t12 * m[7] + t15 * m[11] + t16 * m[15]) -
                (t13 * m[7] + t14 * m[11] + t17 * m[15]));
    o[9] = d * ((t13 * m[3] + t18 * m[11] + t21 * m[15]) -
                (t12 * m[3] + t19 * m[11] + t20 * m[15]));
    o[10] = d * ((t14 * m[3] + t19 * m[7] + t22 * m[15]) -
                 (t15 * m[3] + t18 * m[7] + t23 * m[15]));
    o[11] = d * ((t17 * m[3] + t20 * m[7] + t23 * m[11]) -
                 (t16 * m[3] + t21 * m[7] + t22 * m[11]));
    o[12] = d * ((t14 * m[10] + t17 * m[14] + t13 * m[6]) -
                 (t16 * m[14] + t12 * m[6] + t15 * m[10]));
    o[13] = d * ((t20 * m[14] + t12 * m[2] + t19 * m[10]) -
                 (t18 * m[10] + t21 * m[14] + t13 * m[2]));
    o[14] = d * ((t18 * m[6] + t23 * m[14] + t15 * m[2]) -
                 (t22 * m[14] + t14 * m[2] + t19 * m[6]));
    o[15] = d * ((t22 * m[10] + t16 * m[2] + t21 * m[6]) -
                 (t20 * m[6] + t23 * m[10] + t17 * m[2]));

    return out_matrix;
}

template<typename T>
T lerp(const T a, const T b, float t)
{
 return (1 - t) * a + t * b;
}

bool ray_hit_plane(v3 ray_origin, v3 ray_dir,
 v3 plane_normal, v3 plane_point, float *hit_t)
{
 float denom = dot(ray_dir, plane_normal);
 if (fabsf(denom) < 1e-5)
  return false;
 float t = (dot(plane_normal, plane_point) - dot(ray_origin, plane_normal)) / denom;
 if (t >= 0) {
  if (hit_t)
   *hit_t = t;
  return true;
 }
 return false;
}

void push_cube_outline(v3 p, v3 r, v3 color);

float ray_hit_box(v3 ray_origin, v3 ray_dir, v3 box_center, v3 box_xaxis,
 v3 box_yaxis, v3 box_zaxis)
{
 struct {
  v3 normal;
  v3 p;
 } planes[6];

 planes[0] = {box_xaxis, box_center + box_xaxis};
 planes[1] = {-box_xaxis, box_center - box_xaxis};
 planes[2] = {box_yaxis, box_center + box_yaxis};
 planes[3] = {-box_yaxis, box_center - box_yaxis};
 planes[4] = {box_zaxis, box_center + box_zaxis};
 planes[5] = {-box_zaxis, box_center - box_zaxis};

 float lx = length(box_xaxis);
 float ly = length(box_yaxis);
 float lz = length(box_zaxis);

 v3 xaxis = normalize(box_xaxis);
 v3 yaxis = normalize(box_yaxis);
 v3 zaxis = normalize(box_zaxis);

 float min_t = 3.40282346638528859811704183484516925e+38F;
 for (int i = 0; i < 6; i++) {






  float denom = dot(ray_dir, planes[i].normal);
  if (fabsf(denom) < 1e-6)
   continue ;
  float t = (dot(planes[i].normal, planes[i].p) - dot(ray_origin, planes[i].normal)) / denom;
  if (t >= 0 && t < min_t) {
   v3 p = ray_origin + t * ray_dir - box_center;
   float eps = 1e-4;
   if (dot(p, xaxis) >= -lx - eps && dot(p, xaxis) <= lx + eps &&
    dot(p, yaxis) >= -ly - eps && dot(p, yaxis) <= ly + eps &&
    dot(p, zaxis) >= -lz - eps && dot(p, zaxis) <= lz + eps)
    min_t = t;
  }
 }
 if (min_t == 3.40282346638528859811704183484516925e+38F)
  return -1;
 return min_t;
}
# 15 "code/game.cpp" 2
# 1 "code/platform.h" 1
       

enum GameButtonType
{
 BUTTON_A, BUTTON_B, BUTTON_C, BUTTON_D, BUTTON_E, BUTTON_F, BUTTON_G, BUTTON_H, BUTTON_I,
 BUTTON_J, BUTTON_K, BUTTON_L, BUTTON_M, BUTTON_N, BUTTON_O, BUTTON_P, BUTTON_Q, BUTTON_R,
 BUTTON_S, BUTTON_T, BUTTON_U, BUTTON_V, BUTTON_W, BUTTON_X, BUTTON_Y, BUTTON_Z,

 BUTTON_LEFT_CONTROL,
 BUTTON_LEFT_SHIFT,
 BUTTON_MOUSE_LEFT,
 BUTTON_MOUSE_RIGHT,
 BUTTON_SPACE,
 BUTTON_F1, BUTTON_F2, BUTTON_F3, BUTTON_F4, BUTTON_F5, BUTTON_F6,
 BUTTON_F7, BUTTON_F8, BUTTON_F9, BUTTON_F10, BUTTON_F11, BUTTON_F12,
 BUTTON_COUNT
};
# 29 "code/platform.h"
struct GameButton
{
 b32 is_down;
 b32 was_down;
};

struct GameInput
{
 GameButton buttons[BUTTON_COUNT];
 v2 mouse_dp;
 v2 mouse_p;
 v2 last_mouse_p;
};
# 109 "code/platform.h"
struct Platform {
 void *render_context;
 void *imgui_context;
 TempArena temp_arena;



};


typedef void game_update_and_render_fn(Platform &platform, Arena *memory, GameInput &input, float dt);
# 16 "code/game.cpp" 2
# 1 "code/renderer.h" 1
       

struct Texture
{



 uint32_t id;

 String name;
 b32 valid;
};

enum ShaderType
{
 SHADER_TYPE_VERTEX,
 SHADER_TYPE_FRAGMENT,
};

struct Shader
{
 ShaderType type;
# 31 "code/renderer.h"
 uint32_t id;

};

enum InputElementType
{
 INPUT_ELEMENT_FLOAT,
 INPUT_ELEMENT_SIGNED_INT,
};

struct VertexInputElement
{
 int offset;
 int count;
 InputElementType type;
 const char *name;
};

enum PrimitiveType
{
 PRIMITIVE_TRIANGLES,
 PRIMITIVE_LINES,
};

enum VertexBufferUsage
{
 VERTEX_BUFFER_IMMUTABLE,
 VERTEX_BUFFER_DYNAMIC,
};

struct VertexBuffer
{
 usize size;
 VertexBufferUsage usage;




 uint32_t vao;
 uint32_t vbo;

};

struct FrameBuffer
{




 uint32_t id;

};

struct DepthStencilState
{
 bool enable_depth;



};

enum RasterizerFillMode
{
 RASTERIZER_FILL_SOLID,
 RASTERIZER_FILL_WIREFRAME
};

enum RasterizerCullMode
{
 RASTERIZER_CULL_NONE,
 RASTERIZER_CULL_FRONT,
 RASTERIZER_CULL_BACK,
};

struct RasterizerState
{
 RasterizerFillMode fillmode;
 RasterizerCullMode cullmode;



};

struct VertexInputLayout
{
 VertexInputElement elements[64];
 int element_count;
 int vertex_size;



};

struct RenderPass
{
 PrimitiveType primitive_type;

 Shader vs;
 Shader fs;
 DepthStencilState depth_stencil_state;
 RasterizerState rasterizer_state;
 VertexInputLayout input_layout;

 uint32_t program;
};

struct RenderContext
{
 int window_width;
 int window_height;

 FrameBuffer window_framebuffer;







 GLFWwindow *window;

 GL_FUNCTIONS(X)



    Array<Texture> loaded_textures;

    RenderPass *render_pass;
 Texture white_texture;

 Array<v3> debug_lines;

 uintptr_t active_framebuffer_id;


};

usize get_input_element_size(int type)
{
    if (type == INPUT_ELEMENT_FLOAT)
        return sizeof(float);
    else if (type == INPUT_ELEMENT_SIGNED_INT)
        return sizeof(int);
    else
        
# 175 "code/renderer.h" 3 4
       (static_cast <bool> (
# 175 "code/renderer.h"
       0
# 175 "code/renderer.h" 3 4
       ) ? void (0) : __assert_fail (
# 175 "code/renderer.h"
       "0"
# 175 "code/renderer.h" 3 4
       , "code/renderer.h", 175, __extension__ __PRETTY_FUNCTION__))
# 175 "code/renderer.h"
                ;
    return 0;
}

enum ConstantBufferElementType
{
 CONSTANT_BUFFER_ELEMENT_MAT4,
 CONSTANT_BUFFER_ELEMENT_VEC4,
 CONSTANT_BUFFER_ELEMENT_VEC3,
 CONSTANT_BUFFER_ELEMENT_VEC2,
 CONSTANT_BUFFER_ELEMENT_FLOAT,
 CONSTANT_BUFFER_ELEMENT_INT,
 CONSTANT_BUFFER_ELEMENT_COUNT
};

int get_c_type_alignement(ConstantBufferElementType type)
{
 switch (type) {
  case CONSTANT_BUFFER_ELEMENT_MAT4: return alignof(mat4);
  case CONSTANT_BUFFER_ELEMENT_VEC4: return alignof(v4);
  case CONSTANT_BUFFER_ELEMENT_VEC3: return alignof(v3);
  case CONSTANT_BUFFER_ELEMENT_VEC2: return alignof(v2);
  case CONSTANT_BUFFER_ELEMENT_FLOAT: return alignof(float);
  case CONSTANT_BUFFER_ELEMENT_INT: return alignof(int);
  default: 
# 199 "code/renderer.h" 3 4
          (static_cast <bool> (
# 199 "code/renderer.h"
          0
# 199 "code/renderer.h" 3 4
          ) ? void (0) : __assert_fail (
# 199 "code/renderer.h"
          "0"
# 199 "code/renderer.h" 3 4
          , "code/renderer.h", 199, __extension__ __PRETTY_FUNCTION__))
# 199 "code/renderer.h"
                   ;
 }
 return 0;
}

struct ConstantBufferElement
{
 ConstantBufferElementType type;
 int array_size;
};

struct ConstantBuffer
{
 usize size;
 ConstantBufferElement elements[64];
 int element_count;



 uint32_t id;

};
# 17 "code/game.cpp" 2

static RenderContext *g_rc;




# 1 "code/renderer_opengl.cpp" 1



Texture create_texture(String name, void *data, int width, int height, bool srgb = true,
  bool mipmapping = true)
{
 Texture texture = {};

 texture.name = name;
 texture.valid = true;

 uint32_t internal_format, format;

 if (srgb)
  internal_format = 0x8C42;
 else
  internal_format = 0x1908;

 format = 0x1908;

 uint32_t tex;
 glad_glGenTextures(1, &tex);

 glad_glBindTexture(0x0DE1, tex);
 glad_glTexParameteri(0x0DE1, 0x2802, 0x2901);
 glad_glTexParameteri(0x0DE1, 0x2803, 0x2901);
 if (mipmapping)
  glad_glTexParameteri(0x0DE1, 0x2801,
    0x2703);
 else
  glad_glTexParameteri(0x0DE1, 0x2801,
    0x2601);
 glad_glTexParameteri(0x0DE1, 0x2800, 0x2601);

 glad_glTexImage2D(0x0DE1, 0, internal_format, width, height, 0, format,
   0x1401, data);
 if (mipmapping)
  glad_glGenerateMipmap(0x0DE1);

 texture.id = tex;
 return texture;
}

void bind_texture(int index, Texture &texture)
{
 glad_glActiveTexture(0x84C0 + index);
 glad_glBindTexture(0x0DE1, (uintptr_t)texture.id);
}

Shader load_shader(String filename, ShaderType type, const char *main = "")
{
 (void)main;

 Shader result = {};

 result.type = type;

 Arena *temp = begin_temp_memory();

 String content = load_entire_file(temp, filename);
 int gl_type = 0;
 if (type == SHADER_TYPE_VERTEX)
  gl_type = 0x8B31;
 else if (type == SHADER_TYPE_FRAGMENT)
  gl_type = 0x8B30;
 else
  
# 67 "code/renderer_opengl.cpp" 3 4
 (static_cast <bool> (
# 67 "code/renderer_opengl.cpp"
 0
# 67 "code/renderer_opengl.cpp" 3 4
 ) ? void (0) : __assert_fail (
# 67 "code/renderer_opengl.cpp"
 "0"
# 67 "code/renderer_opengl.cpp" 3 4
 , "code/renderer_opengl.cpp", 67, __extension__ __PRETTY_FUNCTION__))
# 67 "code/renderer_opengl.cpp"
          ;

 uint32_t shader = glad_glCreateShader(gl_type);
 glad_glShaderSource(shader, 1, &content.data, (GLint *)&content.count);

 end_temp_memory();

 glad_glCompileShader(shader);

 int success;
 glad_glGetShaderiv(shader, 0x8B81, &success);
 if (!success) {
  printf("OPENGL: failed to compile shader \"%.*s\": ", (int)filename.count, filename.data);

  char info_log[2048];
  glad_glGetShaderInfoLog(shader, sizeof(info_log), 0, info_log);
  printf("%s\n", info_log);
  
# 84 "code/renderer_opengl.cpp" 3 4
 (static_cast <bool> (
# 84 "code/renderer_opengl.cpp"
 0
# 84 "code/renderer_opengl.cpp" 3 4
 ) ? void (0) : __assert_fail (
# 84 "code/renderer_opengl.cpp"
 "0"
# 84 "code/renderer_opengl.cpp" 3 4
 , "code/renderer_opengl.cpp", 84, __extension__ __PRETTY_FUNCTION__))
# 84 "code/renderer_opengl.cpp"
          ;
 }

 result.id = shader;
 return result;

}

RasterizerState create_rasterizer_state(RasterizerFillMode fillmode, RasterizerCullMode cullmode)
{
 RasterizerState result = {};

 result.fillmode = fillmode;
 result.cullmode = cullmode;

 return result;
}

DepthStencilState create_depth_stencil_state(bool enable_depth)
{
 DepthStencilState result = {};

 result.enable_depth = enable_depth;
 return result;
}

void bind_rasterizer_state(const RasterizerState &state)
{
 if (state.fillmode == RASTERIZER_FILL_SOLID)
  glad_glPolygonMode(0x0408, 0x1B02);
 else if (state.fillmode == RASTERIZER_FILL_WIREFRAME)
  glad_glPolygonMode(0x0408, 0x1B01);

 if (state.cullmode == RASTERIZER_CULL_NONE)
  glad_glDisable(0x0B44);
 else if (state.cullmode == RASTERIZER_CULL_FRONT) {
  glad_glEnable(0x0B44);
  glad_glCullFace(0x0404);
 }
 else if (state.cullmode == RASTERIZER_CULL_BACK) {
  glad_glEnable(0x0B44);
  glad_glCullFace(0x0405);
 }
}

void bind_depth_stencil_state(const DepthStencilState &state)
{
 if (state.enable_depth)
  glad_glEnable(0x0B71);
 else
  glad_glDisable(0x0B71);
}

VertexInputLayout create_vertex_input_layout(VertexInputElement *elements, int element_count,
  int vertex_size)
{
 VertexInputLayout result = {};

 result.vertex_size = vertex_size;
 result.element_count = element_count;
 for (int i = 0; i < element_count; i++)
  result.elements[i] = elements[i];

 return result;
}

RenderPass create_render_pass(Shader vs, Shader fs,
  PrimitiveType primitive_type, const DepthStencilState &depth_stencil_state,
  const RasterizerState &rasterizer_state, const VertexInputLayout &input_layout)
{
 RenderPass rp = {};

 rp.vs = vs;
 rp.fs = fs;
 rp.depth_stencil_state = depth_stencil_state;
 rp.rasterizer_state = rasterizer_state;
 rp.primitive_type = primitive_type;
 rp.input_layout = input_layout;

 rp.program = glad_glCreateProgram();

 glad_glAttachShader(rp.program, vs.id);
 glad_glAttachShader(rp.program, fs.id);
 glad_glLinkProgram(rp.program);

 int success;
 glad_glGetProgramiv(rp.program, 0x8B82, &success);
 if (!success) {
  char info_log[2048];
  glad_glGetProgramInfoLog(rp.program, sizeof(info_log), 0, info_log);
  printf("failed to link program: %s\n", info_log);
  
# 175 "code/renderer_opengl.cpp" 3 4
 (static_cast <bool> (
# 175 "code/renderer_opengl.cpp"
 0
# 175 "code/renderer_opengl.cpp" 3 4
 ) ? void (0) : __assert_fail (
# 175 "code/renderer_opengl.cpp"
 "0"
# 175 "code/renderer_opengl.cpp" 3 4
 , "code/renderer_opengl.cpp", 175, __extension__ __PRETTY_FUNCTION__))
# 175 "code/renderer_opengl.cpp"
          ;
 }

 return rp;
}

void begin_render_pass(RenderPass &rp)
{
 g_rc->render_pass = &rp;
 glad_glUseProgram(rp.program);
 bind_depth_stencil_state(rp.depth_stencil_state);
 bind_rasterizer_state(rp.rasterizer_state);
}

void end_render_pass()
{
 g_rc->render_pass = 0;
}

void set_viewport(float top_left_x, float top_left_y, float width, float height)
{
 glad_glViewport(top_left_x, top_left_y, width, height);
}

void bind_framebuffer(FrameBuffer &framebuffer)
{

 glad_glBindFramebuffer(0x8D40, framebuffer.id);
}

void clear_framebuffer_color(FrameBuffer &framebuffer, v4 color)
{
 bind_framebuffer(framebuffer);
 glad_glClearColor(color.x, color.y, color.z, color.w);
 glad_glClear(0x00004000);
}

void clear_framebuffer_depth(FrameBuffer &framebuffer, float depth)
{
 bind_framebuffer(framebuffer);
 glad_glClearDepth(depth);
 glad_glClear(0x00000100);
}

VertexBuffer create_vertex_buffer(VertexBufferUsage usage, usize size, void *data = 0)
{
 VertexBuffer result = {};

 result.usage = usage;
 result.size = size;

 glad_glGenVertexArrays(1, &result.vao);
 glad_glBindVertexArray(result.vao);

 glad_glGenBuffers(1, &result.vbo);
 glad_glBindBuffer(0x8892, result.vbo);
 if (data)
  glad_glBufferData(0x8892, size, data, usage == VERTEX_BUFFER_IMMUTABLE ? 0x88E4 : 0x88E8);

 return result;
}

void update_vertex_buffer(VertexBuffer &vb, int size, void *data)
{
 
# 239 "code/renderer_opengl.cpp" 3 4
(static_cast <bool> (
# 239 "code/renderer_opengl.cpp"
vb.usage == VERTEX_BUFFER_DYNAMIC
# 239 "code/renderer_opengl.cpp" 3 4
) ? void (0) : __assert_fail (
# 239 "code/renderer_opengl.cpp"
"vb.usage == VERTEX_BUFFER_DYNAMIC"
# 239 "code/renderer_opengl.cpp" 3 4
, "code/renderer_opengl.cpp", 239, __extension__ __PRETTY_FUNCTION__))
# 239 "code/renderer_opengl.cpp"
                                         ;
 glad_glBindVertexArray(vb.vao);
 glad_glBindBuffer(0x8892, vb.vbo);
 glad_glBufferData(0x8892, size, data, 0x88E8);
}

void bind_vertex_buffer(VertexBuffer &vb)
{
 auto &layout = g_rc->render_pass->input_layout;

 glad_glBindVertexArray(vb.vao);
 glad_glBindBuffer(0x8892, vb.vbo);

 for (int i = 0; i < layout.element_count; i++) {
  int type = 0;
  if (layout.elements[i].type == INPUT_ELEMENT_FLOAT)
   type = 0x1406;
  else if (layout.elements[i].type == INPUT_ELEMENT_SIGNED_INT)
   type = 0x1404;
  else
   
# 259 "code/renderer_opengl.cpp" 3 4
  (static_cast <bool> (
# 259 "code/renderer_opengl.cpp"
  0
# 259 "code/renderer_opengl.cpp" 3 4
  ) ? void (0) : __assert_fail (
# 259 "code/renderer_opengl.cpp"
  "0"
# 259 "code/renderer_opengl.cpp" 3 4
  , "code/renderer_opengl.cpp", 259, __extension__ __PRETTY_FUNCTION__))
# 259 "code/renderer_opengl.cpp"
           ;

  glad_glVertexAttribPointer(i, layout.elements[i].count,
    type, 0, (GLsizei) layout.vertex_size, (void *)layout.elements[i].offset);
  glad_glEnableVertexAttribArray(i);
 }
}

void draw(int offset, int vertices_count)
{
 int mode = 0;
 if (g_rc->render_pass->primitive_type == PRIMITIVE_TRIANGLES)
  mode = 0x0004;
 else if (g_rc->render_pass->primitive_type == PRIMITIVE_LINES)
  mode = 0x0001;
 else
  
# 275 "code/renderer_opengl.cpp" 3 4
 (static_cast <bool> (
# 275 "code/renderer_opengl.cpp"
 0
# 275 "code/renderer_opengl.cpp" 3 4
 ) ? void (0) : __assert_fail (
# 275 "code/renderer_opengl.cpp"
 "0"
# 275 "code/renderer_opengl.cpp" 3 4
 , "code/renderer_opengl.cpp", 275, __extension__ __PRETTY_FUNCTION__))
# 275 "code/renderer_opengl.cpp"
          ;
 glad_glDrawArrays(mode, offset, vertices_count);
}

int get_constant_buffer_element_size(int type)
{
 int size[] = {
  sizeof(mat4),
  sizeof(v4),
  sizeof(v3),
  sizeof(v2),
  sizeof(float),
  sizeof(int)
 };
 static_assert((sizeof(size) / sizeof(*size)) == CONSTANT_BUFFER_ELEMENT_COUNT);
 return size[type];
}


int get_constant_buffer_element_alignement(int type)
{
 int align[] = {
  alignof(mat4),
  alignof(v4),
  alignof(v3),
  alignof(v2),
  alignof(float),
  alignof(int)
 };
 static_assert((sizeof(align) / sizeof(*align)) == CONSTANT_BUFFER_ELEMENT_COUNT);
 return align[type];
}

int get_type_alignement(ConstantBufferElement e)
{
 int align = 0;
 if (e.array_size > 0)
  align = 4 * alignof(float);
 else if (e.type == CONSTANT_BUFFER_ELEMENT_VEC2)
  align = 2 * alignof(float);
 else if (e.type == CONSTANT_BUFFER_ELEMENT_VEC3 || e.type == CONSTANT_BUFFER_ELEMENT_VEC4
   || e.type == CONSTANT_BUFFER_ELEMENT_MAT4)
  align = 4 * alignof(float);
 else if (e.type == CONSTANT_BUFFER_ELEMENT_INT || e.type == CONSTANT_BUFFER_ELEMENT_FLOAT)
  align = alignof(float);
 else
  
# 321 "code/renderer_opengl.cpp" 3 4
 (static_cast <bool> (
# 321 "code/renderer_opengl.cpp"
 0
# 321 "code/renderer_opengl.cpp" 3 4
 ) ? void (0) : __assert_fail (
# 321 "code/renderer_opengl.cpp"
 "0"
# 321 "code/renderer_opengl.cpp" 3 4
 , "code/renderer_opengl.cpp", 321, __extension__ __PRETTY_FUNCTION__))
# 321 "code/renderer_opengl.cpp"
          ;
 return align;
}

int get_type_size(ConstantBufferElement e)
{
 return get_constant_buffer_element_size(e.type);
}

ConstantBuffer create_constant_buffer(Array<ConstantBufferElement> elements)
{
 ConstantBuffer result = {};

 
# 334 "code/renderer_opengl.cpp" 3 4
(static_cast <bool> (
# 334 "code/renderer_opengl.cpp"
elements.count < (sizeof(result.elements) / sizeof(*result.elements))
# 334 "code/renderer_opengl.cpp" 3 4
) ? void (0) : __assert_fail (
# 334 "code/renderer_opengl.cpp"
"elements.count < ARRAY_SIZE(result.elements)"
# 334 "code/renderer_opengl.cpp" 3 4
, "code/renderer_opengl.cpp", 334, __extension__ __PRETTY_FUNCTION__))
# 334 "code/renderer_opengl.cpp"
                                                    ;
 int offset = 0;
 for (int i = 0; i < elements.count; i++) {
  result.elements[i] = elements[i];

  offset = align_to(offset, get_type_alignement(elements[i]))
   + get_type_size(elements[i]) * (elements[i].array_size ? elements[i].array_size : 1);
 }

 result.element_count = elements.count;
 result.size = offset;

 glad_glGenBuffers(1, &result.id);
 glad_glBindBuffer(0x8A11, result.id);

 glad_glBufferData(0x8A11, result.size, 0, 0x88E8);

 return result;
}

void update_constant_buffer(ConstantBuffer &buffer, void *data)
{
 char dest[sizeof(mat4) * 512] = {};

 
# 358 "code/renderer_opengl.cpp" 3 4
(static_cast <bool> (
# 358 "code/renderer_opengl.cpp"
buffer.size < sizeof(dest)
# 358 "code/renderer_opengl.cpp" 3 4
) ? void (0) : __assert_fail (
# 358 "code/renderer_opengl.cpp"
"buffer.size < sizeof(dest)"
# 358 "code/renderer_opengl.cpp" 3 4
, "code/renderer_opengl.cpp", 358, __extension__ __PRETTY_FUNCTION__))
# 358 "code/renderer_opengl.cpp"
                                  ;

 int cstruct_offset = 0;
 int ubo_offset = 0;

 for (int i = 0; i < buffer.element_count; i++) {
  ConstantBufferElement e = buffer.elements[i];

  ubo_offset = align_to(ubo_offset, get_type_alignement(e));
  cstruct_offset = align_to(cstruct_offset, get_constant_buffer_element_alignement(e.type));

  int count = e.array_size ? e.array_size : 1;
  for (int j = 0; j < count; j++) {
   memcpy(dest + ubo_offset, (char *)data + cstruct_offset, get_constant_buffer_element_size(e.type));
   ubo_offset += get_type_size(e);
   cstruct_offset += get_constant_buffer_element_size(e.type);
  }
 }


 glad_glBindBuffer(0x8A11, buffer.id);

 glad_glBufferSubData(0x8A11, 0, buffer.size, (void *)dest);
}

void bind_constant_buffer(ConstantBuffer &cbuffer, int index)
{
 glad_glBindBufferBase(0x8A11, index, cbuffer.id);
}

void begin_render_frame()
{
 glfwGetFramebufferSize(g_rc->window, &g_rc->window_width, &g_rc->window_height);
 g_rc->debug_lines.count = 0;
 ImGui_ImplGlfw_NewFrame();
 ImGui_ImplOpenGL3_NewFrame();
 ImGui::NewFrame();
}

void end_render_frame()
{
 bind_framebuffer(g_rc->window_framebuffer);
 ImGui::Render();
 ImGui_ImplOpenGL3_RenderDrawData(ImGui::GetDrawData());
}

void gl_debug_output(GLenum source, GLenum type, unsigned int id,
  GLenum severity, GLsizei length,
  const char *message, const void *userParam) {

 if (id == 131169 || id == 131185 || id == 131218 || id == 131204)
  return;

 printf("---------------\nOPENGL Debug: (%d): %s\n", id, message);
 printf("Sorce: ");
 switch (source) {
  case 0x8246: printf("API"); break;
  case 0x8247: printf("Window System"); break;
  case 0x8248: printf("Shader Compiled"); break;
  case 0x8249: printf("Third Party"); break;
  case 0x824A: printf("Application"); break;
  case 0x824B: printf("Other"); break;
 }
 printf("\nType: ");

 switch (type) {
  case 0x824C: printf("Error"); break;
  case 0x824D: printf("Deprecated Behaviour"); break ;
  case 0x824E: printf("Undefined Behaviour"); break;
  case 0x824F: printf("Portability"); break;
  case 0x8250: printf("Performance"); break;
  case 0x8268: printf("Marker"); break;
  case 0x8269: printf("Push Group"); break;
  case 0x826A: printf("Pop Group"); break;
  case 0x8251: printf("Other"); break;
 }
 printf("\nSeverity: ");

 switch (severity) {
  case 0x9146: printf("high"); break;
  case 0x9147: printf("meduim"); break;
  case 0x9148: printf("low"); break;
  case 0x826B: printf("notification"); break;
 }
 printf("\n\n");
}

void init_render_context_opengl(RenderContext &rc, Platform &platform)
{
 rc.window = platform.window;

 int flags;
 glad_glGetIntegerv(0x821E, &flags);
 if (flags & 0x00000002) {
  glad_glEnable(0x8242);
  glad_glEnable(0x92E0);
  glad_glDebugMessageCallback(gl_debug_output, nullptr);
  glad_glDebugMessageControl(0x1100, 0x1100, 0x1100, 0,
    nullptr, 1);
 }

 rc.window_framebuffer.id = 0;
 glad_glEnable(0x8DB9);
}


Texture create_depth_texture(int width, int height)
{
 Texture result = {};

 uint32_t texture;

 glad_glGenTextures(1, &texture);
 glad_glBindTexture(0x0DE1, texture);
 glad_glTexImage2D(0x0DE1, 0, 0x1902, width, height,
   0, 0x1902, 0x1406, 0);
 glad_glTexParameteri(0x0DE1, 0x2801, 0x2600);
 glad_glTexParameteri(0x0DE1, 0x2800, 0x2600);
 glad_glTexParameteri(0x0DE1, 0x2802, 0x812F);
 glad_glTexParameteri(0x0DE1, 0x2803, 0x812F);

 result.id = texture;
 result.valid = true;
 result.name = make_cstring("shadow map depth texture");
 return result;
}

FrameBuffer create_frame_buffer()
{
 FrameBuffer result = {};
 uint32_t fbo;

 glad_glGenFramebuffers(1, &fbo);
 glad_glBindFramebuffer(0x8D40, fbo);
 glad_glDrawBuffer(0);
 glad_glReadBuffer(0);



 result.id = fbo;
 return result;
}

void bind_framebuffer_depthbuffer(FrameBuffer &framebuffer, Texture &texture)
{
 bind_framebuffer(framebuffer);
 glad_glFramebufferTexture2D(0x8D40, 0x8D00, 0x0DE1,
   texture.id, 0);
 glad_glLineWidth(1.5f);
}
# 24 "code/game.cpp" 2


# 1 "code/scene.h" 1
       




struct Vertex
{
 v3 position;
 v3 normal;
 v2 uv;

 float weights[4];
 float indices[4];
};

VertexInputElement g_vertex_input_elements[] = {
 {
# 17 "code/scene.h" 3 4
 __builtin_offsetof (
# 17 "code/scene.h"
 Vertex
# 17 "code/scene.h" 3 4
 , 
# 17 "code/scene.h"
 position
# 17 "code/scene.h" 3 4
 )
# 17 "code/scene.h"
                           , 3, INPUT_ELEMENT_FLOAT, "POSITION"},
 {
# 18 "code/scene.h" 3 4
 __builtin_offsetof (
# 18 "code/scene.h"
 Vertex
# 18 "code/scene.h" 3 4
 , 
# 18 "code/scene.h"
 normal
# 18 "code/scene.h" 3 4
 )
# 18 "code/scene.h"
                         , 3, INPUT_ELEMENT_FLOAT, "NORMAL"},
 {
# 19 "code/scene.h" 3 4
 __builtin_offsetof (
# 19 "code/scene.h"
 Vertex
# 19 "code/scene.h" 3 4
 , 
# 19 "code/scene.h"
 uv
# 19 "code/scene.h" 3 4
 )
# 19 "code/scene.h"
                     , 2, INPUT_ELEMENT_FLOAT, "TEXCOORD"},
 {
# 20 "code/scene.h" 3 4
 __builtin_offsetof (
# 20 "code/scene.h"
 Vertex
# 20 "code/scene.h" 3 4
 , 
# 20 "code/scene.h"
 weights
# 20 "code/scene.h" 3 4
 )
# 20 "code/scene.h"
                          , 4, INPUT_ELEMENT_FLOAT, "BLENDWEIGHT"},
 {
# 21 "code/scene.h" 3 4
 __builtin_offsetof (
# 21 "code/scene.h"
 Vertex
# 21 "code/scene.h" 3 4
 , 
# 21 "code/scene.h"
 indices
# 21 "code/scene.h" 3 4
 )
# 21 "code/scene.h"
                          , 4, INPUT_ELEMENT_FLOAT, "BLENDINDICES"},
};

struct Material
{
 Texture diffuse;
 Texture normal_map;
 Texture specular;
 Texture ambient;
 Texture specular_exponent;

 float diffuse_factor;
 float specular_factor;
 float specular_exponent_factor;
};

struct MeshPart
{
 Material material;
 usize vertices_count;
 usize offset;
};

struct Bone
{
 String name;
 mat4 transform;
 mat4 inv_bind;
 int parent;
};

struct Mesh
{
 String name;
 Array<MeshPart> parts;
 VertexBuffer vertex_buffer;
 Array<Bone> bones;
 v3 box_min;
 v3 box_max;
 mat4 transform;
};

struct NodeAnimation
{
 String name;
 Array<v3> position;
 Array<v3> scale;
 Array<quat> rotation;

 v3 const_position;
 v3 const_scale;
 quat const_rotation;

 mat4 transform;
};

struct Animation
{
 float timebegin;
 float duration;

 float frametime;

 int frame_count;

 Array<NodeAnimation> nodes;
};

struct SceneNode
{
 String name;
 SceneNode *parent;
 Array<SceneNode *> childs;
 Mesh *mesh;
 mat4 local_transform;
 mat4 geometry_transform;
 int id;
 b32 skip_render;
};

struct Scene
{
 Array<SceneNode> nodes;
 Array<Mesh> meshes;

 SceneNode *root;
 Array<Animation> animations;
 String path;
};
# 27 "code/game.cpp" 2
# 1 "code/scene.cpp" 1



v3 ufbx_to_v3(ufbx_vec3 v)
{
 return v3{(float)v.x, (float)v.y, (float)v.z};
}

v2 ufbx_to_v2(ufbx_vec2 v)
{
 return v2{(float)v.x, (float)v.y};
}

quat ufbx_to_quat(ufbx_quat q)
{
 return quat{(float)q.x, (float)q.y, (float)q.z, (float)q.w};
}

mat4 ufbx_to_mat4(ufbx_matrix m)
{
 mat4 result = {};

 for (int i = 0; i < 4; i++) {
  result.e[0][i] = m.cols[i].x;
  result.e[1][i] = m.cols[i].y;
  result.e[2][i] = m.cols[i].z;
 }

 result.e[3][3] = 1;

 return (result);
}


Arena *g_stb_image_arena;

Texture load_texture(Arena *arena, Scene &scene, ufbx_texture *utex, bool srgb = true)
{
 
# 39 "code/scene.cpp" 3 4
(static_cast <bool> (
# 39 "code/scene.cpp"
utex->type == UFBX_TEXTURE_FILE
# 39 "code/scene.cpp" 3 4
) ? void (0) : __assert_fail (
# 39 "code/scene.cpp"
"utex->type == UFBX_TEXTURE_FILE"
# 39 "code/scene.cpp" 3 4
, "code/scene.cpp", 39, __extension__ __PRETTY_FUNCTION__))
# 39 "code/scene.cpp"
                                       ;

 void *data;
 int width, height, n_channels;

 stbi_set_flip_vertically_on_load(true);

 String name = make_string(arena, utex->filename.length, utex->filename.data);

 if (name.count) {
  for (int i = 0; i < g_rc->loaded_textures.count; i++) {
   if (strings_equal(g_rc->loaded_textures[i].name, name))
    return g_rc->loaded_textures[i];
  }
 }
 g_stb_image_arena = begin_temp_memory();
 if (utex->content.size) {
  data = stbi_load_from_memory((stbi_uc *)utex->content.data,
    (int)utex->content.size, &width, &height,
    &n_channels, 4);
 } else {
  int last_slash = (int)utex->filename.length - 1;

  while (last_slash >= 0 &&
    (utex->filename.data[last_slash] != '/' &&
     utex->filename.data[last_slash] != '\\'))
   last_slash--;
  last_slash++;

  String path = concact_string(g_stb_image_arena, scene.path, make_string(g_stb_image_arena, utex->filename.length - last_slash, utex->filename.data + last_slash));
  path = concact_string(g_stb_image_arena, path, make_string(g_stb_image_arena, 1, ""));
  data = stbi_load(path.data, &width, &height, &n_channels, 4);
  if (!data)
   printf("failed to load texture file: %s\n", path.data);
 }
 
# 74 "code/scene.cpp" 3 4
(static_cast <bool> (
# 74 "code/scene.cpp"
data
# 74 "code/scene.cpp" 3 4
) ? void (0) : __assert_fail (
# 74 "code/scene.cpp"
"data"
# 74 "code/scene.cpp" 3 4
, "code/scene.cpp", 74, __extension__ __PRETTY_FUNCTION__))
# 74 "code/scene.cpp"
            ;
 end_temp_memory();

 Texture texture = create_texture(name, data, width, height, srgb);
 if (name.count)
  g_rc->loaded_textures.push(texture);

 return texture;
}

Material load_material(Arena *arena, Scene &scene, ufbx_material *umat)
{
 Material mat = {};

 if (umat->fbx.diffuse_color.texture_enabled)
  mat.diffuse = load_texture(arena, scene, umat->fbx.diffuse_color.texture);
 if (umat->fbx.specular_color.texture_enabled)
  mat.specular = load_texture(arena, scene, umat->fbx.specular_color.texture);
 if (umat->fbx.normal_map.texture_enabled)
  mat.normal_map = load_texture(arena, scene, umat->fbx.normal_map.texture, false);
 else if (umat->fbx.bump.texture_enabled)
  mat.normal_map = load_texture(arena, scene, umat->fbx.bump.texture, false);

 if (umat->fbx.specular_exponent.texture_enabled)
  mat.specular_exponent = load_texture(arena, scene, umat->fbx.specular_exponent.texture, false);

 mat.diffuse_factor = umat->fbx.diffuse_factor.has_value ? umat->fbx.diffuse_factor.value_real : 1;
 mat.specular_factor = umat->fbx.specular_factor.has_value ? umat->fbx.specular_factor.value_real : 1;
 mat.specular_exponent_factor = umat->fbx.specular_exponent.has_value ? umat->fbx.specular_exponent.value_real : 20;
 return mat;
}

Vertex get_ufbx_vertex(ufbx_mesh *umesh, ufbx_skin_deformer *skin, int index)
{
 Vertex v = {};

 v.position = ufbx_to_v3(ufbx_get_vertex_vec3(&umesh->vertex_position, index));
 v.normal = ufbx_to_v3(ufbx_get_vertex_vec3(&umesh->vertex_normal, index));
 if (umesh->vertex_uv.exists)
  v.uv = ufbx_to_v2(ufbx_get_vertex_vec2(&umesh->vertex_uv, index));

 if (skin) {
  uint32_t vertex = umesh->vertex_indices.data[index];

  ufbx_skin_vertex skin_vertex = skin->vertices.data[vertex];
  size_t num_weights = skin_vertex.num_weights;
  if (num_weights > 4)
   num_weights = 4;

  float total_weight = 0.0f;
  for (size_t i = 0; i < num_weights; i++) {
   ufbx_skin_weight skin_weight = skin->weights.data[skin_vertex.weight_begin + i];
   v.indices[i] = skin_weight.cluster_index;
   v.weights[i] = (float)skin_weight.weight;
   total_weight += (float)skin_weight.weight;
  }

  for (size_t i = 0; i < num_weights; i++)
   v.weights[i] /= total_weight;
 }
 return v;
}

void make_bones_transform_relative_to_parent(Array<Bone> bones, usize index, Array<bool> computed)
{
 if (computed[index] || bones[index].parent == -1)
  return ;
 make_bones_transform_relative_to_parent(bones, bones[index].parent, computed);
 mat4 M = identity();
 int i = bones[index].parent;
 while (i != -1)
 {
  M = bones[i].transform * M;
  i = bones[i].parent;
 }
 bones[index].transform = inverse(M) * bones[index].transform;
 computed[index] = true;
}

Mesh load_mesh(Arena *arena, Scene &scene, ufbx_node *unode)
{
 ufbx_mesh *umesh = unode->mesh;
 Mesh mesh = {};

 mesh.name = make_string(arena, unode->name.length, unode->name.data);
 mesh.parts = make_array<MeshPart>(arena, umesh->material_parts.count);

 Arena *tmp_arena = begin_temp_memory();

 Array<uint32_t> tri_indices = make_array<uint32_t>(tmp_arena, umesh->max_face_triangles * 3);

 Array<Vertex> vertices = make_array_max<Vertex>(tmp_arena, umesh->num_triangles * 3);

 ufbx_skin_deformer *skin = 0;
 if (umesh->skin_deformers.count) {
  
# 169 "code/scene.cpp" 3 4
 (static_cast <bool> (
# 169 "code/scene.cpp"
 umesh->skin_deformers.count == 1
# 169 "code/scene.cpp" 3 4
 ) ? void (0) : __assert_fail (
# 169 "code/scene.cpp"
 "umesh->skin_deformers.count == 1"
# 169 "code/scene.cpp" 3 4
 , "code/scene.cpp", 169, __extension__ __PRETTY_FUNCTION__))
# 169 "code/scene.cpp"
                                         ;
  skin = umesh->skin_deformers.data[0];
  
# 171 "code/scene.cpp" 3 4
 (static_cast <bool> (
# 171 "code/scene.cpp"
 skin->skinning_method == UFBX_SKINNING_METHOD_LINEAR
# 171 "code/scene.cpp" 3 4
 ) ? void (0) : __assert_fail (
# 171 "code/scene.cpp"
 "skin->skinning_method == UFBX_SKINNING_METHOD_LINEAR"
# 171 "code/scene.cpp" 3 4
 , "code/scene.cpp", 171, __extension__ __PRETTY_FUNCTION__))
# 171 "code/scene.cpp"
                                                             ;


  mesh.bones = make_array<Bone>(arena, skin->clusters.count);
  for (usize i = 0; i < mesh.bones.count; i++) {
   ufbx_skin_cluster *cluster = skin->clusters.data[i];
   mesh.bones[i].inv_bind = ufbx_to_mat4(cluster->geometry_to_bone);
   mesh.bones[i].transform = inverse(mesh.bones[i].inv_bind);
   mesh.bones[i].parent = -1;
   mesh.bones[i].name = make_string(arena, cluster->bone_node->name.length,
     cluster->bone_node->name.data);

   for (int j = 0; j < mesh.bones.count; j++) {
    if (cluster->bone_node->parent == skin->clusters.data[j]->bone_node) {
     mesh.bones[i].parent = j;
     break ;
    }
   }
  }
  Array<bool> computed = make_zero_array<bool>(tmp_arena, mesh.bones.count);
  for (usize i = 0; i < mesh.bones.count; i++)
   make_bones_transform_relative_to_parent(mesh.bones, i, computed);
 }

 for (usize part_idx = 0; part_idx < umesh->material_parts.count; part_idx++) {
  MeshPart &part = mesh.parts[part_idx];
  part.offset = vertices.count;

  ufbx_mesh_part upart = umesh->material_parts.data[part_idx];
  uint32_t num_vertices = 0;

  for (usize face_idx = 0; face_idx < upart.num_faces; face_idx++) {
   ufbx_face face = umesh->faces.data[upart.face_indices.data[face_idx]];
   uint32_t num_tris = ufbx_triangulate_face(tri_indices.data, tri_indices.count, umesh, face);

   for (size_t i = 0; i < num_tris * 3; i++) {
    uint32_t index = tri_indices[i];


    vertices.push(get_ufbx_vertex(umesh, skin, index));
   }
  }
  if (upart.face_indices.count && umesh->face_material.count) {

   part.material = load_material(arena, scene,
     umesh->materials.data[umesh->face_material.data[upart.face_indices.data[0]]]);
  }

  part.vertices_count = vertices.count - part.offset;
 }
 mesh.box_min = V3(3.40282346638528859811704183484516925e+38F);
 mesh.box_max = V3(1.17549435082228750796873653722224568e-38F);
 for (usize i = 0; i < vertices.count; i++) {
  mesh.box_min = min(mesh.box_min, vertices[i].position);
  mesh.box_max = max(mesh.box_max, vertices[i].position);
 }

 mesh.vertex_buffer = create_vertex_buffer(VERTEX_BUFFER_IMMUTABLE,
   vertices.count * sizeof(Vertex), vertices.data);

 end_temp_memory();
 return mesh;
}

void *ufbx_arena_realloc(void *user, void *old_ptr, size_t old_size, size_t new_size)
{
 Arena *arena = (Arena *)user;

 void *data = _arena_alloc("code/scene.cpp", __func__, 239, arena, new_size);

 if (old_size > new_size)
  old_size = new_size;
 if (old_size)
  memcpy(data, old_ptr, old_size);
 return data;
}

b32 quat_equal(quat a, quat b)
{
 const float eps = 1e-9;
 return fabsf(a.x - b.x) < eps &&
  fabsf(a.y - b.y) < eps &&
  fabsf(a.z - b.z) < eps &&
  fabsf(a.w - b.w) < eps;
}

mat4 get_animated_node_transform(Animation &anim, NodeAnimation &node, float anim_time)
{
 int frame = anim_time / anim.frametime;
 if (frame >= anim.frame_count)
  frame = anim.frame_count - 1;

 int next_frame = frame + 1 == anim.frame_count ? frame : frame + 1;
 float t = (anim_time - frame * anim.frametime) / anim.frametime;

 v3 position = node.const_position;
 quat rotation = node.const_rotation;
 v3 s = node.const_scale;

 if (node.position.count)
  position = lerp(node.position[frame], node.position[next_frame], t);
 if (node.rotation.count)
  rotation = quat_lerp(node.rotation[frame], node.rotation[next_frame], t);
 if (node.scale.count)
  s = lerp(node.scale[frame], node.scale[next_frame], t);
 return translate(position) * quat_to_mat(rotation) * scale(s);
}

void get_animated_node_transform(Animation &anim, NodeAnimation &node, float anim_time,
  v3 &position, v3 &s, quat &rotation)
{
 int frame = anim_time / anim.frametime;
 if (frame >= anim.frame_count)
  frame = anim.frame_count - 1;

 int next_frame = frame + 1 == anim.frame_count ? frame : frame + 1;
 float t = (anim_time - frame * anim.frametime) / anim.frametime;

 position = node.const_position;
 rotation = node.const_rotation;
 s = node.const_scale;

 if (node.position.count)
  position = lerp(node.position[frame], node.position[next_frame], t);
 if (node.rotation.count)
  rotation = quat_lerp(node.rotation[frame], node.rotation[next_frame], t);
 if (node.scale.count)
  s = lerp(node.scale[frame], node.scale[next_frame], t);
}

Animation load_animation(Arena *arena, ufbx_scene *uscene, ufbx_anim_stack *stack)
{
 Arena *temp = begin_temp_memory();

 Animation anim = {};

 anim.timebegin = stack->time_begin;
 anim.duration = stack->time_end - stack->time_begin;
 int target_framerate = 60;

 anim.frame_count = (u32)(anim.duration * target_framerate);
 if (anim.frame_count < 2)
  anim.frame_count = 2;
 anim.frametime = anim.duration / (anim.frame_count - 1);

 Array<v3> position = make_array<v3>(temp, anim.frame_count);
 Array<quat> rotation = make_array<quat>(temp, anim.frame_count);
 Array<v3> scale = make_array<v3>(temp, anim.frame_count);

 anim.nodes = make_array_max<NodeAnimation>(arena, uscene->nodes.count);
 for (usize j = 0; j < uscene->nodes.count; j++) {
  ufbx_node *node = uscene->nodes.data[j];
  if (node->is_root)
   continue ;
  NodeAnimation node_anim = {};
  node_anim.name = make_string(arena, (usize)node->name.length, (char *)node->name.data);

  b32 const_position = true;
  b32 const_scale = true;
  b32 const_rotation = true;

  for (usize frame = 0; frame < anim.frame_count; frame++) {
   float t = anim.timebegin + frame * anim.frametime;
   ufbx_transform transform = ufbx_evaluate_transform(stack->anim, node, t);

   position[frame] = ufbx_to_v3(transform.translation);
   rotation[frame] = ufbx_to_quat(transform.rotation);
   scale[frame] = ufbx_to_v3(transform.scale);

   if (frame) {



    if (dot(rotation[frame], rotation[frame - 1]) < 0.0f)
     rotation[frame] = -rotation[frame];

    if (!v3_equal(position[frame - 1], position[frame]))
     const_position = false;
    if (!quat_equal(rotation[frame - 1], rotation[frame]))
     const_rotation = false;
    if (!v3_equal(scale[frame - 1], scale[frame]))
     const_scale = false;
   }

  }



  if (const_position)
   node_anim.const_position = position[0];
  else
   node_anim.position = clone_array(arena, position);
  if (const_rotation)
   node_anim.const_rotation = rotation[0];
  else
   node_anim.rotation = clone_array(arena, rotation);
  if (const_scale)
   node_anim.const_scale = scale[0];
  else
   node_anim.scale = clone_array(arena, scale);

  anim.nodes.push(node_anim);
 }

 end_temp_memory();

 return anim;
}

void compute_meshes_transform(Scene &scene, SceneNode *node, mat4 transform)
{
 transform = transform * node->local_transform;
 if (node->mesh)
  node->mesh->transform = transform * node->geometry_transform;
 for (usize i = 0; i < node->childs.count; i++)
  compute_meshes_transform(scene, node->childs[i], transform);
}

Scene load_scene(Arena *arena, const char *filename)
{
 Arena *temp = begin_temp_memory();
 Scene scene = {};

 {
  int slash = -1;

  for (int i = 0; filename[i]; i++) {
   if (filename[i] == '/' || filename[i] == '\\')
    slash = i;
  }
  scene.path = make_string(arena, slash + 1, filename);
 }

 ufbx_load_opts opts = {};

 opts.target_axes.right = UFBX_COORDINATE_AXIS_POSITIVE_X;
 opts.target_axes.up = UFBX_COORDINATE_AXIS_POSITIVE_Z;
 opts.target_axes.front = UFBX_COORDINATE_AXIS_POSITIVE_Y;
 opts.target_unit_meters = 1;
 opts.temp_allocator.allocator.realloc_fn = ufbx_arena_realloc;
 opts.temp_allocator.allocator.user = temp;
 opts.result_allocator.allocator.realloc_fn = ufbx_arena_realloc;
 opts.result_allocator.allocator.user = temp;
 opts.generate_missing_normals = true;

 ufbx_error error;
 ufbx_scene *uscene = ufbx_load_file(filename, &opts, &error);
 if (!uscene) {
  fprintf(
# 419 "code/scene.cpp" 3 4
         stderr
# 419 "code/scene.cpp"
               , "Failed to load %s: %s\n", filename, error.description.data);
  exit(1);
 }

 printf("loading scene %s\n", filename);

 scene.nodes = make_array<SceneNode>(arena, uscene->nodes.count);
 scene.meshes = make_array<Mesh>(arena, uscene->meshes.count);
 scene.root = &scene.nodes[(int)uscene->root_node->typed_id];

 for (size_t i = 0; i < uscene->nodes.count; i++) {
  ufbx_node *unode = uscene->nodes.data[i];
  
# 431 "code/scene.cpp" 3 4
 (static_cast <bool> (
# 431 "code/scene.cpp"
 unode->typed_id == i
# 431 "code/scene.cpp" 3 4
 ) ? void (0) : __assert_fail (
# 431 "code/scene.cpp"
 "unode->typed_id == i"
# 431 "code/scene.cpp" 3 4
 , "code/scene.cpp", 431, __extension__ __PRETTY_FUNCTION__))
# 431 "code/scene.cpp"
                             ;

  scene.nodes[i].id = (int)i;
  scene.nodes[i].local_transform = ufbx_to_mat4(unode->node_to_parent);
  scene.nodes[i].geometry_transform = ufbx_to_mat4(unode->geometry_to_node);
  scene.nodes[i].name = make_string(arena, unode->name.length, unode->name.data);

  if (unode->parent)
   scene.nodes[i].parent = &scene.nodes[(int)unode->parent->typed_id];

  if (unode->parent)
   
# 442 "code/scene.cpp" 3 4
  (static_cast <bool> (
# 442 "code/scene.cpp"
  unode->parent->typed_id < i
# 442 "code/scene.cpp" 3 4
  ) ? void (0) : __assert_fail (
# 442 "code/scene.cpp"
  "unode->parent->typed_id < i"
# 442 "code/scene.cpp" 3 4
  , "code/scene.cpp", 442, __extension__ __PRETTY_FUNCTION__))
# 442 "code/scene.cpp"
                                     ;

  if (scene.nodes[i].parent)
   scene.nodes[i].skip_render |= scene.nodes[i].parent->skip_render;

  if (unode->light || unode->bone || unode->camera)
   scene.nodes[i].skip_render = true;

  if (unode->mesh) {
   scene.meshes[(int)unode->mesh->typed_id] = load_mesh(arena, scene, unode);
   scene.nodes[i].mesh = &scene.meshes[(int)unode->mesh->typed_id];
   
# 453 "code/scene.cpp" 3 4
  (static_cast <bool> (
# 453 "code/scene.cpp"
  !scene.nodes[i].skip_render
# 453 "code/scene.cpp" 3 4
  ) ? void (0) : __assert_fail (
# 453 "code/scene.cpp"
  "!scene.nodes[i].skip_render"
# 453 "code/scene.cpp" 3 4
  , "code/scene.cpp", 453, __extension__ __PRETTY_FUNCTION__))
# 453 "code/scene.cpp"
                                     ;
  }
  scene.nodes[i].childs = make_array<SceneNode *>(arena, unode->children.count);

  for (usize j = 0; j < unode->children.count; j++)
   scene.nodes[i].childs[j] = &scene.nodes[(int)unode->children.data[j]->typed_id];
 }

 scene.animations = make_array_max<Animation>(arena, uscene->anim_stacks.count);
 for (usize i = 0; i < uscene->anim_stacks.count; i++) {
  Animation anim = load_animation(arena, uscene, uscene->anim_stacks.data[i]);
  bool const_anim = true;
  for (usize j = 0; j < anim.nodes.count; j++)
   if (anim.nodes[j].position.count ||
     anim.nodes[j].rotation.count ||
     anim.nodes[j].scale.count)
    const_anim = false;
  if (!const_anim)
   scene.animations.push(anim);
 }

 compute_meshes_transform(scene, scene.root, identity());

 end_temp_memory();
 return scene;
}
# 28 "code/game.cpp" 2
# 1 "code/game.h" 1
       

enum EntityType
{
 EntityType_Player,
 EntityType_Enemy,
 EntityType_Static
};

enum CollisionShapeType
{
 COLLISION_SHAPE_TRIANGLES,
 COLLISION_SHAPE_ELLIPSOID,
};

struct CollisionTriangle
{
 v3 v0, v1, v2;
};

struct CollisionShape
{
 int type;
 Array<CollisionTriangle> triangles;
 v3 ellipsoid_radius;

 v3 box_radius;
 mat4 transform;
 v3 scale;
};

typedef usize entity_id;

struct Entity
{
 entity_id id;
 int type;
 v3 position;
 v3 dp;

 v3 rotation;
 v3 scale;

 v3 color;

 b32 moved;
 b32 run;
 b32 shooting;
 b32 can_jump;
 b32 on_ground;

 CollisionShape shape;

 Scene *scene;
 mat4 scene_transform;



 Animation *curr_anim;
 Animation *next_anim;
 float anim_time;
 float blend_time;

 Animation *animation;

 float speed;

 float height_above_ground;
};

enum AnimationType {
 ANIMATION_JUMP,
 ANIMATION_SHOOT,
 ANIMATION_RUN,
 ANIMATION_FORWARD_GUN_WALK,
 ANIMATION_BACKWARD_GUN_WALK,
 ANIMATION_GUN_IDLE,
 ANIMATION_COUNT
};

struct ShadowMap {
 FrameBuffer framebuffer;
 v3 light_dir;
 v3 light_p;
 mat4 view;
 mat4 projection;
 int width, height;
 Texture depth_texture;
};

struct Camera
{
 v3 position;
 mat4 view;
 mat4 projection;

 float znear, zfar, width, height;
 v3 forward, right, up;
};



# 1 "/usr/include/c++/10/unordered_map" 1 3
# 32 "/usr/include/c++/10/unordered_map" 3
       
# 33 "/usr/include/c++/10/unordered_map" 3





# 1 "/usr/include/c++/10/type_traits" 1 3
# 32 "/usr/include/c++/10/type_traits" 3
       
# 33 "/usr/include/c++/10/type_traits" 3








# 40 "/usr/include/c++/10/type_traits" 3
namespace std __attribute__ ((__visibility__ ("default")))
{

# 56 "/usr/include/c++/10/type_traits" 3
  template<typename _Tp, _Tp __v>
    struct integral_constant
    {
      static constexpr _Tp value = __v;
      typedef _Tp value_type;
      typedef integral_constant<_Tp, __v> type;
      constexpr operator value_type() const noexcept { return value; }




      constexpr value_type operator()() const noexcept { return value; }

    };

  template<typename _Tp, _Tp __v>
    constexpr _Tp integral_constant<_Tp, __v>::value;


  typedef integral_constant<bool, true> true_type;


  typedef integral_constant<bool, false> false_type;

  template<bool __v>
    using __bool_constant = integral_constant<bool, __v>;
# 91 "/usr/include/c++/10/type_traits" 3
  template<bool, typename, typename>
    struct conditional;

  template <typename _Type>
    struct __type_identity
    { using type = _Type; };

  template<typename _Tp>
    using __type_identity_t = typename __type_identity<_Tp>::type;

  template<typename...>
    struct __or_;

  template<>
    struct __or_<>
    : public false_type
    { };

  template<typename _B1>
    struct __or_<_B1>
    : public _B1
    { };

  template<typename _B1, typename _B2>
    struct __or_<_B1, _B2>
    : public conditional<_B1::value, _B1, _B2>::type
    { };

  template<typename _B1, typename _B2, typename _B3, typename... _Bn>
    struct __or_<_B1, _B2, _B3, _Bn...>
    : public conditional<_B1::value, _B1, __or_<_B2, _B3, _Bn...>>::type
    { };

  template<typename...>
    struct __and_;

  template<>
    struct __and_<>
    : public true_type
    { };

  template<typename _B1>
    struct __and_<_B1>
    : public _B1
    { };

  template<typename _B1, typename _B2>
    struct __and_<_B1, _B2>
    : public conditional<_B1::value, _B2, _B1>::type
    { };

  template<typename _B1, typename _B2, typename _B3, typename... _Bn>
    struct __and_<_B1, _B2, _B3, _Bn...>
    : public conditional<_B1::value, __and_<_B2, _B3, _Bn...>, _B1>::type
    { };

  template<typename _Pp>
    struct __not_
    : public __bool_constant<!bool(_Pp::value)>
    { };
# 188 "/usr/include/c++/10/type_traits" 3
  template<typename>
    struct is_reference;
  template<typename>
    struct is_function;
  template<typename>
    struct is_void;
  template<typename>
    struct __is_array_unknown_bounds;




  template <typename _Tp, size_t = sizeof(_Tp)>
    constexpr true_type __is_complete_or_unbounded(__type_identity<_Tp>)
    { return {}; }

  template <typename _TypeIdentity,
      typename _NestedType = typename _TypeIdentity::type>
    constexpr typename __or_<
      is_reference<_NestedType>,
      is_function<_NestedType>,
      is_void<_NestedType>,
      __is_array_unknown_bounds<_NestedType>
    >::type __is_complete_or_unbounded(_TypeIdentity)
    { return {}; }






  template<typename _Tp>
    struct __success_type
    { typedef _Tp type; };

  struct __failure_type
  { };

  template<typename>
    struct remove_cv;


  template<typename _Tp>
    using __remove_cv_t = typename remove_cv<_Tp>::type;

  template<typename>
    struct is_const;



  template<typename>
    struct __is_void_helper
    : public false_type { };

  template<>
    struct __is_void_helper<void>
    : public true_type { };


  template<typename _Tp>
    struct is_void
    : public __is_void_helper<__remove_cv_t<_Tp>>::type
    { };

  template<typename>
    struct __is_integral_helper
    : public false_type { };

  template<>
    struct __is_integral_helper<bool>
    : public true_type { };

  template<>
    struct __is_integral_helper<char>
    : public true_type { };

  template<>
    struct __is_integral_helper<signed char>
    : public true_type { };

  template<>
    struct __is_integral_helper<unsigned char>
    : public true_type { };


  template<>
    struct __is_integral_helper<wchar_t>
    : public true_type { };
# 284 "/usr/include/c++/10/type_traits" 3
  template<>
    struct __is_integral_helper<char16_t>
    : public true_type { };

  template<>
    struct __is_integral_helper<char32_t>
    : public true_type { };

  template<>
    struct __is_integral_helper<short>
    : public true_type { };

  template<>
    struct __is_integral_helper<unsigned short>
    : public true_type { };

  template<>
    struct __is_integral_helper<int>
    : public true_type { };

  template<>
    struct __is_integral_helper<unsigned int>
    : public true_type { };

  template<>
    struct __is_integral_helper<long>
    : public true_type { };

  template<>
    struct __is_integral_helper<unsigned long>
    : public true_type { };

  template<>
    struct __is_integral_helper<long long>
    : public true_type { };

  template<>
    struct __is_integral_helper<unsigned long long>
    : public true_type { };




  template<>
    struct __is_integral_helper<__int128>
    : public true_type { };

  template<>
    struct __is_integral_helper<unsigned __int128>
    : public true_type { };
# 364 "/usr/include/c++/10/type_traits" 3
  template<typename _Tp>
    struct is_integral
    : public __is_integral_helper<__remove_cv_t<_Tp>>::type
    { };

  template<typename>
    struct __is_floating_point_helper
    : public false_type { };

  template<>
    struct __is_floating_point_helper<float>
    : public true_type { };

  template<>
    struct __is_floating_point_helper<double>
    : public true_type { };

  template<>
    struct __is_floating_point_helper<long double>
    : public true_type { };


  template<>
    struct __is_floating_point_helper<__float128>
    : public true_type { };



  template<typename _Tp>
    struct is_floating_point
    : public __is_floating_point_helper<__remove_cv_t<_Tp>>::type
    { };


  template<typename>
    struct is_array
    : public false_type { };

  template<typename _Tp, std::size_t _Size>
    struct is_array<_Tp[_Size]>
    : public true_type { };

  template<typename _Tp>
    struct is_array<_Tp[]>
    : public true_type { };

  template<typename>
    struct __is_pointer_helper
    : public false_type { };

  template<typename _Tp>
    struct __is_pointer_helper<_Tp*>
    : public true_type { };


  template<typename _Tp>
    struct is_pointer
    : public __is_pointer_helper<__remove_cv_t<_Tp>>::type
    { };


  template<typename>
    struct is_lvalue_reference
    : public false_type { };

  template<typename _Tp>
    struct is_lvalue_reference<_Tp&>
    : public true_type { };


  template<typename>
    struct is_rvalue_reference
    : public false_type { };

  template<typename _Tp>
    struct is_rvalue_reference<_Tp&&>
    : public true_type { };

  template<typename>
    struct __is_member_object_pointer_helper
    : public false_type { };

  template<typename _Tp, typename _Cp>
    struct __is_member_object_pointer_helper<_Tp _Cp::*>
    : public __not_<is_function<_Tp>>::type { };


  template<typename _Tp>
    struct is_member_object_pointer
    : public __is_member_object_pointer_helper<__remove_cv_t<_Tp>>::type
    { };

  template<typename>
    struct __is_member_function_pointer_helper
    : public false_type { };

  template<typename _Tp, typename _Cp>
    struct __is_member_function_pointer_helper<_Tp _Cp::*>
    : public is_function<_Tp>::type { };


  template<typename _Tp>
    struct is_member_function_pointer
    : public __is_member_function_pointer_helper<__remove_cv_t<_Tp>>::type
    { };


  template<typename _Tp>
    struct is_enum
    : public integral_constant<bool, __is_enum(_Tp)>
    { };


  template<typename _Tp>
    struct is_union
    : public integral_constant<bool, __is_union(_Tp)>
    { };


  template<typename _Tp>
    struct is_class
    : public integral_constant<bool, __is_class(_Tp)>
    { };


  template<typename _Tp>
    struct is_function
    : public __bool_constant<!is_const<const _Tp>::value> { };

  template<typename _Tp>
    struct is_function<_Tp&>
    : public false_type { };

  template<typename _Tp>
    struct is_function<_Tp&&>
    : public false_type { };



  template<typename>
    struct __is_null_pointer_helper
    : public false_type { };

  template<>
    struct __is_null_pointer_helper<std::nullptr_t>
    : public true_type { };


  template<typename _Tp>
    struct is_null_pointer
    : public __is_null_pointer_helper<__remove_cv_t<_Tp>>::type
    { };


  template<typename _Tp>
    struct __is_nullptr_t
    : public is_null_pointer<_Tp>
    { } __attribute__ ((__deprecated__ ("use '" "std::is_null_pointer" "' instead")));




  template<typename _Tp>
    struct is_reference
    : public __or_<is_lvalue_reference<_Tp>,
                   is_rvalue_reference<_Tp>>::type
    { };


  template<typename _Tp>
    struct is_arithmetic
    : public __or_<is_integral<_Tp>, is_floating_point<_Tp>>::type
    { };


  template<typename _Tp>
    struct is_fundamental
    : public __or_<is_arithmetic<_Tp>, is_void<_Tp>,
     is_null_pointer<_Tp>>::type
    { };


  template<typename _Tp>
    struct is_object
    : public __not_<__or_<is_function<_Tp>, is_reference<_Tp>,
                          is_void<_Tp>>>::type
    { };

  template<typename>
    struct is_member_pointer;


  template<typename _Tp>
    struct is_scalar
    : public __or_<is_arithmetic<_Tp>, is_enum<_Tp>, is_pointer<_Tp>,
                   is_member_pointer<_Tp>, is_null_pointer<_Tp>>::type
    { };


  template<typename _Tp>
    struct is_compound
    : public __not_<is_fundamental<_Tp>>::type { };

  template<typename _Tp>
    struct __is_member_pointer_helper
    : public false_type { };

  template<typename _Tp, typename _Cp>
    struct __is_member_pointer_helper<_Tp _Cp::*>
    : public true_type { };


  template<typename _Tp>
    struct is_member_pointer
    : public __is_member_pointer_helper<__remove_cv_t<_Tp>>::type
    { };

  template<typename, typename>
    struct is_same;

  template<typename _Tp, typename... _Types>
    using __is_one_of = __or_<is_same<_Tp, _Types>...>;


  template<typename _Tp>
    using __is_signed_integer = __is_one_of<__remove_cv_t<_Tp>,
   signed char, signed short, signed int, signed long,
   signed long long

   , signed __int128
# 604 "/usr/include/c++/10/type_traits" 3
   >;


  template<typename _Tp>
    using __is_unsigned_integer = __is_one_of<__remove_cv_t<_Tp>,
   unsigned char, unsigned short, unsigned int, unsigned long,
   unsigned long long

   , unsigned __int128
# 623 "/usr/include/c++/10/type_traits" 3
   >;


  template<typename _Tp>
    using __is_standard_integer
      = __or_<__is_signed_integer<_Tp>, __is_unsigned_integer<_Tp>>;


  template<typename...> using __void_t = void;



  template<typename _Tp, typename = void>
    struct __is_referenceable
    : public false_type
    { };

  template<typename _Tp>
    struct __is_referenceable<_Tp, __void_t<_Tp&>>
    : public true_type
    { };




  template<typename>
    struct is_const
    : public false_type { };

  template<typename _Tp>
    struct is_const<_Tp const>
    : public true_type { };


  template<typename>
    struct is_volatile
    : public false_type { };

  template<typename _Tp>
    struct is_volatile<_Tp volatile>
    : public true_type { };


  template<typename _Tp>
    struct is_trivial
    : public integral_constant<bool, __is_trivial(_Tp)>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };


  template<typename _Tp>
    struct is_trivially_copyable
    : public integral_constant<bool, __is_trivially_copyable(_Tp)>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };


  template<typename _Tp>
    struct is_standard_layout
    : public integral_constant<bool, __is_standard_layout(_Tp)>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };



  template<typename _Tp>
    struct
   
    is_pod
    : public integral_constant<bool, __is_pod(_Tp)>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };


  template<typename _Tp>
    struct is_literal_type
    : public integral_constant<bool, __is_literal_type(_Tp)>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };


  template<typename _Tp>
    struct is_empty
    : public integral_constant<bool, __is_empty(_Tp)>
    { };


  template<typename _Tp>
    struct is_polymorphic
    : public integral_constant<bool, __is_polymorphic(_Tp)>
    { };




  template<typename _Tp>
    struct is_final
    : public integral_constant<bool, __is_final(_Tp)>
    { };



  template<typename _Tp>
    struct is_abstract
    : public integral_constant<bool, __is_abstract(_Tp)>
    { };

  template<typename _Tp,
    bool = is_arithmetic<_Tp>::value>
    struct __is_signed_helper
    : public false_type { };

  template<typename _Tp>
    struct __is_signed_helper<_Tp, true>
    : public integral_constant<bool, _Tp(-1) < _Tp(0)>
    { };


  template<typename _Tp>
    struct is_signed
    : public __is_signed_helper<_Tp>::type
    { };


  template<typename _Tp>
    struct is_unsigned
    : public __and_<is_arithmetic<_Tp>, __not_<is_signed<_Tp>>>
    { };
# 770 "/usr/include/c++/10/type_traits" 3
  template<typename _Tp, typename _Up = _Tp&&>
    _Up
    __declval(int);

  template<typename _Tp>
    _Tp
    __declval(long);

  template<typename _Tp>
    auto declval() noexcept -> decltype(__declval<_Tp>(0));

  template<typename, unsigned = 0>
    struct extent;

  template<typename>
    struct remove_all_extents;

  template<typename _Tp>
    struct __is_array_known_bounds
    : public integral_constant<bool, (extent<_Tp>::value > 0)>
    { };

  template<typename _Tp>
    struct __is_array_unknown_bounds
    : public __and_<is_array<_Tp>, __not_<extent<_Tp>>>
    { };






  struct __do_is_destructible_impl
  {
    template<typename _Tp, typename = decltype(declval<_Tp&>().~_Tp())>
      static true_type __test(int);

    template<typename>
      static false_type __test(...);
  };

  template<typename _Tp>
    struct __is_destructible_impl
    : public __do_is_destructible_impl
    {
      typedef decltype(__test<_Tp>(0)) type;
    };

  template<typename _Tp,
           bool = __or_<is_void<_Tp>,
                        __is_array_unknown_bounds<_Tp>,
                        is_function<_Tp>>::value,
           bool = __or_<is_reference<_Tp>, is_scalar<_Tp>>::value>
    struct __is_destructible_safe;

  template<typename _Tp>
    struct __is_destructible_safe<_Tp, false, false>
    : public __is_destructible_impl<typename
               remove_all_extents<_Tp>::type>::type
    { };

  template<typename _Tp>
    struct __is_destructible_safe<_Tp, true, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_destructible_safe<_Tp, false, true>
    : public true_type { };


  template<typename _Tp>
    struct is_destructible
    : public __is_destructible_safe<_Tp>::type
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };





  struct __do_is_nt_destructible_impl
  {
    template<typename _Tp>
      static __bool_constant<noexcept(declval<_Tp&>().~_Tp())>
      __test(int);

    template<typename>
      static false_type __test(...);
  };

  template<typename _Tp>
    struct __is_nt_destructible_impl
    : public __do_is_nt_destructible_impl
    {
      typedef decltype(__test<_Tp>(0)) type;
    };

  template<typename _Tp,
           bool = __or_<is_void<_Tp>,
                        __is_array_unknown_bounds<_Tp>,
                        is_function<_Tp>>::value,
           bool = __or_<is_reference<_Tp>, is_scalar<_Tp>>::value>
    struct __is_nt_destructible_safe;

  template<typename _Tp>
    struct __is_nt_destructible_safe<_Tp, false, false>
    : public __is_nt_destructible_impl<typename
               remove_all_extents<_Tp>::type>::type
    { };

  template<typename _Tp>
    struct __is_nt_destructible_safe<_Tp, true, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_nt_destructible_safe<_Tp, false, true>
    : public true_type { };


  template<typename _Tp>
    struct is_nothrow_destructible
    : public __is_nt_destructible_safe<_Tp>::type
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };

  template<typename _Tp, typename... _Args>
    struct __is_constructible_impl
    : public __bool_constant<__is_constructible(_Tp, _Args...)>
    { };


  template<typename _Tp, typename... _Args>
    struct is_constructible
      : public __is_constructible_impl<_Tp, _Args...>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };


  template<typename _Tp>
    struct is_default_constructible
    : public __is_constructible_impl<_Tp>::type
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };

  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __is_copy_constructible_impl;

  template<typename _Tp>
    struct __is_copy_constructible_impl<_Tp, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_copy_constructible_impl<_Tp, true>
    : public __is_constructible_impl<_Tp, const _Tp&>
    { };


  template<typename _Tp>
    struct is_copy_constructible
    : public __is_copy_constructible_impl<_Tp>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };

  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __is_move_constructible_impl;

  template<typename _Tp>
    struct __is_move_constructible_impl<_Tp, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_move_constructible_impl<_Tp, true>
    : public __is_constructible_impl<_Tp, _Tp&&>
    { };


  template<typename _Tp>
    struct is_move_constructible
    : public __is_move_constructible_impl<_Tp>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };

  template<bool, typename _Tp, typename... _Args>
    struct __is_nt_constructible_impl
    : public false_type
    { };

  template<typename _Tp, typename... _Args>
    struct __is_nt_constructible_impl<true, _Tp, _Args...>
    : public __bool_constant<noexcept(_Tp(std::declval<_Args>()...))>
    { };

  template<typename _Tp, typename _Arg>
    struct __is_nt_constructible_impl<true, _Tp, _Arg>
    : public __bool_constant<noexcept(static_cast<_Tp>(std::declval<_Arg>()))>
    { };

  template<typename _Tp>
    struct __is_nt_constructible_impl<true, _Tp>
    : public __bool_constant<noexcept(_Tp())>
    { };

  template<typename _Tp, size_t _Num>
    struct __is_nt_constructible_impl<true, _Tp[_Num]>
    : public __bool_constant<noexcept(typename remove_all_extents<_Tp>::type())>
    { };
# 1001 "/usr/include/c++/10/type_traits" 3
  template<typename _Tp, typename... _Args>
    using __is_nothrow_constructible_impl
      = __is_nt_constructible_impl<__is_constructible(_Tp, _Args...),
       _Tp, _Args...>;


  template<typename _Tp, typename... _Args>
    struct is_nothrow_constructible
    : public __is_nothrow_constructible_impl<_Tp, _Args...>::type
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };


  template<typename _Tp>
    struct is_nothrow_default_constructible
    : public __is_nothrow_constructible_impl<_Tp>::type
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };


  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __is_nothrow_copy_constructible_impl;

  template<typename _Tp>
    struct __is_nothrow_copy_constructible_impl<_Tp, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_nothrow_copy_constructible_impl<_Tp, true>
    : public __is_nothrow_constructible_impl<_Tp, const _Tp&>
    { };


  template<typename _Tp>
    struct is_nothrow_copy_constructible
    : public __is_nothrow_copy_constructible_impl<_Tp>::type
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };

  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __is_nothrow_move_constructible_impl;

  template<typename _Tp>
    struct __is_nothrow_move_constructible_impl<_Tp, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_nothrow_move_constructible_impl<_Tp, true>
    : public __is_nothrow_constructible_impl<_Tp, _Tp&&>
    { };


  template<typename _Tp>
    struct is_nothrow_move_constructible
    : public __is_nothrow_move_constructible_impl<_Tp>::type
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };


  template<typename _Tp, typename _Up>
    struct is_assignable
    : public __bool_constant<__is_assignable(_Tp, _Up)>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };

  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __is_copy_assignable_impl;

  template<typename _Tp>
    struct __is_copy_assignable_impl<_Tp, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_copy_assignable_impl<_Tp, true>
    : public __bool_constant<__is_assignable(_Tp&, const _Tp&)>
    { };


  template<typename _Tp>
    struct is_copy_assignable
    : public __is_copy_assignable_impl<_Tp>::type
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };

  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __is_move_assignable_impl;

  template<typename _Tp>
    struct __is_move_assignable_impl<_Tp, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_move_assignable_impl<_Tp, true>
    : public __bool_constant<__is_assignable(_Tp&, _Tp&&)>
    { };


  template<typename _Tp>
    struct is_move_assignable
    : public __is_move_assignable_impl<_Tp>::type
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };

  template<typename _Tp, typename _Up>
    struct __is_nt_assignable_impl
    : public integral_constant<bool, noexcept(declval<_Tp>() = declval<_Up>())>
    { };

  template<typename _Tp, typename _Up>
    struct __is_nothrow_assignable_impl
    : public __and_<__bool_constant<__is_assignable(_Tp, _Up)>,
      __is_nt_assignable_impl<_Tp, _Up>>
    { };


  template<typename _Tp, typename _Up>
    struct is_nothrow_assignable
    : public __is_nothrow_assignable_impl<_Tp, _Up>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };

  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __is_nt_copy_assignable_impl;

  template<typename _Tp>
    struct __is_nt_copy_assignable_impl<_Tp, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_nt_copy_assignable_impl<_Tp, true>
    : public __is_nothrow_assignable_impl<_Tp&, const _Tp&>
    { };


  template<typename _Tp>
    struct is_nothrow_copy_assignable
    : public __is_nt_copy_assignable_impl<_Tp>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };

  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __is_nt_move_assignable_impl;

  template<typename _Tp>
    struct __is_nt_move_assignable_impl<_Tp, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_nt_move_assignable_impl<_Tp, true>
    : public __is_nothrow_assignable_impl<_Tp&, _Tp&&>
    { };


  template<typename _Tp>
    struct is_nothrow_move_assignable
    : public __is_nt_move_assignable_impl<_Tp>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };


  template<typename _Tp, typename... _Args>
    struct is_trivially_constructible
    : public __bool_constant<__is_trivially_constructible(_Tp, _Args...)>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };


  template<typename _Tp>
    struct is_trivially_default_constructible
    : public __bool_constant<__is_trivially_constructible(_Tp)>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };

  struct __do_is_implicitly_default_constructible_impl
  {
    template <typename _Tp>
    static void __helper(const _Tp&);

    template <typename _Tp>
    static true_type __test(const _Tp&,
                            decltype(__helper<const _Tp&>({}))* = 0);

    static false_type __test(...);
  };

  template<typename _Tp>
    struct __is_implicitly_default_constructible_impl
    : public __do_is_implicitly_default_constructible_impl
    {
      typedef decltype(__test(declval<_Tp>())) type;
    };

  template<typename _Tp>
    struct __is_implicitly_default_constructible_safe
    : public __is_implicitly_default_constructible_impl<_Tp>::type
    { };

  template <typename _Tp>
    struct __is_implicitly_default_constructible
    : public __and_<__is_constructible_impl<_Tp>,
      __is_implicitly_default_constructible_safe<_Tp>>
    { };

  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __is_trivially_copy_constructible_impl;

  template<typename _Tp>
    struct __is_trivially_copy_constructible_impl<_Tp, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_trivially_copy_constructible_impl<_Tp, true>
    : public __and_<__is_copy_constructible_impl<_Tp>,
      integral_constant<bool,
   __is_trivially_constructible(_Tp, const _Tp&)>>
    { };


  template<typename _Tp>
    struct is_trivially_copy_constructible
    : public __is_trivially_copy_constructible_impl<_Tp>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };

  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __is_trivially_move_constructible_impl;

  template<typename _Tp>
    struct __is_trivially_move_constructible_impl<_Tp, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_trivially_move_constructible_impl<_Tp, true>
    : public __and_<__is_move_constructible_impl<_Tp>,
      integral_constant<bool,
   __is_trivially_constructible(_Tp, _Tp&&)>>
    { };


  template<typename _Tp>
    struct is_trivially_move_constructible
    : public __is_trivially_move_constructible_impl<_Tp>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };


  template<typename _Tp, typename _Up>
    struct is_trivially_assignable
    : public __bool_constant<__is_trivially_assignable(_Tp, _Up)>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };

  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __is_trivially_copy_assignable_impl;

  template<typename _Tp>
    struct __is_trivially_copy_assignable_impl<_Tp, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_trivially_copy_assignable_impl<_Tp, true>
    : public __bool_constant<__is_trivially_assignable(_Tp&, const _Tp&)>
    { };


  template<typename _Tp>
    struct is_trivially_copy_assignable
    : public __is_trivially_copy_assignable_impl<_Tp>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };

  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __is_trivially_move_assignable_impl;

  template<typename _Tp>
    struct __is_trivially_move_assignable_impl<_Tp, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_trivially_move_assignable_impl<_Tp, true>
    : public __bool_constant<__is_trivially_assignable(_Tp&, _Tp&&)>
    { };


  template<typename _Tp>
    struct is_trivially_move_assignable
    : public __is_trivially_move_assignable_impl<_Tp>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };


  template<typename _Tp>
    struct is_trivially_destructible
    : public __and_<__is_destructible_safe<_Tp>,
      __bool_constant<__has_trivial_destructor(_Tp)>>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };



  template<typename _Tp>
    struct has_virtual_destructor
    : public integral_constant<bool, __has_virtual_destructor(_Tp)>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };





  template<typename _Tp>
    struct alignment_of
    : public integral_constant<std::size_t, alignof(_Tp)>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };


  template<typename>
    struct rank
    : public integral_constant<std::size_t, 0> { };

  template<typename _Tp, std::size_t _Size>
    struct rank<_Tp[_Size]>
    : public integral_constant<std::size_t, 1 + rank<_Tp>::value> { };

  template<typename _Tp>
    struct rank<_Tp[]>
    : public integral_constant<std::size_t, 1 + rank<_Tp>::value> { };


  template<typename, unsigned _Uint>
    struct extent
    : public integral_constant<std::size_t, 0> { };

  template<typename _Tp, unsigned _Uint, std::size_t _Size>
    struct extent<_Tp[_Size], _Uint>
    : public integral_constant<std::size_t,
          _Uint == 0 ? _Size : extent<_Tp,
          _Uint - 1>::value>
    { };

  template<typename _Tp, unsigned _Uint>
    struct extent<_Tp[], _Uint>
    : public integral_constant<std::size_t,
          _Uint == 0 ? 0 : extent<_Tp,
             _Uint - 1>::value>
    { };





  template<typename _Tp, typename _Up>
    struct is_same

    : public integral_constant<bool, __is_same_as(_Tp, _Up)>



    { };
# 1410 "/usr/include/c++/10/type_traits" 3
  template<typename _Base, typename _Derived>
    struct is_base_of
    : public integral_constant<bool, __is_base_of(_Base, _Derived)>
    { };

  template<typename _From, typename _To,
           bool = __or_<is_void<_From>, is_function<_To>,
                        is_array<_To>>::value>
    struct __is_convertible_helper
    {
      typedef typename is_void<_To>::type type;
    };

#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wctor-dtor-privacy"
  template<typename _From, typename _To>
    class __is_convertible_helper<_From, _To, false>
    {
      template<typename _To1>
 static void __test_aux(_To1) noexcept;

      template<typename _From1, typename _To1,
        typename = decltype(__test_aux<_To1>(std::declval<_From1>()))>
 static true_type
 __test(int);

      template<typename, typename>
 static false_type
 __test(...);

    public:
      typedef decltype(__test<_From, _To>(0)) type;
    };
#pragma GCC diagnostic pop


  template<typename _From, typename _To>
    struct is_convertible
    : public __is_convertible_helper<_From, _To>::type
    { };


  template<typename _ToElementType, typename _FromElementType>
    using __is_array_convertible
      = is_convertible<_FromElementType(*)[], _ToElementType(*)[]>;

  template<typename _From, typename _To,
           bool = __or_<is_void<_From>, is_function<_To>,
                        is_array<_To>>::value>
    struct __is_nt_convertible_helper
    : is_void<_To>
    { };

#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wctor-dtor-privacy"
  template<typename _From, typename _To>
    class __is_nt_convertible_helper<_From, _To, false>
    {
      template<typename _To1>
 static void __test_aux(_To1) noexcept;

      template<typename _From1, typename _To1>
 static
 __bool_constant<noexcept(__test_aux<_To1>(std::declval<_From1>()))>
 __test(int);

      template<typename, typename>
 static false_type
 __test(...);

    public:
      using type = decltype(__test<_From, _To>(0));
    };
#pragma GCC diagnostic pop


  template<typename _From, typename _To>
    struct __is_nothrow_convertible
    : public __is_nt_convertible_helper<_From, _To>::type
    { };
# 1508 "/usr/include/c++/10/type_traits" 3
  template<typename _Tp>
    struct remove_const
    { typedef _Tp type; };

  template<typename _Tp>
    struct remove_const<_Tp const>
    { typedef _Tp type; };


  template<typename _Tp>
    struct remove_volatile
    { typedef _Tp type; };

  template<typename _Tp>
    struct remove_volatile<_Tp volatile>
    { typedef _Tp type; };


  template<typename _Tp>
    struct remove_cv
    { using type = _Tp; };

  template<typename _Tp>
    struct remove_cv<const _Tp>
    { using type = _Tp; };

  template<typename _Tp>
    struct remove_cv<volatile _Tp>
    { using type = _Tp; };

  template<typename _Tp>
    struct remove_cv<const volatile _Tp>
    { using type = _Tp; };


  template<typename _Tp>
    struct add_const
    { typedef _Tp const type; };


  template<typename _Tp>
    struct add_volatile
    { typedef _Tp volatile type; };


  template<typename _Tp>
    struct add_cv
    {
      typedef typename
      add_const<typename add_volatile<_Tp>::type>::type type;
    };






  template<typename _Tp>
    using remove_const_t = typename remove_const<_Tp>::type;


  template<typename _Tp>
    using remove_volatile_t = typename remove_volatile<_Tp>::type;


  template<typename _Tp>
    using remove_cv_t = typename remove_cv<_Tp>::type;


  template<typename _Tp>
    using add_const_t = typename add_const<_Tp>::type;


  template<typename _Tp>
    using add_volatile_t = typename add_volatile<_Tp>::type;


  template<typename _Tp>
    using add_cv_t = typename add_cv<_Tp>::type;





  template<typename _Tp>
    struct remove_reference
    { typedef _Tp type; };

  template<typename _Tp>
    struct remove_reference<_Tp&>
    { typedef _Tp type; };

  template<typename _Tp>
    struct remove_reference<_Tp&&>
    { typedef _Tp type; };

  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __add_lvalue_reference_helper
    { typedef _Tp type; };

  template<typename _Tp>
    struct __add_lvalue_reference_helper<_Tp, true>
    { typedef _Tp& type; };


  template<typename _Tp>
    struct add_lvalue_reference
    : public __add_lvalue_reference_helper<_Tp>
    { };

  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __add_rvalue_reference_helper
    { typedef _Tp type; };

  template<typename _Tp>
    struct __add_rvalue_reference_helper<_Tp, true>
    { typedef _Tp&& type; };


  template<typename _Tp>
    struct add_rvalue_reference
    : public __add_rvalue_reference_helper<_Tp>
    { };



  template<typename _Tp>
    using remove_reference_t = typename remove_reference<_Tp>::type;


  template<typename _Tp>
    using add_lvalue_reference_t = typename add_lvalue_reference<_Tp>::type;


  template<typename _Tp>
    using add_rvalue_reference_t = typename add_rvalue_reference<_Tp>::type;





  template<typename _Unqualified, bool _IsConst, bool _IsVol>
    struct __cv_selector;

  template<typename _Unqualified>
    struct __cv_selector<_Unqualified, false, false>
    { typedef _Unqualified __type; };

  template<typename _Unqualified>
    struct __cv_selector<_Unqualified, false, true>
    { typedef volatile _Unqualified __type; };

  template<typename _Unqualified>
    struct __cv_selector<_Unqualified, true, false>
    { typedef const _Unqualified __type; };

  template<typename _Unqualified>
    struct __cv_selector<_Unqualified, true, true>
    { typedef const volatile _Unqualified __type; };

  template<typename _Qualified, typename _Unqualified,
    bool _IsConst = is_const<_Qualified>::value,
    bool _IsVol = is_volatile<_Qualified>::value>
    class __match_cv_qualifiers
    {
      typedef __cv_selector<_Unqualified, _IsConst, _IsVol> __match;

    public:
      typedef typename __match::__type __type;
    };


  template<typename _Tp>
    struct __make_unsigned
    { typedef _Tp __type; };

  template<>
    struct __make_unsigned<char>
    { typedef unsigned char __type; };

  template<>
    struct __make_unsigned<signed char>
    { typedef unsigned char __type; };

  template<>
    struct __make_unsigned<short>
    { typedef unsigned short __type; };

  template<>
    struct __make_unsigned<int>
    { typedef unsigned int __type; };

  template<>
    struct __make_unsigned<long>
    { typedef unsigned long __type; };

  template<>
    struct __make_unsigned<long long>
    { typedef unsigned long long __type; };


  template<>
    struct __make_unsigned<__int128>
    { typedef unsigned __int128 __type; };
# 1730 "/usr/include/c++/10/type_traits" 3
  template<typename _Tp,
    bool _IsInt = is_integral<_Tp>::value,
    bool _IsEnum = is_enum<_Tp>::value>
    class __make_unsigned_selector;

  template<typename _Tp>
    class __make_unsigned_selector<_Tp, true, false>
    {
      using __unsigned_type
 = typename __make_unsigned<__remove_cv_t<_Tp>>::__type;

    public:
      using __type
 = typename __match_cv_qualifiers<_Tp, __unsigned_type>::__type;
    };

  class __make_unsigned_selector_base
  {
  protected:
    template<typename...> struct _List { };

    template<typename _Tp, typename... _Up>
      struct _List<_Tp, _Up...> : _List<_Up...>
      { static constexpr size_t __size = sizeof(_Tp); };

    template<size_t _Sz, typename _Tp, bool = (_Sz <= _Tp::__size)>
      struct __select;

    template<size_t _Sz, typename _Uint, typename... _UInts>
      struct __select<_Sz, _List<_Uint, _UInts...>, true>
      { using __type = _Uint; };

    template<size_t _Sz, typename _Uint, typename... _UInts>
      struct __select<_Sz, _List<_Uint, _UInts...>, false>
      : __select<_Sz, _List<_UInts...>>
      { };
  };


  template<typename _Tp>
    class __make_unsigned_selector<_Tp, false, true>
    : __make_unsigned_selector_base
    {

      using _UInts = _List<unsigned char, unsigned short, unsigned int,
      unsigned long, unsigned long long>;

      using __unsigned_type = typename __select<sizeof(_Tp), _UInts>::__type;

    public:
      using __type
 = typename __match_cv_qualifiers<_Tp, __unsigned_type>::__type;
    };






  template<>
    struct __make_unsigned<wchar_t>
    {
      using __type
 = typename __make_unsigned_selector<wchar_t, false, true>::__type;
    };
# 1806 "/usr/include/c++/10/type_traits" 3
  template<>
    struct __make_unsigned<char16_t>
    {
      using __type
 = typename __make_unsigned_selector<char16_t, false, true>::__type;
    };

  template<>
    struct __make_unsigned<char32_t>
    {
      using __type
 = typename __make_unsigned_selector<char32_t, false, true>::__type;
    };





  template<typename _Tp>
    struct make_unsigned
    { typedef typename __make_unsigned_selector<_Tp>::__type type; };


  template<>
    struct make_unsigned<bool>;



  template<typename _Tp>
    struct __make_signed
    { typedef _Tp __type; };

  template<>
    struct __make_signed<char>
    { typedef signed char __type; };

  template<>
    struct __make_signed<unsigned char>
    { typedef signed char __type; };

  template<>
    struct __make_signed<unsigned short>
    { typedef signed short __type; };

  template<>
    struct __make_signed<unsigned int>
    { typedef signed int __type; };

  template<>
    struct __make_signed<unsigned long>
    { typedef signed long __type; };

  template<>
    struct __make_signed<unsigned long long>
    { typedef signed long long __type; };


  template<>
    struct __make_signed<unsigned __int128>
    { typedef __int128 __type; };
# 1884 "/usr/include/c++/10/type_traits" 3
  template<typename _Tp,
    bool _IsInt = is_integral<_Tp>::value,
    bool _IsEnum = is_enum<_Tp>::value>
    class __make_signed_selector;

  template<typename _Tp>
    class __make_signed_selector<_Tp, true, false>
    {
      using __signed_type
 = typename __make_signed<__remove_cv_t<_Tp>>::__type;

    public:
      using __type
 = typename __match_cv_qualifiers<_Tp, __signed_type>::__type;
    };


  template<typename _Tp>
    class __make_signed_selector<_Tp, false, true>
    {
      typedef typename __make_unsigned_selector<_Tp>::__type __unsigned_type;

    public:
      typedef typename __make_signed_selector<__unsigned_type>::__type __type;
    };






  template<>
    struct __make_signed<wchar_t>
    {
      using __type
 = typename __make_signed_selector<wchar_t, false, true>::__type;
    };
# 1932 "/usr/include/c++/10/type_traits" 3
  template<>
    struct __make_signed<char16_t>
    {
      using __type
 = typename __make_signed_selector<char16_t, false, true>::__type;
    };

  template<>
    struct __make_signed<char32_t>
    {
      using __type
 = typename __make_signed_selector<char32_t, false, true>::__type;
    };





  template<typename _Tp>
    struct make_signed
    { typedef typename __make_signed_selector<_Tp>::__type type; };


  template<>
    struct make_signed<bool>;



  template<typename _Tp>
    using make_signed_t = typename make_signed<_Tp>::type;


  template<typename _Tp>
    using make_unsigned_t = typename make_unsigned<_Tp>::type;





  template<typename _Tp>
    struct remove_extent
    { typedef _Tp type; };

  template<typename _Tp, std::size_t _Size>
    struct remove_extent<_Tp[_Size]>
    { typedef _Tp type; };

  template<typename _Tp>
    struct remove_extent<_Tp[]>
    { typedef _Tp type; };


  template<typename _Tp>
    struct remove_all_extents
    { typedef _Tp type; };

  template<typename _Tp, std::size_t _Size>
    struct remove_all_extents<_Tp[_Size]>
    { typedef typename remove_all_extents<_Tp>::type type; };

  template<typename _Tp>
    struct remove_all_extents<_Tp[]>
    { typedef typename remove_all_extents<_Tp>::type type; };



  template<typename _Tp>
    using remove_extent_t = typename remove_extent<_Tp>::type;


  template<typename _Tp>
    using remove_all_extents_t = typename remove_all_extents<_Tp>::type;




  template<typename _Tp, typename>
    struct __remove_pointer_helper
    { typedef _Tp type; };

  template<typename _Tp, typename _Up>
    struct __remove_pointer_helper<_Tp, _Up*>
    { typedef _Up type; };


  template<typename _Tp>
    struct remove_pointer
    : public __remove_pointer_helper<_Tp, __remove_cv_t<_Tp>>
    { };


  template<typename _Tp, bool = __or_<__is_referenceable<_Tp>,
          is_void<_Tp>>::value>
    struct __add_pointer_helper
    { typedef _Tp type; };

  template<typename _Tp>
    struct __add_pointer_helper<_Tp, true>
    { typedef typename remove_reference<_Tp>::type* type; };

  template<typename _Tp>
    struct add_pointer
    : public __add_pointer_helper<_Tp>
    { };



  template<typename _Tp>
    using remove_pointer_t = typename remove_pointer<_Tp>::type;


  template<typename _Tp>
    using add_pointer_t = typename add_pointer<_Tp>::type;


  template<std::size_t _Len>
    struct __aligned_storage_msa
    {
      union __type
      {
 unsigned char __data[_Len];
 struct __attribute__((__aligned__)) { } __align;
      };
    };
# 2067 "/usr/include/c++/10/type_traits" 3
  template<std::size_t _Len, std::size_t _Align =
    __alignof__(typename __aligned_storage_msa<_Len>::__type)>
    struct aligned_storage
    {
      union type
      {
 unsigned char __data[_Len];
 struct __attribute__((__aligned__((_Align)))) { } __align;
      };
    };

  template <typename... _Types>
    struct __strictest_alignment
    {
      static const size_t _S_alignment = 0;
      static const size_t _S_size = 0;
    };

  template <typename _Tp, typename... _Types>
    struct __strictest_alignment<_Tp, _Types...>
    {
      static const size_t _S_alignment =
        alignof(_Tp) > __strictest_alignment<_Types...>::_S_alignment
 ? alignof(_Tp) : __strictest_alignment<_Types...>::_S_alignment;
      static const size_t _S_size =
        sizeof(_Tp) > __strictest_alignment<_Types...>::_S_size
 ? sizeof(_Tp) : __strictest_alignment<_Types...>::_S_size;
    };
# 2106 "/usr/include/c++/10/type_traits" 3
  template <size_t _Len, typename... _Types>
    struct aligned_union
    {
    private:
      static_assert(sizeof...(_Types) != 0, "At least one type is required");

      using __strictest = __strictest_alignment<_Types...>;
      static const size_t _S_len = _Len > __strictest::_S_size
 ? _Len : __strictest::_S_size;
    public:

      static const size_t alignment_value = __strictest::_S_alignment;

      typedef typename aligned_storage<_S_len, alignment_value>::type type;
    };

  template <size_t _Len, typename... _Types>
    const size_t aligned_union<_Len, _Types...>::alignment_value;



  template<typename _Up,
    bool _IsArray = is_array<_Up>::value,
    bool _IsFunction = is_function<_Up>::value>
    struct __decay_selector;


  template<typename _Up>
    struct __decay_selector<_Up, false, false>
    { typedef __remove_cv_t<_Up> __type; };

  template<typename _Up>
    struct __decay_selector<_Up, true, false>
    { typedef typename remove_extent<_Up>::type* __type; };

  template<typename _Up>
    struct __decay_selector<_Up, false, true>
    { typedef typename add_pointer<_Up>::type __type; };


  template<typename _Tp>
    class decay
    {
      typedef typename remove_reference<_Tp>::type __remove_type;

    public:
      typedef typename __decay_selector<__remove_type>::__type type;
    };


  template<typename _Tp>
    using __decay_t = typename decay<_Tp>::type;

  template<typename _Tp>
    class reference_wrapper;


  template<typename _Tp>
    struct __strip_reference_wrapper
    {
      typedef _Tp __type;
    };

  template<typename _Tp>
    struct __strip_reference_wrapper<reference_wrapper<_Tp> >
    {
      typedef _Tp& __type;
    };

  template<typename _Tp>
    using __decay_and_strip = __strip_reference_wrapper<__decay_t<_Tp>>;




  template<bool, typename _Tp = void>
    struct enable_if
    { };


  template<typename _Tp>
    struct enable_if<true, _Tp>
    { typedef _Tp type; };


  template<bool _Cond, typename _Tp = void>
    using __enable_if_t = typename enable_if<_Cond, _Tp>::type;

  template<typename... _Cond>
    using _Require = __enable_if_t<__and_<_Cond...>::value>;



  template<bool _Cond, typename _Iftrue, typename _Iffalse>
    struct conditional
    { typedef _Iftrue type; };


  template<typename _Iftrue, typename _Iffalse>
    struct conditional<false, _Iftrue, _Iffalse>
    { typedef _Iffalse type; };


  template<typename _Tp>
    using __remove_cvref_t
     = typename remove_cv<typename remove_reference<_Tp>::type>::type;


  template<typename... _Tp>
    struct common_type;



  struct __do_common_type_impl
  {
    template<typename _Tp, typename _Up>
      using __cond_t
 = decltype(true ? std::declval<_Tp>() : std::declval<_Up>());



    template<typename _Tp, typename _Up>
      static __success_type<__decay_t<__cond_t<_Tp, _Up>>>
      _S_test(int);
# 2239 "/usr/include/c++/10/type_traits" 3
    template<typename, typename>
      static __failure_type
      _S_test_2(...);

    template<typename _Tp, typename _Up>
      static decltype(_S_test_2<_Tp, _Up>(0))
      _S_test(...);
  };


  template<>
    struct common_type<>
    { };


  template<typename _Tp0>
    struct common_type<_Tp0>
    : public common_type<_Tp0, _Tp0>
    { };


  template<typename _Tp1, typename _Tp2,
    typename _Dp1 = __decay_t<_Tp1>, typename _Dp2 = __decay_t<_Tp2>>
    struct __common_type_impl
    {


      using type = common_type<_Dp1, _Dp2>;
    };

  template<typename _Tp1, typename _Tp2>
    struct __common_type_impl<_Tp1, _Tp2, _Tp1, _Tp2>
    : private __do_common_type_impl
    {


      using type = decltype(_S_test<_Tp1, _Tp2>(0));
    };


  template<typename _Tp1, typename _Tp2>
    struct common_type<_Tp1, _Tp2>
    : public __common_type_impl<_Tp1, _Tp2>::type
    { };

  template<typename...>
    struct __common_type_pack
    { };

  template<typename, typename, typename = void>
    struct __common_type_fold;


  template<typename _Tp1, typename _Tp2, typename... _Rp>
    struct common_type<_Tp1, _Tp2, _Rp...>
    : public __common_type_fold<common_type<_Tp1, _Tp2>,
    __common_type_pack<_Rp...>>
    { };




  template<typename _CTp, typename... _Rp>
    struct __common_type_fold<_CTp, __common_type_pack<_Rp...>,
         __void_t<typename _CTp::type>>
    : public common_type<typename _CTp::type, _Rp...>
    { };


  template<typename _CTp, typename _Rp>
    struct __common_type_fold<_CTp, _Rp, void>
    { };

  template<typename _Tp, bool = is_enum<_Tp>::value>
    struct __underlying_type_impl
    {
      using type = __underlying_type(_Tp);
    };

  template<typename _Tp>
    struct __underlying_type_impl<_Tp, false>
    { };


  template<typename _Tp>
    struct underlying_type
    : public __underlying_type_impl<_Tp>
    { };

  template<typename _Tp>
    struct __declval_protector
    {
      static const bool __stop = false;
    };

  template<typename _Tp>
    auto declval() noexcept -> decltype(__declval<_Tp>(0))
    {
      static_assert(__declval_protector<_Tp>::__stop,
      "declval() must not be used!");
      return __declval<_Tp>(0);
    }


  template<typename _Signature>
    class result_of;





  struct __invoke_memfun_ref { };
  struct __invoke_memfun_deref { };
  struct __invoke_memobj_ref { };
  struct __invoke_memobj_deref { };
  struct __invoke_other { };


  template<typename _Tp, typename _Tag>
    struct __result_of_success : __success_type<_Tp>
    { using __invoke_type = _Tag; };


  struct __result_of_memfun_ref_impl
  {
    template<typename _Fp, typename _Tp1, typename... _Args>
      static __result_of_success<decltype(
      (std::declval<_Tp1>().*std::declval<_Fp>())(std::declval<_Args>()...)
      ), __invoke_memfun_ref> _S_test(int);

    template<typename...>
      static __failure_type _S_test(...);
  };

  template<typename _MemPtr, typename _Arg, typename... _Args>
    struct __result_of_memfun_ref
    : private __result_of_memfun_ref_impl
    {
      typedef decltype(_S_test<_MemPtr, _Arg, _Args...>(0)) type;
    };


  struct __result_of_memfun_deref_impl
  {
    template<typename _Fp, typename _Tp1, typename... _Args>
      static __result_of_success<decltype(
      ((*std::declval<_Tp1>()).*std::declval<_Fp>())(std::declval<_Args>()...)
      ), __invoke_memfun_deref> _S_test(int);

    template<typename...>
      static __failure_type _S_test(...);
  };

  template<typename _MemPtr, typename _Arg, typename... _Args>
    struct __result_of_memfun_deref
    : private __result_of_memfun_deref_impl
    {
      typedef decltype(_S_test<_MemPtr, _Arg, _Args...>(0)) type;
    };


  struct __result_of_memobj_ref_impl
  {
    template<typename _Fp, typename _Tp1>
      static __result_of_success<decltype(
      std::declval<_Tp1>().*std::declval<_Fp>()
      ), __invoke_memobj_ref> _S_test(int);

    template<typename, typename>
      static __failure_type _S_test(...);
  };

  template<typename _MemPtr, typename _Arg>
    struct __result_of_memobj_ref
    : private __result_of_memobj_ref_impl
    {
      typedef decltype(_S_test<_MemPtr, _Arg>(0)) type;
    };


  struct __result_of_memobj_deref_impl
  {
    template<typename _Fp, typename _Tp1>
      static __result_of_success<decltype(
      (*std::declval<_Tp1>()).*std::declval<_Fp>()
      ), __invoke_memobj_deref> _S_test(int);

    template<typename, typename>
      static __failure_type _S_test(...);
  };

  template<typename _MemPtr, typename _Arg>
    struct __result_of_memobj_deref
    : private __result_of_memobj_deref_impl
    {
      typedef decltype(_S_test<_MemPtr, _Arg>(0)) type;
    };

  template<typename _MemPtr, typename _Arg>
    struct __result_of_memobj;

  template<typename _Res, typename _Class, typename _Arg>
    struct __result_of_memobj<_Res _Class::*, _Arg>
    {
      typedef __remove_cvref_t<_Arg> _Argval;
      typedef _Res _Class::* _MemPtr;
      typedef typename conditional<__or_<is_same<_Argval, _Class>,
        is_base_of<_Class, _Argval>>::value,
        __result_of_memobj_ref<_MemPtr, _Arg>,
        __result_of_memobj_deref<_MemPtr, _Arg>
      >::type::type type;
    };

  template<typename _MemPtr, typename _Arg, typename... _Args>
    struct __result_of_memfun;

  template<typename _Res, typename _Class, typename _Arg, typename... _Args>
    struct __result_of_memfun<_Res _Class::*, _Arg, _Args...>
    {
      typedef typename remove_reference<_Arg>::type _Argval;
      typedef _Res _Class::* _MemPtr;
      typedef typename conditional<is_base_of<_Class, _Argval>::value,
        __result_of_memfun_ref<_MemPtr, _Arg, _Args...>,
        __result_of_memfun_deref<_MemPtr, _Arg, _Args...>
      >::type::type type;
    };






  template<typename _Tp, typename _Up = __remove_cvref_t<_Tp>>
    struct __inv_unwrap
    {
      using type = _Tp;
    };

  template<typename _Tp, typename _Up>
    struct __inv_unwrap<_Tp, reference_wrapper<_Up>>
    {
      using type = _Up&;
    };

  template<bool, bool, typename _Functor, typename... _ArgTypes>
    struct __result_of_impl
    {
      typedef __failure_type type;
    };

  template<typename _MemPtr, typename _Arg>
    struct __result_of_impl<true, false, _MemPtr, _Arg>
    : public __result_of_memobj<__decay_t<_MemPtr>,
    typename __inv_unwrap<_Arg>::type>
    { };

  template<typename _MemPtr, typename _Arg, typename... _Args>
    struct __result_of_impl<false, true, _MemPtr, _Arg, _Args...>
    : public __result_of_memfun<__decay_t<_MemPtr>,
    typename __inv_unwrap<_Arg>::type, _Args...>
    { };


  struct __result_of_other_impl
  {
    template<typename _Fn, typename... _Args>
      static __result_of_success<decltype(
      std::declval<_Fn>()(std::declval<_Args>()...)
      ), __invoke_other> _S_test(int);

    template<typename...>
      static __failure_type _S_test(...);
  };

  template<typename _Functor, typename... _ArgTypes>
    struct __result_of_impl<false, false, _Functor, _ArgTypes...>
    : private __result_of_other_impl
    {
      typedef decltype(_S_test<_Functor, _ArgTypes...>(0)) type;
    };


  template<typename _Functor, typename... _ArgTypes>
    struct __invoke_result
    : public __result_of_impl<
        is_member_object_pointer<
          typename remove_reference<_Functor>::type
        >::value,
        is_member_function_pointer<
          typename remove_reference<_Functor>::type
        >::value,
 _Functor, _ArgTypes...
      >::type
    { };

  template<typename _Functor, typename... _ArgTypes>
    struct result_of<_Functor(_ArgTypes...)>
    : public __invoke_result<_Functor, _ArgTypes...>
    { };



  template<size_t _Len, size_t _Align =
     __alignof__(typename __aligned_storage_msa<_Len>::__type)>
    using aligned_storage_t = typename aligned_storage<_Len, _Align>::type;

  template <size_t _Len, typename... _Types>
    using aligned_union_t = typename aligned_union<_Len, _Types...>::type;


  template<typename _Tp>
    using decay_t = typename decay<_Tp>::type;


  template<bool _Cond, typename _Tp = void>
    using enable_if_t = typename enable_if<_Cond, _Tp>::type;


  template<bool _Cond, typename _Iftrue, typename _Iffalse>
    using conditional_t = typename conditional<_Cond, _Iftrue, _Iffalse>::type;


  template<typename... _Tp>
    using common_type_t = typename common_type<_Tp...>::type;


  template<typename _Tp>
    using underlying_type_t = typename underlying_type<_Tp>::type;


  template<typename _Tp>
    using result_of_t = typename result_of<_Tp>::type;





  template<typename...> using void_t = void;



  template<typename _Default, typename _AlwaysVoid,
    template<typename...> class _Op, typename... _Args>
    struct __detector
    {
      using value_t = false_type;
      using type = _Default;
    };


  template<typename _Default, template<typename...> class _Op,
     typename... _Args>
    struct __detector<_Default, __void_t<_Op<_Args...>>, _Op, _Args...>
    {
      using value_t = true_type;
      using type = _Op<_Args...>;
    };


  template<typename _Default, template<typename...> class _Op,
    typename... _Args>
    using __detected_or = __detector<_Default, void, _Op, _Args...>;


  template<typename _Default, template<typename...> class _Op,
    typename... _Args>
    using __detected_or_t
      = typename __detected_or<_Default, _Op, _Args...>::type;
# 2624 "/usr/include/c++/10/type_traits" 3
  template <typename _Tp>
    struct __is_swappable;

  template <typename _Tp>
    struct __is_nothrow_swappable;

  template<typename... _Elements>
    class tuple;

  template<typename>
    struct __is_tuple_like_impl : false_type
    { };

  template<typename... _Tps>
    struct __is_tuple_like_impl<tuple<_Tps...>> : true_type
    { };


  template<typename _Tp>
    struct __is_tuple_like
    : public __is_tuple_like_impl<__remove_cvref_t<_Tp>>::type
    { };

  template<typename _Tp>
   
    inline
    _Require<__not_<__is_tuple_like<_Tp>>,
      is_move_constructible<_Tp>,
      is_move_assignable<_Tp>>
    swap(_Tp&, _Tp&)
    noexcept(__and_<is_nothrow_move_constructible<_Tp>,
             is_nothrow_move_assignable<_Tp>>::value);

  template<typename _Tp, size_t _Nm>
   
    inline
    __enable_if_t<__is_swappable<_Tp>::value>
    swap(_Tp (&__a)[_Nm], _Tp (&__b)[_Nm])
    noexcept(__is_nothrow_swappable<_Tp>::value);

  namespace __swappable_details {
    using std::swap;

    struct __do_is_swappable_impl
    {
      template<typename _Tp, typename
               = decltype(swap(std::declval<_Tp&>(), std::declval<_Tp&>()))>
        static true_type __test(int);

      template<typename>
        static false_type __test(...);
    };

    struct __do_is_nothrow_swappable_impl
    {
      template<typename _Tp>
        static __bool_constant<
          noexcept(swap(std::declval<_Tp&>(), std::declval<_Tp&>()))
        > __test(int);

      template<typename>
        static false_type __test(...);
    };

  }

  template<typename _Tp>
    struct __is_swappable_impl
    : public __swappable_details::__do_is_swappable_impl
    {
      typedef decltype(__test<_Tp>(0)) type;
    };

  template<typename _Tp>
    struct __is_nothrow_swappable_impl
    : public __swappable_details::__do_is_nothrow_swappable_impl
    {
      typedef decltype(__test<_Tp>(0)) type;
    };

  template<typename _Tp>
    struct __is_swappable
    : public __is_swappable_impl<_Tp>::type
    { };

  template<typename _Tp>
    struct __is_nothrow_swappable
    : public __is_nothrow_swappable_impl<_Tp>::type
    { };






  template<typename _Tp>
    struct is_swappable
    : public __is_swappable_impl<_Tp>::type
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };


  template<typename _Tp>
    struct is_nothrow_swappable
    : public __is_nothrow_swappable_impl<_Tp>::type
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };



  template<typename _Tp>
    constexpr bool is_swappable_v =
      is_swappable<_Tp>::value;


  template<typename _Tp>
    constexpr bool is_nothrow_swappable_v =
      is_nothrow_swappable<_Tp>::value;


  namespace __swappable_with_details {
    using std::swap;

    struct __do_is_swappable_with_impl
    {
      template<typename _Tp, typename _Up, typename
               = decltype(swap(std::declval<_Tp>(), std::declval<_Up>())),
               typename
               = decltype(swap(std::declval<_Up>(), std::declval<_Tp>()))>
        static true_type __test(int);

      template<typename, typename>
        static false_type __test(...);
    };

    struct __do_is_nothrow_swappable_with_impl
    {
      template<typename _Tp, typename _Up>
        static __bool_constant<
          noexcept(swap(std::declval<_Tp>(), std::declval<_Up>()))
          &&
          noexcept(swap(std::declval<_Up>(), std::declval<_Tp>()))
        > __test(int);

      template<typename, typename>
        static false_type __test(...);
    };

  }

  template<typename _Tp, typename _Up>
    struct __is_swappable_with_impl
    : public __swappable_with_details::__do_is_swappable_with_impl
    {
      typedef decltype(__test<_Tp, _Up>(0)) type;
    };


  template<typename _Tp>
    struct __is_swappable_with_impl<_Tp&, _Tp&>
    : public __swappable_details::__do_is_swappable_impl
    {
      typedef decltype(__test<_Tp&>(0)) type;
    };

  template<typename _Tp, typename _Up>
    struct __is_nothrow_swappable_with_impl
    : public __swappable_with_details::__do_is_nothrow_swappable_with_impl
    {
      typedef decltype(__test<_Tp, _Up>(0)) type;
    };


  template<typename _Tp>
    struct __is_nothrow_swappable_with_impl<_Tp&, _Tp&>
    : public __swappable_details::__do_is_nothrow_swappable_impl
    {
      typedef decltype(__test<_Tp&>(0)) type;
    };


  template<typename _Tp, typename _Up>
    struct is_swappable_with
    : public __is_swappable_with_impl<_Tp, _Up>::type
    { };


  template<typename _Tp, typename _Up>
    struct is_nothrow_swappable_with
    : public __is_nothrow_swappable_with_impl<_Tp, _Up>::type
    { };



  template<typename _Tp, typename _Up>
    constexpr bool is_swappable_with_v =
      is_swappable_with<_Tp, _Up>::value;


  template<typename _Tp, typename _Up>
    constexpr bool is_nothrow_swappable_with_v =
      is_nothrow_swappable_with<_Tp, _Up>::value;







  template<typename _Result, typename _Ret,
    bool = is_void<_Ret>::value, typename = void>
    struct __is_invocable_impl : false_type { };


  template<typename _Result, typename _Ret>
    struct __is_invocable_impl<_Result, _Ret,
                                true,
          __void_t<typename _Result::type>>
    : true_type
    { };

#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wctor-dtor-privacy"

  template<typename _Result, typename _Ret>
    struct __is_invocable_impl<_Result, _Ret,
                                false,
          __void_t<typename _Result::type>>
    {
    private:


      static typename _Result::type _S_get();

      template<typename _Tp>
 static void _S_conv(_Tp);


      template<typename _Tp, typename = decltype(_S_conv<_Tp>(_S_get()))>
 static true_type
 _S_test(int);

      template<typename _Tp>
 static false_type
 _S_test(...);

    public:
      using type = decltype(_S_test<_Ret>(1));
    };
#pragma GCC diagnostic pop

  template<typename _Fn, typename... _ArgTypes>
    struct __is_invocable
    : __is_invocable_impl<__invoke_result<_Fn, _ArgTypes...>, void>::type
    { };

  template<typename _Fn, typename _Tp, typename... _Args>
    constexpr bool __call_is_nt(__invoke_memfun_ref)
    {
      using _Up = typename __inv_unwrap<_Tp>::type;
      return noexcept((std::declval<_Up>().*std::declval<_Fn>())(
     std::declval<_Args>()...));
    }

  template<typename _Fn, typename _Tp, typename... _Args>
    constexpr bool __call_is_nt(__invoke_memfun_deref)
    {
      return noexcept(((*std::declval<_Tp>()).*std::declval<_Fn>())(
     std::declval<_Args>()...));
    }

  template<typename _Fn, typename _Tp>
    constexpr bool __call_is_nt(__invoke_memobj_ref)
    {
      using _Up = typename __inv_unwrap<_Tp>::type;
      return noexcept(std::declval<_Up>().*std::declval<_Fn>());
    }

  template<typename _Fn, typename _Tp>
    constexpr bool __call_is_nt(__invoke_memobj_deref)
    {
      return noexcept((*std::declval<_Tp>()).*std::declval<_Fn>());
    }

  template<typename _Fn, typename... _Args>
    constexpr bool __call_is_nt(__invoke_other)
    {
      return noexcept(std::declval<_Fn>()(std::declval<_Args>()...));
    }

  template<typename _Result, typename _Fn, typename... _Args>
    struct __call_is_nothrow
    : __bool_constant<
 std::__call_is_nt<_Fn, _Args...>(typename _Result::__invoke_type{})
      >
    { };

  template<typename _Fn, typename... _Args>
    using __call_is_nothrow_
      = __call_is_nothrow<__invoke_result<_Fn, _Args...>, _Fn, _Args...>;


  template<typename _Fn, typename... _Args>
    struct __is_nothrow_invocable
    : __and_<__is_invocable<_Fn, _Args...>,
             __call_is_nothrow_<_Fn, _Args...>>::type
    { };

#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wctor-dtor-privacy"
  struct __nonesuchbase {};
  struct __nonesuch : private __nonesuchbase {
    ~__nonesuch() = delete;
    __nonesuch(__nonesuch const&) = delete;
    void operator=(__nonesuch const&) = delete;
  };
#pragma GCC diagnostic pop
# 3461 "/usr/include/c++/10/type_traits" 3

}
# 39 "/usr/include/c++/10/unordered_map" 2 3
# 1 "/usr/include/c++/10/initializer_list" 1 3
# 33 "/usr/include/c++/10/initializer_list" 3
       
# 34 "/usr/include/c++/10/initializer_list" 3





#pragma GCC visibility push(default)



namespace std
{

  template<class _E>
    class initializer_list
    {
    public:
      typedef _E value_type;
      typedef const _E& reference;
      typedef const _E& const_reference;
      typedef size_t size_type;
      typedef const _E* iterator;
      typedef const _E* const_iterator;

    private:
      iterator _M_array;
      size_type _M_len;


      constexpr initializer_list(const_iterator __a, size_type __l)
      : _M_array(__a), _M_len(__l) { }

    public:
      constexpr initializer_list() noexcept
      : _M_array(0), _M_len(0) { }


      constexpr size_type
      size() const noexcept { return _M_len; }


      constexpr const_iterator
      begin() const noexcept { return _M_array; }


      constexpr const_iterator
      end() const noexcept { return begin() + size(); }
    };







  template<class _Tp>
    constexpr const _Tp*
    begin(initializer_list<_Tp> __ils) noexcept
    { return __ils.begin(); }







  template<class _Tp>
    constexpr const _Tp*
    end(initializer_list<_Tp> __ils) noexcept
    { return __ils.end(); }
}

#pragma GCC visibility pop
# 40 "/usr/include/c++/10/unordered_map" 2 3
# 1 "/usr/include/c++/10/bits/allocator.h" 1 3
# 46 "/usr/include/c++/10/bits/allocator.h" 3
# 1 "/usr/include/x86_64-linux-gnu/c++/10/bits/c++allocator.h" 1 3
# 33 "/usr/include/x86_64-linux-gnu/c++/10/bits/c++allocator.h" 3
# 1 "/usr/include/c++/10/ext/new_allocator.h" 1 3
# 33 "/usr/include/c++/10/ext/new_allocator.h" 3
# 1 "/usr/include/c++/10/new" 1 3
# 38 "/usr/include/c++/10/new" 3
       
# 39 "/usr/include/c++/10/new" 3


# 1 "/usr/include/c++/10/exception" 1 3
# 33 "/usr/include/c++/10/exception" 3
       
# 34 "/usr/include/c++/10/exception" 3

#pragma GCC visibility push(default)


# 1 "/usr/include/c++/10/bits/exception.h" 1 3
# 34 "/usr/include/c++/10/bits/exception.h" 3
       
# 35 "/usr/include/c++/10/bits/exception.h" 3

#pragma GCC visibility push(default)



extern "C++" {

namespace std
{
# 60 "/usr/include/c++/10/bits/exception.h" 3
  class exception
  {
  public:
    exception() noexcept { }
    virtual ~exception() noexcept;

    exception(const exception&) = default;
    exception& operator=(const exception&) = default;
    exception(exception&&) = default;
    exception& operator=(exception&&) = default;




    virtual const char*
    what() const noexcept;
  };



}

}

#pragma GCC visibility pop
# 39 "/usr/include/c++/10/exception" 2 3

extern "C++" {

namespace std
{






  class bad_exception : public exception
  {
  public:
    bad_exception() noexcept { }



    virtual ~bad_exception() noexcept;


    virtual const char*
    what() const noexcept;
  };


  typedef void (*terminate_handler) ();


  typedef void (*unexpected_handler) ();


  terminate_handler set_terminate(terminate_handler) noexcept;



  terminate_handler get_terminate() noexcept;




  void terminate() noexcept __attribute__ ((__noreturn__));


  unexpected_handler set_unexpected(unexpected_handler) noexcept;



  unexpected_handler get_unexpected() noexcept;




  void unexpected() __attribute__ ((__noreturn__));
# 105 "/usr/include/c++/10/exception" 3
 
  bool uncaught_exception() noexcept __attribute__ ((__pure__));




  int uncaught_exceptions() noexcept __attribute__ ((__pure__));



}

namespace __gnu_cxx
{

# 137 "/usr/include/c++/10/exception" 3
  void __verbose_terminate_handler();


}

}

#pragma GCC visibility pop


# 1 "/usr/include/c++/10/bits/exception_ptr.h" 1 3
# 34 "/usr/include/c++/10/bits/exception_ptr.h" 3
#pragma GCC visibility push(default)


# 1 "/usr/include/c++/10/bits/exception_defines.h" 1 3
# 38 "/usr/include/c++/10/bits/exception_ptr.h" 2 3
# 1 "/usr/include/c++/10/bits/cxxabi_init_exception.h" 1 3
# 34 "/usr/include/c++/10/bits/cxxabi_init_exception.h" 3
       
# 35 "/usr/include/c++/10/bits/cxxabi_init_exception.h" 3

#pragma GCC visibility push(default)

# 1 "/usr/lib/gcc/x86_64-linux-gnu/10/include/stddef.h" 1 3 4
# 39 "/usr/include/c++/10/bits/cxxabi_init_exception.h" 2 3
# 50 "/usr/include/c++/10/bits/cxxabi_init_exception.h" 3
namespace std
{
  class type_info;
}

namespace __cxxabiv1
{
  struct __cxa_refcounted_exception;

  extern "C"
    {

      void*
      __cxa_allocate_exception(size_t) noexcept;

      void
      __cxa_free_exception(void*) noexcept;


      __cxa_refcounted_exception*
      __cxa_init_primary_exception(void *object, std::type_info *tinfo,
                void ( *dest) (void *)) noexcept;

    }
}



#pragma GCC visibility pop
# 39 "/usr/include/c++/10/bits/exception_ptr.h" 2 3
# 1 "/usr/include/c++/10/typeinfo" 1 3
# 32 "/usr/include/c++/10/typeinfo" 3
       
# 33 "/usr/include/c++/10/typeinfo" 3



# 1 "/usr/include/c++/10/bits/hash_bytes.h" 1 3
# 33 "/usr/include/c++/10/bits/hash_bytes.h" 3
       
# 34 "/usr/include/c++/10/bits/hash_bytes.h" 3



namespace std
{







  size_t
  _Hash_bytes(const void* __ptr, size_t __len, size_t __seed);





  size_t
  _Fnv_hash_bytes(const void* __ptr, size_t __len, size_t __seed);


}
# 37 "/usr/include/c++/10/typeinfo" 2 3


#pragma GCC visibility push(default)

extern "C++" {

namespace __cxxabiv1
{
  class __class_type_info;
}
# 80 "/usr/include/c++/10/typeinfo" 3
namespace std
{






  class type_info
  {
  public:




    virtual ~type_info();



    const char* name() const noexcept
    { return __name[0] == '*' ? __name + 1 : __name; }
# 115 "/usr/include/c++/10/typeinfo" 3
    bool before(const type_info& __arg) const noexcept
    { return (__name[0] == '*' && __arg.__name[0] == '*')
 ? __name < __arg.__name
 : __builtin_strcmp (__name, __arg.__name) < 0; }

    bool operator==(const type_info& __arg) const noexcept
    {
      return ((__name == __arg.__name)
       || (__name[0] != '*' &&
    __builtin_strcmp (__name, __arg.__name) == 0));
    }
# 138 "/usr/include/c++/10/typeinfo" 3
    bool operator!=(const type_info& __arg) const noexcept
    { return !operator==(__arg); }



    size_t hash_code() const noexcept
    {

      return _Hash_bytes(name(), __builtin_strlen(name()),
    static_cast<size_t>(0xc70f6907UL));



    }



    virtual bool __is_pointer_p() const;


    virtual bool __is_function_p() const;







    virtual bool __do_catch(const type_info *__thr_type, void **__thr_obj,
       unsigned __outer) const;


    virtual bool __do_upcast(const __cxxabiv1::__class_type_info *__target,
        void **__obj_ptr) const;

  protected:
    const char *__name;

    explicit type_info(const char *__n): __name(__n) { }

  private:

    type_info& operator=(const type_info&);
    type_info(const type_info&);
  };







  class bad_cast : public exception
  {
  public:
    bad_cast() noexcept { }



    virtual ~bad_cast() noexcept;


    virtual const char* what() const noexcept;
  };





  class bad_typeid : public exception
  {
  public:
    bad_typeid () noexcept { }



    virtual ~bad_typeid() noexcept;


    virtual const char* what() const noexcept;
  };
}

}

#pragma GCC visibility pop
# 40 "/usr/include/c++/10/bits/exception_ptr.h" 2 3
# 1 "/usr/include/c++/10/new" 1 3
# 41 "/usr/include/c++/10/bits/exception_ptr.h" 2 3


# 1 "/usr/include/c++/10/bits/move.h" 1 3
# 38 "/usr/include/c++/10/bits/move.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{







  template<typename _Tp>
    inline constexpr _Tp*
    __addressof(_Tp& __r) noexcept
    { return __builtin_addressof(__r); }




}



namespace std __attribute__ ((__visibility__ ("default")))
{

# 74 "/usr/include/c++/10/bits/move.h" 3
  template<typename _Tp>
    constexpr _Tp&&
    forward(typename std::remove_reference<_Tp>::type& __t) noexcept
    { return static_cast<_Tp&&>(__t); }







  template<typename _Tp>
    constexpr _Tp&&
    forward(typename std::remove_reference<_Tp>::type&& __t) noexcept
    {
      static_assert(!std::is_lvalue_reference<_Tp>::value,
   "std::forward must not be used to convert an rvalue to an lvalue");
      return static_cast<_Tp&&>(__t);
    }






  template<typename _Tp>
    constexpr typename std::remove_reference<_Tp>::type&&
    move(_Tp&& __t) noexcept
    { return static_cast<typename std::remove_reference<_Tp>::type&&>(__t); }


  template<typename _Tp>
    struct __move_if_noexcept_cond
    : public __and_<__not_<is_nothrow_move_constructible<_Tp>>,
                    is_copy_constructible<_Tp>>::type { };
# 118 "/usr/include/c++/10/bits/move.h" 3
  template<typename _Tp>
    constexpr typename
    conditional<__move_if_noexcept_cond<_Tp>::value, const _Tp&, _Tp&&>::type
    move_if_noexcept(_Tp& __x) noexcept
    { return std::move(__x); }
# 138 "/usr/include/c++/10/bits/move.h" 3
  template<typename _Tp>
    inline _Tp*
    addressof(_Tp& __r) noexcept
    { return std::__addressof(__r); }



  template<typename _Tp>
    const _Tp* addressof(const _Tp&&) = delete;


  template <typename _Tp, typename _Up = _Tp>
   
    inline _Tp
    __exchange(_Tp& __obj, _Up&& __new_val)
    {
      _Tp __old_val = std::move(__obj);
      __obj = std::forward<_Up>(__new_val);
      return __old_val;
    }
# 179 "/usr/include/c++/10/bits/move.h" 3
  template<typename _Tp>
   
    inline

    typename enable_if<__and_<__not_<__is_tuple_like<_Tp>>,
         is_move_constructible<_Tp>,
         is_move_assignable<_Tp>>::value>::type



    swap(_Tp& __a, _Tp& __b)
    noexcept(__and_<is_nothrow_move_constructible<_Tp>, is_nothrow_move_assignable<_Tp>>::value)

    {




      _Tp __tmp = std::move(__a);
      __a = std::move(__b);
      __b = std::move(__tmp);
    }




  template<typename _Tp, size_t _Nm>
   
    inline

    typename enable_if<__is_swappable<_Tp>::value>::type



    swap(_Tp (&__a)[_Nm], _Tp (&__b)[_Nm])
    noexcept(__is_nothrow_swappable<_Tp>::value)
    {
      for (size_t __n = 0; __n < _Nm; ++__n)
 swap(__a[__n], __b[__n]);
    }



}
# 44 "/usr/include/c++/10/bits/exception_ptr.h" 2 3


extern "C++" {

namespace std
{
  class type_info;






  namespace __exception_ptr
  {
    class exception_ptr;
  }

  using __exception_ptr::exception_ptr;





  exception_ptr current_exception() noexcept;

  template<typename _Ex>
  exception_ptr make_exception_ptr(_Ex) noexcept;


  void rethrow_exception(exception_ptr) __attribute__ ((__noreturn__));

  namespace __exception_ptr
  {
    using std::rethrow_exception;





    class exception_ptr
    {
      void* _M_exception_object;

      explicit exception_ptr(void* __e) noexcept;

      void _M_addref() noexcept;
      void _M_release() noexcept;

      void *_M_get() const noexcept __attribute__ ((__pure__));

      friend exception_ptr std::current_exception() noexcept;
      friend void std::rethrow_exception(exception_ptr);
      template<typename _Ex>
      friend exception_ptr std::make_exception_ptr(_Ex) noexcept;

    public:
      exception_ptr() noexcept;

      exception_ptr(const exception_ptr&) noexcept;


      exception_ptr(nullptr_t) noexcept
      : _M_exception_object(0)
      { }

      exception_ptr(exception_ptr&& __o) noexcept
      : _M_exception_object(__o._M_exception_object)
      { __o._M_exception_object = 0; }
# 122 "/usr/include/c++/10/bits/exception_ptr.h" 3
      exception_ptr&
      operator=(const exception_ptr&) noexcept;


      exception_ptr&
      operator=(exception_ptr&& __o) noexcept
      {
        exception_ptr(static_cast<exception_ptr&&>(__o)).swap(*this);
        return *this;
      }


      ~exception_ptr() noexcept;

      void
      swap(exception_ptr&) noexcept;
# 149 "/usr/include/c++/10/bits/exception_ptr.h" 3
      explicit operator bool() const
      { return _M_exception_object; }


      friend bool
      operator==(const exception_ptr&, const exception_ptr&)
 noexcept __attribute__ ((__pure__));

      const class std::type_info*
      __cxa_exception_type() const noexcept
 __attribute__ ((__pure__));
    };



    bool
    operator==(const exception_ptr&, const exception_ptr&)
      noexcept __attribute__ ((__pure__));

    bool
    operator!=(const exception_ptr&, const exception_ptr&)
      noexcept __attribute__ ((__pure__));

    inline void
    swap(exception_ptr& __lhs, exception_ptr& __rhs)
    { __lhs.swap(__rhs); }




    template<typename _Ex>
      inline void
      __dest_thunk(void* __x)
      { static_cast<_Ex*>(__x)->~_Ex(); }


  }


  template<typename _Ex>
    exception_ptr
    make_exception_ptr(_Ex __ex) noexcept
    {


      using _Ex2 = typename remove_reference<_Ex>::type;
      void* __e = __cxxabiv1::__cxa_allocate_exception(sizeof(_Ex));
      (void) __cxxabiv1::__cxa_init_primary_exception(
   __e, const_cast<std::type_info*>(&typeid(_Ex)),
   __exception_ptr::__dest_thunk<_Ex2>);
      try
 {
   ::new (__e) _Ex2(std::forward<_Ex>(__ex));
          return exception_ptr(__e);
 }
      catch(...)
 {
   __cxxabiv1::__cxa_free_exception(__e);
   return current_exception();
 }
# 221 "/usr/include/c++/10/bits/exception_ptr.h" 3
    }


}

}

#pragma GCC visibility pop
# 148 "/usr/include/c++/10/exception" 2 3
# 1 "/usr/include/c++/10/bits/nested_exception.h" 1 3
# 33 "/usr/include/c++/10/bits/nested_exception.h" 3
#pragma GCC visibility push(default)
# 42 "/usr/include/c++/10/bits/nested_exception.h" 3
extern "C++" {

namespace std
{






  class nested_exception
  {
    exception_ptr _M_ptr;

  public:
    nested_exception() noexcept : _M_ptr(current_exception()) { }

    nested_exception(const nested_exception&) noexcept = default;

    nested_exception& operator=(const nested_exception&) noexcept = default;

    virtual ~nested_exception() noexcept;

    [[noreturn]]
    void
    rethrow_nested() const
    {
      if (_M_ptr)
 rethrow_exception(_M_ptr);
      std::terminate();
    }

    exception_ptr
    nested_ptr() const noexcept
    { return _M_ptr; }
  };



  template<typename _Except>
    struct _Nested_exception : public _Except, public nested_exception
    {
      explicit _Nested_exception(const _Except& __ex)
      : _Except(__ex)
      { }

      explicit _Nested_exception(_Except&& __ex)
      : _Except(static_cast<_Except&&>(__ex))
      { }
    };




  template<typename _Tp>
    [[noreturn]]
    inline void
    __throw_with_nested_impl(_Tp&& __t, true_type)
    {
      using _Up = typename remove_reference<_Tp>::type;
      throw _Nested_exception<_Up>{std::forward<_Tp>(__t)};
    }

  template<typename _Tp>
    [[noreturn]]
    inline void
    __throw_with_nested_impl(_Tp&& __t, false_type)
    { throw std::forward<_Tp>(__t); }





  template<typename _Tp>
    [[noreturn]]
    inline void
    throw_with_nested(_Tp&& __t)
    {
      using _Up = typename decay<_Tp>::type;
      using _CopyConstructible
 = __and_<is_copy_constructible<_Up>, is_move_constructible<_Up>>;
      static_assert(_CopyConstructible::value,
   "throw_with_nested argument must be CopyConstructible");
      using __nest = __and_<is_class<_Up>, __bool_constant<!__is_final(_Up)>,
       __not_<is_base_of<nested_exception, _Up>>>;
      std::__throw_with_nested_impl(std::forward<_Tp>(__t), __nest{});
    }




  template<typename _Tp>
    using __rethrow_if_nested_cond = typename enable_if<
      __and_<is_polymorphic<_Tp>,
      __or_<__not_<is_base_of<nested_exception, _Tp>>,
     is_convertible<_Tp*, nested_exception*>>>::value
    >::type;


  template<typename _Ex>
    inline __rethrow_if_nested_cond<_Ex>
    __rethrow_if_nested_impl(const _Ex* __ptr)
    {
      if (auto __ne_ptr = dynamic_cast<const nested_exception*>(__ptr))
 __ne_ptr->rethrow_nested();
    }


  inline void
  __rethrow_if_nested_impl(const void*)
  { }




  template<typename _Ex>
    inline void
    rethrow_if_nested(const _Ex& __ex)
    { std::__rethrow_if_nested_impl(std::__addressof(__ex)); }


}

}



#pragma GCC visibility pop
# 149 "/usr/include/c++/10/exception" 2 3
# 42 "/usr/include/c++/10/new" 2 3

#pragma GCC visibility push(default)

extern "C++" {

namespace std
{






  class bad_alloc : public exception
  {
  public:
    bad_alloc() throw() { }


    bad_alloc(const bad_alloc&) = default;
    bad_alloc& operator=(const bad_alloc&) = default;




    virtual ~bad_alloc() throw();


    virtual const char* what() const throw();
  };


  class bad_array_new_length : public bad_alloc
  {
  public:
    bad_array_new_length() throw() { }



    virtual ~bad_array_new_length() throw();


    virtual const char* what() const throw();
  };






  struct nothrow_t
  {

    explicit nothrow_t() = default;

  };

  extern const nothrow_t nothrow;



  typedef void (*new_handler)();



  new_handler set_new_handler(new_handler) throw();



  new_handler get_new_handler() noexcept;

}
# 126 "/usr/include/c++/10/new" 3
 void* operator new(std::size_t)
  __attribute__((__externally_visible__));
 void* operator new[](std::size_t)
  __attribute__((__externally_visible__));
void operator delete(void*) noexcept
  __attribute__((__externally_visible__));
void operator delete[](void*) noexcept
  __attribute__((__externally_visible__));

void operator delete(void*, std::size_t) noexcept
  __attribute__((__externally_visible__));
void operator delete[](void*, std::size_t) noexcept
  __attribute__((__externally_visible__));

 void* operator new(std::size_t, const std::nothrow_t&) noexcept
  __attribute__((__externally_visible__, __malloc__));
 void* operator new[](std::size_t, const std::nothrow_t&) noexcept
  __attribute__((__externally_visible__, __malloc__));
void operator delete(void*, const std::nothrow_t&) noexcept
  __attribute__((__externally_visible__));
void operator delete[](void*, const std::nothrow_t&) noexcept
  __attribute__((__externally_visible__));
# 174 "/usr/include/c++/10/new" 3
 inline void* operator new(std::size_t, void* __p) noexcept
{ return __p; }
 inline void* operator new[](std::size_t, void* __p) noexcept
{ return __p; }


inline void operator delete (void*, void*) noexcept { }
inline void operator delete[](void*, void*) noexcept { }

}
# 230 "/usr/include/c++/10/new" 3
#pragma GCC visibility pop
# 34 "/usr/include/c++/10/ext/new_allocator.h" 2 3
# 1 "/usr/include/c++/10/bits/functexcept.h" 1 3
# 42 "/usr/include/c++/10/bits/functexcept.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{



  void
  __throw_bad_exception(void) __attribute__((__noreturn__));


  void
  __throw_bad_alloc(void) __attribute__((__noreturn__));


  void
  __throw_bad_cast(void) __attribute__((__noreturn__));

  void
  __throw_bad_typeid(void) __attribute__((__noreturn__));


  void
  __throw_logic_error(const char*) __attribute__((__noreturn__));

  void
  __throw_domain_error(const char*) __attribute__((__noreturn__));

  void
  __throw_invalid_argument(const char*) __attribute__((__noreturn__));

  void
  __throw_length_error(const char*) __attribute__((__noreturn__));

  void
  __throw_out_of_range(const char*) __attribute__((__noreturn__));

  void
  __throw_out_of_range_fmt(const char*, ...) __attribute__((__noreturn__))
    __attribute__((__format__(__gnu_printf__, 1, 2)));

  void
  __throw_runtime_error(const char*) __attribute__((__noreturn__));

  void
  __throw_range_error(const char*) __attribute__((__noreturn__));

  void
  __throw_overflow_error(const char*) __attribute__((__noreturn__));

  void
  __throw_underflow_error(const char*) __attribute__((__noreturn__));


  void
  __throw_ios_failure(const char*) __attribute__((__noreturn__));

  void
  __throw_ios_failure(const char*, int) __attribute__((__noreturn__));


  void
  __throw_system_error(int) __attribute__((__noreturn__));


  void
  __throw_future_error(int) __attribute__((__noreturn__));


  void
  __throw_bad_function_call() __attribute__((__noreturn__));


}
# 35 "/usr/include/c++/10/ext/new_allocator.h" 2 3





namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{

# 54 "/usr/include/c++/10/ext/new_allocator.h" 3
  template<typename _Tp>
    class new_allocator
    {
    public:
      typedef _Tp value_type;
      typedef std::size_t size_type;
      typedef std::ptrdiff_t difference_type;

      typedef _Tp* pointer;
      typedef const _Tp* const_pointer;
      typedef _Tp& reference;
      typedef const _Tp& const_reference;

      template<typename _Tp1>
 struct rebind
 { typedef new_allocator<_Tp1> other; };





      typedef std::true_type propagate_on_container_move_assignment;


     
      new_allocator() noexcept { }

     
      new_allocator(const new_allocator&) noexcept { }

      template<typename _Tp1>

 new_allocator(const new_allocator<_Tp1>&) noexcept { }


      ~new_allocator() noexcept { }

      pointer
      address(reference __x) const noexcept
      { return std::__addressof(__x); }

      const_pointer
      address(const_reference __x) const noexcept
      { return std::__addressof(__x); }




      _Tp*
      allocate(size_type __n, const void* = static_cast<const void*>(0))
      {



  static_assert(sizeof(_Tp) != 0, "cannot allocate incomplete types");


 if (__n > this->_M_max_size())
   std::__throw_bad_alloc();
# 121 "/usr/include/c++/10/ext/new_allocator.h" 3
 return static_cast<_Tp*>(::operator new(__n * sizeof(_Tp)));
      }


      void
      deallocate(_Tp* __p, size_type __t)
      {
# 139 "/usr/include/c++/10/ext/new_allocator.h" 3
 ::operator delete(__p

     , __t * sizeof(_Tp)

    );
      }


      size_type
      max_size() const noexcept
      { return _M_max_size(); }


      template<typename _Up, typename... _Args>
 void
 construct(_Up* __p, _Args&&... __args)
 noexcept(std::is_nothrow_constructible<_Up, _Args...>::value)
 { ::new((void *)__p) _Up(std::forward<_Args>(__args)...); }

      template<typename _Up>
 void
 destroy(_Up* __p)
 noexcept(std::is_nothrow_destructible<_Up>::value)
 { __p->~_Up(); }
# 175 "/usr/include/c++/10/ext/new_allocator.h" 3
      template<typename _Up>
 friend bool
 operator==(const new_allocator&, const new_allocator<_Up>&)
 noexcept
 { return true; }


      template<typename _Up>
 friend bool
 operator!=(const new_allocator&, const new_allocator<_Up>&)
 noexcept
 { return false; }


    private:
      constexpr size_type
      _M_max_size() const noexcept
      {

 return std::size_t(0x7fffffffffffffffL) / sizeof(_Tp);



      }
    };


}
# 34 "/usr/include/x86_64-linux-gnu/c++/10/bits/c++allocator.h" 2 3


namespace std
{
# 47 "/usr/include/x86_64-linux-gnu/c++/10/bits/c++allocator.h" 3
  template<typename _Tp>
    using __allocator_base = __gnu_cxx::new_allocator<_Tp>;
}
# 47 "/usr/include/c++/10/bits/allocator.h" 2 3
# 1 "/usr/include/c++/10/bits/memoryfwd.h" 1 3
# 46 "/usr/include/c++/10/bits/memoryfwd.h" 3
       
# 47 "/usr/include/c++/10/bits/memoryfwd.h" 3



namespace std __attribute__ ((__visibility__ ("default")))
{

# 63 "/usr/include/c++/10/bits/memoryfwd.h" 3
  template<typename>
    class allocator;

  template<>
    class allocator<void>;



  template<typename, typename>
    struct uses_allocator;

  template<typename>
    struct allocator_traits;





}
# 48 "/usr/include/c++/10/bits/allocator.h" 2 3






namespace std __attribute__ ((__visibility__ ("default")))
{

# 71 "/usr/include/c++/10/bits/allocator.h" 3
  template<>
    class allocator<void>
    {
    public:
      typedef void value_type;
      typedef size_t size_type;
      typedef ptrdiff_t difference_type;



      typedef void* pointer;
      typedef const void* const_pointer;

      template<typename _Tp1>
 struct rebind
 { typedef allocator<_Tp1> other; };





      typedef true_type propagate_on_container_move_assignment;

      typedef true_type is_always_equal;
# 111 "/usr/include/c++/10/bits/allocator.h" 3
    };
# 121 "/usr/include/c++/10/bits/allocator.h" 3
  template<typename _Tp>
    class allocator : public __allocator_base<_Tp>
    {
    public:
      typedef _Tp value_type;
      typedef size_t size_type;
      typedef ptrdiff_t difference_type;



      typedef _Tp* pointer;
      typedef const _Tp* const_pointer;
      typedef _Tp& reference;
      typedef const _Tp& const_reference;

      template<typename _Tp1>
 struct rebind
 { typedef allocator<_Tp1> other; };





      typedef true_type propagate_on_container_move_assignment;

      typedef true_type is_always_equal;




     
      allocator() noexcept { }

     
      allocator(const allocator& __a) noexcept
      : __allocator_base<_Tp>(__a) { }



      allocator& operator=(const allocator&) = default;


      template<typename _Tp1>

 allocator(const allocator<_Tp1>&) noexcept { }




      ~allocator() noexcept { }
# 199 "/usr/include/c++/10/bits/allocator.h" 3
      friend bool
      operator==(const allocator&, const allocator&) noexcept
      { return true; }


      friend bool
      operator!=(const allocator&, const allocator&) noexcept
      { return false; }



    };

  template<typename _T1, typename _T2>
    inline bool
    operator==(const allocator<_T1>&, const allocator<_T2>&)
    noexcept
    { return true; }


  template<typename _T1, typename _T2>
    inline bool
    operator!=(const allocator<_T1>&, const allocator<_T2>&)
    noexcept
    { return false; }




  template<typename _Tp>
    class allocator<const _Tp>
    {
    public:
      typedef _Tp value_type;
      template<typename _Up> allocator(const allocator<_Up>&) { }
    };

  template<typename _Tp>
    class allocator<volatile _Tp>
    {
    public:
      typedef _Tp value_type;
      template<typename _Up> allocator(const allocator<_Up>&) { }
    };

  template<typename _Tp>
    class allocator<const volatile _Tp>
    {
    public:
      typedef _Tp value_type;
      template<typename _Up> allocator(const allocator<_Up>&) { }
    };






  extern template class allocator<char>;
  extern template class allocator<wchar_t>;






  template<typename _Alloc, bool = __is_empty(_Alloc)>
    struct __alloc_swap
    { static void _S_do_it(_Alloc&, _Alloc&) noexcept { } };

  template<typename _Alloc>
    struct __alloc_swap<_Alloc, false>
    {
      static void
      _S_do_it(_Alloc& __one, _Alloc& __two) noexcept
      {

 if (__one != __two)
   swap(__one, __two);
      }
    };


  template<typename _Alloc, bool = __is_empty(_Alloc)>
    struct __alloc_neq
    {
      static bool
      _S_do_it(const _Alloc&, const _Alloc&)
      { return false; }
    };

  template<typename _Alloc>
    struct __alloc_neq<_Alloc, false>
    {
      static bool
      _S_do_it(const _Alloc& __one, const _Alloc& __two)
      { return __one != __two; }
    };


  template<typename _Tp, bool
    = __or_<is_copy_constructible<typename _Tp::value_type>,
            is_nothrow_move_constructible<typename _Tp::value_type>>::value>
    struct __shrink_to_fit_aux
    { static bool _S_do_it(_Tp&) noexcept { return false; } };

  template<typename _Tp>
    struct __shrink_to_fit_aux<_Tp, true>
    {
      static bool
      _S_do_it(_Tp& __c) noexcept
      {

 try
   {
     _Tp(__make_move_if_noexcept_iterator(__c.begin()),
  __make_move_if_noexcept_iterator(__c.end()),
  __c.get_allocator()).swap(__c);
     return true;
   }
 catch(...)
   { return false; }



      }
    };



}
# 41 "/usr/include/c++/10/unordered_map" 2 3
# 1 "/usr/include/c++/10/ext/alloc_traits.h" 1 3
# 32 "/usr/include/c++/10/ext/alloc_traits.h" 3
       
# 33 "/usr/include/c++/10/ext/alloc_traits.h" 3

# 1 "/usr/include/c++/10/bits/alloc_traits.h" 1 3
# 33 "/usr/include/c++/10/bits/alloc_traits.h" 3
# 1 "/usr/include/c++/10/bits/stl_construct.h" 1 3
# 61 "/usr/include/c++/10/bits/stl_construct.h" 3
# 1 "/usr/include/c++/10/bits/stl_iterator_base_types.h" 1 3
# 62 "/usr/include/c++/10/bits/stl_iterator_base_types.h" 3
       
# 63 "/usr/include/c++/10/bits/stl_iterator_base_types.h" 3
# 74 "/usr/include/c++/10/bits/stl_iterator_base_types.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{

# 93 "/usr/include/c++/10/bits/stl_iterator_base_types.h" 3
  struct input_iterator_tag { };


  struct output_iterator_tag { };


  struct forward_iterator_tag : public input_iterator_tag { };



  struct bidirectional_iterator_tag : public forward_iterator_tag { };



  struct random_access_iterator_tag : public bidirectional_iterator_tag { };
# 125 "/usr/include/c++/10/bits/stl_iterator_base_types.h" 3
  template<typename _Category, typename _Tp, typename _Distance = ptrdiff_t,
           typename _Pointer = _Tp*, typename _Reference = _Tp&>
    struct iterator
    {

      typedef _Category iterator_category;

      typedef _Tp value_type;

      typedef _Distance difference_type;

      typedef _Pointer pointer;

      typedef _Reference reference;
    };
# 149 "/usr/include/c++/10/bits/stl_iterator_base_types.h" 3
  template<typename _Iterator>
    struct iterator_traits;




  template<typename _Iterator, typename = __void_t<>>
    struct __iterator_traits { };



  template<typename _Iterator>
    struct __iterator_traits<_Iterator,
        __void_t<typename _Iterator::iterator_category,
          typename _Iterator::value_type,
          typename _Iterator::difference_type,
          typename _Iterator::pointer,
          typename _Iterator::reference>>
    {
      typedef typename _Iterator::iterator_category iterator_category;
      typedef typename _Iterator::value_type value_type;
      typedef typename _Iterator::difference_type difference_type;
      typedef typename _Iterator::pointer pointer;
      typedef typename _Iterator::reference reference;
    };


  template<typename _Iterator>
    struct iterator_traits
    : public __iterator_traits<_Iterator> { };
# 209 "/usr/include/c++/10/bits/stl_iterator_base_types.h" 3
  template<typename _Tp>
    struct iterator_traits<_Tp*>
    {
      typedef random_access_iterator_tag iterator_category;
      typedef _Tp value_type;
      typedef ptrdiff_t difference_type;
      typedef _Tp* pointer;
      typedef _Tp& reference;
    };


  template<typename _Tp>
    struct iterator_traits<const _Tp*>
    {
      typedef random_access_iterator_tag iterator_category;
      typedef _Tp value_type;
      typedef ptrdiff_t difference_type;
      typedef const _Tp* pointer;
      typedef const _Tp& reference;
    };






  template<typename _Iter>
    inline constexpr
    typename iterator_traits<_Iter>::iterator_category
    __iterator_category(const _Iter&)
    { return typename iterator_traits<_Iter>::iterator_category(); }




  template<typename _Iter>
    using __iterator_category_t
      = typename iterator_traits<_Iter>::iterator_category;

  template<typename _InIter>
    using _RequireInputIter =
      __enable_if_t<is_convertible<__iterator_category_t<_InIter>,
       input_iterator_tag>::value>;

  template<typename _It,
    typename _Cat = __iterator_category_t<_It>>
    struct __is_random_access_iter
      : is_base_of<random_access_iterator_tag, _Cat>
    {
      typedef is_base_of<random_access_iterator_tag, _Cat> _Base;
      enum { __value = _Base::value };
    };








}
# 62 "/usr/include/c++/10/bits/stl_construct.h" 2 3
# 1 "/usr/include/c++/10/bits/stl_iterator_base_funcs.h" 1 3
# 62 "/usr/include/c++/10/bits/stl_iterator_base_funcs.h" 3
       
# 63 "/usr/include/c++/10/bits/stl_iterator_base_funcs.h" 3

# 1 "/usr/include/c++/10/bits/concept_check.h" 1 3
# 33 "/usr/include/c++/10/bits/concept_check.h" 3
       
# 34 "/usr/include/c++/10/bits/concept_check.h" 3
# 65 "/usr/include/c++/10/bits/stl_iterator_base_funcs.h" 2 3
# 1 "/usr/include/c++/10/debug/assertions.h" 1 3
# 66 "/usr/include/c++/10/bits/stl_iterator_base_funcs.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{




  template <typename> struct _List_iterator;
  template <typename> struct _List_const_iterator;


  template<typename _InputIterator>
    inline constexpr
    typename iterator_traits<_InputIterator>::difference_type
    __distance(_InputIterator __first, _InputIterator __last,
               input_iterator_tag)
    {

     

      typename iterator_traits<_InputIterator>::difference_type __n = 0;
      while (__first != __last)
 {
   ++__first;
   ++__n;
 }
      return __n;
    }

  template<typename _RandomAccessIterator>
    inline constexpr
    typename iterator_traits<_RandomAccessIterator>::difference_type
    __distance(_RandomAccessIterator __first, _RandomAccessIterator __last,
               random_access_iterator_tag)
    {

     

      return __last - __first;
    }



  template<typename _Tp>
    ptrdiff_t
    __distance(std::_List_iterator<_Tp>,
        std::_List_iterator<_Tp>,
        input_iterator_tag);

  template<typename _Tp>
    ptrdiff_t
    __distance(std::_List_const_iterator<_Tp>,
        std::_List_const_iterator<_Tp>,
        input_iterator_tag);
# 135 "/usr/include/c++/10/bits/stl_iterator_base_funcs.h" 3
  template<typename _InputIterator>
    inline
    typename iterator_traits<_InputIterator>::difference_type
    distance(_InputIterator __first, _InputIterator __last)
    {

      return std::__distance(__first, __last,
        std::__iterator_category(__first));
    }

  template<typename _InputIterator, typename _Distance>
    inline constexpr void
    __advance(_InputIterator& __i, _Distance __n, input_iterator_tag)
    {

     
      ;
      while (__n--)
 ++__i;
    }

  template<typename _BidirectionalIterator, typename _Distance>
    inline constexpr void
    __advance(_BidirectionalIterator& __i, _Distance __n,
       bidirectional_iterator_tag)
    {

     

      if (__n > 0)
        while (__n--)
   ++__i;
      else
        while (__n++)
   --__i;
    }

  template<typename _RandomAccessIterator, typename _Distance>
    inline constexpr void
    __advance(_RandomAccessIterator& __i, _Distance __n,
              random_access_iterator_tag)
    {

     

      if (__builtin_constant_p(__n) && __n == 1)
 ++__i;
      else if (__builtin_constant_p(__n) && __n == -1)
 --__i;
      else
 __i += __n;
    }
# 200 "/usr/include/c++/10/bits/stl_iterator_base_funcs.h" 3
  template<typename _InputIterator, typename _Distance>
    inline void
    advance(_InputIterator& __i, _Distance __n)
    {

      typename iterator_traits<_InputIterator>::difference_type __d = __n;
      std::__advance(__i, __d, std::__iterator_category(__i));
    }



  template<typename _InputIterator>
    inline _InputIterator
    next(_InputIterator __x, typename
  iterator_traits<_InputIterator>::difference_type __n = 1)
    {

     
      std::advance(__x, __n);
      return __x;
    }

  template<typename _BidirectionalIterator>
    inline _BidirectionalIterator
    prev(_BidirectionalIterator __x, typename
  iterator_traits<_BidirectionalIterator>::difference_type __n = 1)
    {

     

      std::advance(__x, -__n);
      return __x;
    }




}
# 63 "/usr/include/c++/10/bits/stl_construct.h" 2 3
# 73 "/usr/include/c++/10/bits/stl_construct.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{

# 106 "/usr/include/c++/10/bits/stl_construct.h" 3
  template<typename _Tp, typename... _Args>
    inline void
    _Construct(_Tp* __p, _Args&&... __args)
    { ::new(static_cast<void*>(__p)) _Tp(std::forward<_Args>(__args)...); }
# 121 "/usr/include/c++/10/bits/stl_construct.h" 3
  template<typename _T1>
    inline void
    _Construct_novalue(_T1* __p)
    { ::new(static_cast<void*>(__p)) _T1; }

  template<typename _ForwardIterator>
    void
    _Destroy(_ForwardIterator __first, _ForwardIterator __last);




  template<typename _Tp>
    constexpr inline void
    _Destroy(_Tp* __pointer)
    {



      __pointer->~_Tp();

    }

  template<bool>
    struct _Destroy_aux
    {
      template<typename _ForwardIterator>
 static void
 __destroy(_ForwardIterator __first, _ForwardIterator __last)
 {
   for (; __first != __last; ++__first)
     std::_Destroy(std::__addressof(*__first));
 }
    };

  template<>
    struct _Destroy_aux<true>
    {
      template<typename _ForwardIterator>
        static void
        __destroy(_ForwardIterator, _ForwardIterator) { }
    };






  template<typename _ForwardIterator>
    inline void
    _Destroy(_ForwardIterator __first, _ForwardIterator __last)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
                       _Value_type;


      static_assert(is_destructible<_Value_type>::value,
      "value type is destructible");





      std::_Destroy_aux<__has_trivial_destructor(_Value_type)>::
 __destroy(__first, __last);
    }

  template<bool>
    struct _Destroy_n_aux
    {
      template<typename _ForwardIterator, typename _Size>
 static _ForwardIterator
 __destroy_n(_ForwardIterator __first, _Size __count)
 {
   for (; __count > 0; (void)++__first, --__count)
     std::_Destroy(std::__addressof(*__first));
   return __first;
 }
    };

  template<>
    struct _Destroy_n_aux<true>
    {
      template<typename _ForwardIterator, typename _Size>
        static _ForwardIterator
        __destroy_n(_ForwardIterator __first, _Size __count)
 {
   std::advance(__first, __count);
   return __first;
 }
    };






  template<typename _ForwardIterator, typename _Size>
    inline _ForwardIterator
    _Destroy_n(_ForwardIterator __first, _Size __count)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
                       _Value_type;


      static_assert(is_destructible<_Value_type>::value,
      "value type is destructible");





      return std::_Destroy_n_aux<__has_trivial_destructor(_Value_type)>::
 __destroy_n(__first, __count);
    }
# 253 "/usr/include/c++/10/bits/stl_construct.h" 3

}
# 34 "/usr/include/c++/10/bits/alloc_traits.h" 2 3



# 1 "/usr/include/c++/10/bits/ptr_traits.h" 1 3
# 42 "/usr/include/c++/10/bits/ptr_traits.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{


  class __undefined;


  template<typename _Tp>
    struct __get_first_arg
    { using type = __undefined; };

  template<template<typename, typename...> class _Template, typename _Tp,
           typename... _Types>
    struct __get_first_arg<_Template<_Tp, _Types...>>
    { using type = _Tp; };

  template<typename _Tp>
    using __get_first_arg_t = typename __get_first_arg<_Tp>::type;


  template<typename _Tp, typename _Up>
    struct __replace_first_arg
    { };

  template<template<typename, typename...> class _Template, typename _Up,
           typename _Tp, typename... _Types>
    struct __replace_first_arg<_Template<_Tp, _Types...>, _Up>
    { using type = _Template<_Up, _Types...>; };

  template<typename _Tp, typename _Up>
    using __replace_first_arg_t = typename __replace_first_arg<_Tp, _Up>::type;

  template<typename _Tp>
    using __make_not_void
      = typename conditional<is_void<_Tp>::value, __undefined, _Tp>::type;





  template<typename _Ptr>
    struct pointer_traits
    {
    private:
      template<typename _Tp>
 using __element_type = typename _Tp::element_type;

      template<typename _Tp>
 using __difference_type = typename _Tp::difference_type;

      template<typename _Tp, typename _Up, typename = void>
 struct __rebind : __replace_first_arg<_Tp, _Up> { };

      template<typename _Tp, typename _Up>
 struct __rebind<_Tp, _Up, __void_t<typename _Tp::template rebind<_Up>>>
 { using type = typename _Tp::template rebind<_Up>; };

    public:

      using pointer = _Ptr;


      using element_type
 = __detected_or_t<__get_first_arg_t<_Ptr>, __element_type, _Ptr>;


      using difference_type
 = __detected_or_t<ptrdiff_t, __difference_type, _Ptr>;


      template<typename _Up>
        using rebind = typename __rebind<_Ptr, _Up>::type;

      static _Ptr
      pointer_to(__make_not_void<element_type>& __e)
      { return _Ptr::pointer_to(__e); }

      static_assert(!is_same<element_type, __undefined>::value,
   "pointer type defines element_type or is like SomePointer<T, Args>");
    };





  template<typename _Tp>
    struct pointer_traits<_Tp*>
    {

      typedef _Tp* pointer;

      typedef _Tp element_type;

      typedef ptrdiff_t difference_type;

      template<typename _Up>
        using rebind = _Up*;






      static pointer
      pointer_to(__make_not_void<element_type>& __r) noexcept
      { return std::addressof(__r); }
    };


  template<typename _Ptr, typename _Tp>
    using __ptr_rebind = typename pointer_traits<_Ptr>::template rebind<_Tp>;

  template<typename _Tp>
    constexpr _Tp*
    __to_address(_Tp* __ptr) noexcept
    {
      static_assert(!std::is_function<_Tp>::value, "not a function pointer");
      return __ptr;
    }


  template<typename _Ptr>
    constexpr typename std::pointer_traits<_Ptr>::element_type*
    __to_address(const _Ptr& __ptr)
    { return std::__to_address(__ptr.operator->()); }
# 210 "/usr/include/c++/10/bits/ptr_traits.h" 3

}
# 38 "/usr/include/c++/10/bits/alloc_traits.h" 2 3
# 1 "/usr/include/c++/10/ext/numeric_traits.h" 1 3
# 32 "/usr/include/c++/10/ext/numeric_traits.h" 3
       
# 33 "/usr/include/c++/10/ext/numeric_traits.h" 3




namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{

# 50 "/usr/include/c++/10/ext/numeric_traits.h" 3
  template<typename _Tp>
    struct __is_integer_nonstrict
    : public std::__is_integer<_Tp>
    {
      using std::__is_integer<_Tp>::__value;


      enum { __width = __value ? sizeof(_Tp) * 8 : 0 };
    };

  template<typename _Value>
    struct __numeric_traits_integer
    {

      static_assert(__is_integer_nonstrict<_Value>::__value,
      "invalid specialization");




      static const bool __is_signed = (_Value)(-1) < 0;
      static const int __digits
 = __is_integer_nonstrict<_Value>::__width - __is_signed;


      static const _Value __max = __is_signed
 ? (((((_Value)1 << (__digits - 1)) - 1) << 1) + 1)
 : ~(_Value)0;
      static const _Value __min = __is_signed ? -__max - 1 : (_Value)0;
    };

  template<typename _Value>
    const _Value __numeric_traits_integer<_Value>::__min;

  template<typename _Value>
    const _Value __numeric_traits_integer<_Value>::__max;

  template<typename _Value>
    const bool __numeric_traits_integer<_Value>::__is_signed;

  template<typename _Value>
    const int __numeric_traits_integer<_Value>::__digits;
# 135 "/usr/include/c++/10/ext/numeric_traits.h" 3
  template<typename _Tp>
    using __int_traits = __numeric_traits_integer<_Tp>;
# 155 "/usr/include/c++/10/ext/numeric_traits.h" 3
  template<typename _Value>
    struct __numeric_traits_floating
    {

      static const int __max_digits10 = (2 + (std::__are_same<_Value, float>::__value ? 24 : std::__are_same<_Value, double>::__value ? 53 : 64) * 643L / 2136);


      static const bool __is_signed = true;
      static const int __digits10 = (std::__are_same<_Value, float>::__value ? 6 : std::__are_same<_Value, double>::__value ? 15 : 18);
      static const int __max_exponent10 = (std::__are_same<_Value, float>::__value ? 38 : std::__are_same<_Value, double>::__value ? 308 : 4932);
    };

  template<typename _Value>
    const int __numeric_traits_floating<_Value>::__max_digits10;

  template<typename _Value>
    const bool __numeric_traits_floating<_Value>::__is_signed;

  template<typename _Value>
    const int __numeric_traits_floating<_Value>::__digits10;

  template<typename _Value>
    const int __numeric_traits_floating<_Value>::__max_exponent10;

  template<typename _Value>
    struct __numeric_traits
    : public __conditional_type<__is_integer_nonstrict<_Value>::__value,
    __numeric_traits_integer<_Value>,
    __numeric_traits_floating<_Value> >::__type
    { };


}
# 39 "/usr/include/c++/10/bits/alloc_traits.h" 2 3


namespace std __attribute__ ((__visibility__ ("default")))
{





  struct __allocator_traits_base
  {
    template<typename _Tp, typename _Up, typename = void>
      struct __rebind : __replace_first_arg<_Tp, _Up> { };

    template<typename _Tp, typename _Up>
      struct __rebind<_Tp, _Up,
        __void_t<typename _Tp::template rebind<_Up>::other>>
      { using type = typename _Tp::template rebind<_Up>::other; };

  protected:
    template<typename _Tp>
      using __pointer = typename _Tp::pointer;
    template<typename _Tp>
      using __c_pointer = typename _Tp::const_pointer;
    template<typename _Tp>
      using __v_pointer = typename _Tp::void_pointer;
    template<typename _Tp>
      using __cv_pointer = typename _Tp::const_void_pointer;
    template<typename _Tp>
      using __pocca = typename _Tp::propagate_on_container_copy_assignment;
    template<typename _Tp>
      using __pocma = typename _Tp::propagate_on_container_move_assignment;
    template<typename _Tp>
      using __pocs = typename _Tp::propagate_on_container_swap;
    template<typename _Tp>
      using __equal = typename _Tp::is_always_equal;
  };

  template<typename _Alloc, typename _Up>
    using __alloc_rebind
      = typename __allocator_traits_base::template __rebind<_Alloc, _Up>::type;





  template<typename _Alloc>
    struct allocator_traits : __allocator_traits_base
    {

      typedef _Alloc allocator_type;

      typedef typename _Alloc::value_type value_type;






      using pointer = __detected_or_t<value_type*, __pointer, _Alloc>;

    private:

      template<template<typename> class _Func, typename _Tp, typename = void>
 struct _Ptr
 {
   using type = typename pointer_traits<pointer>::template rebind<_Tp>;
 };

      template<template<typename> class _Func, typename _Tp>
 struct _Ptr<_Func, _Tp, __void_t<_Func<_Alloc>>>
 {
   using type = _Func<_Alloc>;
 };


      template<typename _A2, typename _PtrT, typename = void>
 struct _Diff
 { using type = typename pointer_traits<_PtrT>::difference_type; };

      template<typename _A2, typename _PtrT>
 struct _Diff<_A2, _PtrT, __void_t<typename _A2::difference_type>>
 { using type = typename _A2::difference_type; };


      template<typename _A2, typename _DiffT, typename = void>
 struct _Size : make_unsigned<_DiffT> { };

      template<typename _A2, typename _DiffT>
 struct _Size<_A2, _DiffT, __void_t<typename _A2::size_type>>
 { using type = typename _A2::size_type; };

    public:






      using const_pointer = typename _Ptr<__c_pointer, const value_type>::type;







      using void_pointer = typename _Ptr<__v_pointer, void>::type;







      using const_void_pointer = typename _Ptr<__cv_pointer, const void>::type;







      using difference_type = typename _Diff<_Alloc, pointer>::type;







      using size_type = typename _Size<_Alloc, difference_type>::type;







      using propagate_on_container_copy_assignment
 = __detected_or_t<false_type, __pocca, _Alloc>;







      using propagate_on_container_move_assignment
 = __detected_or_t<false_type, __pocma, _Alloc>;







      using propagate_on_container_swap
 = __detected_or_t<false_type, __pocs, _Alloc>;







      using is_always_equal
 = __detected_or_t<typename is_empty<_Alloc>::type, __equal, _Alloc>;

      template<typename _Tp>
 using rebind_alloc = __alloc_rebind<_Alloc, _Tp>;
      template<typename _Tp>
 using rebind_traits = allocator_traits<rebind_alloc<_Tp>>;

    private:
      template<typename _Alloc2>
 static constexpr auto
 _S_allocate(_Alloc2& __a, size_type __n, const_void_pointer __hint, int)
 -> decltype(__a.allocate(__n, __hint))
 { return __a.allocate(__n, __hint); }

      template<typename _Alloc2>
 static constexpr pointer
 _S_allocate(_Alloc2& __a, size_type __n, const_void_pointer, ...)
 { return __a.allocate(__n); }

      template<typename _Tp, typename... _Args>
 struct __construct_helper
 {
   template<typename _Alloc2,
     typename = decltype(std::declval<_Alloc2*>()->construct(
    std::declval<_Tp*>(), std::declval<_Args>()...))>
     static true_type __test(int);

   template<typename>
     static false_type __test(...);

   using type = decltype(__test<_Alloc>(0));
 };

      template<typename _Tp, typename... _Args>
 using __has_construct
   = typename __construct_helper<_Tp, _Args...>::type;

      template<typename _Tp, typename... _Args>
 static constexpr _Require<__has_construct<_Tp, _Args...>>
 _S_construct(_Alloc& __a, _Tp* __p, _Args&&... __args)
 noexcept(noexcept(__a.construct(__p, std::forward<_Args>(__args)...)))
 { __a.construct(__p, std::forward<_Args>(__args)...); }

      template<typename _Tp, typename... _Args>
 static constexpr
 _Require<__and_<__not_<__has_construct<_Tp, _Args...>>,
          is_constructible<_Tp, _Args...>>>
 _S_construct(_Alloc&, _Tp* __p, _Args&&... __args)
 noexcept(std::is_nothrow_constructible<_Tp, _Args...>::value)
 {

   ::new((void*)__p) _Tp(std::forward<_Args>(__args)...);



 }

      template<typename _Alloc2, typename _Tp>
 static constexpr auto
 _S_destroy(_Alloc2& __a, _Tp* __p, int)
 noexcept(noexcept(__a.destroy(__p)))
 -> decltype(__a.destroy(__p))
 { __a.destroy(__p); }

      template<typename _Alloc2, typename _Tp>
 static constexpr void
 _S_destroy(_Alloc2&, _Tp* __p, ...)
 noexcept(std::is_nothrow_destructible<_Tp>::value)
 { std::_Destroy(__p); }

      template<typename _Alloc2>
 static constexpr auto
 _S_max_size(_Alloc2& __a, int)
 -> decltype(__a.max_size())
 { return __a.max_size(); }

      template<typename _Alloc2>
 static constexpr size_type
 _S_max_size(_Alloc2&, ...)
 {


   return __gnu_cxx::__numeric_traits<size_type>::__max
     / sizeof(value_type);
 }

      template<typename _Alloc2>
 static constexpr auto
 _S_select(_Alloc2& __a, int)
 -> decltype(__a.select_on_container_copy_construction())
 { return __a.select_on_container_copy_construction(); }

      template<typename _Alloc2>
 static constexpr _Alloc2
 _S_select(_Alloc2& __a, ...)
 { return __a; }

    public:
# 312 "/usr/include/c++/10/bits/alloc_traits.h" 3
      static pointer
      allocate(_Alloc& __a, size_type __n)
      { return __a.allocate(__n); }
# 327 "/usr/include/c++/10/bits/alloc_traits.h" 3
      static pointer
      allocate(_Alloc& __a, size_type __n, const_void_pointer __hint)
      { return _S_allocate(__a, __n, __hint, 0); }
# 339 "/usr/include/c++/10/bits/alloc_traits.h" 3
      static void
      deallocate(_Alloc& __a, pointer __p, size_type __n)
      { __a.deallocate(__p, __n); }
# 354 "/usr/include/c++/10/bits/alloc_traits.h" 3
      template<typename _Tp, typename... _Args>
 static auto
 construct(_Alloc& __a, _Tp* __p, _Args&&... __args)
 noexcept(noexcept(_S_construct(__a, __p,
           std::forward<_Args>(__args)...)))
 -> decltype(_S_construct(__a, __p, std::forward<_Args>(__args)...))
 { _S_construct(__a, __p, std::forward<_Args>(__args)...); }
# 370 "/usr/include/c++/10/bits/alloc_traits.h" 3
      template<typename _Tp>
 static void
 destroy(_Alloc& __a, _Tp* __p)
 noexcept(noexcept(_S_destroy(__a, __p, 0)))
 { _S_destroy(__a, __p, 0); }
# 384 "/usr/include/c++/10/bits/alloc_traits.h" 3
      static size_type
      max_size(const _Alloc& __a) noexcept
      { return _S_max_size(__a, 0); }
# 396 "/usr/include/c++/10/bits/alloc_traits.h" 3
      static _Alloc
      select_on_container_copy_construction(const _Alloc& __rhs)
      { return _S_select(__rhs, 0); }
    };






  template<typename _Tp>
    struct allocator_traits<allocator<_Tp>>
    {

      using allocator_type = allocator<_Tp>;


      using value_type = _Tp;


      using pointer = _Tp*;


      using const_pointer = const _Tp*;


      using void_pointer = void*;


      using const_void_pointer = const void*;


      using difference_type = std::ptrdiff_t;


      using size_type = std::size_t;


      using propagate_on_container_copy_assignment = false_type;


      using propagate_on_container_move_assignment = true_type;


      using propagate_on_container_swap = false_type;


      using is_always_equal = true_type;

      template<typename _Up>
 using rebind_alloc = allocator<_Up>;

      template<typename _Up>
 using rebind_traits = allocator_traits<allocator<_Up>>;
# 458 "/usr/include/c++/10/bits/alloc_traits.h" 3
      static pointer
      allocate(allocator_type& __a, size_type __n)
      { return __a.allocate(__n); }
# 472 "/usr/include/c++/10/bits/alloc_traits.h" 3
      static pointer
      allocate(allocator_type& __a, size_type __n, const_void_pointer __hint)
      {

 return __a.allocate(__n, __hint);



      }
# 490 "/usr/include/c++/10/bits/alloc_traits.h" 3
      static void
      deallocate(allocator_type& __a, pointer __p, size_type __n)
      { __a.deallocate(__p, __n); }
# 505 "/usr/include/c++/10/bits/alloc_traits.h" 3
      template<typename _Up, typename... _Args>
 static void
 construct(allocator_type& __a __attribute__((__unused__)), _Up* __p,
    _Args&&... __args)
 noexcept(std::is_nothrow_constructible<_Up, _Args...>::value)
 {

   __a.construct(__p, std::forward<_Args>(__args)...);



 }
# 525 "/usr/include/c++/10/bits/alloc_traits.h" 3
      template<typename _Up>
 static void
 destroy(allocator_type& __a __attribute__((__unused__)), _Up* __p)
 noexcept(is_nothrow_destructible<_Up>::value)
 {

   __a.destroy(__p);



 }






      static size_type
      max_size(const allocator_type& __a __attribute__((__unused__))) noexcept
      {

 return __a.max_size();



      }






      static allocator_type
      select_on_container_copy_construction(const allocator_type& __rhs)
      { return __rhs; }
    };


  template<>
    struct allocator_traits<allocator<void>>
    {

      using allocator_type = allocator<void>;


      using value_type = void;


      using pointer = void*;


      using const_pointer = const void*;


      using void_pointer = void*;


      using const_void_pointer = const void*;


      using difference_type = std::ptrdiff_t;


      using size_type = std::size_t;


      using propagate_on_container_copy_assignment = false_type;


      using propagate_on_container_move_assignment = true_type;


      using propagate_on_container_swap = false_type;


      using is_always_equal = true_type;

      template<typename _Up>
 using rebind_alloc = allocator<_Up>;

      template<typename _Up>
 using rebind_traits = allocator_traits<allocator<_Up>>;


      static void*
      allocate(allocator_type&, size_type, const void* = nullptr) = delete;


      static void
      deallocate(allocator_type&, void*, size_type) = delete;
# 627 "/usr/include/c++/10/bits/alloc_traits.h" 3
      template<typename _Up, typename... _Args>
 static void
 construct(allocator_type&, _Up* __p, _Args&&... __args)
 noexcept(std::is_nothrow_constructible<_Up, _Args...>::value)
 {

   ::new((void *)__p) _Up(std::forward<_Args>(__args)...);



 }
# 646 "/usr/include/c++/10/bits/alloc_traits.h" 3
      template<typename _Up>
 static void
 destroy(allocator_type&, _Up* __p)
 noexcept(is_nothrow_destructible<_Up>::value)
 { std::_Destroy(__p); }


      static size_type
      max_size(const allocator_type&) = delete;






      static allocator_type
      select_on_container_copy_construction(const allocator_type& __rhs)
      { return __rhs; }
    };


  template<typename _Alloc>
    inline void
    __do_alloc_on_copy(_Alloc& __one, const _Alloc& __two, true_type)
    { __one = __two; }

  template<typename _Alloc>
    inline void
    __do_alloc_on_copy(_Alloc&, const _Alloc&, false_type)
    { }


  template<typename _Alloc>
    constexpr inline void
    __alloc_on_copy(_Alloc& __one, const _Alloc& __two)
    {
      typedef allocator_traits<_Alloc> __traits;
      typedef typename __traits::propagate_on_container_copy_assignment __pocca;




      __do_alloc_on_copy(__one, __two, __pocca());

    }

  template<typename _Alloc>
    constexpr _Alloc
    __alloc_on_copy(const _Alloc& __a)
    {
      typedef allocator_traits<_Alloc> __traits;
      return __traits::select_on_container_copy_construction(__a);
    }


  template<typename _Alloc>
    inline void __do_alloc_on_move(_Alloc& __one, _Alloc& __two, true_type)
    { __one = std::move(__two); }

  template<typename _Alloc>
    inline void __do_alloc_on_move(_Alloc&, _Alloc&, false_type)
    { }


  template<typename _Alloc>
    constexpr inline void
    __alloc_on_move(_Alloc& __one, _Alloc& __two)
    {
      typedef allocator_traits<_Alloc> __traits;
      typedef typename __traits::propagate_on_container_move_assignment __pocma;




      __do_alloc_on_move(__one, __two, __pocma());

    }


  template<typename _Alloc>
    inline void __do_alloc_on_swap(_Alloc& __one, _Alloc& __two, true_type)
    {
      using std::swap;
      swap(__one, __two);
    }

  template<typename _Alloc>
    inline void __do_alloc_on_swap(_Alloc&, _Alloc&, false_type)
    { }


  template<typename _Alloc>
    constexpr inline void
    __alloc_on_swap(_Alloc& __one, _Alloc& __two)
    {
      typedef allocator_traits<_Alloc> __traits;
      typedef typename __traits::propagate_on_container_swap __pocs;







      __do_alloc_on_swap(__one, __two, __pocs());

    }

  template<typename _Alloc, typename _Tp,
    typename _ValueT = __remove_cvref_t<typename _Alloc::value_type>,
    typename = void>
    struct __is_alloc_insertable_impl
    : false_type
    { };

  template<typename _Alloc, typename _Tp, typename _ValueT>
    struct __is_alloc_insertable_impl<_Alloc, _Tp, _ValueT,
      __void_t<decltype(allocator_traits<_Alloc>::construct(
     std::declval<_Alloc&>(), std::declval<_ValueT*>(),
     std::declval<_Tp>()))>>
    : true_type
    { };




  template<typename _Alloc>
    struct __is_copy_insertable
    : __is_alloc_insertable_impl<_Alloc,
     typename _Alloc::value_type const&>::type
    { };


  template<typename _Tp>
    struct __is_copy_insertable<allocator<_Tp>>
    : is_copy_constructible<_Tp>
    { };




  template<typename _Alloc>
    struct __is_move_insertable
    : __is_alloc_insertable_impl<_Alloc, typename _Alloc::value_type>::type
    { };


  template<typename _Tp>
    struct __is_move_insertable<allocator<_Tp>>
    : is_move_constructible<_Tp>
    { };


  template<typename _Alloc, typename = void>
    struct __is_allocator : false_type { };

  template<typename _Alloc>
    struct __is_allocator<_Alloc,
      __void_t<typename _Alloc::value_type,
        decltype(std::declval<_Alloc&>().allocate(size_t{}))>>
    : true_type { };

  template<typename _Alloc>
    using _RequireAllocator
      = typename enable_if<__is_allocator<_Alloc>::value, _Alloc>::type;

  template<typename _Alloc>
    using _RequireNotAllocator
      = typename enable_if<!__is_allocator<_Alloc>::value, _Alloc>::type;
# 823 "/usr/include/c++/10/bits/alloc_traits.h" 3
  template<typename _ForwardIterator, typename _Allocator>
    void
    _Destroy(_ForwardIterator __first, _ForwardIterator __last,
      _Allocator& __alloc)
    {
      for (; __first != __last; ++__first)



 allocator_traits<_Allocator>::destroy(__alloc,
           std::__addressof(*__first));

    }

  template<typename _ForwardIterator, typename _Tp>
    inline void
    _Destroy(_ForwardIterator __first, _ForwardIterator __last,
      allocator<_Tp>&)
    {
      _Destroy(__first, __last);
    }


}
# 35 "/usr/include/c++/10/ext/alloc_traits.h" 2 3




namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{






template<typename _Alloc, typename = typename _Alloc::value_type>
  struct __alloc_traits

  : std::allocator_traits<_Alloc>

  {
    typedef _Alloc allocator_type;

    typedef std::allocator_traits<_Alloc> _Base_type;
    typedef typename _Base_type::value_type value_type;
    typedef typename _Base_type::pointer pointer;
    typedef typename _Base_type::const_pointer const_pointer;
    typedef typename _Base_type::size_type size_type;
    typedef typename _Base_type::difference_type difference_type;

    typedef value_type& reference;
    typedef const value_type& const_reference;
    using _Base_type::allocate;
    using _Base_type::deallocate;
    using _Base_type::construct;
    using _Base_type::destroy;
    using _Base_type::max_size;

  private:
    template<typename _Ptr>
      using __is_custom_pointer
 = std::__and_<std::is_same<pointer, _Ptr>,
        std::__not_<std::is_pointer<_Ptr>>>;

  public:

    template<typename _Ptr, typename... _Args>
      static constexpr
      std::__enable_if_t<__is_custom_pointer<_Ptr>::value>
      construct(_Alloc& __a, _Ptr __p, _Args&&... __args)
      noexcept(noexcept(_Base_type::construct(__a, std::__to_address(__p),
           std::forward<_Args>(__args)...)))
      {
 _Base_type::construct(__a, std::__to_address(__p),
         std::forward<_Args>(__args)...);
      }


    template<typename _Ptr>
      static constexpr
      std::__enable_if_t<__is_custom_pointer<_Ptr>::value>
      destroy(_Alloc& __a, _Ptr __p)
      noexcept(noexcept(_Base_type::destroy(__a, std::__to_address(__p))))
      { _Base_type::destroy(__a, std::__to_address(__p)); }

    static constexpr _Alloc _S_select_on_copy(const _Alloc& __a)
    { return _Base_type::select_on_container_copy_construction(__a); }

    static constexpr void _S_on_swap(_Alloc& __a, _Alloc& __b)
    { std::__alloc_on_swap(__a, __b); }

    static constexpr bool _S_propagate_on_copy_assign()
    { return _Base_type::propagate_on_container_copy_assignment::value; }

    static constexpr bool _S_propagate_on_move_assign()
    { return _Base_type::propagate_on_container_move_assignment::value; }

    static constexpr bool _S_propagate_on_swap()
    { return _Base_type::propagate_on_container_swap::value; }

    static constexpr bool _S_always_equal()
    { return _Base_type::is_always_equal::value; }

    static constexpr bool _S_nothrow_move()
    { return _S_propagate_on_move_assign() || _S_always_equal(); }

    template<typename _Tp>
      struct rebind
      { typedef typename _Base_type::template rebind_alloc<_Tp> other; };
# 166 "/usr/include/c++/10/ext/alloc_traits.h" 3
  };


}
# 42 "/usr/include/c++/10/unordered_map" 2 3
# 1 "/usr/include/c++/10/ext/aligned_buffer.h" 1 3
# 32 "/usr/include/c++/10/ext/aligned_buffer.h" 3
       
# 33 "/usr/include/c++/10/ext/aligned_buffer.h" 3







namespace __gnu_cxx
{




  template<typename _Tp>
    struct __aligned_membuf
    {





      struct _Tp2 { _Tp _M_t; };

      alignas(__alignof__(_Tp2::_M_t)) unsigned char _M_storage[sizeof(_Tp)];

      __aligned_membuf() = default;


      __aligned_membuf(std::nullptr_t) { }

      void*
      _M_addr() noexcept
      { return static_cast<void*>(&_M_storage); }

      const void*
      _M_addr() const noexcept
      { return static_cast<const void*>(&_M_storage); }

      _Tp*
      _M_ptr() noexcept
      { return static_cast<_Tp*>(_M_addr()); }

      const _Tp*
      _M_ptr() const noexcept
      { return static_cast<const _Tp*>(_M_addr()); }
    };
# 89 "/usr/include/c++/10/ext/aligned_buffer.h" 3
  template<typename _Tp>
    struct __aligned_buffer
    : std::aligned_storage<sizeof(_Tp), __alignof__(_Tp)>
    {
      typename
 std::aligned_storage<sizeof(_Tp), __alignof__(_Tp)>::type _M_storage;

      __aligned_buffer() = default;


      __aligned_buffer(std::nullptr_t) { }

      void*
      _M_addr() noexcept
      {
        return static_cast<void*>(&_M_storage);
      }

      const void*
      _M_addr() const noexcept
      {
        return static_cast<const void*>(&_M_storage);
      }

      _Tp*
      _M_ptr() noexcept
      { return static_cast<_Tp*>(_M_addr()); }

      const _Tp*
      _M_ptr() const noexcept
      { return static_cast<const _Tp*>(_M_addr()); }
    };


}
# 43 "/usr/include/c++/10/unordered_map" 2 3
# 1 "/usr/include/c++/10/bits/stl_pair.h" 1 3
# 69 "/usr/include/c++/10/bits/stl_pair.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{

# 80 "/usr/include/c++/10/bits/stl_pair.h" 3
  struct piecewise_construct_t { explicit piecewise_construct_t() = default; };


  constexpr piecewise_construct_t piecewise_construct =
    piecewise_construct_t();




  template<typename...>
    class tuple;

  template<std::size_t...>
    struct _Index_tuple;






  template <bool, typename _T1, typename _T2>
    struct _PCC
    {
      template <typename _U1, typename _U2>
      static constexpr bool _ConstructiblePair()
      {
 return __and_<is_constructible<_T1, const _U1&>,
        is_constructible<_T2, const _U2&>>::value;
      }

      template <typename _U1, typename _U2>
      static constexpr bool _ImplicitlyConvertiblePair()
      {
 return __and_<is_convertible<const _U1&, _T1>,
        is_convertible<const _U2&, _T2>>::value;
      }

      template <typename _U1, typename _U2>
      static constexpr bool _MoveConstructiblePair()
      {
 return __and_<is_constructible<_T1, _U1&&>,
        is_constructible<_T2, _U2&&>>::value;
      }

      template <typename _U1, typename _U2>
      static constexpr bool _ImplicitlyMoveConvertiblePair()
      {
 return __and_<is_convertible<_U1&&, _T1>,
        is_convertible<_U2&&, _T2>>::value;
      }

      template <bool __implicit, typename _U1, typename _U2>
      static constexpr bool _CopyMovePair()
      {
 using __do_converts = __and_<is_convertible<const _U1&, _T1>,
      is_convertible<_U2&&, _T2>>;
 using __converts = typename conditional<__implicit,
           __do_converts,
           __not_<__do_converts>>::type;
 return __and_<is_constructible<_T1, const _U1&>,
        is_constructible<_T2, _U2&&>,
        __converts
        >::value;
      }

      template <bool __implicit, typename _U1, typename _U2>
      static constexpr bool _MoveCopyPair()
      {
 using __do_converts = __and_<is_convertible<_U1&&, _T1>,
      is_convertible<const _U2&, _T2>>;
 using __converts = typename conditional<__implicit,
           __do_converts,
           __not_<__do_converts>>::type;
 return __and_<is_constructible<_T1, _U1&&>,
        is_constructible<_T2, const _U2&&>,
        __converts
        >::value;
      }
  };

  template <typename _T1, typename _T2>
    struct _PCC<false, _T1, _T2>
    {
      template <typename _U1, typename _U2>
      static constexpr bool _ConstructiblePair()
      {
 return false;
      }

      template <typename _U1, typename _U2>
      static constexpr bool _ImplicitlyConvertiblePair()
      {
 return false;
      }

      template <typename _U1, typename _U2>
      static constexpr bool _MoveConstructiblePair()
      {
 return false;
      }

      template <typename _U1, typename _U2>
      static constexpr bool _ImplicitlyMoveConvertiblePair()
      {
 return false;
      }
  };


  template<typename _U1, typename _U2> class __pair_base
  {

    template<typename _T1, typename _T2> friend struct pair;
    __pair_base() = default;
    ~__pair_base() = default;
    __pair_base(const __pair_base&) = default;
    __pair_base& operator=(const __pair_base&) = delete;

  };
# 210 "/usr/include/c++/10/bits/stl_pair.h" 3
  template<typename _T1, typename _T2>
    struct pair
    : private __pair_base<_T1, _T2>
    {
      typedef _T1 first_type;
      typedef _T2 second_type;

      _T1 first;
      _T2 second;






      template <typename _U1 = _T1,
                typename _U2 = _T2,
                typename enable_if<__and_<
                                     __is_implicitly_default_constructible<_U1>,
                                     __is_implicitly_default_constructible<_U2>>
                                   ::value, bool>::type = true>

      constexpr pair()
      : first(), second() { }


      template <typename _U1 = _T1,
                typename _U2 = _T2,
                typename enable_if<__and_<
                       is_default_constructible<_U1>,
                       is_default_constructible<_U2>,
                       __not_<
                         __and_<__is_implicitly_default_constructible<_U1>,
                                __is_implicitly_default_constructible<_U2>>>>
                                   ::value, bool>::type = false>
      explicit constexpr pair()
      : first(), second() { }
# 256 "/usr/include/c++/10/bits/stl_pair.h" 3
      using _PCCP = _PCC<true, _T1, _T2>;



      template<typename _U1 = _T1, typename _U2=_T2, typename
        enable_if<_PCCP::template
      _ConstructiblePair<_U1, _U2>()
                  && _PCCP::template
      _ImplicitlyConvertiblePair<_U1, _U2>(),
                         bool>::type=true>
      constexpr pair(const _T1& __a, const _T2& __b)
      : first(__a), second(__b) { }


       template<typename _U1 = _T1, typename _U2=_T2, typename
  enable_if<_PCCP::template
       _ConstructiblePair<_U1, _U2>()
                   && !_PCCP::template
       _ImplicitlyConvertiblePair<_U1, _U2>(),
                         bool>::type=false>
      explicit constexpr pair(const _T1& __a, const _T2& __b)
      : first(__a), second(__b) { }
# 288 "/usr/include/c++/10/bits/stl_pair.h" 3
      template <typename _U1, typename _U2>
        using _PCCFP = _PCC<!is_same<_T1, _U1>::value
       || !is_same<_T2, _U2>::value,
       _T1, _T2>;


      template<typename _U1, typename _U2, typename
        enable_if<_PCCFP<_U1, _U2>::template
      _ConstructiblePair<_U1, _U2>()
                  && _PCCFP<_U1, _U2>::template
      _ImplicitlyConvertiblePair<_U1, _U2>(),
     bool>::type=true>
        constexpr pair(const pair<_U1, _U2>& __p)
        : first(__p.first), second(__p.second) { }

      template<typename _U1, typename _U2, typename
        enable_if<_PCCFP<_U1, _U2>::template
      _ConstructiblePair<_U1, _U2>()
    && !_PCCFP<_U1, _U2>::template
      _ImplicitlyConvertiblePair<_U1, _U2>(),
                         bool>::type=false>
 explicit constexpr pair(const pair<_U1, _U2>& __p)
 : first(__p.first), second(__p.second) { }



      constexpr pair(const pair&) = default;
      constexpr pair(pair&&) = default;


      template<typename _U1, typename
        enable_if<_PCCP::template
      _MoveCopyPair<true, _U1, _T2>(),
                         bool>::type=true>
       constexpr pair(_U1&& __x, const _T2& __y)
       : first(std::forward<_U1>(__x)), second(__y) { }

      template<typename _U1, typename
        enable_if<_PCCP::template
      _MoveCopyPair<false, _U1, _T2>(),
                         bool>::type=false>
       explicit constexpr pair(_U1&& __x, const _T2& __y)
       : first(std::forward<_U1>(__x)), second(__y) { }

      template<typename _U2, typename
        enable_if<_PCCP::template
      _CopyMovePair<true, _T1, _U2>(),
                         bool>::type=true>
       constexpr pair(const _T1& __x, _U2&& __y)
       : first(__x), second(std::forward<_U2>(__y)) { }

      template<typename _U2, typename
        enable_if<_PCCP::template
      _CopyMovePair<false, _T1, _U2>(),
                         bool>::type=false>
       explicit pair(const _T1& __x, _U2&& __y)
       : first(__x), second(std::forward<_U2>(__y)) { }

      template<typename _U1, typename _U2, typename
        enable_if<_PCCP::template
      _MoveConstructiblePair<_U1, _U2>()
     && _PCCP::template
      _ImplicitlyMoveConvertiblePair<_U1, _U2>(),
                         bool>::type=true>
 constexpr pair(_U1&& __x, _U2&& __y)
 : first(std::forward<_U1>(__x)), second(std::forward<_U2>(__y)) { }

      template<typename _U1, typename _U2, typename
        enable_if<_PCCP::template
      _MoveConstructiblePair<_U1, _U2>()
     && !_PCCP::template
      _ImplicitlyMoveConvertiblePair<_U1, _U2>(),
                         bool>::type=false>
 explicit constexpr pair(_U1&& __x, _U2&& __y)
 : first(std::forward<_U1>(__x)), second(std::forward<_U2>(__y)) { }


      template<typename _U1, typename _U2, typename
        enable_if<_PCCFP<_U1, _U2>::template
      _MoveConstructiblePair<_U1, _U2>()
     && _PCCFP<_U1, _U2>::template
      _ImplicitlyMoveConvertiblePair<_U1, _U2>(),
                         bool>::type=true>
 constexpr pair(pair<_U1, _U2>&& __p)
 : first(std::forward<_U1>(__p.first)),
   second(std::forward<_U2>(__p.second)) { }

      template<typename _U1, typename _U2, typename
        enable_if<_PCCFP<_U1, _U2>::template
      _MoveConstructiblePair<_U1, _U2>()
     && !_PCCFP<_U1, _U2>::template
      _ImplicitlyMoveConvertiblePair<_U1, _U2>(),
                         bool>::type=false>
 explicit constexpr pair(pair<_U1, _U2>&& __p)
 : first(std::forward<_U1>(__p.first)),
   second(std::forward<_U2>(__p.second)) { }

      template<typename... _Args1, typename... _Args2>

        pair(piecewise_construct_t, tuple<_Args1...>, tuple<_Args2...>);

      pair&
      operator=(typename conditional<
  __and_<is_copy_assignable<_T1>,
         is_copy_assignable<_T2>>::value,
  const pair&, const __nonesuch&>::type __p)
      {
 first = __p.first;
 second = __p.second;
 return *this;
      }

      pair&
      operator=(typename conditional<
  __and_<is_move_assignable<_T1>,
         is_move_assignable<_T2>>::value,
  pair&&, __nonesuch&&>::type __p)
      noexcept(__and_<is_nothrow_move_assignable<_T1>,
        is_nothrow_move_assignable<_T2>>::value)
      {
 first = std::forward<first_type>(__p.first);
 second = std::forward<second_type>(__p.second);
 return *this;
      }

      template<typename _U1, typename _U2>

 typename enable_if<__and_<is_assignable<_T1&, const _U1&>,
      is_assignable<_T2&, const _U2&>>::value,
      pair&>::type
 operator=(const pair<_U1, _U2>& __p)
 {
   first = __p.first;
   second = __p.second;
   return *this;
 }

      template<typename _U1, typename _U2>

 typename enable_if<__and_<is_assignable<_T1&, _U1&&>,
      is_assignable<_T2&, _U2&&>>::value,
      pair&>::type
 operator=(pair<_U1, _U2>&& __p)
 {
   first = std::forward<_U1>(__p.first);
   second = std::forward<_U2>(__p.second);
   return *this;
 }


      void
      swap(pair& __p)
      noexcept(__and_<__is_nothrow_swappable<_T1>,
                      __is_nothrow_swappable<_T2>>::value)
      {
 using std::swap;
 swap(first, __p.first);
 swap(second, __p.second);
      }

    private:
      template<typename... _Args1, std::size_t... _Indexes1,
               typename... _Args2, std::size_t... _Indexes2>

        pair(tuple<_Args1...>&, tuple<_Args2...>&,
             _Index_tuple<_Indexes1...>, _Index_tuple<_Indexes2...>);

    };
# 464 "/usr/include/c++/10/bits/stl_pair.h" 3
  template<typename _T1, typename _T2>
    inline constexpr bool
    operator==(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return __x.first == __y.first && __x.second == __y.second; }
# 487 "/usr/include/c++/10/bits/stl_pair.h" 3
  template<typename _T1, typename _T2>
    inline constexpr bool
    operator<(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return __x.first < __y.first
      || (!(__y.first < __x.first) && __x.second < __y.second); }


  template<typename _T1, typename _T2>
    inline constexpr bool
    operator!=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return !(__x == __y); }


  template<typename _T1, typename _T2>
    inline constexpr bool
    operator>(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return __y < __x; }


  template<typename _T1, typename _T2>
    inline constexpr bool
    operator<=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return !(__y < __x); }


  template<typename _T1, typename _T2>
    inline constexpr bool
    operator>=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return !(__x < __y); }
# 524 "/usr/include/c++/10/bits/stl_pair.h" 3
  template<typename _T1, typename _T2>
    inline


    typename enable_if<__and_<__is_swappable<_T1>,
                              __is_swappable<_T2>>::value>::type



    swap(pair<_T1, _T2>& __x, pair<_T1, _T2>& __y)
    noexcept(noexcept(__x.swap(__y)))
    { __x.swap(__y); }


  template<typename _T1, typename _T2>
    typename enable_if<!__and_<__is_swappable<_T1>,
          __is_swappable<_T2>>::value>::type
    swap(pair<_T1, _T2>&, pair<_T1, _T2>&) = delete;
# 564 "/usr/include/c++/10/bits/stl_pair.h" 3
  template<typename _T1, typename _T2>
    constexpr pair<typename __decay_and_strip<_T1>::__type,
                   typename __decay_and_strip<_T2>::__type>
    make_pair(_T1&& __x, _T2&& __y)
    {
      typedef typename __decay_and_strip<_T1>::__type __ds_type1;
      typedef typename __decay_and_strip<_T2>::__type __ds_type2;
      typedef pair<__ds_type1, __ds_type2> __pair_type;
      return __pair_type(std::forward<_T1>(__x), std::forward<_T2>(__y));
    }
# 583 "/usr/include/c++/10/bits/stl_pair.h" 3

}
# 44 "/usr/include/c++/10/unordered_map" 2 3
# 1 "/usr/include/c++/10/bits/stl_function.h" 1 3
# 63 "/usr/include/c++/10/bits/stl_function.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{

# 104 "/usr/include/c++/10/bits/stl_function.h" 3
  template<typename _Arg, typename _Result>
    struct unary_function
    {

      typedef _Arg argument_type;


      typedef _Result result_type;
    };




  template<typename _Arg1, typename _Arg2, typename _Result>
    struct binary_function
    {

      typedef _Arg1 first_argument_type;


      typedef _Arg2 second_argument_type;


      typedef _Result result_type;
    };
# 144 "/usr/include/c++/10/bits/stl_function.h" 3
  struct __is_transparent;

  template<typename _Tp = void>
    struct plus;

  template<typename _Tp = void>
    struct minus;

  template<typename _Tp = void>
    struct multiplies;

  template<typename _Tp = void>
    struct divides;

  template<typename _Tp = void>
    struct modulus;

  template<typename _Tp = void>
    struct negate;



  template<typename _Tp>
    struct plus : public binary_function<_Tp, _Tp, _Tp>
    {
      constexpr
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x + __y; }
    };


  template<typename _Tp>
    struct minus : public binary_function<_Tp, _Tp, _Tp>
    {
      constexpr
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x - __y; }
    };


  template<typename _Tp>
    struct multiplies : public binary_function<_Tp, _Tp, _Tp>
    {
      constexpr
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x * __y; }
    };


  template<typename _Tp>
    struct divides : public binary_function<_Tp, _Tp, _Tp>
    {
      constexpr
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x / __y; }
    };


  template<typename _Tp>
    struct modulus : public binary_function<_Tp, _Tp, _Tp>
    {
      constexpr
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x % __y; }
    };


  template<typename _Tp>
    struct negate : public unary_function<_Tp, _Tp>
    {
      constexpr
      _Tp
      operator()(const _Tp& __x) const
      { return -__x; }
    };





  template<>
    struct plus<void>
    {
      template <typename _Tp, typename _Up>
 constexpr
 auto
 operator()(_Tp&& __t, _Up&& __u) const
 noexcept(noexcept(std::forward<_Tp>(__t) + std::forward<_Up>(__u)))
 -> decltype(std::forward<_Tp>(__t) + std::forward<_Up>(__u))
 { return std::forward<_Tp>(__t) + std::forward<_Up>(__u); }

      typedef __is_transparent is_transparent;
    };


  template<>
    struct minus<void>
    {
      template <typename _Tp, typename _Up>
 constexpr
 auto
 operator()(_Tp&& __t, _Up&& __u) const
 noexcept(noexcept(std::forward<_Tp>(__t) - std::forward<_Up>(__u)))
 -> decltype(std::forward<_Tp>(__t) - std::forward<_Up>(__u))
 { return std::forward<_Tp>(__t) - std::forward<_Up>(__u); }

      typedef __is_transparent is_transparent;
    };


  template<>
    struct multiplies<void>
    {
      template <typename _Tp, typename _Up>
 constexpr
 auto
 operator()(_Tp&& __t, _Up&& __u) const
 noexcept(noexcept(std::forward<_Tp>(__t) * std::forward<_Up>(__u)))
 -> decltype(std::forward<_Tp>(__t) * std::forward<_Up>(__u))
 { return std::forward<_Tp>(__t) * std::forward<_Up>(__u); }

      typedef __is_transparent is_transparent;
    };


  template<>
    struct divides<void>
    {
      template <typename _Tp, typename _Up>
 constexpr
 auto
 operator()(_Tp&& __t, _Up&& __u) const
 noexcept(noexcept(std::forward<_Tp>(__t) / std::forward<_Up>(__u)))
 -> decltype(std::forward<_Tp>(__t) / std::forward<_Up>(__u))
 { return std::forward<_Tp>(__t) / std::forward<_Up>(__u); }

      typedef __is_transparent is_transparent;
    };


  template<>
    struct modulus<void>
    {
      template <typename _Tp, typename _Up>
 constexpr
 auto
 operator()(_Tp&& __t, _Up&& __u) const
 noexcept(noexcept(std::forward<_Tp>(__t) % std::forward<_Up>(__u)))
 -> decltype(std::forward<_Tp>(__t) % std::forward<_Up>(__u))
 { return std::forward<_Tp>(__t) % std::forward<_Up>(__u); }

      typedef __is_transparent is_transparent;
    };


  template<>
    struct negate<void>
    {
      template <typename _Tp>
 constexpr
 auto
 operator()(_Tp&& __t) const
 noexcept(noexcept(-std::forward<_Tp>(__t)))
 -> decltype(-std::forward<_Tp>(__t))
 { return -std::forward<_Tp>(__t); }

      typedef __is_transparent is_transparent;
    };
# 330 "/usr/include/c++/10/bits/stl_function.h" 3
  template<typename _Tp = void>
    struct equal_to;

  template<typename _Tp = void>
    struct not_equal_to;

  template<typename _Tp = void>
    struct greater;

  template<typename _Tp = void>
    struct less;

  template<typename _Tp = void>
    struct greater_equal;

  template<typename _Tp = void>
    struct less_equal;



  template<typename _Tp>
    struct equal_to : public binary_function<_Tp, _Tp, bool>
    {
      constexpr
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x == __y; }
    };


  template<typename _Tp>
    struct not_equal_to : public binary_function<_Tp, _Tp, bool>
    {
      constexpr
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x != __y; }
    };


  template<typename _Tp>
    struct greater : public binary_function<_Tp, _Tp, bool>
    {
      constexpr
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x > __y; }
    };


  template<typename _Tp>
    struct less : public binary_function<_Tp, _Tp, bool>
    {
      constexpr
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x < __y; }
    };


  template<typename _Tp>
    struct greater_equal : public binary_function<_Tp, _Tp, bool>
    {
      constexpr
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x >= __y; }
    };


  template<typename _Tp>
    struct less_equal : public binary_function<_Tp, _Tp, bool>
    {
      constexpr
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x <= __y; }
    };


  template<typename _Tp>
    struct greater<_Tp*> : public binary_function<_Tp*, _Tp*, bool>
    {
      constexpr bool
      operator()(_Tp* __x, _Tp* __y) const noexcept
      {


 if (__builtin_is_constant_evaluated())



   return __x > __y;

 return (long unsigned int)__x > (long unsigned int)__y;
      }
    };


  template<typename _Tp>
    struct less<_Tp*> : public binary_function<_Tp*, _Tp*, bool>
    {
      constexpr bool
      operator()(_Tp* __x, _Tp* __y) const noexcept
      {


 if (__builtin_is_constant_evaluated())



   return __x < __y;

 return (long unsigned int)__x < (long unsigned int)__y;
      }
    };


  template<typename _Tp>
    struct greater_equal<_Tp*> : public binary_function<_Tp*, _Tp*, bool>
    {
      constexpr bool
      operator()(_Tp* __x, _Tp* __y) const noexcept
      {


 if (__builtin_is_constant_evaluated())



   return __x >= __y;

 return (long unsigned int)__x >= (long unsigned int)__y;
      }
    };


  template<typename _Tp>
    struct less_equal<_Tp*> : public binary_function<_Tp*, _Tp*, bool>
    {
      constexpr bool
      operator()(_Tp* __x, _Tp* __y) const noexcept
      {


 if (__builtin_is_constant_evaluated())



   return __x <= __y;

 return (long unsigned int)__x <= (long unsigned int)__y;
      }
    };



  template<>
    struct equal_to<void>
    {
      template <typename _Tp, typename _Up>
 constexpr auto
 operator()(_Tp&& __t, _Up&& __u) const
 noexcept(noexcept(std::forward<_Tp>(__t) == std::forward<_Up>(__u)))
 -> decltype(std::forward<_Tp>(__t) == std::forward<_Up>(__u))
 { return std::forward<_Tp>(__t) == std::forward<_Up>(__u); }

      typedef __is_transparent is_transparent;
    };


  template<>
    struct not_equal_to<void>
    {
      template <typename _Tp, typename _Up>
 constexpr auto
 operator()(_Tp&& __t, _Up&& __u) const
 noexcept(noexcept(std::forward<_Tp>(__t) != std::forward<_Up>(__u)))
 -> decltype(std::forward<_Tp>(__t) != std::forward<_Up>(__u))
 { return std::forward<_Tp>(__t) != std::forward<_Up>(__u); }

      typedef __is_transparent is_transparent;
    };


  template<>
    struct greater<void>
    {
      template <typename _Tp, typename _Up>
 constexpr auto
 operator()(_Tp&& __t, _Up&& __u) const
 noexcept(noexcept(std::forward<_Tp>(__t) > std::forward<_Up>(__u)))
 -> decltype(std::forward<_Tp>(__t) > std::forward<_Up>(__u))
 {
   return _S_cmp(std::forward<_Tp>(__t), std::forward<_Up>(__u),
   __ptr_cmp<_Tp, _Up>{});
 }

      template<typename _Tp, typename _Up>
 constexpr bool
 operator()(_Tp* __t, _Up* __u) const noexcept
 { return greater<common_type_t<_Tp*, _Up*>>{}(__t, __u); }

      typedef __is_transparent is_transparent;

    private:
      template <typename _Tp, typename _Up>
 static constexpr decltype(auto)
 _S_cmp(_Tp&& __t, _Up&& __u, false_type)
 { return std::forward<_Tp>(__t) > std::forward<_Up>(__u); }

      template <typename _Tp, typename _Up>
 static constexpr bool
 _S_cmp(_Tp&& __t, _Up&& __u, true_type) noexcept
 {
   return greater<const volatile void*>{}(
       static_cast<const volatile void*>(std::forward<_Tp>(__t)),
       static_cast<const volatile void*>(std::forward<_Up>(__u)));
 }


      template<typename _Tp, typename _Up, typename = void>
 struct __not_overloaded2 : true_type { };


      template<typename _Tp, typename _Up>
 struct __not_overloaded2<_Tp, _Up, __void_t<
   decltype(std::declval<_Tp>().operator>(std::declval<_Up>()))>>
 : false_type { };


      template<typename _Tp, typename _Up, typename = void>
 struct __not_overloaded : __not_overloaded2<_Tp, _Up> { };


      template<typename _Tp, typename _Up>
 struct __not_overloaded<_Tp, _Up, __void_t<
   decltype(operator>(std::declval<_Tp>(), std::declval<_Up>()))>>
 : false_type { };

      template<typename _Tp, typename _Up>
 using __ptr_cmp = __and_<__not_overloaded<_Tp, _Up>,
       is_convertible<_Tp, const volatile void*>,
       is_convertible<_Up, const volatile void*>>;
    };


  template<>
    struct less<void>
    {
      template <typename _Tp, typename _Up>
 constexpr auto
 operator()(_Tp&& __t, _Up&& __u) const
 noexcept(noexcept(std::forward<_Tp>(__t) < std::forward<_Up>(__u)))
 -> decltype(std::forward<_Tp>(__t) < std::forward<_Up>(__u))
 {
   return _S_cmp(std::forward<_Tp>(__t), std::forward<_Up>(__u),
   __ptr_cmp<_Tp, _Up>{});
 }

      template<typename _Tp, typename _Up>
 constexpr bool
 operator()(_Tp* __t, _Up* __u) const noexcept
 { return less<common_type_t<_Tp*, _Up*>>{}(__t, __u); }

      typedef __is_transparent is_transparent;

    private:
      template <typename _Tp, typename _Up>
 static constexpr decltype(auto)
 _S_cmp(_Tp&& __t, _Up&& __u, false_type)
 { return std::forward<_Tp>(__t) < std::forward<_Up>(__u); }

      template <typename _Tp, typename _Up>
 static constexpr bool
 _S_cmp(_Tp&& __t, _Up&& __u, true_type) noexcept
 {
   return less<const volatile void*>{}(
       static_cast<const volatile void*>(std::forward<_Tp>(__t)),
       static_cast<const volatile void*>(std::forward<_Up>(__u)));
 }


      template<typename _Tp, typename _Up, typename = void>
 struct __not_overloaded2 : true_type { };


      template<typename _Tp, typename _Up>
 struct __not_overloaded2<_Tp, _Up, __void_t<
   decltype(std::declval<_Tp>().operator<(std::declval<_Up>()))>>
 : false_type { };


      template<typename _Tp, typename _Up, typename = void>
 struct __not_overloaded : __not_overloaded2<_Tp, _Up> { };


      template<typename _Tp, typename _Up>
 struct __not_overloaded<_Tp, _Up, __void_t<
   decltype(operator<(std::declval<_Tp>(), std::declval<_Up>()))>>
 : false_type { };

      template<typename _Tp, typename _Up>
 using __ptr_cmp = __and_<__not_overloaded<_Tp, _Up>,
       is_convertible<_Tp, const volatile void*>,
       is_convertible<_Up, const volatile void*>>;
    };


  template<>
    struct greater_equal<void>
    {
      template <typename _Tp, typename _Up>
 constexpr auto
 operator()(_Tp&& __t, _Up&& __u) const
 noexcept(noexcept(std::forward<_Tp>(__t) >= std::forward<_Up>(__u)))
 -> decltype(std::forward<_Tp>(__t) >= std::forward<_Up>(__u))
 {
   return _S_cmp(std::forward<_Tp>(__t), std::forward<_Up>(__u),
   __ptr_cmp<_Tp, _Up>{});
 }

      template<typename _Tp, typename _Up>
 constexpr bool
 operator()(_Tp* __t, _Up* __u) const noexcept
 { return greater_equal<common_type_t<_Tp*, _Up*>>{}(__t, __u); }

      typedef __is_transparent is_transparent;

    private:
      template <typename _Tp, typename _Up>
 static constexpr decltype(auto)
 _S_cmp(_Tp&& __t, _Up&& __u, false_type)
 { return std::forward<_Tp>(__t) >= std::forward<_Up>(__u); }

      template <typename _Tp, typename _Up>
 static constexpr bool
 _S_cmp(_Tp&& __t, _Up&& __u, true_type) noexcept
 {
   return greater_equal<const volatile void*>{}(
       static_cast<const volatile void*>(std::forward<_Tp>(__t)),
       static_cast<const volatile void*>(std::forward<_Up>(__u)));
 }


      template<typename _Tp, typename _Up, typename = void>
 struct __not_overloaded2 : true_type { };


      template<typename _Tp, typename _Up>
 struct __not_overloaded2<_Tp, _Up, __void_t<
   decltype(std::declval<_Tp>().operator>=(std::declval<_Up>()))>>
 : false_type { };


      template<typename _Tp, typename _Up, typename = void>
 struct __not_overloaded : __not_overloaded2<_Tp, _Up> { };


      template<typename _Tp, typename _Up>
 struct __not_overloaded<_Tp, _Up, __void_t<
   decltype(operator>=(std::declval<_Tp>(), std::declval<_Up>()))>>
 : false_type { };

      template<typename _Tp, typename _Up>
 using __ptr_cmp = __and_<__not_overloaded<_Tp, _Up>,
       is_convertible<_Tp, const volatile void*>,
       is_convertible<_Up, const volatile void*>>;
    };


  template<>
    struct less_equal<void>
    {
      template <typename _Tp, typename _Up>
 constexpr auto
 operator()(_Tp&& __t, _Up&& __u) const
 noexcept(noexcept(std::forward<_Tp>(__t) <= std::forward<_Up>(__u)))
 -> decltype(std::forward<_Tp>(__t) <= std::forward<_Up>(__u))
 {
   return _S_cmp(std::forward<_Tp>(__t), std::forward<_Up>(__u),
   __ptr_cmp<_Tp, _Up>{});
 }

      template<typename _Tp, typename _Up>
 constexpr bool
 operator()(_Tp* __t, _Up* __u) const noexcept
 { return less_equal<common_type_t<_Tp*, _Up*>>{}(__t, __u); }

      typedef __is_transparent is_transparent;

    private:
      template <typename _Tp, typename _Up>
 static constexpr decltype(auto)
 _S_cmp(_Tp&& __t, _Up&& __u, false_type)
 { return std::forward<_Tp>(__t) <= std::forward<_Up>(__u); }

      template <typename _Tp, typename _Up>
 static constexpr bool
 _S_cmp(_Tp&& __t, _Up&& __u, true_type) noexcept
 {
   return less_equal<const volatile void*>{}(
       static_cast<const volatile void*>(std::forward<_Tp>(__t)),
       static_cast<const volatile void*>(std::forward<_Up>(__u)));
 }


      template<typename _Tp, typename _Up, typename = void>
 struct __not_overloaded2 : true_type { };


      template<typename _Tp, typename _Up>
 struct __not_overloaded2<_Tp, _Up, __void_t<
   decltype(std::declval<_Tp>().operator<=(std::declval<_Up>()))>>
 : false_type { };


      template<typename _Tp, typename _Up, typename = void>
 struct __not_overloaded : __not_overloaded2<_Tp, _Up> { };


      template<typename _Tp, typename _Up>
 struct __not_overloaded<_Tp, _Up, __void_t<
   decltype(operator<=(std::declval<_Tp>(), std::declval<_Up>()))>>
 : false_type { };

      template<typename _Tp, typename _Up>
 using __ptr_cmp = __and_<__not_overloaded<_Tp, _Up>,
       is_convertible<_Tp, const volatile void*>,
       is_convertible<_Up, const volatile void*>>;
    };
# 774 "/usr/include/c++/10/bits/stl_function.h" 3
  template<typename _Tp = void>
    struct logical_and;

  template<typename _Tp = void>
    struct logical_or;

  template<typename _Tp = void>
    struct logical_not;



  template<typename _Tp>
    struct logical_and : public binary_function<_Tp, _Tp, bool>
    {
      constexpr
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x && __y; }
    };


  template<typename _Tp>
    struct logical_or : public binary_function<_Tp, _Tp, bool>
    {
      constexpr
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x || __y; }
    };


  template<typename _Tp>
    struct logical_not : public unary_function<_Tp, bool>
    {
      constexpr
      bool
      operator()(const _Tp& __x) const
      { return !__x; }
    };



  template<>
    struct logical_and<void>
    {
      template <typename _Tp, typename _Up>
 constexpr
 auto
 operator()(_Tp&& __t, _Up&& __u) const
 noexcept(noexcept(std::forward<_Tp>(__t) && std::forward<_Up>(__u)))
 -> decltype(std::forward<_Tp>(__t) && std::forward<_Up>(__u))
 { return std::forward<_Tp>(__t) && std::forward<_Up>(__u); }

      typedef __is_transparent is_transparent;
    };


  template<>
    struct logical_or<void>
    {
      template <typename _Tp, typename _Up>
 constexpr
 auto
 operator()(_Tp&& __t, _Up&& __u) const
 noexcept(noexcept(std::forward<_Tp>(__t) || std::forward<_Up>(__u)))
 -> decltype(std::forward<_Tp>(__t) || std::forward<_Up>(__u))
 { return std::forward<_Tp>(__t) || std::forward<_Up>(__u); }

      typedef __is_transparent is_transparent;
    };


  template<>
    struct logical_not<void>
    {
      template <typename _Tp>
 constexpr
 auto
 operator()(_Tp&& __t) const
 noexcept(noexcept(!std::forward<_Tp>(__t)))
 -> decltype(!std::forward<_Tp>(__t))
 { return !std::forward<_Tp>(__t); }

      typedef __is_transparent is_transparent;
    };




  template<typename _Tp = void>
    struct bit_and;

  template<typename _Tp = void>
    struct bit_or;

  template<typename _Tp = void>
    struct bit_xor;

  template<typename _Tp = void>
    struct bit_not;




  template<typename _Tp>
    struct bit_and : public binary_function<_Tp, _Tp, _Tp>
    {
      constexpr
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x & __y; }
    };

  template<typename _Tp>
    struct bit_or : public binary_function<_Tp, _Tp, _Tp>
    {
      constexpr
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x | __y; }
    };

  template<typename _Tp>
    struct bit_xor : public binary_function<_Tp, _Tp, _Tp>
    {
      constexpr
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x ^ __y; }
    };

  template<typename _Tp>
    struct bit_not : public unary_function<_Tp, _Tp>
    {
    constexpr
      _Tp
      operator()(const _Tp& __x) const
      { return ~__x; }
    };


  template <>
    struct bit_and<void>
    {
      template <typename _Tp, typename _Up>
 constexpr
 auto
 operator()(_Tp&& __t, _Up&& __u) const
 noexcept(noexcept(std::forward<_Tp>(__t) & std::forward<_Up>(__u)))
 -> decltype(std::forward<_Tp>(__t) & std::forward<_Up>(__u))
 { return std::forward<_Tp>(__t) & std::forward<_Up>(__u); }

      typedef __is_transparent is_transparent;
    };

  template <>
    struct bit_or<void>
    {
      template <typename _Tp, typename _Up>
 constexpr
 auto
 operator()(_Tp&& __t, _Up&& __u) const
 noexcept(noexcept(std::forward<_Tp>(__t) | std::forward<_Up>(__u)))
 -> decltype(std::forward<_Tp>(__t) | std::forward<_Up>(__u))
 { return std::forward<_Tp>(__t) | std::forward<_Up>(__u); }

      typedef __is_transparent is_transparent;
    };

  template <>
    struct bit_xor<void>
    {
      template <typename _Tp, typename _Up>
 constexpr
 auto
 operator()(_Tp&& __t, _Up&& __u) const
 noexcept(noexcept(std::forward<_Tp>(__t) ^ std::forward<_Up>(__u)))
 -> decltype(std::forward<_Tp>(__t) ^ std::forward<_Up>(__u))
 { return std::forward<_Tp>(__t) ^ std::forward<_Up>(__u); }

      typedef __is_transparent is_transparent;
    };

  template <>
    struct bit_not<void>
    {
      template <typename _Tp>
 constexpr
 auto
 operator()(_Tp&& __t) const
 noexcept(noexcept(~std::forward<_Tp>(__t)))
 -> decltype(~std::forward<_Tp>(__t))
 { return ~std::forward<_Tp>(__t); }

      typedef __is_transparent is_transparent;
    };
# 1002 "/usr/include/c++/10/bits/stl_function.h" 3
  template<typename _Predicate>
    class unary_negate
    : public unary_function<typename _Predicate::argument_type, bool>
    {
    protected:
      _Predicate _M_pred;

    public:
      constexpr
      explicit
      unary_negate(const _Predicate& __x) : _M_pred(__x) { }

      constexpr
      bool
      operator()(const typename _Predicate::argument_type& __x) const
      { return !_M_pred(__x); }
    };


  template<typename _Predicate>
    constexpr
    inline unary_negate<_Predicate>
    not1(const _Predicate& __pred)
    { return unary_negate<_Predicate>(__pred); }


  template<typename _Predicate>
    class binary_negate
    : public binary_function<typename _Predicate::first_argument_type,
        typename _Predicate::second_argument_type, bool>
    {
    protected:
      _Predicate _M_pred;

    public:
      constexpr
      explicit
      binary_negate(const _Predicate& __x) : _M_pred(__x) { }

      constexpr
      bool
      operator()(const typename _Predicate::first_argument_type& __x,
   const typename _Predicate::second_argument_type& __y) const
      { return !_M_pred(__x, __y); }
    };


  template<typename _Predicate>
    constexpr
    inline binary_negate<_Predicate>
    not2(const _Predicate& __pred)
    { return binary_negate<_Predicate>(__pred); }
# 1079 "/usr/include/c++/10/bits/stl_function.h" 3
  template<typename _Arg, typename _Result>
    class pointer_to_unary_function : public unary_function<_Arg, _Result>
    {
    protected:
      _Result (*_M_ptr)(_Arg);

    public:
      pointer_to_unary_function() { }

      explicit
      pointer_to_unary_function(_Result (*__x)(_Arg))
      : _M_ptr(__x) { }

      _Result
      operator()(_Arg __x) const
      { return _M_ptr(__x); }
    };


  template<typename _Arg, typename _Result>
    inline pointer_to_unary_function<_Arg, _Result>
    ptr_fun(_Result (*__x)(_Arg))
    { return pointer_to_unary_function<_Arg, _Result>(__x); }


  template<typename _Arg1, typename _Arg2, typename _Result>
    class pointer_to_binary_function
    : public binary_function<_Arg1, _Arg2, _Result>
    {
    protected:
      _Result (*_M_ptr)(_Arg1, _Arg2);

    public:
      pointer_to_binary_function() { }

      explicit
      pointer_to_binary_function(_Result (*__x)(_Arg1, _Arg2))
      : _M_ptr(__x) { }

      _Result
      operator()(_Arg1 __x, _Arg2 __y) const
      { return _M_ptr(__x, __y); }
    };


  template<typename _Arg1, typename _Arg2, typename _Result>
    inline pointer_to_binary_function<_Arg1, _Arg2, _Result>
    ptr_fun(_Result (*__x)(_Arg1, _Arg2))
    { return pointer_to_binary_function<_Arg1, _Arg2, _Result>(__x); }


  template<typename _Tp>
    struct _Identity
    : public unary_function<_Tp, _Tp>
    {
      _Tp&
      operator()(_Tp& __x) const
      { return __x; }

      const _Tp&
      operator()(const _Tp& __x) const
      { return __x; }
    };


  template<typename _Tp> struct _Identity<const _Tp> : _Identity<_Tp> { };

  template<typename _Pair>
    struct _Select1st
    : public unary_function<_Pair, typename _Pair::first_type>
    {
      typename _Pair::first_type&
      operator()(_Pair& __x) const
      { return __x.first; }

      const typename _Pair::first_type&
      operator()(const _Pair& __x) const
      { return __x.first; }


      template<typename _Pair2>
        typename _Pair2::first_type&
        operator()(_Pair2& __x) const
        { return __x.first; }

      template<typename _Pair2>
        const typename _Pair2::first_type&
        operator()(const _Pair2& __x) const
        { return __x.first; }

    };

  template<typename _Pair>
    struct _Select2nd
    : public unary_function<_Pair, typename _Pair::second_type>
    {
      typename _Pair::second_type&
      operator()(_Pair& __x) const
      { return __x.second; }

      const typename _Pair::second_type&
      operator()(const _Pair& __x) const
      { return __x.second; }
    };
# 1202 "/usr/include/c++/10/bits/stl_function.h" 3
  template<typename _Ret, typename _Tp>
    class mem_fun_t : public unary_function<_Tp*, _Ret>
    {
    public:
      explicit
      mem_fun_t(_Ret (_Tp::*__pf)())
      : _M_f(__pf) { }

      _Ret
      operator()(_Tp* __p) const
      { return (__p->*_M_f)(); }

    private:
      _Ret (_Tp::*_M_f)();
    };



  template<typename _Ret, typename _Tp>
    class const_mem_fun_t : public unary_function<const _Tp*, _Ret>
    {
    public:
      explicit
      const_mem_fun_t(_Ret (_Tp::*__pf)() const)
      : _M_f(__pf) { }

      _Ret
      operator()(const _Tp* __p) const
      { return (__p->*_M_f)(); }

    private:
      _Ret (_Tp::*_M_f)() const;
    };



  template<typename _Ret, typename _Tp>
    class mem_fun_ref_t : public unary_function<_Tp, _Ret>
    {
    public:
      explicit
      mem_fun_ref_t(_Ret (_Tp::*__pf)())
      : _M_f(__pf) { }

      _Ret
      operator()(_Tp& __r) const
      { return (__r.*_M_f)(); }

    private:
      _Ret (_Tp::*_M_f)();
  };



  template<typename _Ret, typename _Tp>
    class const_mem_fun_ref_t : public unary_function<_Tp, _Ret>
    {
    public:
      explicit
      const_mem_fun_ref_t(_Ret (_Tp::*__pf)() const)
      : _M_f(__pf) { }

      _Ret
      operator()(const _Tp& __r) const
      { return (__r.*_M_f)(); }

    private:
      _Ret (_Tp::*_M_f)() const;
    };



  template<typename _Ret, typename _Tp, typename _Arg>
    class mem_fun1_t : public binary_function<_Tp*, _Arg, _Ret>
    {
    public:
      explicit
      mem_fun1_t(_Ret (_Tp::*__pf)(_Arg))
      : _M_f(__pf) { }

      _Ret
      operator()(_Tp* __p, _Arg __x) const
      { return (__p->*_M_f)(__x); }

    private:
      _Ret (_Tp::*_M_f)(_Arg);
    };



  template<typename _Ret, typename _Tp, typename _Arg>
    class const_mem_fun1_t : public binary_function<const _Tp*, _Arg, _Ret>
    {
    public:
      explicit
      const_mem_fun1_t(_Ret (_Tp::*__pf)(_Arg) const)
      : _M_f(__pf) { }

      _Ret
      operator()(const _Tp* __p, _Arg __x) const
      { return (__p->*_M_f)(__x); }

    private:
      _Ret (_Tp::*_M_f)(_Arg) const;
    };



  template<typename _Ret, typename _Tp, typename _Arg>
    class mem_fun1_ref_t : public binary_function<_Tp, _Arg, _Ret>
    {
    public:
      explicit
      mem_fun1_ref_t(_Ret (_Tp::*__pf)(_Arg))
      : _M_f(__pf) { }

      _Ret
      operator()(_Tp& __r, _Arg __x) const
      { return (__r.*_M_f)(__x); }

    private:
      _Ret (_Tp::*_M_f)(_Arg);
    };



  template<typename _Ret, typename _Tp, typename _Arg>
    class const_mem_fun1_ref_t : public binary_function<_Tp, _Arg, _Ret>
    {
    public:
      explicit
      const_mem_fun1_ref_t(_Ret (_Tp::*__pf)(_Arg) const)
      : _M_f(__pf) { }

      _Ret
      operator()(const _Tp& __r, _Arg __x) const
      { return (__r.*_M_f)(__x); }

    private:
      _Ret (_Tp::*_M_f)(_Arg) const;
    };



  template<typename _Ret, typename _Tp>
    inline mem_fun_t<_Ret, _Tp>
    mem_fun(_Ret (_Tp::*__f)())
    { return mem_fun_t<_Ret, _Tp>(__f); }

  template<typename _Ret, typename _Tp>
    inline const_mem_fun_t<_Ret, _Tp>
    mem_fun(_Ret (_Tp::*__f)() const)
    { return const_mem_fun_t<_Ret, _Tp>(__f); }

  template<typename _Ret, typename _Tp>
    inline mem_fun_ref_t<_Ret, _Tp>
    mem_fun_ref(_Ret (_Tp::*__f)())
    { return mem_fun_ref_t<_Ret, _Tp>(__f); }

  template<typename _Ret, typename _Tp>
    inline const_mem_fun_ref_t<_Ret, _Tp>
    mem_fun_ref(_Ret (_Tp::*__f)() const)
    { return const_mem_fun_ref_t<_Ret, _Tp>(__f); }

  template<typename _Ret, typename _Tp, typename _Arg>
    inline mem_fun1_t<_Ret, _Tp, _Arg>
    mem_fun(_Ret (_Tp::*__f)(_Arg))
    { return mem_fun1_t<_Ret, _Tp, _Arg>(__f); }

  template<typename _Ret, typename _Tp, typename _Arg>
    inline const_mem_fun1_t<_Ret, _Tp, _Arg>
    mem_fun(_Ret (_Tp::*__f)(_Arg) const)
    { return const_mem_fun1_t<_Ret, _Tp, _Arg>(__f); }

  template<typename _Ret, typename _Tp, typename _Arg>
    inline mem_fun1_ref_t<_Ret, _Tp, _Arg>
    mem_fun_ref(_Ret (_Tp::*__f)(_Arg))
    { return mem_fun1_ref_t<_Ret, _Tp, _Arg>(__f); }

  template<typename _Ret, typename _Tp, typename _Arg>
    inline const_mem_fun1_ref_t<_Ret, _Tp, _Arg>
    mem_fun_ref(_Ret (_Tp::*__f)(_Arg) const)
    { return const_mem_fun1_ref_t<_Ret, _Tp, _Arg>(__f); }




}


# 1 "/usr/include/c++/10/backward/binders.h" 1 3
# 60 "/usr/include/c++/10/backward/binders.h" 3
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"

namespace std __attribute__ ((__visibility__ ("default")))
{

# 107 "/usr/include/c++/10/backward/binders.h" 3
  template<typename _Operation>
    class binder1st
    : public unary_function<typename _Operation::second_argument_type,
       typename _Operation::result_type>
    {
    protected:
      _Operation op;
      typename _Operation::first_argument_type value;

    public:
      binder1st(const _Operation& __x,
  const typename _Operation::first_argument_type& __y)
      : op(__x), value(__y) { }

      typename _Operation::result_type
      operator()(const typename _Operation::second_argument_type& __x) const
      { return op(value, __x); }



      typename _Operation::result_type
      operator()(typename _Operation::second_argument_type& __x) const
      { return op(value, __x); }
    } __attribute__ ((__deprecated__));


  template<typename _Operation, typename _Tp>
    inline binder1st<_Operation>
    bind1st(const _Operation& __fn, const _Tp& __x)
    {
      typedef typename _Operation::first_argument_type _Arg1_type;
      return binder1st<_Operation>(__fn, _Arg1_type(__x));
    }


  template<typename _Operation>
    class binder2nd
    : public unary_function<typename _Operation::first_argument_type,
       typename _Operation::result_type>
    {
    protected:
      _Operation op;
      typename _Operation::second_argument_type value;

    public:
      binder2nd(const _Operation& __x,
  const typename _Operation::second_argument_type& __y)
      : op(__x), value(__y) { }

      typename _Operation::result_type
      operator()(const typename _Operation::first_argument_type& __x) const
      { return op(__x, value); }



      typename _Operation::result_type
      operator()(typename _Operation::first_argument_type& __x) const
      { return op(__x, value); }
    } __attribute__ ((__deprecated__));


  template<typename _Operation, typename _Tp>
    inline binder2nd<_Operation>
    bind2nd(const _Operation& __fn, const _Tp& __x)
    {
      typedef typename _Operation::second_argument_type _Arg2_type;
      return binder2nd<_Operation>(__fn, _Arg2_type(__x));
    }



}

#pragma GCC diagnostic pop
# 1393 "/usr/include/c++/10/bits/stl_function.h" 2 3
# 45 "/usr/include/c++/10/unordered_map" 2 3
# 1 "/usr/include/c++/10/bits/functional_hash.h" 1 3
# 33 "/usr/include/c++/10/bits/functional_hash.h" 3
       
# 34 "/usr/include/c++/10/bits/functional_hash.h" 3



namespace std __attribute__ ((__visibility__ ("default")))
{

# 49 "/usr/include/c++/10/bits/functional_hash.h" 3
  template<typename _Result, typename _Arg>
    struct __hash_base
    {
      typedef _Result result_type ;
      typedef _Arg argument_type ;
    };


  template<typename _Tp>
    struct hash;

  template<typename _Tp, typename = void>
    struct __poison_hash
    {
      static constexpr bool __enable_hash_call = false;
    private:

      __poison_hash(__poison_hash&&);
      ~__poison_hash();
    };

  template<typename _Tp>
    struct __poison_hash<_Tp, __void_t<decltype(hash<_Tp>()(declval<_Tp>()))>>
    {
      static constexpr bool __enable_hash_call = true;
    };


  template<typename _Tp, bool = is_enum<_Tp>::value>
    struct __hash_enum
    {
    private:

      __hash_enum(__hash_enum&&);
      ~__hash_enum();
    };


  template<typename _Tp>
    struct __hash_enum<_Tp, true> : public __hash_base<size_t, _Tp>
    {
      size_t
      operator()(_Tp __val) const noexcept
      {
       using __type = typename underlying_type<_Tp>::type;
       return hash<__type>{}(static_cast<__type>(__val));
      }
    };



  template<typename _Tp>
    struct hash : __hash_enum<_Tp>
    { };


  template<typename _Tp>
    struct hash<_Tp*> : public __hash_base<size_t, _Tp*>
    {
      size_t
      operator()(_Tp* __p) const noexcept
      { return reinterpret_cast<size_t>(__p); }
    };
# 124 "/usr/include/c++/10/bits/functional_hash.h" 3
  template<> struct hash<bool> : public __hash_base<size_t, bool> { size_t operator()(bool __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<char> : public __hash_base<size_t, char> { size_t operator()(char __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<signed char> : public __hash_base<size_t, signed char> { size_t operator()(signed char __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<unsigned char> : public __hash_base<size_t, unsigned char> { size_t operator()(unsigned char __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<wchar_t> : public __hash_base<size_t, wchar_t> { size_t operator()(wchar_t __val) const noexcept { return static_cast<size_t>(__val); } };







  template<> struct hash<char16_t> : public __hash_base<size_t, char16_t> { size_t operator()(char16_t __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<char32_t> : public __hash_base<size_t, char32_t> { size_t operator()(char32_t __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<short> : public __hash_base<size_t, short> { size_t operator()(short __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<int> : public __hash_base<size_t, int> { size_t operator()(int __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<long> : public __hash_base<size_t, long> { size_t operator()(long __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<long long> : public __hash_base<size_t, long long> { size_t operator()(long long __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<unsigned short> : public __hash_base<size_t, unsigned short> { size_t operator()(unsigned short __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<unsigned int> : public __hash_base<size_t, unsigned int> { size_t operator()(unsigned int __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<unsigned long> : public __hash_base<size_t, unsigned long> { size_t operator()(unsigned long __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<unsigned long long> : public __hash_base<size_t, unsigned long long> { size_t operator()(unsigned long long __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<__int128> : public __hash_base<size_t, __int128> { size_t operator()(__int128 __val) const noexcept { return static_cast<size_t>(__val); } };
  template<> struct hash<__int128 unsigned> : public __hash_base<size_t, __int128 unsigned> { size_t operator()(__int128 unsigned __val) const noexcept { return static_cast<size_t>(__val); } };
# 192 "/usr/include/c++/10/bits/functional_hash.h" 3
  struct _Hash_impl
  {
    static size_t
    hash(const void* __ptr, size_t __clength,
  size_t __seed = static_cast<size_t>(0xc70f6907UL))
    { return _Hash_bytes(__ptr, __clength, __seed); }

    template<typename _Tp>
      static size_t
      hash(const _Tp& __val)
      { return hash(&__val, sizeof(__val)); }

    template<typename _Tp>
      static size_t
      __hash_combine(const _Tp& __val, size_t __hash)
      { return hash(&__val, sizeof(__val), __hash); }
  };


  struct _Fnv_hash_impl
  {
    static size_t
    hash(const void* __ptr, size_t __clength,
  size_t __seed = static_cast<size_t>(2166136261UL))
    { return _Fnv_hash_bytes(__ptr, __clength, __seed); }

    template<typename _Tp>
      static size_t
      hash(const _Tp& __val)
      { return hash(&__val, sizeof(__val)); }

    template<typename _Tp>
      static size_t
      __hash_combine(const _Tp& __val, size_t __hash)
      { return hash(&__val, sizeof(__val), __hash); }
  };


  template<>
    struct hash<float> : public __hash_base<size_t, float>
    {
      size_t
      operator()(float __val) const noexcept
      {

 return __val != 0.0f ? std::_Hash_impl::hash(__val) : 0;
      }
    };


  template<>
    struct hash<double> : public __hash_base<size_t, double>
    {
      size_t
      operator()(double __val) const noexcept
      {

 return __val != 0.0 ? std::_Hash_impl::hash(__val) : 0;
      }
    };


  template<>
    struct hash<long double>
    : public __hash_base<size_t, long double>
    {
      __attribute__ ((__pure__)) size_t
      operator()(long double __val) const noexcept;
    };
# 278 "/usr/include/c++/10/bits/functional_hash.h" 3
  template<typename _Hash>
    struct __is_fast_hash : public std::true_type
    { };

  template<>
    struct __is_fast_hash<hash<long double>> : public std::false_type
    { };


}
# 46 "/usr/include/c++/10/unordered_map" 2 3
# 1 "/usr/include/c++/10/bits/hashtable.h" 1 3
# 33 "/usr/include/c++/10/bits/hashtable.h" 3
       
# 34 "/usr/include/c++/10/bits/hashtable.h" 3

# 1 "/usr/include/c++/10/bits/hashtable_policy.h" 1 3
# 34 "/usr/include/c++/10/bits/hashtable_policy.h" 3
# 1 "/usr/include/c++/10/tuple" 1 3
# 32 "/usr/include/c++/10/tuple" 3
       
# 33 "/usr/include/c++/10/tuple" 3





# 1 "/usr/include/c++/10/utility" 1 3
# 58 "/usr/include/c++/10/utility" 3
       
# 59 "/usr/include/c++/10/utility" 3
# 69 "/usr/include/c++/10/utility" 3
# 1 "/usr/include/c++/10/bits/stl_relops.h" 1 3
# 67 "/usr/include/c++/10/bits/stl_relops.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{


  namespace rel_ops
  {
# 85 "/usr/include/c++/10/bits/stl_relops.h" 3
    template <class _Tp>
      inline bool
      operator!=(const _Tp& __x, const _Tp& __y)
      { return !(__x == __y); }
# 98 "/usr/include/c++/10/bits/stl_relops.h" 3
    template <class _Tp>
      inline bool
      operator>(const _Tp& __x, const _Tp& __y)
      { return __y < __x; }
# 111 "/usr/include/c++/10/bits/stl_relops.h" 3
    template <class _Tp>
      inline bool
      operator<=(const _Tp& __x, const _Tp& __y)
      { return !(__y < __x); }
# 124 "/usr/include/c++/10/bits/stl_relops.h" 3
    template <class _Tp>
      inline bool
      operator>=(const _Tp& __x, const _Tp& __y)
      { return !(__x < __y); }
  }


}
# 70 "/usr/include/c++/10/utility" 2 3
# 82 "/usr/include/c++/10/utility" 3
namespace std __attribute__ ((__visibility__ ("default")))
{



  template<typename _Tp>
    struct tuple_size;





  template<typename _Tp,
    typename _Up = typename remove_cv<_Tp>::type,
    typename = typename enable_if<is_same<_Tp, _Up>::value>::type,
    size_t = tuple_size<_Tp>::value>
    using __enable_if_has_tuple_size = _Tp;

  template<typename _Tp>
    struct tuple_size<const __enable_if_has_tuple_size<_Tp>>
    : public tuple_size<_Tp> { };

  template<typename _Tp>
    struct tuple_size<volatile __enable_if_has_tuple_size<_Tp>>
    : public tuple_size<_Tp> { };

  template<typename _Tp>
    struct tuple_size<const volatile __enable_if_has_tuple_size<_Tp>>
    : public tuple_size<_Tp> { };


  template<std::size_t __i, typename _Tp>
    struct tuple_element;


  template<std::size_t __i, typename _Tp>
    using __tuple_element_t = typename tuple_element<__i, _Tp>::type;

  template<std::size_t __i, typename _Tp>
    struct tuple_element<__i, const _Tp>
    {
      typedef typename add_const<__tuple_element_t<__i, _Tp>>::type type;
    };

  template<std::size_t __i, typename _Tp>
    struct tuple_element<__i, volatile _Tp>
    {
      typedef typename add_volatile<__tuple_element_t<__i, _Tp>>::type type;
    };

  template<std::size_t __i, typename _Tp>
    struct tuple_element<__i, const volatile _Tp>
    {
      typedef typename add_cv<__tuple_element_t<__i, _Tp>>::type type;
    };







  template<std::size_t __i, typename _Tp>
    using tuple_element_t = typename tuple_element<__i, _Tp>::type;





  template<typename _T1, typename _T2>
    struct __is_tuple_like_impl<std::pair<_T1, _T2>> : true_type
    { };


  template<class _Tp1, class _Tp2>
    struct tuple_size<std::pair<_Tp1, _Tp2>>
    : public integral_constant<std::size_t, 2> { };


  template<class _Tp1, class _Tp2>
    struct tuple_element<0, std::pair<_Tp1, _Tp2>>
    { typedef _Tp1 type; };


  template<class _Tp1, class _Tp2>
    struct tuple_element<1, std::pair<_Tp1, _Tp2>>
    { typedef _Tp2 type; };

  template<std::size_t _Int>
    struct __pair_get;

  template<>
    struct __pair_get<0>
    {
      template<typename _Tp1, typename _Tp2>
        static constexpr _Tp1&
        __get(std::pair<_Tp1, _Tp2>& __pair) noexcept
        { return __pair.first; }

      template<typename _Tp1, typename _Tp2>
        static constexpr _Tp1&&
        __move_get(std::pair<_Tp1, _Tp2>&& __pair) noexcept
        { return std::forward<_Tp1>(__pair.first); }

      template<typename _Tp1, typename _Tp2>
        static constexpr const _Tp1&
        __const_get(const std::pair<_Tp1, _Tp2>& __pair) noexcept
        { return __pair.first; }

      template<typename _Tp1, typename _Tp2>
        static constexpr const _Tp1&&
        __const_move_get(const std::pair<_Tp1, _Tp2>&& __pair) noexcept
        { return std::forward<const _Tp1>(__pair.first); }
    };

  template<>
    struct __pair_get<1>
    {
      template<typename _Tp1, typename _Tp2>
        static constexpr _Tp2&
        __get(std::pair<_Tp1, _Tp2>& __pair) noexcept
        { return __pair.second; }

      template<typename _Tp1, typename _Tp2>
        static constexpr _Tp2&&
        __move_get(std::pair<_Tp1, _Tp2>&& __pair) noexcept
        { return std::forward<_Tp2>(__pair.second); }

      template<typename _Tp1, typename _Tp2>
        static constexpr const _Tp2&
        __const_get(const std::pair<_Tp1, _Tp2>& __pair) noexcept
        { return __pair.second; }

      template<typename _Tp1, typename _Tp2>
        static constexpr const _Tp2&&
        __const_move_get(const std::pair<_Tp1, _Tp2>&& __pair) noexcept
        { return std::forward<const _Tp2>(__pair.second); }
    };

  template<std::size_t _Int, class _Tp1, class _Tp2>
    constexpr typename tuple_element<_Int, std::pair<_Tp1, _Tp2>>::type&
    get(std::pair<_Tp1, _Tp2>& __in) noexcept
    { return __pair_get<_Int>::__get(__in); }

  template<std::size_t _Int, class _Tp1, class _Tp2>
    constexpr typename tuple_element<_Int, std::pair<_Tp1, _Tp2>>::type&&
    get(std::pair<_Tp1, _Tp2>&& __in) noexcept
    { return __pair_get<_Int>::__move_get(std::move(__in)); }

  template<std::size_t _Int, class _Tp1, class _Tp2>
    constexpr const typename tuple_element<_Int, std::pair<_Tp1, _Tp2>>::type&
    get(const std::pair<_Tp1, _Tp2>& __in) noexcept
    { return __pair_get<_Int>::__const_get(__in); }

  template<std::size_t _Int, class _Tp1, class _Tp2>
    constexpr const typename tuple_element<_Int, std::pair<_Tp1, _Tp2>>::type&&
    get(const std::pair<_Tp1, _Tp2>&& __in) noexcept
    { return __pair_get<_Int>::__const_move_get(std::move(__in)); }





  template <typename _Tp, typename _Up>
    constexpr _Tp&
    get(pair<_Tp, _Up>& __p) noexcept
    { return __p.first; }

  template <typename _Tp, typename _Up>
    constexpr const _Tp&
    get(const pair<_Tp, _Up>& __p) noexcept
    { return __p.first; }

  template <typename _Tp, typename _Up>
    constexpr _Tp&&
    get(pair<_Tp, _Up>&& __p) noexcept
    { return std::move(__p.first); }

  template <typename _Tp, typename _Up>
    constexpr const _Tp&&
    get(const pair<_Tp, _Up>&& __p) noexcept
    { return std::move(__p.first); }

  template <typename _Tp, typename _Up>
    constexpr _Tp&
    get(pair<_Up, _Tp>& __p) noexcept
    { return __p.second; }

  template <typename _Tp, typename _Up>
    constexpr const _Tp&
    get(const pair<_Up, _Tp>& __p) noexcept
    { return __p.second; }

  template <typename _Tp, typename _Up>
    constexpr _Tp&&
    get(pair<_Up, _Tp>&& __p) noexcept
    { return std::move(__p.second); }

  template <typename _Tp, typename _Up>
    constexpr const _Tp&&
    get(const pair<_Up, _Tp>&& __p) noexcept
    { return std::move(__p.second); }




  template <typename _Tp, typename _Up = _Tp>
   
    inline _Tp
    exchange(_Tp& __obj, _Up&& __new_val)
    { return std::__exchange(__obj, std::forward<_Up>(__new_val)); }





  template<size_t... _Indexes> struct _Index_tuple { };
# 307 "/usr/include/c++/10/utility" 3
  template<size_t _Num>
    struct _Build_index_tuple
    {






      using __type = _Index_tuple<__integer_pack(_Num)...>;

    };






  template<typename _Tp, _Tp... _Idx>
    struct integer_sequence
    {
      typedef _Tp value_type;
      static constexpr size_t size() noexcept { return sizeof...(_Idx); }
    };


  template<typename _Tp, _Tp _Num>
    using make_integer_sequence



      = integer_sequence<_Tp, __integer_pack(_Num)...>;





  template<size_t... _Idx>
    using index_sequence = integer_sequence<size_t, _Idx...>;


  template<size_t _Num>
    using make_index_sequence = make_integer_sequence<size_t, _Num>;


  template<typename... _Types>
    using index_sequence_for = make_index_sequence<sizeof...(_Types)>;
# 473 "/usr/include/c++/10/utility" 3

}
# 39 "/usr/include/c++/10/tuple" 2 3
# 1 "/usr/include/c++/10/array" 1 3
# 32 "/usr/include/c++/10/array" 3
       
# 33 "/usr/include/c++/10/array" 3







# 1 "/usr/include/c++/10/bits/stl_algobase.h" 1 3
# 67 "/usr/include/c++/10/bits/stl_algobase.h" 3
# 1 "/usr/include/c++/10/bits/stl_iterator.h" 1 3
# 86 "/usr/include/c++/10/bits/stl_iterator.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{

# 125 "/usr/include/c++/10/bits/stl_iterator.h" 3
  template<typename _Iterator>
    class reverse_iterator
    : public iterator<typename iterator_traits<_Iterator>::iterator_category,
        typename iterator_traits<_Iterator>::value_type,
        typename iterator_traits<_Iterator>::difference_type,
        typename iterator_traits<_Iterator>::pointer,
                      typename iterator_traits<_Iterator>::reference>
    {
    protected:
      _Iterator current;

      typedef iterator_traits<_Iterator> __traits_type;

    public:
      typedef _Iterator iterator_type;
      typedef typename __traits_type::pointer pointer;

      typedef typename __traits_type::difference_type difference_type;
      typedef typename __traits_type::reference reference;
# 164 "/usr/include/c++/10/bits/stl_iterator.h" 3
     
      reverse_iterator() : current() { }




      explicit
      reverse_iterator(iterator_type __x) : current(__x) { }




     
      reverse_iterator(const reverse_iterator& __x)
      : current(__x.current) { }


      reverse_iterator& operator=(const reverse_iterator&) = default;






      template<typename _Iter>

        reverse_iterator(const reverse_iterator<_Iter>& __x)
 : current(__x.base()) { }




      iterator_type
      base() const
      { return current; }
# 210 "/usr/include/c++/10/bits/stl_iterator.h" 3
      reference
      operator*() const
      {
 _Iterator __tmp = current;
 return *--__tmp;
      }






      pointer
      operator->() const




      {


 _Iterator __tmp = current;
 --__tmp;
 return _S_to_pointer(__tmp);
      }






      reverse_iterator&
      operator++()
      {
 --current;
 return *this;
      }






      reverse_iterator
      operator++(int)
      {
 reverse_iterator __tmp = *this;
 --current;
 return __tmp;
      }






      reverse_iterator&
      operator--()
      {
 ++current;
 return *this;
      }






      reverse_iterator
      operator--(int)
      {
 reverse_iterator __tmp = *this;
 ++current;
 return __tmp;
      }






      reverse_iterator
      operator+(difference_type __n) const
      { return reverse_iterator(current - __n); }







      reverse_iterator&
      operator+=(difference_type __n)
      {
 current -= __n;
 return *this;
      }






      reverse_iterator
      operator-(difference_type __n) const
      { return reverse_iterator(current + __n); }







      reverse_iterator&
      operator-=(difference_type __n)
      {
 current += __n;
 return *this;
      }






      reference
      operator[](difference_type __n) const
      { return *(*this + __n); }
# 364 "/usr/include/c++/10/bits/stl_iterator.h" 3
    private:
      template<typename _Tp>
 static _Tp*
 _S_to_pointer(_Tp* __p)
        { return __p; }

      template<typename _Tp>
 static pointer
 _S_to_pointer(_Tp __t)
        { return __t.operator->(); }
    };
# 387 "/usr/include/c++/10/bits/stl_iterator.h" 3
  template<typename _Iterator>
    inline bool
    operator==(const reverse_iterator<_Iterator>& __x,
        const reverse_iterator<_Iterator>& __y)
    { return __x.base() == __y.base(); }

  template<typename _Iterator>
    inline bool
    operator<(const reverse_iterator<_Iterator>& __x,
       const reverse_iterator<_Iterator>& __y)
    { return __y.base() < __x.base(); }

  template<typename _Iterator>
    inline bool
    operator!=(const reverse_iterator<_Iterator>& __x,
        const reverse_iterator<_Iterator>& __y)
    { return !(__x == __y); }

  template<typename _Iterator>
    inline bool
    operator>(const reverse_iterator<_Iterator>& __x,
       const reverse_iterator<_Iterator>& __y)
    { return __y < __x; }

  template<typename _Iterator>
    inline bool
    operator<=(const reverse_iterator<_Iterator>& __x,
        const reverse_iterator<_Iterator>& __y)
    { return !(__y < __x); }

  template<typename _Iterator>
    inline bool
    operator>=(const reverse_iterator<_Iterator>& __x,
        const reverse_iterator<_Iterator>& __y)
    { return !(__x < __y); }



  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator==(const reverse_iterator<_IteratorL>& __x,
        const reverse_iterator<_IteratorR>& __y)
    { return __x.base() == __y.base(); }

  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator<(const reverse_iterator<_IteratorL>& __x,
       const reverse_iterator<_IteratorR>& __y)
    { return __y.base() < __x.base(); }

  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator!=(const reverse_iterator<_IteratorL>& __x,
        const reverse_iterator<_IteratorR>& __y)
    { return !(__x == __y); }

  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator>(const reverse_iterator<_IteratorL>& __x,
       const reverse_iterator<_IteratorR>& __y)
    { return __y < __x; }

  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator<=(const reverse_iterator<_IteratorL>& __x,
        const reverse_iterator<_IteratorR>& __y)
    { return !(__y < __x); }

  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator>=(const reverse_iterator<_IteratorL>& __x,
        const reverse_iterator<_IteratorR>& __y)
    { return !(__x < __y); }
# 543 "/usr/include/c++/10/bits/stl_iterator.h" 3
  template<typename _IteratorL, typename _IteratorR>
    inline auto
    operator-(const reverse_iterator<_IteratorL>& __x,
       const reverse_iterator<_IteratorR>& __y)
    -> decltype(__y.base() - __x.base())
    { return __y.base() - __x.base(); }


  template<typename _Iterator>
    inline reverse_iterator<_Iterator>
    operator+(typename reverse_iterator<_Iterator>::difference_type __n,
       const reverse_iterator<_Iterator>& __x)
    { return reverse_iterator<_Iterator>(__x.base() - __n); }



  template<typename _Iterator>
    inline reverse_iterator<_Iterator>
    __make_reverse_iterator(_Iterator __i)
    { return reverse_iterator<_Iterator>(__i); }







  template<typename _Iterator>
    inline reverse_iterator<_Iterator>
    make_reverse_iterator(_Iterator __i)
    { return reverse_iterator<_Iterator>(__i); }
# 584 "/usr/include/c++/10/bits/stl_iterator.h" 3
  template<typename _Iterator>
   
    auto
    __niter_base(reverse_iterator<_Iterator> __it)
    -> decltype(__make_reverse_iterator(__niter_base(__it.base())))
    { return __make_reverse_iterator(__niter_base(__it.base())); }

  template<typename _Iterator>
    struct __is_move_iterator<reverse_iterator<_Iterator> >
      : __is_move_iterator<_Iterator>
    { };

  template<typename _Iterator>
   
    auto
    __miter_base(reverse_iterator<_Iterator> __it)
    -> decltype(__make_reverse_iterator(__miter_base(__it.base())))
    { return __make_reverse_iterator(__miter_base(__it.base())); }
# 615 "/usr/include/c++/10/bits/stl_iterator.h" 3
  template<typename _Container>
    class back_insert_iterator
    : public iterator<output_iterator_tag, void, void, void, void>
    {
    protected:
      _Container* container;

    public:

      typedef _Container container_type;







      explicit
      back_insert_iterator(_Container& __x)
      : container(std::__addressof(__x)) { }
# 655 "/usr/include/c++/10/bits/stl_iterator.h" 3
     
      back_insert_iterator&
      operator=(const typename _Container::value_type& __value)
      {
 container->push_back(__value);
 return *this;
      }

     
      back_insert_iterator&
      operator=(typename _Container::value_type&& __value)
      {
 container->push_back(std::move(__value));
 return *this;
      }



     
      back_insert_iterator&
      operator*()
      { return *this; }


     
      back_insert_iterator&
      operator++()
      { return *this; }


     
      back_insert_iterator
      operator++(int)
      { return *this; }
    };
# 702 "/usr/include/c++/10/bits/stl_iterator.h" 3
  template<typename _Container>
   
    inline back_insert_iterator<_Container>
    back_inserter(_Container& __x)
    { return back_insert_iterator<_Container>(__x); }
# 718 "/usr/include/c++/10/bits/stl_iterator.h" 3
  template<typename _Container>
    class front_insert_iterator
    : public iterator<output_iterator_tag, void, void, void, void>
    {
    protected:
      _Container* container;

    public:

      typedef _Container container_type;







      explicit
      front_insert_iterator(_Container& __x)
      : container(std::__addressof(__x)) { }
# 758 "/usr/include/c++/10/bits/stl_iterator.h" 3
     
      front_insert_iterator&
      operator=(const typename _Container::value_type& __value)
      {
 container->push_front(__value);
 return *this;
      }

     
      front_insert_iterator&
      operator=(typename _Container::value_type&& __value)
      {
 container->push_front(std::move(__value));
 return *this;
      }



     
      front_insert_iterator&
      operator*()
      { return *this; }


     
      front_insert_iterator&
      operator++()
      { return *this; }


     
      front_insert_iterator
      operator++(int)
      { return *this; }
    };
# 805 "/usr/include/c++/10/bits/stl_iterator.h" 3
  template<typename _Container>
   
    inline front_insert_iterator<_Container>
    front_inserter(_Container& __x)
    { return front_insert_iterator<_Container>(__x); }
# 825 "/usr/include/c++/10/bits/stl_iterator.h" 3
  template<typename _Container>
    class insert_iterator
    : public iterator<output_iterator_tag, void, void, void, void>
    {







      typedef typename _Container::iterator _Iter;

    protected:
      _Container* container;
      _Iter iter;


    public:

      typedef _Container container_type;
# 857 "/usr/include/c++/10/bits/stl_iterator.h" 3
     
      insert_iterator(_Container& __x, _Iter __i)
      : container(std::__addressof(__x)), iter(__i) {}
# 893 "/usr/include/c++/10/bits/stl_iterator.h" 3
     
      insert_iterator&
      operator=(const typename _Container::value_type& __value)
      {
 iter = container->insert(iter, __value);
 ++iter;
 return *this;
      }

     
      insert_iterator&
      operator=(typename _Container::value_type&& __value)
      {
 iter = container->insert(iter, std::move(__value));
 ++iter;
 return *this;
      }



     
      insert_iterator&
      operator*()
      { return *this; }


     
      insert_iterator&
      operator++()
      { return *this; }


     
      insert_iterator&
      operator++(int)
      { return *this; }
    };
# 949 "/usr/include/c++/10/bits/stl_iterator.h" 3
  template<typename _Container>
    inline insert_iterator<_Container>
    inserter(_Container& __x, typename _Container::iterator __i)
    { return insert_iterator<_Container>(__x, __i); }





}

namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{

# 971 "/usr/include/c++/10/bits/stl_iterator.h" 3
  template<typename _Iterator, typename _Container>
    class __normal_iterator
    {
    protected:
      _Iterator _M_current;

      typedef std::iterator_traits<_Iterator> __traits_type;

    public:
      typedef _Iterator iterator_type;
      typedef typename __traits_type::iterator_category iterator_category;
      typedef typename __traits_type::value_type value_type;
      typedef typename __traits_type::difference_type difference_type;
      typedef typename __traits_type::reference reference;
      typedef typename __traits_type::pointer pointer;





      constexpr __normal_iterator() noexcept
      : _M_current(_Iterator()) { }

      explicit
      __normal_iterator(const _Iterator& __i) noexcept
      : _M_current(__i) { }


      template<typename _Iter>
       
        __normal_iterator(const __normal_iterator<_Iter,
     typename __enable_if<
              (std::__are_same<_Iter, typename _Container::pointer>::__value),
        _Container>::__type>& __i) noexcept
        : _M_current(__i.base()) { }


     
      reference
      operator*() const noexcept
      { return *_M_current; }

     
      pointer
      operator->() const noexcept
      { return _M_current; }

     
      __normal_iterator&
      operator++() noexcept
      {
 ++_M_current;
 return *this;
      }

     
      __normal_iterator
      operator++(int) noexcept
      { return __normal_iterator(_M_current++); }


     
      __normal_iterator&
      operator--() noexcept
      {
 --_M_current;
 return *this;
      }

     
      __normal_iterator
      operator--(int) noexcept
      { return __normal_iterator(_M_current--); }


     
      reference
      operator[](difference_type __n) const noexcept
      { return _M_current[__n]; }

     
      __normal_iterator&
      operator+=(difference_type __n) noexcept
      { _M_current += __n; return *this; }

     
      __normal_iterator
      operator+(difference_type __n) const noexcept
      { return __normal_iterator(_M_current + __n); }

     
      __normal_iterator&
      operator-=(difference_type __n) noexcept
      { _M_current -= __n; return *this; }

     
      __normal_iterator
      operator-(difference_type __n) const noexcept
      { return __normal_iterator(_M_current - __n); }

     
      const _Iterator&
      base() const noexcept
      { return _M_current; }
    };
# 1120 "/usr/include/c++/10/bits/stl_iterator.h" 3
  template<typename _IteratorL, typename _IteratorR, typename _Container>
   
    inline bool
    operator==(const __normal_iterator<_IteratorL, _Container>& __lhs,
        const __normal_iterator<_IteratorR, _Container>& __rhs)
    noexcept
    { return __lhs.base() == __rhs.base(); }

  template<typename _Iterator, typename _Container>
   
    inline bool
    operator==(const __normal_iterator<_Iterator, _Container>& __lhs,
        const __normal_iterator<_Iterator, _Container>& __rhs)
    noexcept
    { return __lhs.base() == __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
   
    inline bool
    operator!=(const __normal_iterator<_IteratorL, _Container>& __lhs,
        const __normal_iterator<_IteratorR, _Container>& __rhs)
    noexcept
    { return __lhs.base() != __rhs.base(); }

  template<typename _Iterator, typename _Container>
   
    inline bool
    operator!=(const __normal_iterator<_Iterator, _Container>& __lhs,
        const __normal_iterator<_Iterator, _Container>& __rhs)
    noexcept
    { return __lhs.base() != __rhs.base(); }


  template<typename _IteratorL, typename _IteratorR, typename _Container>
    inline bool
    operator<(const __normal_iterator<_IteratorL, _Container>& __lhs,
       const __normal_iterator<_IteratorR, _Container>& __rhs)
    noexcept
    { return __lhs.base() < __rhs.base(); }

  template<typename _Iterator, typename _Container>
   
    inline bool
    operator<(const __normal_iterator<_Iterator, _Container>& __lhs,
       const __normal_iterator<_Iterator, _Container>& __rhs)
    noexcept
    { return __lhs.base() < __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
    inline bool
    operator>(const __normal_iterator<_IteratorL, _Container>& __lhs,
       const __normal_iterator<_IteratorR, _Container>& __rhs)
    noexcept
    { return __lhs.base() > __rhs.base(); }

  template<typename _Iterator, typename _Container>
   
    inline bool
    operator>(const __normal_iterator<_Iterator, _Container>& __lhs,
       const __normal_iterator<_Iterator, _Container>& __rhs)
    noexcept
    { return __lhs.base() > __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
    inline bool
    operator<=(const __normal_iterator<_IteratorL, _Container>& __lhs,
        const __normal_iterator<_IteratorR, _Container>& __rhs)
    noexcept
    { return __lhs.base() <= __rhs.base(); }

  template<typename _Iterator, typename _Container>
   
    inline bool
    operator<=(const __normal_iterator<_Iterator, _Container>& __lhs,
        const __normal_iterator<_Iterator, _Container>& __rhs)
    noexcept
    { return __lhs.base() <= __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
    inline bool
    operator>=(const __normal_iterator<_IteratorL, _Container>& __lhs,
        const __normal_iterator<_IteratorR, _Container>& __rhs)
    noexcept
    { return __lhs.base() >= __rhs.base(); }

  template<typename _Iterator, typename _Container>
   
    inline bool
    operator>=(const __normal_iterator<_Iterator, _Container>& __lhs,
        const __normal_iterator<_Iterator, _Container>& __rhs)
    noexcept
    { return __lhs.base() >= __rhs.base(); }






  template<typename _IteratorL, typename _IteratorR, typename _Container>


   
    inline auto
    operator-(const __normal_iterator<_IteratorL, _Container>& __lhs,
       const __normal_iterator<_IteratorR, _Container>& __rhs) noexcept
    -> decltype(__lhs.base() - __rhs.base())





    { return __lhs.base() - __rhs.base(); }

  template<typename _Iterator, typename _Container>
   
    inline typename __normal_iterator<_Iterator, _Container>::difference_type
    operator-(const __normal_iterator<_Iterator, _Container>& __lhs,
       const __normal_iterator<_Iterator, _Container>& __rhs)
    noexcept
    { return __lhs.base() - __rhs.base(); }

  template<typename _Iterator, typename _Container>
   
    inline __normal_iterator<_Iterator, _Container>
    operator+(typename __normal_iterator<_Iterator, _Container>::difference_type
       __n, const __normal_iterator<_Iterator, _Container>& __i)
    noexcept
    { return __normal_iterator<_Iterator, _Container>(__i.base() + __n); }


}

namespace std __attribute__ ((__visibility__ ("default")))
{


  template<typename _Iterator, typename _Container>
   
    _Iterator
    __niter_base(__gnu_cxx::__normal_iterator<_Iterator, _Container> __it)
    noexcept(std::is_nothrow_copy_constructible<_Iterator>::value)
    { return __it.base(); }
# 1310 "/usr/include/c++/10/bits/stl_iterator.h" 3
  namespace __detail
  {
# 1326 "/usr/include/c++/10/bits/stl_iterator.h" 3
  }
# 1337 "/usr/include/c++/10/bits/stl_iterator.h" 3
  template<typename _Iterator>
    class move_iterator



    {
      _Iterator _M_current;

      using __traits_type = iterator_traits<_Iterator>;

      using __base_ref = typename __traits_type::reference;


    public:
      using iterator_type = _Iterator;
# 1361 "/usr/include/c++/10/bits/stl_iterator.h" 3
      typedef typename __traits_type::iterator_category iterator_category;
      typedef typename __traits_type::value_type value_type;
      typedef typename __traits_type::difference_type difference_type;

      typedef _Iterator pointer;


      typedef typename conditional<is_reference<__base_ref>::value,
    typename remove_reference<__base_ref>::type&&,
    __base_ref>::type reference;


     
      move_iterator()
      : _M_current() { }

      explicit
      move_iterator(iterator_type __i)
      : _M_current(std::move(__i)) { }

      template<typename _Iter>

 move_iterator(const move_iterator<_Iter>& __i)
 : _M_current(__i.base()) { }

      template<typename _Iter>

 move_iterator& operator=(const move_iterator<_Iter>& __i)
 {
   _M_current = __i.base();
   return *this;
 }


      iterator_type
      base() const
      { return _M_current; }
# 1408 "/usr/include/c++/10/bits/stl_iterator.h" 3
      reference
      operator*() const



      { return static_cast<reference>(*_M_current); }


      pointer
      operator->() const
      { return _M_current; }

      move_iterator&
      operator++()
      {
 ++_M_current;
 return *this;
      }

      move_iterator
      operator++(int)
      {
 move_iterator __tmp = *this;
 ++_M_current;
 return __tmp;
      }







      move_iterator&
      operator--()
      {
 --_M_current;
 return *this;
      }

      move_iterator
      operator--(int)
      {
 move_iterator __tmp = *this;
 --_M_current;
 return __tmp;
      }

      move_iterator
      operator+(difference_type __n) const
      { return move_iterator(_M_current + __n); }

      move_iterator&
      operator+=(difference_type __n)
      {
 _M_current += __n;
 return *this;
      }

      move_iterator
      operator-(difference_type __n) const
      { return move_iterator(_M_current - __n); }

      move_iterator&
      operator-=(difference_type __n)
      {
 _M_current -= __n;
 return *this;
      }

      reference
      operator[](difference_type __n) const



      { return std::move(_M_current[__n]); }
# 1513 "/usr/include/c++/10/bits/stl_iterator.h" 3
    };

  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator==(const move_iterator<_IteratorL>& __x,
        const move_iterator<_IteratorR>& __y)



    { return __x.base() == __y.base(); }
# 1532 "/usr/include/c++/10/bits/stl_iterator.h" 3
  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator!=(const move_iterator<_IteratorL>& __x,
        const move_iterator<_IteratorR>& __y)
    { return !(__x == __y); }


  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator<(const move_iterator<_IteratorL>& __x,
       const move_iterator<_IteratorR>& __y)



    { return __x.base() < __y.base(); }

  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator<=(const move_iterator<_IteratorL>& __x,
        const move_iterator<_IteratorR>& __y)



    { return !(__y < __x); }

  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator>(const move_iterator<_IteratorL>& __x,
       const move_iterator<_IteratorR>& __y)



    { return __y < __x; }

  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator>=(const move_iterator<_IteratorL>& __x,
        const move_iterator<_IteratorR>& __y)



    { return !(__x < __y); }




  template<typename _Iterator>
    inline bool
    operator==(const move_iterator<_Iterator>& __x,
        const move_iterator<_Iterator>& __y)
    { return __x.base() == __y.base(); }
# 1591 "/usr/include/c++/10/bits/stl_iterator.h" 3
  template<typename _Iterator>
    inline bool
    operator!=(const move_iterator<_Iterator>& __x,
        const move_iterator<_Iterator>& __y)
    { return !(__x == __y); }

  template<typename _Iterator>
    inline bool
    operator<(const move_iterator<_Iterator>& __x,
       const move_iterator<_Iterator>& __y)
    { return __x.base() < __y.base(); }

  template<typename _Iterator>
    inline bool
    operator<=(const move_iterator<_Iterator>& __x,
        const move_iterator<_Iterator>& __y)
    { return !(__y < __x); }

  template<typename _Iterator>
    inline bool
    operator>(const move_iterator<_Iterator>& __x,
       const move_iterator<_Iterator>& __y)
    { return __y < __x; }

  template<typename _Iterator>
    inline bool
    operator>=(const move_iterator<_Iterator>& __x,
        const move_iterator<_Iterator>& __y)
    { return !(__x < __y); }



  template<typename _IteratorL, typename _IteratorR>
    inline auto
    operator-(const move_iterator<_IteratorL>& __x,
       const move_iterator<_IteratorR>& __y)
    -> decltype(__x.base() - __y.base())
    { return __x.base() - __y.base(); }

  template<typename _Iterator>
    inline move_iterator<_Iterator>
    operator+(typename move_iterator<_Iterator>::difference_type __n,
       const move_iterator<_Iterator>& __x)
    { return __x + __n; }

  template<typename _Iterator>
    inline move_iterator<_Iterator>
    make_move_iterator(_Iterator __i)
    { return move_iterator<_Iterator>(std::move(__i)); }

  template<typename _Iterator, typename _ReturnType
    = typename conditional<__move_if_noexcept_cond
      <typename iterator_traits<_Iterator>::value_type>::value,
                _Iterator, move_iterator<_Iterator>>::type>
    inline _ReturnType
    __make_move_if_noexcept_iterator(_Iterator __i)
    { return _ReturnType(__i); }



  template<typename _Tp, typename _ReturnType
    = typename conditional<__move_if_noexcept_cond<_Tp>::value,
      const _Tp*, move_iterator<_Tp*>>::type>
    inline _ReturnType
    __make_move_if_noexcept_iterator(_Tp* __i)
    { return _ReturnType(__i); }
# 2363 "/usr/include/c++/10/bits/stl_iterator.h" 3
  template<typename _Iterator>
   
    auto
    __niter_base(move_iterator<_Iterator> __it)
    -> decltype(make_move_iterator(__niter_base(__it.base())))
    { return make_move_iterator(__niter_base(__it.base())); }

  template<typename _Iterator>
    struct __is_move_iterator<move_iterator<_Iterator> >
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<typename _Iterator>
   
    auto
    __miter_base(move_iterator<_Iterator> __it)
    -> decltype(__miter_base(__it.base()))
    { return __miter_base(__it.base()); }
# 2412 "/usr/include/c++/10/bits/stl_iterator.h" 3

}
# 68 "/usr/include/c++/10/bits/stl_algobase.h" 2 3

# 1 "/usr/include/c++/10/debug/debug.h" 1 3
# 48 "/usr/include/c++/10/debug/debug.h" 3
namespace std
{
  namespace __debug { }
}




namespace __gnu_debug
{
  using namespace std::__debug;

  template<typename _Ite, typename _Seq, typename _Cat>
    struct _Safe_iterator;
}
# 70 "/usr/include/c++/10/bits/stl_algobase.h" 2 3

# 1 "/usr/include/c++/10/bits/predefined_ops.h" 1 3
# 33 "/usr/include/c++/10/bits/predefined_ops.h" 3
namespace __gnu_cxx
{
namespace __ops
{
  struct _Iter_less_iter
  {
    template<typename _Iterator1, typename _Iterator2>
      constexpr
      bool
      operator()(_Iterator1 __it1, _Iterator2 __it2) const
      { return *__it1 < *__it2; }
  };

  constexpr
  inline _Iter_less_iter
  __iter_less_iter()
  { return _Iter_less_iter(); }

  struct _Iter_less_val
  {

    constexpr _Iter_less_val() = default;




   
    explicit
    _Iter_less_val(_Iter_less_iter) { }

    template<typename _Iterator, typename _Value>
     
      bool
      operator()(_Iterator __it, _Value& __val) const
      { return *__it < __val; }
  };

 
  inline _Iter_less_val
  __iter_less_val()
  { return _Iter_less_val(); }

 
  inline _Iter_less_val
  __iter_comp_val(_Iter_less_iter)
  { return _Iter_less_val(); }

  struct _Val_less_iter
  {

    constexpr _Val_less_iter() = default;




   
    explicit
    _Val_less_iter(_Iter_less_iter) { }

    template<typename _Value, typename _Iterator>
     
      bool
      operator()(_Value& __val, _Iterator __it) const
      { return __val < *__it; }
  };

 
  inline _Val_less_iter
  __val_less_iter()
  { return _Val_less_iter(); }

 
  inline _Val_less_iter
  __val_comp_iter(_Iter_less_iter)
  { return _Val_less_iter(); }

  struct _Iter_equal_to_iter
  {
    template<typename _Iterator1, typename _Iterator2>
     
      bool
      operator()(_Iterator1 __it1, _Iterator2 __it2) const
      { return *__it1 == *__it2; }
  };

 
  inline _Iter_equal_to_iter
  __iter_equal_to_iter()
  { return _Iter_equal_to_iter(); }

  struct _Iter_equal_to_val
  {
    template<typename _Iterator, typename _Value>
     
      bool
      operator()(_Iterator __it, _Value& __val) const
      { return *__it == __val; }
  };

 
  inline _Iter_equal_to_val
  __iter_equal_to_val()
  { return _Iter_equal_to_val(); }

 
  inline _Iter_equal_to_val
  __iter_comp_val(_Iter_equal_to_iter)
  { return _Iter_equal_to_val(); }

  template<typename _Compare>
    struct _Iter_comp_iter
    {
      _Compare _M_comp;

      explicit constexpr
      _Iter_comp_iter(_Compare __comp)
 : _M_comp(std::move(__comp))
      { }

      template<typename _Iterator1, typename _Iterator2>
        constexpr
        bool
        operator()(_Iterator1 __it1, _Iterator2 __it2)
        { return bool(_M_comp(*__it1, *__it2)); }
    };

  template<typename _Compare>
    constexpr
    inline _Iter_comp_iter<_Compare>
    __iter_comp_iter(_Compare __comp)
    { return _Iter_comp_iter<_Compare>(std::move(__comp)); }

  template<typename _Compare>
    struct _Iter_comp_val
    {
      _Compare _M_comp;

     
      explicit
      _Iter_comp_val(_Compare __comp)
 : _M_comp(std::move(__comp))
      { }

     
      explicit
      _Iter_comp_val(const _Iter_comp_iter<_Compare>& __comp)
 : _M_comp(__comp._M_comp)
      { }


     
      explicit
      _Iter_comp_val(_Iter_comp_iter<_Compare>&& __comp)
 : _M_comp(std::move(__comp._M_comp))
      { }


      template<typename _Iterator, typename _Value>

 bool
 operator()(_Iterator __it, _Value& __val)
 { return bool(_M_comp(*__it, __val)); }
    };

  template<typename _Compare>
   
    inline _Iter_comp_val<_Compare>
    __iter_comp_val(_Compare __comp)
    { return _Iter_comp_val<_Compare>(std::move(__comp)); }

  template<typename _Compare>
   
    inline _Iter_comp_val<_Compare>
    __iter_comp_val(_Iter_comp_iter<_Compare> __comp)
    { return _Iter_comp_val<_Compare>(std::move(__comp)); }

  template<typename _Compare>
    struct _Val_comp_iter
    {
      _Compare _M_comp;

     
      explicit
      _Val_comp_iter(_Compare __comp)
 : _M_comp(std::move(__comp))
      { }

     
      explicit
      _Val_comp_iter(const _Iter_comp_iter<_Compare>& __comp)
 : _M_comp(__comp._M_comp)
      { }


     
      explicit
      _Val_comp_iter(_Iter_comp_iter<_Compare>&& __comp)
 : _M_comp(std::move(__comp._M_comp))
      { }


      template<typename _Value, typename _Iterator>

 bool
 operator()(_Value& __val, _Iterator __it)
 { return bool(_M_comp(__val, *__it)); }
    };

  template<typename _Compare>
   
    inline _Val_comp_iter<_Compare>
    __val_comp_iter(_Compare __comp)
    { return _Val_comp_iter<_Compare>(std::move(__comp)); }

  template<typename _Compare>
   
    inline _Val_comp_iter<_Compare>
    __val_comp_iter(_Iter_comp_iter<_Compare> __comp)
    { return _Val_comp_iter<_Compare>(std::move(__comp)); }

  template<typename _Value>
    struct _Iter_equals_val
    {
      _Value& _M_value;

     
      explicit
      _Iter_equals_val(_Value& __value)
 : _M_value(__value)
      { }

      template<typename _Iterator>

 bool
 operator()(_Iterator __it)
 { return *__it == _M_value; }
    };

  template<typename _Value>
   
    inline _Iter_equals_val<_Value>
    __iter_equals_val(_Value& __val)
    { return _Iter_equals_val<_Value>(__val); }

  template<typename _Iterator1>
    struct _Iter_equals_iter
    {
      _Iterator1 _M_it1;

     
      explicit
      _Iter_equals_iter(_Iterator1 __it1)
 : _M_it1(__it1)
      { }

      template<typename _Iterator2>

 bool
 operator()(_Iterator2 __it2)
 { return *__it2 == *_M_it1; }
    };

  template<typename _Iterator>
   
    inline _Iter_equals_iter<_Iterator>
    __iter_comp_iter(_Iter_equal_to_iter, _Iterator __it)
    { return _Iter_equals_iter<_Iterator>(__it); }

  template<typename _Predicate>
    struct _Iter_pred
    {
      _Predicate _M_pred;

     
      explicit
      _Iter_pred(_Predicate __pred)
 : _M_pred(std::move(__pred))
      { }

      template<typename _Iterator>

 bool
 operator()(_Iterator __it)
 { return bool(_M_pred(*__it)); }
    };

  template<typename _Predicate>
   
    inline _Iter_pred<_Predicate>
    __pred_iter(_Predicate __pred)
    { return _Iter_pred<_Predicate>(std::move(__pred)); }

  template<typename _Compare, typename _Value>
    struct _Iter_comp_to_val
    {
      _Compare _M_comp;
      _Value& _M_value;

     
      _Iter_comp_to_val(_Compare __comp, _Value& __value)
 : _M_comp(std::move(__comp)), _M_value(__value)
      { }

      template<typename _Iterator>

 bool
 operator()(_Iterator __it)
 { return bool(_M_comp(*__it, _M_value)); }
    };

  template<typename _Compare, typename _Value>
    _Iter_comp_to_val<_Compare, _Value>
   
    __iter_comp_val(_Compare __comp, _Value &__val)
    {
      return _Iter_comp_to_val<_Compare, _Value>(std::move(__comp), __val);
    }

  template<typename _Compare, typename _Iterator1>
    struct _Iter_comp_to_iter
    {
      _Compare _M_comp;
      _Iterator1 _M_it1;

     
      _Iter_comp_to_iter(_Compare __comp, _Iterator1 __it1)
 : _M_comp(std::move(__comp)), _M_it1(__it1)
      { }

      template<typename _Iterator2>

 bool
 operator()(_Iterator2 __it2)
 { return bool(_M_comp(*__it2, *_M_it1)); }
    };

  template<typename _Compare, typename _Iterator>
   
    inline _Iter_comp_to_iter<_Compare, _Iterator>
    __iter_comp_iter(_Iter_comp_iter<_Compare> __comp, _Iterator __it)
    {
      return _Iter_comp_to_iter<_Compare, _Iterator>(
   std::move(__comp._M_comp), __it);
    }

  template<typename _Predicate>
    struct _Iter_negate
    {
      _Predicate _M_pred;

     
      explicit
      _Iter_negate(_Predicate __pred)
 : _M_pred(std::move(__pred))
      { }

      template<typename _Iterator>

 bool
 operator()(_Iterator __it)
 { return !bool(_M_pred(*__it)); }
    };

  template<typename _Predicate>
   
    inline _Iter_negate<_Predicate>
    __negate(_Iter_pred<_Predicate> __pred)
    { return _Iter_negate<_Predicate>(std::move(__pred._M_pred)); }

}
}
# 72 "/usr/include/c++/10/bits/stl_algobase.h" 2 3







namespace std __attribute__ ((__visibility__ ("default")))
{






  template<typename _Tp, typename _Up>
    constexpr
    inline int
    __memcmp(const _Tp* __first1, const _Up* __first2, size_t __num)
    {

      static_assert(sizeof(_Tp) == sizeof(_Up), "can be compared with memcmp");
# 105 "/usr/include/c++/10/bits/stl_algobase.h" 3
 return __builtin_memcmp(__first1, __first2, sizeof(_Tp) * __num);
    }
# 149 "/usr/include/c++/10/bits/stl_algobase.h" 3
  template<typename _ForwardIterator1, typename _ForwardIterator2>
   
    inline void
    iter_swap(_ForwardIterator1 __a, _ForwardIterator2 __b)
    {

     

     
# 182 "/usr/include/c++/10/bits/stl_algobase.h" 3
      swap(*__a, *__b);

    }
# 198 "/usr/include/c++/10/bits/stl_algobase.h" 3
  template<typename _ForwardIterator1, typename _ForwardIterator2>
   
    _ForwardIterator2
    swap_ranges(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
  _ForwardIterator2 __first2)
    {

     

     

      ;

      for (; __first1 != __last1; ++__first1, (void)++__first2)
 std::iter_swap(__first1, __first2);
      return __first2;
    }
# 227 "/usr/include/c++/10/bits/stl_algobase.h" 3
  template<typename _Tp>
    constexpr
    inline const _Tp&
    min(const _Tp& __a, const _Tp& __b)
    {

     

      if (__b < __a)
 return __b;
      return __a;
    }
# 251 "/usr/include/c++/10/bits/stl_algobase.h" 3
  template<typename _Tp>
    constexpr
    inline const _Tp&
    max(const _Tp& __a, const _Tp& __b)
    {

     

      if (__a < __b)
 return __b;
      return __a;
    }
# 275 "/usr/include/c++/10/bits/stl_algobase.h" 3
  template<typename _Tp, typename _Compare>
    constexpr
    inline const _Tp&
    min(const _Tp& __a, const _Tp& __b, _Compare __comp)
    {

      if (__comp(__b, __a))
 return __b;
      return __a;
    }
# 297 "/usr/include/c++/10/bits/stl_algobase.h" 3
  template<typename _Tp, typename _Compare>
    constexpr
    inline const _Tp&
    max(const _Tp& __a, const _Tp& __b, _Compare __comp)
    {

      if (__comp(__a, __b))
 return __b;
      return __a;
    }



  template<typename _Iterator>
   
    inline _Iterator
    __niter_base(_Iterator __it)
    noexcept(std::is_nothrow_copy_constructible<_Iterator>::value)
    { return __it; }




  template<typename _From, typename _To>
   
    inline _From
    __niter_wrap(_From __from, _To __res)
    { return __from + (__res - std::__niter_base(__from)); }


  template<typename _Iterator>
   
    inline _Iterator
    __niter_wrap(const _Iterator&, _Iterator __res)
    { return __res; }







  template<bool _IsMove, bool _IsSimple, typename _Category>
    struct __copy_move
    {
      template<typename _II, typename _OI>

 static _OI
 __copy_m(_II __first, _II __last, _OI __result)
 {
   for (; __first != __last; ++__result, (void)++__first)
     *__result = *__first;
   return __result;
 }
    };


  template<typename _Category>
    struct __copy_move<true, false, _Category>
    {
      template<typename _II, typename _OI>

 static _OI
 __copy_m(_II __first, _II __last, _OI __result)
 {
   for (; __first != __last; ++__result, (void)++__first)
     *__result = std::move(*__first);
   return __result;
 }
    };


  template<>
    struct __copy_move<false, false, random_access_iterator_tag>
    {
      template<typename _II, typename _OI>

 static _OI
 __copy_m(_II __first, _II __last, _OI __result)
 {
   typedef typename iterator_traits<_II>::difference_type _Distance;
   for(_Distance __n = __last - __first; __n > 0; --__n)
     {
       *__result = *__first;
       ++__first;
       ++__result;
     }
   return __result;
 }
    };


  template<>
    struct __copy_move<true, false, random_access_iterator_tag>
    {
      template<typename _II, typename _OI>

 static _OI
 __copy_m(_II __first, _II __last, _OI __result)
 {
   typedef typename iterator_traits<_II>::difference_type _Distance;
   for(_Distance __n = __last - __first; __n > 0; --__n)
     {
       *__result = std::move(*__first);
       ++__first;
       ++__result;
     }
   return __result;
 }
    };


  template<bool _IsMove>
    struct __copy_move<_IsMove, true, random_access_iterator_tag>
    {
      template<typename _Tp>

 static _Tp*
 __copy_m(const _Tp* __first, const _Tp* __last, _Tp* __result)
 {

   using __assignable = conditional<_IsMove,
        is_move_assignable<_Tp>,
        is_copy_assignable<_Tp>>;

   static_assert( __assignable::type::value, "type is not assignable" );

   const ptrdiff_t _Num = __last - __first;
   if (_Num)
     __builtin_memmove(__result, __first, sizeof(_Tp) * _Num);
   return __result + _Num;
 }
    };



  template<typename _CharT>
    struct char_traits;

  template<typename _CharT, typename _Traits>
    class istreambuf_iterator;

  template<typename _CharT, typename _Traits>
    class ostreambuf_iterator;

  template<bool _IsMove, typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
      ostreambuf_iterator<_CharT, char_traits<_CharT> > >::__type
    __copy_move_a2(_CharT*, _CharT*,
     ostreambuf_iterator<_CharT, char_traits<_CharT> >);

  template<bool _IsMove, typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
      ostreambuf_iterator<_CharT, char_traits<_CharT> > >::__type
    __copy_move_a2(const _CharT*, const _CharT*,
     ostreambuf_iterator<_CharT, char_traits<_CharT> >);

  template<bool _IsMove, typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
        _CharT*>::__type
    __copy_move_a2(istreambuf_iterator<_CharT, char_traits<_CharT> >,
     istreambuf_iterator<_CharT, char_traits<_CharT> >, _CharT*);

  template<bool _IsMove, typename _II, typename _OI>
   
    inline _OI
    __copy_move_a2(_II __first, _II __last, _OI __result)
    {
      typedef typename iterator_traits<_II>::iterator_category _Category;





      return std::__copy_move<_IsMove, __memcpyable<_OI, _II>::__value,
         _Category>::__copy_m(__first, __last, __result);
    }



  template<typename _Tp, typename _Ref, typename _Ptr>
    struct _Deque_iterator;



  template<bool _IsMove,
    typename _Tp, typename _Ref, typename _Ptr, typename _OI>
    _OI
    __copy_move_a1(std::_Deque_iterator<_Tp, _Ref, _Ptr>,
     std::_Deque_iterator<_Tp, _Ref, _Ptr>,
     _OI);

  template<bool _IsMove,
    typename _ITp, typename _IRef, typename _IPtr, typename _OTp>
    std::_Deque_iterator<_OTp, _OTp&, _OTp*>
    __copy_move_a1(std::_Deque_iterator<_ITp, _IRef, _IPtr>,
     std::_Deque_iterator<_ITp, _IRef, _IPtr>,
     std::_Deque_iterator<_OTp, _OTp&, _OTp*>);

  template<bool _IsMove, typename _II, typename _Tp>
    typename __gnu_cxx::__enable_if<
      __is_random_access_iter<_II>::__value,
      std::_Deque_iterator<_Tp, _Tp&, _Tp*> >::__type
    __copy_move_a1(_II, _II, std::_Deque_iterator<_Tp, _Tp&, _Tp*>);

  template<bool _IsMove, typename _II, typename _OI>
   
    inline _OI
    __copy_move_a1(_II __first, _II __last, _OI __result)
    { return std::__copy_move_a2<_IsMove>(__first, __last, __result); }

  template<bool _IsMove, typename _II, typename _OI>
   
    inline _OI
    __copy_move_a(_II __first, _II __last, _OI __result)
    {
      return std::__niter_wrap(__result,
  std::__copy_move_a1<_IsMove>(std::__niter_base(__first),
          std::__niter_base(__last),
          std::__niter_base(__result)));
    }

  template<bool _IsMove,
    typename _Ite, typename _Seq, typename _Cat, typename _OI>
    _OI
    __copy_move_a(const ::__gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat>&,
    const ::__gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat>&,
    _OI);

  template<bool _IsMove,
    typename _II, typename _Ite, typename _Seq, typename _Cat>
    __gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat>
    __copy_move_a(_II, _II,
    const ::__gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat>&);

  template<bool _IsMove,
    typename _IIte, typename _ISeq, typename _ICat,
    typename _OIte, typename _OSeq, typename _OCat>
    ::__gnu_debug::_Safe_iterator<_OIte, _OSeq, _OCat>
    __copy_move_a(const ::__gnu_debug::_Safe_iterator<_IIte, _ISeq, _ICat>&,
    const ::__gnu_debug::_Safe_iterator<_IIte, _ISeq, _ICat>&,
    const ::__gnu_debug::_Safe_iterator<_OIte, _OSeq, _OCat>&);
# 557 "/usr/include/c++/10/bits/stl_algobase.h" 3
  template<typename _II, typename _OI>
   
    inline _OI
    copy(_II __first, _II __last, _OI __result)
    {

     
     

      ;

      return std::__copy_move_a<__is_move_iterator<_II>::__value>
      (std::__miter_base(__first), std::__miter_base(__last), __result);
    }
# 590 "/usr/include/c++/10/bits/stl_algobase.h" 3
  template<typename _II, typename _OI>
   
    inline _OI
    move(_II __first, _II __last, _OI __result)
    {

     
     

      ;

      return std::__copy_move_a<true>(std::__miter_base(__first),
          std::__miter_base(__last), __result);
    }






  template<bool _IsMove, bool _IsSimple, typename _Category>
    struct __copy_move_backward
    {
      template<typename _BI1, typename _BI2>

 static _BI2
 __copy_move_b(_BI1 __first, _BI1 __last, _BI2 __result)
 {
   while (__first != __last)
     *--__result = *--__last;
   return __result;
 }
    };


  template<typename _Category>
    struct __copy_move_backward<true, false, _Category>
    {
      template<typename _BI1, typename _BI2>

 static _BI2
 __copy_move_b(_BI1 __first, _BI1 __last, _BI2 __result)
 {
   while (__first != __last)
     *--__result = std::move(*--__last);
   return __result;
 }
    };


  template<>
    struct __copy_move_backward<false, false, random_access_iterator_tag>
    {
      template<typename _BI1, typename _BI2>

 static _BI2
 __copy_move_b(_BI1 __first, _BI1 __last, _BI2 __result)
 {
   typename iterator_traits<_BI1>::difference_type
     __n = __last - __first;
   for (; __n > 0; --__n)
     *--__result = *--__last;
   return __result;
 }
    };


  template<>
    struct __copy_move_backward<true, false, random_access_iterator_tag>
    {
      template<typename _BI1, typename _BI2>

 static _BI2
 __copy_move_b(_BI1 __first, _BI1 __last, _BI2 __result)
 {
   typename iterator_traits<_BI1>::difference_type
     __n = __last - __first;
   for (; __n > 0; --__n)
     *--__result = std::move(*--__last);
   return __result;
 }
    };


  template<bool _IsMove>
    struct __copy_move_backward<_IsMove, true, random_access_iterator_tag>
    {
      template<typename _Tp>

 static _Tp*
 __copy_move_b(const _Tp* __first, const _Tp* __last, _Tp* __result)
 {

   using __assignable = conditional<_IsMove,
        is_move_assignable<_Tp>,
        is_copy_assignable<_Tp>>;

   static_assert( __assignable::type::value, "type is not assignable" );

   const ptrdiff_t _Num = __last - __first;
   if (_Num)
     __builtin_memmove(__result - _Num, __first, sizeof(_Tp) * _Num);
   return __result - _Num;
 }
    };

  template<bool _IsMove, typename _BI1, typename _BI2>
   
    inline _BI2
    __copy_move_backward_a2(_BI1 __first, _BI1 __last, _BI2 __result)
    {
      typedef typename iterator_traits<_BI1>::iterator_category _Category;





      return std::__copy_move_backward<_IsMove,
           __memcpyable<_BI2, _BI1>::__value,
           _Category>::__copy_move_b(__first,
         __last,
         __result);
    }

  template<bool _IsMove, typename _BI1, typename _BI2>
   
    inline _BI2
    __copy_move_backward_a1(_BI1 __first, _BI1 __last, _BI2 __result)
    { return std::__copy_move_backward_a2<_IsMove>(__first, __last, __result); }

  template<bool _IsMove,
    typename _Tp, typename _Ref, typename _Ptr, typename _OI>
    _OI
    __copy_move_backward_a1(std::_Deque_iterator<_Tp, _Ref, _Ptr>,
       std::_Deque_iterator<_Tp, _Ref, _Ptr>,
       _OI);

  template<bool _IsMove,
    typename _ITp, typename _IRef, typename _IPtr, typename _OTp>
    std::_Deque_iterator<_OTp, _OTp&, _OTp*>
    __copy_move_backward_a1(
   std::_Deque_iterator<_ITp, _IRef, _IPtr>,
   std::_Deque_iterator<_ITp, _IRef, _IPtr>,
   std::_Deque_iterator<_OTp, _OTp&, _OTp*>);

  template<bool _IsMove, typename _II, typename _Tp>
    typename __gnu_cxx::__enable_if<
      __is_random_access_iter<_II>::__value,
      std::_Deque_iterator<_Tp, _Tp&, _Tp*> >::__type
    __copy_move_backward_a1(_II, _II,
       std::_Deque_iterator<_Tp, _Tp&, _Tp*>);

  template<bool _IsMove, typename _II, typename _OI>
   
    inline _OI
    __copy_move_backward_a(_II __first, _II __last, _OI __result)
    {
      return std::__niter_wrap(__result,
  std::__copy_move_backward_a1<_IsMove>
    (std::__niter_base(__first), std::__niter_base(__last),
     std::__niter_base(__result)));
    }

  template<bool _IsMove,
    typename _Ite, typename _Seq, typename _Cat, typename _OI>
    _OI
    __copy_move_backward_a(
  const ::__gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat>&,
  const ::__gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat>&,
  _OI);

  template<bool _IsMove,
    typename _II, typename _Ite, typename _Seq, typename _Cat>
    __gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat>
    __copy_move_backward_a(_II, _II,
  const ::__gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat>&);

  template<bool _IsMove,
    typename _IIte, typename _ISeq, typename _ICat,
    typename _OIte, typename _OSeq, typename _OCat>
    ::__gnu_debug::_Safe_iterator<_OIte, _OSeq, _OCat>
    __copy_move_backward_a(
  const ::__gnu_debug::_Safe_iterator<_IIte, _ISeq, _ICat>&,
  const ::__gnu_debug::_Safe_iterator<_IIte, _ISeq, _ICat>&,
  const ::__gnu_debug::_Safe_iterator<_OIte, _OSeq, _OCat>&);
# 794 "/usr/include/c++/10/bits/stl_algobase.h" 3
  template<typename _BI1, typename _BI2>
   
    inline _BI2
    copy_backward(_BI1 __first, _BI1 __last, _BI2 __result)
    {

     
     
     


      ;

      return std::__copy_move_backward_a<__is_move_iterator<_BI1>::__value>
      (std::__miter_base(__first), std::__miter_base(__last), __result);
    }
# 830 "/usr/include/c++/10/bits/stl_algobase.h" 3
  template<typename _BI1, typename _BI2>
   
    inline _BI2
    move_backward(_BI1 __first, _BI1 __last, _BI2 __result)
    {

     
     
     


      ;

      return std::__copy_move_backward_a<true>(std::__miter_base(__first),
            std::__miter_base(__last),
            __result);
    }






  template<typename _ForwardIterator, typename _Tp>
   
    inline typename
    __gnu_cxx::__enable_if<!__is_scalar<_Tp>::__value, void>::__type
    __fill_a1(_ForwardIterator __first, _ForwardIterator __last,
       const _Tp& __value)
    {
      for (; __first != __last; ++__first)
 *__first = __value;
    }

  template<typename _ForwardIterator, typename _Tp>
   
    inline typename
    __gnu_cxx::__enable_if<__is_scalar<_Tp>::__value, void>::__type
    __fill_a1(_ForwardIterator __first, _ForwardIterator __last,
       const _Tp& __value)
    {
      const _Tp __tmp = __value;
      for (; __first != __last; ++__first)
 *__first = __tmp;
    }


  template<typename _Tp>
   
    inline typename
    __gnu_cxx::__enable_if<__is_byte<_Tp>::__value, void>::__type
    __fill_a1(_Tp* __first, _Tp* __last, const _Tp& __c)
    {
      const _Tp __tmp = __c;
# 892 "/usr/include/c++/10/bits/stl_algobase.h" 3
      if (const size_t __len = __last - __first)
 __builtin_memset(__first, static_cast<unsigned char>(__tmp), __len);
    }

  template<typename _Ite, typename _Cont, typename _Tp>
   
    inline void
    __fill_a1(::__gnu_cxx::__normal_iterator<_Ite, _Cont> __first,
       ::__gnu_cxx::__normal_iterator<_Ite, _Cont> __last,
       const _Tp& __value)
    { std::__fill_a1(__first.base(), __last.base(), __value); }

  template<typename _Tp, typename _VTp>
    void
    __fill_a1(const std::_Deque_iterator<_Tp, _Tp&, _Tp*>&,
       const std::_Deque_iterator<_Tp, _Tp&, _Tp*>&,
       const _VTp&);

  template<typename _FIte, typename _Tp>
   
    inline void
    __fill_a(_FIte __first, _FIte __last, const _Tp& __value)
    { std::__fill_a1(__first, __last, __value); }

  template<typename _Ite, typename _Seq, typename _Cat, typename _Tp>
    void
    __fill_a(const ::__gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat>&,
      const ::__gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat>&,
      const _Tp&);
# 934 "/usr/include/c++/10/bits/stl_algobase.h" 3
  template<typename _ForwardIterator, typename _Tp>
   
    inline void
    fill(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value)
    {

     

      ;

      std::__fill_a(__first, __last, __value);
    }


  inline constexpr int
  __size_to_integer(int __n) { return __n; }
  inline constexpr unsigned
  __size_to_integer(unsigned __n) { return __n; }
  inline constexpr long
  __size_to_integer(long __n) { return __n; }
  inline constexpr unsigned long
  __size_to_integer(unsigned long __n) { return __n; }
  inline constexpr long long
  __size_to_integer(long long __n) { return __n; }
  inline constexpr unsigned long long
  __size_to_integer(unsigned long long __n) { return __n; }


  inline constexpr __int128
  __size_to_integer(__int128 __n) { return __n; }
  inline constexpr unsigned __int128
  __size_to_integer(unsigned __int128 __n) { return __n; }
# 986 "/usr/include/c++/10/bits/stl_algobase.h" 3
  inline constexpr long long
  __size_to_integer(float __n) { return (long long)__n; }
  inline constexpr long long
  __size_to_integer(double __n) { return (long long)__n; }
  inline constexpr long long
  __size_to_integer(long double __n) { return (long long)__n; }

  inline constexpr long long
  __size_to_integer(__float128 __n) { return (long long)__n; }


  template<typename _OutputIterator, typename _Size, typename _Tp>
   
    inline typename
    __gnu_cxx::__enable_if<!__is_scalar<_Tp>::__value, _OutputIterator>::__type
    __fill_n_a1(_OutputIterator __first, _Size __n, const _Tp& __value)
    {
      for (; __n > 0; --__n, (void) ++__first)
 *__first = __value;
      return __first;
    }

  template<typename _OutputIterator, typename _Size, typename _Tp>
   
    inline typename
    __gnu_cxx::__enable_if<__is_scalar<_Tp>::__value, _OutputIterator>::__type
    __fill_n_a1(_OutputIterator __first, _Size __n, const _Tp& __value)
    {
      const _Tp __tmp = __value;
      for (; __n > 0; --__n, (void) ++__first)
 *__first = __tmp;
      return __first;
    }

  template<typename _Ite, typename _Seq, typename _Cat, typename _Size,
    typename _Tp>
    ::__gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat>
    __fill_n_a(const ::__gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat>& __first,
        _Size __n, const _Tp& __value,
        std::input_iterator_tag);

  template<typename _OutputIterator, typename _Size, typename _Tp>
   
    inline _OutputIterator
    __fill_n_a(_OutputIterator __first, _Size __n, const _Tp& __value,
        std::output_iterator_tag)
    {

      static_assert(is_integral<_Size>{}, "fill_n must pass integral size");

      return __fill_n_a1(__first, __n, __value);
    }

  template<typename _OutputIterator, typename _Size, typename _Tp>
   
    inline _OutputIterator
    __fill_n_a(_OutputIterator __first, _Size __n, const _Tp& __value,
        std::input_iterator_tag)
    {

      static_assert(is_integral<_Size>{}, "fill_n must pass integral size");

      return __fill_n_a1(__first, __n, __value);
    }

  template<typename _OutputIterator, typename _Size, typename _Tp>
   
    inline _OutputIterator
    __fill_n_a(_OutputIterator __first, _Size __n, const _Tp& __value,
        std::random_access_iterator_tag)
    {

      static_assert(is_integral<_Size>{}, "fill_n must pass integral size");

      if (__n <= 0)
 return __first;

      ;

      std::__fill_a(__first, __first + __n, __value);
      return __first + __n;
    }
# 1086 "/usr/include/c++/10/bits/stl_algobase.h" 3
  template<typename _OI, typename _Size, typename _Tp>
   
    inline _OI
    fill_n(_OI __first, _Size __n, const _Tp& __value)
    {

     

      return std::__fill_n_a(__first, std::__size_to_integer(__n), __value,
          std::__iterator_category(__first));
    }

  template<bool _BoolType>
    struct __equal
    {
      template<typename _II1, typename _II2>

 static bool
 equal(_II1 __first1, _II1 __last1, _II2 __first2)
 {
   for (; __first1 != __last1; ++__first1, (void) ++__first2)
     if (!(*__first1 == *__first2))
       return false;
   return true;
 }
    };

  template<>
    struct __equal<true>
    {
      template<typename _Tp>

 static bool
 equal(const _Tp* __first1, const _Tp* __last1, const _Tp* __first2)
 {
   if (const size_t __len = (__last1 - __first1))
     return !std::__memcmp(__first1, __first2, __len);
   return true;
 }
    };

  template<typename _Tp, typename _Ref, typename _Ptr, typename _II>
    typename __gnu_cxx::__enable_if<
      __is_random_access_iter<_II>::__value, bool>::__type
    __equal_aux1(std::_Deque_iterator<_Tp, _Ref, _Ptr>,
   std::_Deque_iterator<_Tp, _Ref, _Ptr>,
   _II);

  template<typename _Tp1, typename _Ref1, typename _Ptr1,
    typename _Tp2, typename _Ref2, typename _Ptr2>
    bool
    __equal_aux1(std::_Deque_iterator<_Tp1, _Ref1, _Ptr1>,
   std::_Deque_iterator<_Tp1, _Ref1, _Ptr1>,
   std::_Deque_iterator<_Tp2, _Ref2, _Ptr2>);

  template<typename _II, typename _Tp, typename _Ref, typename _Ptr>
    typename __gnu_cxx::__enable_if<
      __is_random_access_iter<_II>::__value, bool>::__type
    __equal_aux1(_II, _II,
  std::_Deque_iterator<_Tp, _Ref, _Ptr>);

  template<typename _II1, typename _II2>
   
    inline bool
    __equal_aux1(_II1 __first1, _II1 __last1, _II2 __first2)
    {
      typedef typename iterator_traits<_II1>::value_type _ValueType1;
      const bool __simple = ((__is_integer<_ValueType1>::__value
         || __is_pointer<_ValueType1>::__value)
        && __memcmpable<_II1, _II2>::__value);
      return std::__equal<__simple>::equal(__first1, __last1, __first2);
    }

  template<typename _II1, typename _II2>
   
    inline bool
    __equal_aux(_II1 __first1, _II1 __last1, _II2 __first2)
    {
      return std::__equal_aux1(std::__niter_base(__first1),
          std::__niter_base(__last1),
          std::__niter_base(__first2));
    }

  template<typename _II1, typename _Seq1, typename _Cat1, typename _II2>
    bool
    __equal_aux(const ::__gnu_debug::_Safe_iterator<_II1, _Seq1, _Cat1>&,
  const ::__gnu_debug::_Safe_iterator<_II1, _Seq1, _Cat1>&,
  _II2);

  template<typename _II1, typename _II2, typename _Seq2, typename _Cat2>
    bool
    __equal_aux(_II1, _II1,
  const ::__gnu_debug::_Safe_iterator<_II2, _Seq2, _Cat2>&);

  template<typename _II1, typename _Seq1, typename _Cat1,
    typename _II2, typename _Seq2, typename _Cat2>
    bool
    __equal_aux(const ::__gnu_debug::_Safe_iterator<_II1, _Seq1, _Cat1>&,
  const ::__gnu_debug::_Safe_iterator<_II1, _Seq1, _Cat1>&,
  const ::__gnu_debug::_Safe_iterator<_II2, _Seq2, _Cat2>&);

  template<typename, typename>
    struct __lc_rai
    {
      template<typename _II1, typename _II2>

 static _II1
 __newlast1(_II1, _II1 __last1, _II2, _II2)
 { return __last1; }

      template<typename _II>

 static bool
 __cnd2(_II __first, _II __last)
 { return __first != __last; }
    };

  template<>
    struct __lc_rai<random_access_iterator_tag, random_access_iterator_tag>
    {
      template<typename _RAI1, typename _RAI2>

 static _RAI1
 __newlast1(_RAI1 __first1, _RAI1 __last1,
     _RAI2 __first2, _RAI2 __last2)
 {
   const typename iterator_traits<_RAI1>::difference_type
     __diff1 = __last1 - __first1;
   const typename iterator_traits<_RAI2>::difference_type
     __diff2 = __last2 - __first2;
   return __diff2 < __diff1 ? __first1 + __diff2 : __last1;
 }

      template<typename _RAI>
 static bool
 __cnd2(_RAI, _RAI)
 { return true; }
    };

  template<typename _II1, typename _II2, typename _Compare>
   
    bool
    __lexicographical_compare_impl(_II1 __first1, _II1 __last1,
       _II2 __first2, _II2 __last2,
       _Compare __comp)
    {
      typedef typename iterator_traits<_II1>::iterator_category _Category1;
      typedef typename iterator_traits<_II2>::iterator_category _Category2;
      typedef std::__lc_rai<_Category1, _Category2> __rai_type;

      __last1 = __rai_type::__newlast1(__first1, __last1, __first2, __last2);
      for (; __first1 != __last1 && __rai_type::__cnd2(__first2, __last2);
    ++__first1, (void)++__first2)
 {
   if (__comp(__first1, __first2))
     return true;
   if (__comp(__first2, __first1))
     return false;
 }
      return __first1 == __last1 && __first2 != __last2;
    }

  template<bool _BoolType>
    struct __lexicographical_compare
    {
      template<typename _II1, typename _II2>

 static bool
 __lc(_II1 __first1, _II1 __last1, _II2 __first2, _II2 __last2)
 {
   using __gnu_cxx::__ops::__iter_less_iter;
   return std::__lexicographical_compare_impl(__first1, __last1,
           __first2, __last2,
           __iter_less_iter());
 }
    };

  template<>
    struct __lexicographical_compare<true>
    {
      template<typename _Tp, typename _Up>

 static bool
 __lc(const _Tp* __first1, const _Tp* __last1,
      const _Up* __first2, const _Up* __last2)
 {
   const size_t __len1 = __last1 - __first1;
   const size_t __len2 = __last2 - __first2;
   if (const size_t __len = std::min(__len1, __len2))
     if (int __result = std::__memcmp(__first1, __first2, __len))
       return __result < 0;
   return __len1 < __len2;
 }
    };

  template<typename _II1, typename _II2>
   
    inline bool
    __lexicographical_compare_aux(_II1 __first1, _II1 __last1,
      _II2 __first2, _II2 __last2)
    {
      typedef typename iterator_traits<_II1>::value_type _ValueType1;
      typedef typename iterator_traits<_II2>::value_type _ValueType2;
      const bool __simple =
 (__is_memcmp_ordered_with<_ValueType1, _ValueType2>::__value
  && __is_pointer<_II1>::__value
  && __is_pointer<_II2>::__value







  );

      return std::__lexicographical_compare<__simple>::__lc(__first1, __last1,
           __first2, __last2);
    }

  template<typename _ForwardIterator, typename _Tp, typename _Compare>
   
    _ForwardIterator
    __lower_bound(_ForwardIterator __first, _ForwardIterator __last,
    const _Tp& __val, _Compare __comp)
    {
      typedef typename iterator_traits<_ForwardIterator>::difference_type
 _DistanceType;

      _DistanceType __len = std::distance(__first, __last);

      while (__len > 0)
 {
   _DistanceType __half = __len >> 1;
   _ForwardIterator __middle = __first;
   std::advance(__middle, __half);
   if (__comp(__middle, __val))
     {
       __first = __middle;
       ++__first;
       __len = __len - __half - 1;
     }
   else
     __len = __half;
 }
      return __first;
    }
# 1345 "/usr/include/c++/10/bits/stl_algobase.h" 3
  template<typename _ForwardIterator, typename _Tp>
   
    inline _ForwardIterator
    lower_bound(_ForwardIterator __first, _ForwardIterator __last,
  const _Tp& __val)
    {

     
     

      ;

      return std::__lower_bound(__first, __last, __val,
    __gnu_cxx::__ops::__iter_less_val());
    }



  inline constexpr int
  __lg(int __n)
  { return (int)sizeof(int) * 8 - 1 - __builtin_clz(__n); }

  inline constexpr unsigned
  __lg(unsigned __n)
  { return (int)sizeof(int) * 8 - 1 - __builtin_clz(__n); }

  inline constexpr long
  __lg(long __n)
  { return (int)sizeof(long) * 8 - 1 - __builtin_clzl(__n); }

  inline constexpr unsigned long
  __lg(unsigned long __n)
  { return (int)sizeof(long) * 8 - 1 - __builtin_clzl(__n); }

  inline constexpr long long
  __lg(long long __n)
  { return (int)sizeof(long long) * 8 - 1 - __builtin_clzll(__n); }

  inline constexpr unsigned long long
  __lg(unsigned long long __n)
  { return (int)sizeof(long long) * 8 - 1 - __builtin_clzll(__n); }


# 1401 "/usr/include/c++/10/bits/stl_algobase.h" 3
  template<typename _II1, typename _II2>
   
    inline bool
    equal(_II1 __first1, _II1 __last1, _II2 __first2)
    {

     
     
     


      ;

      return std::__equal_aux(__first1, __last1, __first2);
    }
# 1432 "/usr/include/c++/10/bits/stl_algobase.h" 3
  template<typename _IIter1, typename _IIter2, typename _BinaryPredicate>
   
    inline bool
    equal(_IIter1 __first1, _IIter1 __last1,
   _IIter2 __first2, _BinaryPredicate __binary_pred)
    {

     
     
      ;

      for (; __first1 != __last1; ++__first1, (void)++__first2)
 if (!bool(__binary_pred(*__first1, *__first2)))
   return false;
      return true;
    }



  template<typename _II1, typename _II2>
   
    inline bool
    __equal4(_II1 __first1, _II1 __last1, _II2 __first2, _II2 __last2)
    {
      using _RATag = random_access_iterator_tag;
      using _Cat1 = typename iterator_traits<_II1>::iterator_category;
      using _Cat2 = typename iterator_traits<_II2>::iterator_category;
      using _RAIters = __and_<is_same<_Cat1, _RATag>, is_same<_Cat2, _RATag>>;
      if (_RAIters())
 {
   auto __d1 = std::distance(__first1, __last1);
   auto __d2 = std::distance(__first2, __last2);
   if (__d1 != __d2)
     return false;
   return std::equal(__first1, __last1, __first2);
 }

      for (; __first1 != __last1 && __first2 != __last2;
   ++__first1, (void)++__first2)
 if (!(*__first1 == *__first2))
   return false;
      return __first1 == __last1 && __first2 == __last2;
    }


  template<typename _II1, typename _II2, typename _BinaryPredicate>
   
    inline bool
    __equal4(_II1 __first1, _II1 __last1, _II2 __first2, _II2 __last2,
      _BinaryPredicate __binary_pred)
    {
      using _RATag = random_access_iterator_tag;
      using _Cat1 = typename iterator_traits<_II1>::iterator_category;
      using _Cat2 = typename iterator_traits<_II2>::iterator_category;
      using _RAIters = __and_<is_same<_Cat1, _RATag>, is_same<_Cat2, _RATag>>;
      if (_RAIters())
 {
   auto __d1 = std::distance(__first1, __last1);
   auto __d2 = std::distance(__first2, __last2);
   if (__d1 != __d2)
     return false;
   return std::equal(__first1, __last1, __first2,
           __binary_pred);
 }

      for (; __first1 != __last1 && __first2 != __last2;
   ++__first1, (void)++__first2)
 if (!bool(__binary_pred(*__first1, *__first2)))
   return false;
      return __first1 == __last1 && __first2 == __last2;
    }
# 1522 "/usr/include/c++/10/bits/stl_algobase.h" 3
  template<typename _II1, typename _II2>
   
    inline bool
    equal(_II1 __first1, _II1 __last1, _II2 __first2, _II2 __last2)
    {

     
     
     


      ;
      ;

      return std::__equal4(__first1, __last1, __first2, __last2);
    }
# 1555 "/usr/include/c++/10/bits/stl_algobase.h" 3
  template<typename _IIter1, typename _IIter2, typename _BinaryPredicate>
   
    inline bool
    equal(_IIter1 __first1, _IIter1 __last1,
   _IIter2 __first2, _IIter2 __last2, _BinaryPredicate __binary_pred)
    {

     
     
      ;
      ;

      return std::__equal4(__first1, __last1, __first2, __last2,
          __binary_pred);
    }
# 1587 "/usr/include/c++/10/bits/stl_algobase.h" 3
  template<typename _II1, typename _II2>
   
    inline bool
    lexicographical_compare(_II1 __first1, _II1 __last1,
       _II2 __first2, _II2 __last2)
    {





     
     
     
     
      ;
      ;

      return std::__lexicographical_compare_aux(std::__niter_base(__first1),
      std::__niter_base(__last1),
      std::__niter_base(__first2),
      std::__niter_base(__last2));
    }
# 1624 "/usr/include/c++/10/bits/stl_algobase.h" 3
  template<typename _II1, typename _II2, typename _Compare>
   
    inline bool
    lexicographical_compare(_II1 __first1, _II1 __last1,
       _II2 __first2, _II2 __last2, _Compare __comp)
    {

     
     
      ;
      ;

      return std::__lexicographical_compare_impl
 (__first1, __last1, __first2, __last2,
  __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }
# 1737 "/usr/include/c++/10/bits/stl_algobase.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _BinaryPredicate>
   
    pair<_InputIterator1, _InputIterator2>
    __mismatch(_InputIterator1 __first1, _InputIterator1 __last1,
        _InputIterator2 __first2, _BinaryPredicate __binary_pred)
    {
      while (__first1 != __last1 && __binary_pred(__first1, __first2))
 {
   ++__first1;
   ++__first2;
 }
      return pair<_InputIterator1, _InputIterator2>(__first1, __first2);
    }
# 1765 "/usr/include/c++/10/bits/stl_algobase.h" 3
  template<typename _InputIterator1, typename _InputIterator2>
   
    inline pair<_InputIterator1, _InputIterator2>
    mismatch(_InputIterator1 __first1, _InputIterator1 __last1,
      _InputIterator2 __first2)
    {

     
     
     


      ;

      return std::__mismatch(__first1, __last1, __first2,
        __gnu_cxx::__ops::__iter_equal_to_iter());
    }
# 1799 "/usr/include/c++/10/bits/stl_algobase.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _BinaryPredicate>
   
    inline pair<_InputIterator1, _InputIterator2>
    mismatch(_InputIterator1 __first1, _InputIterator1 __last1,
      _InputIterator2 __first2, _BinaryPredicate __binary_pred)
    {

     
     
      ;

      return std::__mismatch(__first1, __last1, __first2,
 __gnu_cxx::__ops::__iter_comp_iter(__binary_pred));
    }



  template<typename _InputIterator1, typename _InputIterator2,
    typename _BinaryPredicate>
   
    pair<_InputIterator1, _InputIterator2>
    __mismatch(_InputIterator1 __first1, _InputIterator1 __last1,
        _InputIterator2 __first2, _InputIterator2 __last2,
        _BinaryPredicate __binary_pred)
    {
      while (__first1 != __last1 && __first2 != __last2
      && __binary_pred(__first1, __first2))
 {
   ++__first1;
   ++__first2;
 }
      return pair<_InputIterator1, _InputIterator2>(__first1, __first2);
    }
# 1848 "/usr/include/c++/10/bits/stl_algobase.h" 3
  template<typename _InputIterator1, typename _InputIterator2>
   
    inline pair<_InputIterator1, _InputIterator2>
    mismatch(_InputIterator1 __first1, _InputIterator1 __last1,
      _InputIterator2 __first2, _InputIterator2 __last2)
    {

     
     
     


      ;
      ;

      return std::__mismatch(__first1, __last1, __first2, __last2,
        __gnu_cxx::__ops::__iter_equal_to_iter());
    }
# 1884 "/usr/include/c++/10/bits/stl_algobase.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _BinaryPredicate>
   
    inline pair<_InputIterator1, _InputIterator2>
    mismatch(_InputIterator1 __first1, _InputIterator1 __last1,
      _InputIterator2 __first2, _InputIterator2 __last2,
      _BinaryPredicate __binary_pred)
    {

     
     
      ;
      ;

      return std::__mismatch(__first1, __last1, __first2, __last2,
        __gnu_cxx::__ops::__iter_comp_iter(__binary_pred));
    }





  template<typename _InputIterator, typename _Predicate>
   
    inline _InputIterator
    __find_if(_InputIterator __first, _InputIterator __last,
       _Predicate __pred, input_iterator_tag)
    {
      while (__first != __last && !__pred(__first))
 ++__first;
      return __first;
    }


  template<typename _RandomAccessIterator, typename _Predicate>
   
    _RandomAccessIterator
    __find_if(_RandomAccessIterator __first, _RandomAccessIterator __last,
       _Predicate __pred, random_access_iterator_tag)
    {
      typename iterator_traits<_RandomAccessIterator>::difference_type
 __trip_count = (__last - __first) >> 2;

      for (; __trip_count > 0; --__trip_count)
 {
   if (__pred(__first))
     return __first;
   ++__first;

   if (__pred(__first))
     return __first;
   ++__first;

   if (__pred(__first))
     return __first;
   ++__first;

   if (__pred(__first))
     return __first;
   ++__first;
 }

      switch (__last - __first)
 {
 case 3:
   if (__pred(__first))
     return __first;
   ++__first;

 case 2:
   if (__pred(__first))
     return __first;
   ++__first;

 case 1:
   if (__pred(__first))
     return __first;
   ++__first;

 case 0:
 default:
   return __last;
 }
    }

  template<typename _Iterator, typename _Predicate>
   
    inline _Iterator
    __find_if(_Iterator __first, _Iterator __last, _Predicate __pred)
    {
      return __find_if(__first, __last, __pred,
         std::__iterator_category(__first));
    }

  template<typename _InputIterator, typename _Predicate>
   
    typename iterator_traits<_InputIterator>::difference_type
    __count_if(_InputIterator __first, _InputIterator __last, _Predicate __pred)
    {
      typename iterator_traits<_InputIterator>::difference_type __n = 0;
      for (; __first != __last; ++__first)
 if (__pred(__first))
   ++__n;
      return __n;
    }


  template<typename _ForwardIterator1, typename _ForwardIterator2,
    typename _BinaryPredicate>
   
    bool
    __is_permutation(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
       _ForwardIterator2 __first2, _BinaryPredicate __pred)
    {


      for (; __first1 != __last1; ++__first1, (void)++__first2)
 if (!__pred(__first1, __first2))
   break;

      if (__first1 == __last1)
 return true;



      _ForwardIterator2 __last2 = __first2;
      std::advance(__last2, std::distance(__first1, __last1));
      for (_ForwardIterator1 __scan = __first1; __scan != __last1; ++__scan)
 {
   if (__scan != std::__find_if(__first1, __scan,
     __gnu_cxx::__ops::__iter_comp_iter(__pred, __scan)))
     continue;

   auto __matches
     = std::__count_if(__first2, __last2,
   __gnu_cxx::__ops::__iter_comp_iter(__pred, __scan));
   if (0 == __matches ||
       std::__count_if(__scan, __last1,
   __gnu_cxx::__ops::__iter_comp_iter(__pred, __scan))
       != __matches)
     return false;
 }
      return true;
    }
# 2041 "/usr/include/c++/10/bits/stl_algobase.h" 3
  template<typename _ForwardIterator1, typename _ForwardIterator2>
   
    inline bool
    is_permutation(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
     _ForwardIterator2 __first2)
    {

     
     
     


      ;

      return std::__is_permutation(__first1, __last1, __first2,
       __gnu_cxx::__ops::__iter_equal_to_iter());
    }



}
# 41 "/usr/include/c++/10/array" 2 3
# 1 "/usr/include/c++/10/bits/range_access.h" 1 3
# 33 "/usr/include/c++/10/bits/range_access.h" 3
       
# 34 "/usr/include/c++/10/bits/range_access.h" 3



# 1 "/usr/include/c++/10/bits/iterator_concepts.h" 1 3
# 33 "/usr/include/c++/10/bits/iterator_concepts.h" 3
       
# 34 "/usr/include/c++/10/bits/iterator_concepts.h" 3

# 1 "/usr/include/c++/10/concepts" 1 3
# 36 "/usr/include/c++/10/bits/iterator_concepts.h" 2 3

# 1 "/usr/include/c++/10/bits/range_cmp.h" 1 3
# 38 "/usr/include/c++/10/bits/iterator_concepts.h" 2 3
# 38 "/usr/include/c++/10/bits/range_access.h" 2 3


namespace std __attribute__ ((__visibility__ ("default")))
{







  template<typename _Container>
    inline auto
    begin(_Container& __cont) -> decltype(__cont.begin())
    { return __cont.begin(); }






  template<typename _Container>
    inline auto
    begin(const _Container& __cont) -> decltype(__cont.begin())
    { return __cont.begin(); }






  template<typename _Container>
    inline auto
    end(_Container& __cont) -> decltype(__cont.end())
    { return __cont.end(); }






  template<typename _Container>
    inline auto
    end(const _Container& __cont) -> decltype(__cont.end())
    { return __cont.end(); }





  template<typename _Tp, size_t _Nm>
    inline constexpr _Tp*
    begin(_Tp (&__arr)[_Nm]) noexcept
    { return __arr; }






  template<typename _Tp, size_t _Nm>
    inline constexpr _Tp*
    end(_Tp (&__arr)[_Nm]) noexcept
    { return __arr + _Nm; }



  template<typename _Tp> class valarray;

  template<typename _Tp> _Tp* begin(valarray<_Tp>&) noexcept;
  template<typename _Tp> const _Tp* begin(const valarray<_Tp>&) noexcept;
  template<typename _Tp> _Tp* end(valarray<_Tp>&) noexcept;
  template<typename _Tp> const _Tp* end(const valarray<_Tp>&) noexcept;






  template<typename _Container>
    inline constexpr auto
    cbegin(const _Container& __cont) noexcept(noexcept(std::begin(__cont)))
      -> decltype(std::begin(__cont))
    { return std::begin(__cont); }






  template<typename _Container>
    inline constexpr auto
    cend(const _Container& __cont) noexcept(noexcept(std::end(__cont)))
      -> decltype(std::end(__cont))
    { return std::end(__cont); }






  template<typename _Container>
    inline auto
    rbegin(_Container& __cont) -> decltype(__cont.rbegin())
    { return __cont.rbegin(); }






  template<typename _Container>
    inline auto
    rbegin(const _Container& __cont) -> decltype(__cont.rbegin())
    { return __cont.rbegin(); }






  template<typename _Container>
    inline auto
    rend(_Container& __cont) -> decltype(__cont.rend())
    { return __cont.rend(); }






  template<typename _Container>
    inline auto
    rend(const _Container& __cont) -> decltype(__cont.rend())
    { return __cont.rend(); }






  template<typename _Tp, size_t _Nm>
    inline reverse_iterator<_Tp*>
    rbegin(_Tp (&__arr)[_Nm]) noexcept
    { return reverse_iterator<_Tp*>(__arr + _Nm); }






  template<typename _Tp, size_t _Nm>
    inline reverse_iterator<_Tp*>
    rend(_Tp (&__arr)[_Nm]) noexcept
    { return reverse_iterator<_Tp*>(__arr); }






  template<typename _Tp>
    inline reverse_iterator<const _Tp*>
    rbegin(initializer_list<_Tp> __il) noexcept
    { return reverse_iterator<const _Tp*>(__il.end()); }






  template<typename _Tp>
    inline reverse_iterator<const _Tp*>
    rend(initializer_list<_Tp> __il) noexcept
    { return reverse_iterator<const _Tp*>(__il.begin()); }






  template<typename _Container>
    inline auto
    crbegin(const _Container& __cont) -> decltype(std::rbegin(__cont))
    { return std::rbegin(__cont); }






  template<typename _Container>
    inline auto
    crend(const _Container& __cont) -> decltype(std::rend(__cont))
    { return std::rend(__cont); }
# 1176 "/usr/include/c++/10/bits/range_access.h" 3

}
# 42 "/usr/include/c++/10/array" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{


  template<typename _Tp, std::size_t _Nm>
    struct __array_traits
    {
      typedef _Tp _Type[_Nm];
      typedef __is_swappable<_Tp> _Is_swappable;
      typedef __is_nothrow_swappable<_Tp> _Is_nothrow_swappable;

      static constexpr _Tp&
      _S_ref(const _Type& __t, std::size_t __n) noexcept
      { return const_cast<_Tp&>(__t[__n]); }

      static constexpr _Tp*
      _S_ptr(const _Type& __t) noexcept
      { return const_cast<_Tp*>(__t); }
    };

 template<typename _Tp>
   struct __array_traits<_Tp, 0>
   {
     struct _Type { };
     typedef true_type _Is_swappable;
     typedef true_type _Is_nothrow_swappable;

     static constexpr _Tp&
     _S_ref(const _Type&, std::size_t) noexcept
     { return *static_cast<_Tp*>(nullptr); }

     static constexpr _Tp*
     _S_ptr(const _Type&) noexcept
     { return nullptr; }
   };
# 93 "/usr/include/c++/10/array" 3
  template<typename _Tp, std::size_t _Nm>
    struct array
    {
      typedef _Tp value_type;
      typedef value_type* pointer;
      typedef const value_type* const_pointer;
      typedef value_type& reference;
      typedef const value_type& const_reference;
      typedef value_type* iterator;
      typedef const value_type* const_iterator;
      typedef std::size_t size_type;
      typedef std::ptrdiff_t difference_type;
      typedef std::reverse_iterator<iterator> reverse_iterator;
      typedef std::reverse_iterator<const_iterator> const_reverse_iterator;


      typedef std::__array_traits<_Tp, _Nm> _AT_Type;
      typename _AT_Type::_Type _M_elems;




      void
      fill(const value_type& __u)
      { std::fill_n(begin(), size(), __u); }

      void
      swap(array& __other)
      noexcept(_AT_Type::_Is_nothrow_swappable::value)
      { std::swap_ranges(begin(), end(), __other.begin()); }


      iterator
      begin() noexcept
      { return iterator(data()); }

      const_iterator
      begin() const noexcept
      { return const_iterator(data()); }

      iterator
      end() noexcept
      { return iterator(data() + _Nm); }

      const_iterator
      end() const noexcept
      { return const_iterator(data() + _Nm); }

      reverse_iterator
      rbegin() noexcept
      { return reverse_iterator(end()); }

      const_reverse_iterator
      rbegin() const noexcept
      { return const_reverse_iterator(end()); }

      reverse_iterator
      rend() noexcept
      { return reverse_iterator(begin()); }

      const_reverse_iterator
      rend() const noexcept
      { return const_reverse_iterator(begin()); }

      const_iterator
      cbegin() const noexcept
      { return const_iterator(data()); }

      const_iterator
      cend() const noexcept
      { return const_iterator(data() + _Nm); }

      const_reverse_iterator
      crbegin() const noexcept
      { return const_reverse_iterator(end()); }

      const_reverse_iterator
      crend() const noexcept
      { return const_reverse_iterator(begin()); }


      constexpr size_type
      size() const noexcept { return _Nm; }

      constexpr size_type
      max_size() const noexcept { return _Nm; }

      constexpr bool
      empty() const noexcept { return size() == 0; }


      reference
      operator[](size_type __n) noexcept
      { return _AT_Type::_S_ref(_M_elems, __n); }

      constexpr const_reference
      operator[](size_type __n) const noexcept
      { return _AT_Type::_S_ref(_M_elems, __n); }

      reference
      at(size_type __n)
      {
 if (__n >= _Nm)
   std::__throw_out_of_range_fmt(("array::at: __n (which is %zu) " ">= _Nm (which is %zu)")
                                 ,
     __n, _Nm);
 return _AT_Type::_S_ref(_M_elems, __n);
      }

      constexpr const_reference
      at(size_type __n) const
      {


 return __n < _Nm ? _AT_Type::_S_ref(_M_elems, __n)
   : (std::__throw_out_of_range_fmt(("array::at: __n (which is %zu) " ">= _Nm (which is %zu)")
                                    ,
        __n, _Nm),
      _AT_Type::_S_ref(_M_elems, 0));
      }

      reference
      front() noexcept
      { return *begin(); }

      constexpr const_reference
      front() const noexcept
      { return _AT_Type::_S_ref(_M_elems, 0); }

      reference
      back() noexcept
      { return _Nm ? *(end() - 1) : *end(); }

      constexpr const_reference
      back() const noexcept
      {
 return _Nm ? _AT_Type::_S_ref(_M_elems, _Nm - 1)
             : _AT_Type::_S_ref(_M_elems, 0);
      }

      pointer
      data() noexcept
      { return _AT_Type::_S_ptr(_M_elems); }

      const_pointer
      data() const noexcept
      { return _AT_Type::_S_ptr(_M_elems); }
    };
# 250 "/usr/include/c++/10/array" 3
  template<typename _Tp, std::size_t _Nm>
   
    inline bool
    operator==(const array<_Tp, _Nm>& __one, const array<_Tp, _Nm>& __two)
    { return std::equal(__one.begin(), __one.end(), __two.begin()); }
# 279 "/usr/include/c++/10/array" 3
  template<typename _Tp, std::size_t _Nm>
   
    inline bool
    operator!=(const array<_Tp, _Nm>& __one, const array<_Tp, _Nm>& __two)
    { return !(__one == __two); }

  template<typename _Tp, std::size_t _Nm>
   
    inline bool
    operator<(const array<_Tp, _Nm>& __a, const array<_Tp, _Nm>& __b)
    {
      return std::lexicographical_compare(__a.begin(), __a.end(),
       __b.begin(), __b.end());
    }

  template<typename _Tp, std::size_t _Nm>
   
    inline bool
    operator>(const array<_Tp, _Nm>& __one, const array<_Tp, _Nm>& __two)
    { return __two < __one; }

  template<typename _Tp, std::size_t _Nm>
   
    inline bool
    operator<=(const array<_Tp, _Nm>& __one, const array<_Tp, _Nm>& __two)
    { return !(__one > __two); }

  template<typename _Tp, std::size_t _Nm>
   
    inline bool
    operator>=(const array<_Tp, _Nm>& __one, const array<_Tp, _Nm>& __two)
    { return !(__one < __two); }



  template<typename _Tp, std::size_t _Nm>
   
    inline


    typename enable_if<
      std::__array_traits<_Tp, _Nm>::_Is_swappable::value
    >::type



    swap(array<_Tp, _Nm>& __one, array<_Tp, _Nm>& __two)
    noexcept(noexcept(__one.swap(__two)))
    { __one.swap(__two); }


  template<typename _Tp, std::size_t _Nm>
    typename enable_if<
      !std::__array_traits<_Tp, _Nm>::_Is_swappable::value>::type
    swap(array<_Tp, _Nm>&, array<_Tp, _Nm>&) = delete;


  template<std::size_t _Int, typename _Tp, std::size_t _Nm>
    constexpr _Tp&
    get(array<_Tp, _Nm>& __arr) noexcept
    {
      static_assert(_Int < _Nm, "array index is within bounds");
      return std::__array_traits<_Tp, _Nm>::
 _S_ref(__arr._M_elems, _Int);
    }

  template<std::size_t _Int, typename _Tp, std::size_t _Nm>
    constexpr _Tp&&
    get(array<_Tp, _Nm>&& __arr) noexcept
    {
      static_assert(_Int < _Nm, "array index is within bounds");
      return std::move(std::get<_Int>(__arr));
    }

  template<std::size_t _Int, typename _Tp, std::size_t _Nm>
    constexpr const _Tp&
    get(const array<_Tp, _Nm>& __arr) noexcept
    {
      static_assert(_Int < _Nm, "array index is within bounds");
      return std::__array_traits<_Tp, _Nm>::
 _S_ref(__arr._M_elems, _Int);
    }

  template<std::size_t _Int, typename _Tp, std::size_t _Nm>
    constexpr const _Tp&&
    get(const array<_Tp, _Nm>&& __arr) noexcept
    {
      static_assert(_Int < _Nm, "array index is within bounds");
      return std::move(std::get<_Int>(__arr));
    }
# 408 "/usr/include/c++/10/array" 3

}

namespace std __attribute__ ((__visibility__ ("default")))
{





  template<typename _Tp>
    struct tuple_size;


  template<typename _Tp, std::size_t _Nm>
    struct tuple_size<std::array<_Tp, _Nm>>
    : public integral_constant<std::size_t, _Nm> { };


  template<std::size_t _Int, typename _Tp>
    struct tuple_element;


  template<std::size_t _Int, typename _Tp, std::size_t _Nm>
    struct tuple_element<_Int, std::array<_Tp, _Nm>>
    {
      static_assert(_Int < _Nm, "index is out of bounds");
      typedef _Tp type;
    };

  template<typename _Tp, std::size_t _Nm>
    struct __is_tuple_like_impl<std::array<_Tp, _Nm>> : true_type
    { };


}
# 40 "/usr/include/c++/10/tuple" 2 3
# 1 "/usr/include/c++/10/bits/uses_allocator.h" 1 3
# 35 "/usr/include/c++/10/bits/uses_allocator.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{



  struct __erased_type { };




  template<typename _Alloc, typename _Tp>
    using __is_erased_or_convertible
      = __or_<is_convertible<_Alloc, _Tp>, is_same<_Tp, __erased_type>>;


  struct allocator_arg_t { explicit allocator_arg_t() = default; };

  constexpr allocator_arg_t allocator_arg =
    allocator_arg_t();

  template<typename _Tp, typename _Alloc, typename = __void_t<>>
    struct __uses_allocator_helper
    : false_type { };

  template<typename _Tp, typename _Alloc>
    struct __uses_allocator_helper<_Tp, _Alloc,
       __void_t<typename _Tp::allocator_type>>
    : __is_erased_or_convertible<_Alloc, typename _Tp::allocator_type>::type
    { };


  template<typename _Tp, typename _Alloc>
    struct uses_allocator
    : __uses_allocator_helper<_Tp, _Alloc>::type
    { };

  struct __uses_alloc_base { };

  struct __uses_alloc0 : __uses_alloc_base
  {
    struct _Sink { void operator=(const void*) { } } _M_a;
  };

  template<typename _Alloc>
    struct __uses_alloc1 : __uses_alloc_base { const _Alloc* _M_a; };

  template<typename _Alloc>
    struct __uses_alloc2 : __uses_alloc_base { const _Alloc* _M_a; };

  template<bool, typename _Tp, typename _Alloc, typename... _Args>
    struct __uses_alloc;

  template<typename _Tp, typename _Alloc, typename... _Args>
    struct __uses_alloc<true, _Tp, _Alloc, _Args...>
    : conditional<
        is_constructible<_Tp, allocator_arg_t, const _Alloc&, _Args...>::value,
        __uses_alloc1<_Alloc>,
        __uses_alloc2<_Alloc>>::type
    {


      static_assert(__or_<
   is_constructible<_Tp, allocator_arg_t, const _Alloc&, _Args...>,
   is_constructible<_Tp, _Args..., const _Alloc&>>::value,
   "construction with an allocator must be possible"
   " if uses_allocator is true");
    };

  template<typename _Tp, typename _Alloc, typename... _Args>
    struct __uses_alloc<false, _Tp, _Alloc, _Args...>
    : __uses_alloc0 { };

  template<typename _Tp, typename _Alloc, typename... _Args>
    using __uses_alloc_t =
      __uses_alloc<uses_allocator<_Tp, _Alloc>::value, _Tp, _Alloc, _Args...>;

  template<typename _Tp, typename _Alloc, typename... _Args>
   
    inline __uses_alloc_t<_Tp, _Alloc, _Args...>
    __use_alloc(const _Alloc& __a)
    {
      __uses_alloc_t<_Tp, _Alloc, _Args...> __ret;
      __ret._M_a = std::__addressof(__a);
      return __ret;
    }

  template<typename _Tp, typename _Alloc, typename... _Args>
    void
    __use_alloc(const _Alloc&&) = delete;







  template<template<typename...> class _Predicate,
    typename _Tp, typename _Alloc, typename... _Args>
    struct __is_uses_allocator_predicate
    : conditional<uses_allocator<_Tp, _Alloc>::value,
      __or_<_Predicate<_Tp, allocator_arg_t, _Alloc, _Args...>,
     _Predicate<_Tp, _Args..., _Alloc>>,
      _Predicate<_Tp, _Args...>>::type { };

  template<typename _Tp, typename _Alloc, typename... _Args>
    struct __is_uses_allocator_constructible
    : __is_uses_allocator_predicate<is_constructible, _Tp, _Alloc, _Args...>
    { };


  template<typename _Tp, typename _Alloc, typename... _Args>
    constexpr bool __is_uses_allocator_constructible_v =
      __is_uses_allocator_constructible<_Tp, _Alloc, _Args...>::value;


  template<typename _Tp, typename _Alloc, typename... _Args>
    struct __is_nothrow_uses_allocator_constructible
    : __is_uses_allocator_predicate<is_nothrow_constructible,
        _Tp, _Alloc, _Args...>
    { };



  template<typename _Tp, typename _Alloc, typename... _Args>
    constexpr bool
    __is_nothrow_uses_allocator_constructible_v =
      __is_nothrow_uses_allocator_constructible<_Tp, _Alloc, _Args...>::value;


  template<typename _Tp, typename... _Args>
    void __uses_allocator_construct_impl(__uses_alloc0 __a, _Tp* __ptr,
      _Args&&... __args)
    { ::new ((void*)__ptr) _Tp(std::forward<_Args>(__args)...); }

  template<typename _Tp, typename _Alloc, typename... _Args>
    void __uses_allocator_construct_impl(__uses_alloc1<_Alloc> __a, _Tp* __ptr,
      _Args&&... __args)
    {
      ::new ((void*)__ptr) _Tp(allocator_arg, *__a._M_a,
          std::forward<_Args>(__args)...);
    }

  template<typename _Tp, typename _Alloc, typename... _Args>
    void __uses_allocator_construct_impl(__uses_alloc2<_Alloc> __a, _Tp* __ptr,
      _Args&&... __args)
    { ::new ((void*)__ptr) _Tp(std::forward<_Args>(__args)..., *__a._M_a); }

  template<typename _Tp, typename _Alloc, typename... _Args>
    void __uses_allocator_construct(const _Alloc& __a, _Tp* __ptr,
        _Args&&... __args)
    {
      std::__uses_allocator_construct_impl(
   std::__use_alloc<_Tp, _Alloc, _Args...>(__a), __ptr,
   std::forward<_Args>(__args)...);
    }


}
# 41 "/usr/include/c++/10/tuple" 2 3
# 1 "/usr/include/c++/10/bits/invoke.h" 1 3
# 33 "/usr/include/c++/10/bits/invoke.h" 3
       
# 34 "/usr/include/c++/10/bits/invoke.h" 3







namespace std __attribute__ ((__visibility__ ("default")))
{

# 52 "/usr/include/c++/10/bits/invoke.h" 3
  template<typename _Tp, typename _Up = typename __inv_unwrap<_Tp>::type>
    constexpr _Up&&
    __invfwd(typename remove_reference<_Tp>::type& __t) noexcept
    { return static_cast<_Up&&>(__t); }

  template<typename _Res, typename _Fn, typename... _Args>
    constexpr _Res
    __invoke_impl(__invoke_other, _Fn&& __f, _Args&&... __args)
    { return std::forward<_Fn>(__f)(std::forward<_Args>(__args)...); }

  template<typename _Res, typename _MemFun, typename _Tp, typename... _Args>
    constexpr _Res
    __invoke_impl(__invoke_memfun_ref, _MemFun&& __f, _Tp&& __t,
    _Args&&... __args)
    { return (__invfwd<_Tp>(__t).*__f)(std::forward<_Args>(__args)...); }

  template<typename _Res, typename _MemFun, typename _Tp, typename... _Args>
    constexpr _Res
    __invoke_impl(__invoke_memfun_deref, _MemFun&& __f, _Tp&& __t,
    _Args&&... __args)
    {
      return ((*std::forward<_Tp>(__t)).*__f)(std::forward<_Args>(__args)...);
    }

  template<typename _Res, typename _MemPtr, typename _Tp>
    constexpr _Res
    __invoke_impl(__invoke_memobj_ref, _MemPtr&& __f, _Tp&& __t)
    { return __invfwd<_Tp>(__t).*__f; }

  template<typename _Res, typename _MemPtr, typename _Tp>
    constexpr _Res
    __invoke_impl(__invoke_memobj_deref, _MemPtr&& __f, _Tp&& __t)
    { return (*std::forward<_Tp>(__t)).*__f; }


  template<typename _Callable, typename... _Args>
    constexpr typename __invoke_result<_Callable, _Args...>::type
    __invoke(_Callable&& __fn, _Args&&... __args)
    noexcept(__is_nothrow_invocable<_Callable, _Args...>::value)
    {
      using __result = __invoke_result<_Callable, _Args...>;
      using __type = typename __result::type;
      using __tag = typename __result::__invoke_type;
      return std::__invoke_impl<__type>(__tag{}, std::forward<_Callable>(__fn),
     std::forward<_Args>(__args)...);
    }
# 118 "/usr/include/c++/10/bits/invoke.h" 3
  template<typename _Res, typename _Callable, typename... _Args>
    using __can_invoke_as_void = __enable_if_t<
      __and_<is_void<_Res>, __is_invocable<_Callable, _Args...>>::value,
      _Res
    >;

  template<typename _Res, typename _Callable, typename... _Args>
    using __can_invoke_as_nonvoid = __enable_if_t<
      __and_<__not_<is_void<_Res>>,
      is_convertible<typename __invoke_result<_Callable, _Args...>::type,
       _Res>
      >::value,
      _Res
    >;


  template<typename _Res, typename _Callable, typename... _Args>
    constexpr __can_invoke_as_nonvoid<_Res, _Callable, _Args...>
    __invoke_r(_Callable&& __fn, _Args&&... __args)
    {
      using __result = __invoke_result<_Callable, _Args...>;
      using __type = typename __result::type;
      using __tag = typename __result::__invoke_type;
      return std::__invoke_impl<__type>(__tag{}, std::forward<_Callable>(__fn),
     std::forward<_Args>(__args)...);
    }


  template<typename _Res, typename _Callable, typename... _Args>
    constexpr __can_invoke_as_void<_Res, _Callable, _Args...>
    __invoke_r(_Callable&& __fn, _Args&&... __args)
    {
      using __result = __invoke_result<_Callable, _Args...>;
      using __type = typename __result::type;
      using __tag = typename __result::__invoke_type;
      std::__invoke_impl<__type>(__tag{}, std::forward<_Callable>(__fn),
     std::forward<_Args>(__args)...);
    }



}
# 42 "/usr/include/c++/10/tuple" 2 3





namespace std __attribute__ ((__visibility__ ("default")))
{







  template<typename... _Elements>
    class tuple;

  template<typename _Tp>
    struct __is_empty_non_tuple : is_empty<_Tp> { };


  template<typename _El0, typename... _El>
    struct __is_empty_non_tuple<tuple<_El0, _El...>> : false_type { };


  template<typename _Tp>
    using __empty_not_final
    = typename conditional<__is_final(_Tp), false_type,
      __is_empty_non_tuple<_Tp>>::type;

  template<std::size_t _Idx, typename _Head,
    bool = __empty_not_final<_Head>::value>
    struct _Head_base;

  template<std::size_t _Idx, typename _Head>
    struct _Head_base<_Idx, _Head, true>
    : public _Head
    {
      constexpr _Head_base()
      : _Head() { }

      constexpr _Head_base(const _Head& __h)
      : _Head(__h) { }

      constexpr _Head_base(const _Head_base&) = default;
      constexpr _Head_base(_Head_base&&) = default;

      template<typename _UHead>
        constexpr _Head_base(_UHead&& __h)
 : _Head(std::forward<_UHead>(__h)) { }

     
      _Head_base(allocator_arg_t, __uses_alloc0)
      : _Head() { }

      template<typename _Alloc>

 _Head_base(allocator_arg_t, __uses_alloc1<_Alloc> __a)
 : _Head(allocator_arg, *__a._M_a) { }

      template<typename _Alloc>

 _Head_base(allocator_arg_t, __uses_alloc2<_Alloc> __a)
 : _Head(*__a._M_a) { }

      template<typename _UHead>

 _Head_base(__uses_alloc0, _UHead&& __uhead)
 : _Head(std::forward<_UHead>(__uhead)) { }

      template<typename _Alloc, typename _UHead>

 _Head_base(__uses_alloc1<_Alloc> __a, _UHead&& __uhead)
 : _Head(allocator_arg, *__a._M_a, std::forward<_UHead>(__uhead)) { }

      template<typename _Alloc, typename _UHead>

 _Head_base(__uses_alloc2<_Alloc> __a, _UHead&& __uhead)
 : _Head(std::forward<_UHead>(__uhead), *__a._M_a) { }

      static constexpr _Head&
      _M_head(_Head_base& __b) noexcept { return __b; }

      static constexpr const _Head&
      _M_head(const _Head_base& __b) noexcept { return __b; }
    };

  template<std::size_t _Idx, typename _Head>
    struct _Head_base<_Idx, _Head, false>
    {
      constexpr _Head_base()
      : _M_head_impl() { }

      constexpr _Head_base(const _Head& __h)
      : _M_head_impl(__h) { }

      constexpr _Head_base(const _Head_base&) = default;
      constexpr _Head_base(_Head_base&&) = default;

      template<typename _UHead>
        constexpr _Head_base(_UHead&& __h)
 : _M_head_impl(std::forward<_UHead>(__h)) { }

     
      _Head_base(allocator_arg_t, __uses_alloc0)
      : _M_head_impl() { }

      template<typename _Alloc>

 _Head_base(allocator_arg_t, __uses_alloc1<_Alloc> __a)
 : _M_head_impl(allocator_arg, *__a._M_a) { }

      template<typename _Alloc>

 _Head_base(allocator_arg_t, __uses_alloc2<_Alloc> __a)
 : _M_head_impl(*__a._M_a) { }

      template<typename _UHead>

 _Head_base(__uses_alloc0, _UHead&& __uhead)
 : _M_head_impl(std::forward<_UHead>(__uhead)) { }

      template<typename _Alloc, typename _UHead>

 _Head_base(__uses_alloc1<_Alloc> __a, _UHead&& __uhead)
 : _M_head_impl(allocator_arg, *__a._M_a, std::forward<_UHead>(__uhead))
 { }

      template<typename _Alloc, typename _UHead>

 _Head_base(__uses_alloc2<_Alloc> __a, _UHead&& __uhead)
 : _M_head_impl(std::forward<_UHead>(__uhead), *__a._M_a) { }

      static constexpr _Head&
      _M_head(_Head_base& __b) noexcept { return __b._M_head_impl; }

      static constexpr const _Head&
      _M_head(const _Head_base& __b) noexcept { return __b._M_head_impl; }

      _Head _M_head_impl;
    };
# 192 "/usr/include/c++/10/tuple" 3
  template<std::size_t _Idx, typename... _Elements>
    struct _Tuple_impl;






  template<std::size_t _Idx, typename _Head, typename... _Tail>
    struct _Tuple_impl<_Idx, _Head, _Tail...>
    : public _Tuple_impl<_Idx + 1, _Tail...>,
      private _Head_base<_Idx, _Head>
    {
      template<std::size_t, typename...> friend class _Tuple_impl;

      typedef _Tuple_impl<_Idx + 1, _Tail...> _Inherited;
      typedef _Head_base<_Idx, _Head> _Base;

      static constexpr _Head&
      _M_head(_Tuple_impl& __t) noexcept { return _Base::_M_head(__t); }

      static constexpr const _Head&
      _M_head(const _Tuple_impl& __t) noexcept { return _Base::_M_head(__t); }

      static constexpr _Inherited&
      _M_tail(_Tuple_impl& __t) noexcept { return __t; }

      static constexpr const _Inherited&
      _M_tail(const _Tuple_impl& __t) noexcept { return __t; }

      constexpr _Tuple_impl()
      : _Inherited(), _Base() { }

      explicit
      constexpr _Tuple_impl(const _Head& __head, const _Tail&... __tail)
      : _Inherited(__tail...), _Base(__head) { }

      template<typename _UHead, typename... _UTail, typename = typename
               enable_if<sizeof...(_Tail) == sizeof...(_UTail)>::type>
        explicit
        constexpr _Tuple_impl(_UHead&& __head, _UTail&&... __tail)
 : _Inherited(std::forward<_UTail>(__tail)...),
   _Base(std::forward<_UHead>(__head)) { }

      constexpr _Tuple_impl(const _Tuple_impl&) = default;



      _Tuple_impl& operator=(const _Tuple_impl&) = delete;

      constexpr
      _Tuple_impl(_Tuple_impl&& __in)
      noexcept(__and_<is_nothrow_move_constructible<_Head>,
               is_nothrow_move_constructible<_Inherited>>::value)
      : _Inherited(std::move(_M_tail(__in))),
 _Base(std::forward<_Head>(_M_head(__in))) { }

      template<typename... _UElements>
        constexpr _Tuple_impl(const _Tuple_impl<_Idx, _UElements...>& __in)
 : _Inherited(_Tuple_impl<_Idx, _UElements...>::_M_tail(__in)),
   _Base(_Tuple_impl<_Idx, _UElements...>::_M_head(__in)) { }

      template<typename _UHead, typename... _UTails>
        constexpr _Tuple_impl(_Tuple_impl<_Idx, _UHead, _UTails...>&& __in)
 : _Inherited(std::move
       (_Tuple_impl<_Idx, _UHead, _UTails...>::_M_tail(__in))),
   _Base(std::forward<_UHead>
  (_Tuple_impl<_Idx, _UHead, _UTails...>::_M_head(__in))) { }

      template<typename _Alloc>

 _Tuple_impl(allocator_arg_t __tag, const _Alloc& __a)
 : _Inherited(__tag, __a),
          _Base(__tag, __use_alloc<_Head>(__a)) { }

      template<typename _Alloc>

 _Tuple_impl(allocator_arg_t __tag, const _Alloc& __a,
      const _Head& __head, const _Tail&... __tail)
 : _Inherited(__tag, __a, __tail...),
          _Base(__use_alloc<_Head, _Alloc, _Head>(__a), __head) { }

      template<typename _Alloc, typename _UHead, typename... _UTail,
               typename = typename enable_if<sizeof...(_Tail)
          == sizeof...(_UTail)>::type>

 _Tuple_impl(allocator_arg_t __tag, const _Alloc& __a,
             _UHead&& __head, _UTail&&... __tail)
 : _Inherited(__tag, __a, std::forward<_UTail>(__tail)...),
          _Base(__use_alloc<_Head, _Alloc, _UHead>(__a),
         std::forward<_UHead>(__head)) { }

      template<typename _Alloc>

        _Tuple_impl(allocator_arg_t __tag, const _Alloc& __a,
             const _Tuple_impl& __in)
 : _Inherited(__tag, __a, _M_tail(__in)),
          _Base(__use_alloc<_Head, _Alloc, _Head>(__a), _M_head(__in)) { }

      template<typename _Alloc>

 _Tuple_impl(allocator_arg_t __tag, const _Alloc& __a,
             _Tuple_impl&& __in)
 : _Inherited(__tag, __a, std::move(_M_tail(__in))),
   _Base(__use_alloc<_Head, _Alloc, _Head>(__a),
         std::forward<_Head>(_M_head(__in))) { }

      template<typename _Alloc, typename _UHead, typename... _UTails>

 _Tuple_impl(allocator_arg_t __tag, const _Alloc& __a,
      const _Tuple_impl<_Idx, _UHead, _UTails...>& __in)
 : _Inherited(__tag, __a,
       _Tuple_impl<_Idx, _UHead, _UTails...>::_M_tail(__in)),
   _Base(__use_alloc<_Head, _Alloc, const _UHead&>(__a),
  _Tuple_impl<_Idx, _UHead, _UTails...>::_M_head(__in)) { }

      template<typename _Alloc, typename _UHead, typename... _UTails>

 _Tuple_impl(allocator_arg_t __tag, const _Alloc& __a,
             _Tuple_impl<_Idx, _UHead, _UTails...>&& __in)
 : _Inherited(__tag, __a, std::move
       (_Tuple_impl<_Idx, _UHead, _UTails...>::_M_tail(__in))),
   _Base(__use_alloc<_Head, _Alloc, _UHead>(__a),
                std::forward<_UHead>
  (_Tuple_impl<_Idx, _UHead, _UTails...>::_M_head(__in))) { }

      template<typename... _UElements>

        void
        _M_assign(const _Tuple_impl<_Idx, _UElements...>& __in)
        {
   _M_head(*this) = _Tuple_impl<_Idx, _UElements...>::_M_head(__in);
   _M_tail(*this)._M_assign(
       _Tuple_impl<_Idx, _UElements...>::_M_tail(__in));
 }

      template<typename _UHead, typename... _UTails>

        void
        _M_assign(_Tuple_impl<_Idx, _UHead, _UTails...>&& __in)
        {
   _M_head(*this) = std::forward<_UHead>
     (_Tuple_impl<_Idx, _UHead, _UTails...>::_M_head(__in));
   _M_tail(*this)._M_assign(
       std::move(_Tuple_impl<_Idx, _UHead, _UTails...>::_M_tail(__in)));
 }

    protected:
     
      void
      _M_swap(_Tuple_impl& __in)
      {
 using std::swap;
 swap(_M_head(*this), _M_head(__in));
 _Inherited::_M_swap(_M_tail(__in));
      }
    };


  template<std::size_t _Idx, typename _Head>
    struct _Tuple_impl<_Idx, _Head>
    : private _Head_base<_Idx, _Head>
    {
      template<std::size_t, typename...> friend class _Tuple_impl;

      typedef _Head_base<_Idx, _Head> _Base;

      static constexpr _Head&
      _M_head(_Tuple_impl& __t) noexcept { return _Base::_M_head(__t); }

      static constexpr const _Head&
      _M_head(const _Tuple_impl& __t) noexcept { return _Base::_M_head(__t); }

      constexpr _Tuple_impl()
      : _Base() { }

      explicit
      constexpr _Tuple_impl(const _Head& __head)
      : _Base(__head) { }

      template<typename _UHead>
        explicit
        constexpr _Tuple_impl(_UHead&& __head)
 : _Base(std::forward<_UHead>(__head)) { }

      constexpr _Tuple_impl(const _Tuple_impl&) = default;



      _Tuple_impl& operator=(const _Tuple_impl&) = delete;

      constexpr
      _Tuple_impl(_Tuple_impl&& __in)
      noexcept(is_nothrow_move_constructible<_Head>::value)
      : _Base(std::forward<_Head>(_M_head(__in))) { }

      template<typename _UHead>
        constexpr _Tuple_impl(const _Tuple_impl<_Idx, _UHead>& __in)
 : _Base(_Tuple_impl<_Idx, _UHead>::_M_head(__in)) { }

      template<typename _UHead>
        constexpr _Tuple_impl(_Tuple_impl<_Idx, _UHead>&& __in)
 : _Base(std::forward<_UHead>(_Tuple_impl<_Idx, _UHead>::_M_head(__in)))
 { }

      template<typename _Alloc>

 _Tuple_impl(allocator_arg_t __tag, const _Alloc& __a)
 : _Base(__tag, __use_alloc<_Head>(__a)) { }

      template<typename _Alloc>

 _Tuple_impl(allocator_arg_t __tag, const _Alloc& __a,
      const _Head& __head)
 : _Base(__use_alloc<_Head, _Alloc, _Head>(__a), __head) { }

      template<typename _Alloc, typename _UHead>

 _Tuple_impl(allocator_arg_t __tag, const _Alloc& __a,
             _UHead&& __head)
 : _Base(__use_alloc<_Head, _Alloc, _UHead>(__a),
         std::forward<_UHead>(__head)) { }

      template<typename _Alloc>

        _Tuple_impl(allocator_arg_t __tag, const _Alloc& __a,
             const _Tuple_impl& __in)
 : _Base(__use_alloc<_Head, _Alloc, _Head>(__a), _M_head(__in)) { }

      template<typename _Alloc>

 _Tuple_impl(allocator_arg_t __tag, const _Alloc& __a,
             _Tuple_impl&& __in)
 : _Base(__use_alloc<_Head, _Alloc, _Head>(__a),
         std::forward<_Head>(_M_head(__in))) { }

      template<typename _Alloc, typename _UHead>

 _Tuple_impl(allocator_arg_t __tag, const _Alloc& __a,
             const _Tuple_impl<_Idx, _UHead>& __in)
 : _Base(__use_alloc<_Head, _Alloc, const _UHead&>(__a),
  _Tuple_impl<_Idx, _UHead>::_M_head(__in)) { }

      template<typename _Alloc, typename _UHead>

 _Tuple_impl(allocator_arg_t __tag, const _Alloc& __a,
             _Tuple_impl<_Idx, _UHead>&& __in)
 : _Base(__use_alloc<_Head, _Alloc, _UHead>(__a),
                std::forward<_UHead>(_Tuple_impl<_Idx, _UHead>::_M_head(__in)))
 { }

      template<typename _UHead>

        void
        _M_assign(const _Tuple_impl<_Idx, _UHead>& __in)
        {
   _M_head(*this) = _Tuple_impl<_Idx, _UHead>::_M_head(__in);
 }

      template<typename _UHead>

        void
        _M_assign(_Tuple_impl<_Idx, _UHead>&& __in)
        {
   _M_head(*this)
     = std::forward<_UHead>(_Tuple_impl<_Idx, _UHead>::_M_head(__in));
 }

    protected:
     
      void
      _M_swap(_Tuple_impl& __in)
      {
 using std::swap;
 swap(_M_head(*this), _M_head(__in));
      }
    };



  template<bool, typename... _Types>
    struct _TupleConstraints
    {
      template<typename _Tp, typename _Up>
 using is_constructible
   = __bool_constant<__is_constructible(_Tp, _Up)>;




      template<typename... _UTypes>
 static constexpr bool __is_implicitly_constructible()
 {
   return __and_<is_constructible<_Types, _UTypes>...,
   is_convertible<_UTypes, _Types>...
   >::value;
 }




      template<typename... _UTypes>
 static constexpr bool __is_explicitly_constructible()
 {
   return __and_<is_constructible<_Types, _UTypes>...,
   __not_<__and_<is_convertible<_UTypes, _Types>...>>
   >::value;
 }

      static constexpr bool __is_implicitly_default_constructible()
      {
 return __and_<std::__is_implicitly_default_constructible<_Types>...
        >::value;
      }

      static constexpr bool __is_explicitly_default_constructible()
      {
 return __and_<is_default_constructible<_Types>...,
        __not_<__and_<
   std::__is_implicitly_default_constructible<_Types>...>
        >>::value;
      }
    };



  template<typename... _Types>
    struct _TupleConstraints<false, _Types...>
    {
      template<typename... _UTypes>
 static constexpr bool __is_implicitly_constructible()
 { return false; }

      template<typename... _UTypes>
 static constexpr bool __is_explicitly_constructible()
 { return false; }
    };


  template<typename... _Elements>
    class tuple : public _Tuple_impl<0, _Elements...>
    {
      typedef _Tuple_impl<0, _Elements...> _Inherited;

      template<bool _Cond>
 using _TCC = _TupleConstraints<_Cond, _Elements...>;


      template<bool _Dummy>
 using _ImplicitDefaultCtor = __enable_if_t<
   _TCC<_Dummy>::__is_implicitly_default_constructible(),
   bool>;


      template<bool _Dummy>
 using _ExplicitDefaultCtor = __enable_if_t<
   _TCC<_Dummy>::__is_explicitly_default_constructible(),
   bool>;


      template<bool _Cond, typename... _Args>
 using _ImplicitCtor = __enable_if_t<
   _TCC<_Cond>::template __is_implicitly_constructible<_Args...>(),
   bool>;


      template<bool _Cond, typename... _Args>
 using _ExplicitCtor = __enable_if_t<
   _TCC<_Cond>::template __is_explicitly_constructible<_Args...>(),
   bool>;

      template<typename... _UElements>
 static constexpr
 __enable_if_t<sizeof...(_UElements) == sizeof...(_Elements), bool>
 __assignable()
 { return __and_<is_assignable<_Elements&, _UElements>...>::value; }


      template<typename... _UElements>
 static constexpr bool __nothrow_assignable()
 {
   return
     __and_<is_nothrow_assignable<_Elements&, _UElements>...>::value;
 }


      template<typename... _UElements>
 static constexpr bool __nothrow_constructible()
 {
   return
     __and_<is_nothrow_constructible<_Elements, _UElements>...>::value;
 }


      template<typename _Up>
 static constexpr bool __valid_args()
 {
   return sizeof...(_Elements) == 1
     && !is_same<tuple, __remove_cvref_t<_Up>>::value;
 }


      template<typename, typename, typename... _Tail>
 static constexpr bool __valid_args()
 { return (sizeof...(_Tail) + 2) == sizeof...(_Elements); }
# 607 "/usr/include/c++/10/tuple" 3
      template<typename _Tuple, typename = tuple,
        typename = __remove_cvref_t<_Tuple>>
 struct _UseOtherCtor
 : false_type
 { };


      template<typename _Tuple, typename _Tp, typename _Up>
 struct _UseOtherCtor<_Tuple, tuple<_Tp>, tuple<_Up>>
 : __or_<is_convertible<_Tuple, _Tp>, is_constructible<_Tp, _Tuple>>
 { };


      template<typename _Tuple, typename _Tp>
 struct _UseOtherCtor<_Tuple, tuple<_Tp>, tuple<_Tp>>
 : true_type
 { };




      template<typename _Tuple>
 static constexpr bool __use_other_ctor()
 { return _UseOtherCtor<_Tuple>::value; }

    public:
      template<typename _Dummy = void,
        _ImplicitDefaultCtor<is_void<_Dummy>::value> = true>
 constexpr
 tuple()
 noexcept(__and_<is_nothrow_default_constructible<_Elements>...>::value)
 : _Inherited() { }

      template<typename _Dummy = void,
        _ExplicitDefaultCtor<is_void<_Dummy>::value> = false>
 explicit constexpr
 tuple()
 noexcept(__and_<is_nothrow_default_constructible<_Elements>...>::value)
 : _Inherited() { }

      template<bool _NotEmpty = (sizeof...(_Elements) >= 1),
        _ImplicitCtor<_NotEmpty, const _Elements&...> = true>
 constexpr
 tuple(const _Elements&... __elements)
 noexcept(__nothrow_constructible<const _Elements&...>())
 : _Inherited(__elements...) { }

      template<bool _NotEmpty = (sizeof...(_Elements) >= 1),
        _ExplicitCtor<_NotEmpty, const _Elements&...> = false>
 explicit constexpr
 tuple(const _Elements&... __elements)
 noexcept(__nothrow_constructible<const _Elements&...>())
 : _Inherited(__elements...) { }

      template<typename... _UElements,
        bool _Valid = __valid_args<_UElements...>(),
        _ImplicitCtor<_Valid, _UElements...> = true>
 constexpr
 tuple(_UElements&&... __elements)
 noexcept(__nothrow_constructible<_UElements...>())
 : _Inherited(std::forward<_UElements>(__elements)...) { }

      template<typename... _UElements,
        bool _Valid = __valid_args<_UElements...>(),
        _ExplicitCtor<_Valid, _UElements...> = false>
 explicit constexpr
 tuple(_UElements&&... __elements)
 noexcept(__nothrow_constructible<_UElements...>())
 : _Inherited(std::forward<_UElements>(__elements)...) { }

      constexpr tuple(const tuple&) = default;

      constexpr tuple(tuple&&) = default;

      template<typename... _UElements,
        bool _Valid = (sizeof...(_Elements) == sizeof...(_UElements))
      && !__use_other_ctor<const tuple<_UElements...>&>(),
        _ImplicitCtor<_Valid, const _UElements&...> = true>
 constexpr
 tuple(const tuple<_UElements...>& __in)
 noexcept(__nothrow_constructible<const _UElements&...>())
 : _Inherited(static_cast<const _Tuple_impl<0, _UElements...>&>(__in))
 { }

      template<typename... _UElements,
        bool _Valid = (sizeof...(_Elements) == sizeof...(_UElements))
      && !__use_other_ctor<const tuple<_UElements...>&>(),
        _ExplicitCtor<_Valid, const _UElements&...> = false>
 explicit constexpr
 tuple(const tuple<_UElements...>& __in)
 noexcept(__nothrow_constructible<const _UElements&...>())
 : _Inherited(static_cast<const _Tuple_impl<0, _UElements...>&>(__in))
 { }

      template<typename... _UElements,
        bool _Valid = (sizeof...(_Elements) == sizeof...(_UElements))
        && !__use_other_ctor<tuple<_UElements...>&&>(),
        _ImplicitCtor<_Valid, _UElements...> = true>
 constexpr
 tuple(tuple<_UElements...>&& __in)
 noexcept(__nothrow_constructible<_UElements...>())
 : _Inherited(static_cast<_Tuple_impl<0, _UElements...>&&>(__in)) { }

      template<typename... _UElements,
        bool _Valid = (sizeof...(_Elements) == sizeof...(_UElements))
        && !__use_other_ctor<tuple<_UElements...>&&>(),
        _ExplicitCtor<_Valid, _UElements...> = false>
 explicit constexpr
 tuple(tuple<_UElements...>&& __in)
 noexcept(__nothrow_constructible<_UElements...>())
 : _Inherited(static_cast<_Tuple_impl<0, _UElements...>&&>(__in)) { }



      template<typename _Alloc,
        _ImplicitDefaultCtor<is_object<_Alloc>::value> = true>

 tuple(allocator_arg_t __tag, const _Alloc& __a)
 : _Inherited(__tag, __a) { }

      template<typename _Alloc, bool _NotEmpty = (sizeof...(_Elements) >= 1),
        _ImplicitCtor<_NotEmpty, const _Elements&...> = true>

 tuple(allocator_arg_t __tag, const _Alloc& __a,
       const _Elements&... __elements)
 : _Inherited(__tag, __a, __elements...) { }

      template<typename _Alloc, bool _NotEmpty = (sizeof...(_Elements) >= 1),
        _ExplicitCtor<_NotEmpty, const _Elements&...> = false>

 explicit
 tuple(allocator_arg_t __tag, const _Alloc& __a,
       const _Elements&... __elements)
 : _Inherited(__tag, __a, __elements...) { }

      template<typename _Alloc, typename... _UElements,
        bool _Valid = __valid_args<_UElements...>(),
        _ImplicitCtor<_Valid, _UElements...> = true>

 tuple(allocator_arg_t __tag, const _Alloc& __a,
       _UElements&&... __elements)
 : _Inherited(__tag, __a, std::forward<_UElements>(__elements)...)
 { }

      template<typename _Alloc, typename... _UElements,
   bool _Valid = __valid_args<_UElements...>(),
        _ExplicitCtor<_Valid, _UElements...> = false>

 explicit
 tuple(allocator_arg_t __tag, const _Alloc& __a,
       _UElements&&... __elements)
 : _Inherited(__tag, __a, std::forward<_UElements>(__elements)...)
 { }

      template<typename _Alloc>

 tuple(allocator_arg_t __tag, const _Alloc& __a, const tuple& __in)
 : _Inherited(__tag, __a, static_cast<const _Inherited&>(__in)) { }

      template<typename _Alloc>

 tuple(allocator_arg_t __tag, const _Alloc& __a, tuple&& __in)
 : _Inherited(__tag, __a, static_cast<_Inherited&&>(__in)) { }

      template<typename _Alloc, typename... _UElements,
        bool _Valid = (sizeof...(_Elements) == sizeof...(_UElements))
        && !__use_other_ctor<const tuple<_UElements...>&>(),
        _ImplicitCtor<_Valid, const _UElements&...> = true>

 tuple(allocator_arg_t __tag, const _Alloc& __a,
       const tuple<_UElements...>& __in)
 : _Inherited(__tag, __a,
              static_cast<const _Tuple_impl<0, _UElements...>&>(__in))
 { }

      template<typename _Alloc, typename... _UElements,
        bool _Valid = (sizeof...(_Elements) == sizeof...(_UElements))
        && !__use_other_ctor<const tuple<_UElements...>&>(),
        _ExplicitCtor<_Valid, const _UElements&...> = false>

 explicit
 tuple(allocator_arg_t __tag, const _Alloc& __a,
       const tuple<_UElements...>& __in)
 : _Inherited(__tag, __a,
              static_cast<const _Tuple_impl<0, _UElements...>&>(__in))
 { }

      template<typename _Alloc, typename... _UElements,
        bool _Valid = (sizeof...(_Elements) == sizeof...(_UElements))
        && !__use_other_ctor<tuple<_UElements...>&&>(),
        _ImplicitCtor<_Valid, _UElements...> = true>

 tuple(allocator_arg_t __tag, const _Alloc& __a,
       tuple<_UElements...>&& __in)
 : _Inherited(__tag, __a,
              static_cast<_Tuple_impl<0, _UElements...>&&>(__in))
 { }

      template<typename _Alloc, typename... _UElements,
        bool _Valid = (sizeof...(_Elements) == sizeof...(_UElements))
        && !__use_other_ctor<tuple<_UElements...>&&>(),
        _ExplicitCtor<_Valid, _UElements...> = false>

 explicit
 tuple(allocator_arg_t __tag, const _Alloc& __a,
       tuple<_UElements...>&& __in)
 : _Inherited(__tag, __a,
              static_cast<_Tuple_impl<0, _UElements...>&&>(__in))
 { }



     
      tuple&
      operator=(typename conditional<__assignable<const _Elements&...>(),
         const tuple&,
         const __nonesuch&>::type __in)
      noexcept(__nothrow_assignable<const _Elements&...>())
      {
 this->_M_assign(__in);
 return *this;
      }

     
      tuple&
      operator=(typename conditional<__assignable<_Elements...>(),
         tuple&&,
         __nonesuch&&>::type __in)
      noexcept(__nothrow_assignable<_Elements...>())
      {
 this->_M_assign(std::move(__in));
 return *this;
      }

      template<typename... _UElements>

 __enable_if_t<__assignable<const _UElements&...>(), tuple&>
 operator=(const tuple<_UElements...>& __in)
 noexcept(__nothrow_assignable<const _UElements&...>())
 {
   this->_M_assign(__in);
   return *this;
 }

      template<typename... _UElements>

 __enable_if_t<__assignable<_UElements...>(), tuple&>
 operator=(tuple<_UElements...>&& __in)
 noexcept(__nothrow_assignable<_UElements...>())
 {
   this->_M_assign(std::move(__in));
   return *this;
 }


     
      void
      swap(tuple& __in)
      noexcept(__and_<__is_nothrow_swappable<_Elements>...>::value)
      { _Inherited::_M_swap(__in); }
    };
# 883 "/usr/include/c++/10/tuple" 3
  template<>
    class tuple<>
    {
    public:
     
      void swap(tuple&) noexcept { }


      tuple() = default;

      template<typename _Alloc>

 tuple(allocator_arg_t, const _Alloc&) noexcept { }
      template<typename _Alloc>

 tuple(allocator_arg_t, const _Alloc&, const tuple&) noexcept { }
    };



  template<typename _T1, typename _T2>
    class tuple<_T1, _T2> : public _Tuple_impl<0, _T1, _T2>
    {
      typedef _Tuple_impl<0, _T1, _T2> _Inherited;


      template<bool _Dummy, typename _U1, typename _U2>
 using _ImplicitDefaultCtor = __enable_if_t<
   _TupleConstraints<_Dummy, _U1, _U2>::
     __is_implicitly_default_constructible(),
   bool>;


      template<bool _Dummy, typename _U1, typename _U2>
 using _ExplicitDefaultCtor = __enable_if_t<
   _TupleConstraints<_Dummy, _U1, _U2>::
     __is_explicitly_default_constructible(),
   bool>;

      template<bool _Dummy>
 using _TCC = _TupleConstraints<_Dummy, _T1, _T2>;


      template<bool _Cond, typename _U1, typename _U2>
 using _ImplicitCtor = __enable_if_t<
   _TCC<_Cond>::template __is_implicitly_constructible<_U1, _U2>(),
   bool>;


      template<bool _Cond, typename _U1, typename _U2>
 using _ExplicitCtor = __enable_if_t<
   _TCC<_Cond>::template __is_explicitly_constructible<_U1, _U2>(),
   bool>;

      template<typename _U1, typename _U2>
 static constexpr bool __assignable()
 {
   return __and_<is_assignable<_T1&, _U1>,
   is_assignable<_T2&, _U2>>::value;
 }

      template<typename _U1, typename _U2>
 static constexpr bool __nothrow_assignable()
 {
   return __and_<is_nothrow_assignable<_T1&, _U1>,
   is_nothrow_assignable<_T2&, _U2>>::value;
 }

      template<typename _U1, typename _U2>
 static constexpr bool __nothrow_constructible()
 {
   return __and_<is_nothrow_constructible<_T1, _U1>,
       is_nothrow_constructible<_T2, _U2>>::value;
 }

      static constexpr bool __nothrow_default_constructible()
      {
 return __and_<is_nothrow_default_constructible<_T1>,
        is_nothrow_default_constructible<_T2>>::value;
      }

      template<typename _U1>
 static constexpr bool __is_alloc_arg()
 { return is_same<__remove_cvref_t<_U1>, allocator_arg_t>::value; }

    public:
      template<bool _Dummy = true,
        _ImplicitDefaultCtor<_Dummy, _T1, _T2> = true>
 constexpr
 tuple()
 noexcept(__nothrow_default_constructible())
 : _Inherited() { }

      template<bool _Dummy = true,
        _ExplicitDefaultCtor<_Dummy, _T1, _T2> = false>
 explicit constexpr
 tuple()
 noexcept(__nothrow_default_constructible())
 : _Inherited() { }

      template<bool _Dummy = true,
        _ImplicitCtor<_Dummy, const _T1&, const _T2&> = true>
 constexpr
 tuple(const _T1& __a1, const _T2& __a2)
 noexcept(__nothrow_constructible<const _T1&, const _T2&>())
 : _Inherited(__a1, __a2) { }

      template<bool _Dummy = true,
        _ExplicitCtor<_Dummy, const _T1&, const _T2&> = false>
 explicit constexpr
 tuple(const _T1& __a1, const _T2& __a2)
 noexcept(__nothrow_constructible<const _T1&, const _T2&>())
 : _Inherited(__a1, __a2) { }

      template<typename _U1, typename _U2,
        _ImplicitCtor<!__is_alloc_arg<_U1>(), _U1, _U2> = true>
 constexpr
 tuple(_U1&& __a1, _U2&& __a2)
 noexcept(__nothrow_constructible<_U1, _U2>())
 : _Inherited(std::forward<_U1>(__a1), std::forward<_U2>(__a2)) { }

      template<typename _U1, typename _U2,
        _ExplicitCtor<!__is_alloc_arg<_U1>(), _U1, _U2> = false>
 explicit constexpr
 tuple(_U1&& __a1, _U2&& __a2)
 noexcept(__nothrow_constructible<_U1, _U2>())
 : _Inherited(std::forward<_U1>(__a1), std::forward<_U2>(__a2)) { }

      constexpr tuple(const tuple&) = default;

      constexpr tuple(tuple&&) = default;

      template<typename _U1, typename _U2,
        _ImplicitCtor<true, const _U1&, const _U2&> = true>
 constexpr
 tuple(const tuple<_U1, _U2>& __in)
 noexcept(__nothrow_constructible<const _U1&, const _U2&>())
 : _Inherited(static_cast<const _Tuple_impl<0, _U1, _U2>&>(__in)) { }

      template<typename _U1, typename _U2,
        _ExplicitCtor<true, const _U1&, const _U2&> = false>
 explicit constexpr
 tuple(const tuple<_U1, _U2>& __in)
 noexcept(__nothrow_constructible<const _U1&, const _U2&>())
 : _Inherited(static_cast<const _Tuple_impl<0, _U1, _U2>&>(__in)) { }

      template<typename _U1, typename _U2,
        _ImplicitCtor<true, _U1, _U2> = true>
 constexpr
 tuple(tuple<_U1, _U2>&& __in)
 noexcept(__nothrow_constructible<_U1, _U2>())
 : _Inherited(static_cast<_Tuple_impl<0, _U1, _U2>&&>(__in)) { }

      template<typename _U1, typename _U2,
        _ExplicitCtor<true, _U1, _U2> = false>
 explicit constexpr
 tuple(tuple<_U1, _U2>&& __in)
 noexcept(__nothrow_constructible<_U1, _U2>())
 : _Inherited(static_cast<_Tuple_impl<0, _U1, _U2>&&>(__in)) { }

      template<typename _U1, typename _U2,
        _ImplicitCtor<true, const _U1&, const _U2&> = true>
 constexpr
 tuple(const pair<_U1, _U2>& __in)
 noexcept(__nothrow_constructible<const _U1&, const _U2&>())
 : _Inherited(__in.first, __in.second) { }

      template<typename _U1, typename _U2,
        _ExplicitCtor<true, const _U1&, const _U2&> = false>
 explicit constexpr
 tuple(const pair<_U1, _U2>& __in)
 noexcept(__nothrow_constructible<const _U1&, const _U2&>())
 : _Inherited(__in.first, __in.second) { }

      template<typename _U1, typename _U2,
        _ImplicitCtor<true, _U1, _U2> = true>
 constexpr
 tuple(pair<_U1, _U2>&& __in)
 noexcept(__nothrow_constructible<_U1, _U2>())
 : _Inherited(std::forward<_U1>(__in.first),
       std::forward<_U2>(__in.second)) { }

      template<typename _U1, typename _U2,
        _ExplicitCtor<true, _U1, _U2> = false>
 explicit constexpr
 tuple(pair<_U1, _U2>&& __in)
 noexcept(__nothrow_constructible<_U1, _U2>())
 : _Inherited(std::forward<_U1>(__in.first),
       std::forward<_U2>(__in.second)) { }



      template<typename _Alloc,
        _ImplicitDefaultCtor<is_object<_Alloc>::value, _T1, _T2> = true>

 tuple(allocator_arg_t __tag, const _Alloc& __a)
 : _Inherited(__tag, __a) { }

      template<typename _Alloc, bool _Dummy = true,
        _ImplicitCtor<_Dummy, const _T1&, const _T2&> = true>

 tuple(allocator_arg_t __tag, const _Alloc& __a,
       const _T1& __a1, const _T2& __a2)
 : _Inherited(__tag, __a, __a1, __a2) { }

      template<typename _Alloc, bool _Dummy = true,
        _ExplicitCtor<_Dummy, const _T1&, const _T2&> = false>
 explicit

 tuple(allocator_arg_t __tag, const _Alloc& __a,
       const _T1& __a1, const _T2& __a2)
 : _Inherited(__tag, __a, __a1, __a2) { }

      template<typename _Alloc, typename _U1, typename _U2,
        _ImplicitCtor<true, _U1, _U2> = true>

 tuple(allocator_arg_t __tag, const _Alloc& __a, _U1&& __a1, _U2&& __a2)
 : _Inherited(__tag, __a, std::forward<_U1>(__a1),
              std::forward<_U2>(__a2)) { }

      template<typename _Alloc, typename _U1, typename _U2,
        _ExplicitCtor<true, _U1, _U2> = false>
 explicit

 tuple(allocator_arg_t __tag, const _Alloc& __a,
       _U1&& __a1, _U2&& __a2)
 : _Inherited(__tag, __a, std::forward<_U1>(__a1),
              std::forward<_U2>(__a2)) { }

      template<typename _Alloc>

 tuple(allocator_arg_t __tag, const _Alloc& __a, const tuple& __in)
 : _Inherited(__tag, __a, static_cast<const _Inherited&>(__in)) { }

      template<typename _Alloc>

 tuple(allocator_arg_t __tag, const _Alloc& __a, tuple&& __in)
 : _Inherited(__tag, __a, static_cast<_Inherited&&>(__in)) { }

      template<typename _Alloc, typename _U1, typename _U2,
        _ImplicitCtor<true, const _U1&, const _U2&> = true>

 tuple(allocator_arg_t __tag, const _Alloc& __a,
       const tuple<_U1, _U2>& __in)
 : _Inherited(__tag, __a,
              static_cast<const _Tuple_impl<0, _U1, _U2>&>(__in))
 { }

      template<typename _Alloc, typename _U1, typename _U2,
        _ExplicitCtor<true, const _U1&, const _U2&> = false>
 explicit

 tuple(allocator_arg_t __tag, const _Alloc& __a,
       const tuple<_U1, _U2>& __in)
 : _Inherited(__tag, __a,
              static_cast<const _Tuple_impl<0, _U1, _U2>&>(__in))
 { }

      template<typename _Alloc, typename _U1, typename _U2,
        _ImplicitCtor<true, _U1, _U2> = true>

 tuple(allocator_arg_t __tag, const _Alloc& __a, tuple<_U1, _U2>&& __in)
 : _Inherited(__tag, __a, static_cast<_Tuple_impl<0, _U1, _U2>&&>(__in))
 { }

      template<typename _Alloc, typename _U1, typename _U2,
        _ExplicitCtor<true, _U1, _U2> = false>
 explicit

 tuple(allocator_arg_t __tag, const _Alloc& __a, tuple<_U1, _U2>&& __in)
 : _Inherited(__tag, __a, static_cast<_Tuple_impl<0, _U1, _U2>&&>(__in))
 { }

      template<typename _Alloc, typename _U1, typename _U2,
        _ImplicitCtor<true, const _U1&, const _U2&> = true>

 tuple(allocator_arg_t __tag, const _Alloc& __a,
       const pair<_U1, _U2>& __in)
 : _Inherited(__tag, __a, __in.first, __in.second) { }

      template<typename _Alloc, typename _U1, typename _U2,
        _ExplicitCtor<true, const _U1&, const _U2&> = false>
 explicit

 tuple(allocator_arg_t __tag, const _Alloc& __a,
       const pair<_U1, _U2>& __in)
 : _Inherited(__tag, __a, __in.first, __in.second) { }

      template<typename _Alloc, typename _U1, typename _U2,
        _ImplicitCtor<true, _U1, _U2> = true>

 tuple(allocator_arg_t __tag, const _Alloc& __a, pair<_U1, _U2>&& __in)
 : _Inherited(__tag, __a, std::forward<_U1>(__in.first),
       std::forward<_U2>(__in.second)) { }

      template<typename _Alloc, typename _U1, typename _U2,
        _ExplicitCtor<true, _U1, _U2> = false>
 explicit

 tuple(allocator_arg_t __tag, const _Alloc& __a, pair<_U1, _U2>&& __in)
 : _Inherited(__tag, __a, std::forward<_U1>(__in.first),
       std::forward<_U2>(__in.second)) { }



     
      tuple&
      operator=(typename conditional<__assignable<const _T1&, const _T2&>(),
         const tuple&,
         const __nonesuch&>::type __in)
      noexcept(__nothrow_assignable<const _T1&, const _T2&>())
      {
 this->_M_assign(__in);
 return *this;
      }

     
      tuple&
      operator=(typename conditional<__assignable<_T1, _T2>(),
         tuple&&,
         __nonesuch&&>::type __in)
      noexcept(__nothrow_assignable<_T1, _T2>())
      {
 this->_M_assign(std::move(__in));
 return *this;
      }

      template<typename _U1, typename _U2>

 __enable_if_t<__assignable<const _U1&, const _U2&>(), tuple&>
 operator=(const tuple<_U1, _U2>& __in)
 noexcept(__nothrow_assignable<const _U1&, const _U2&>())
 {
   this->_M_assign(__in);
   return *this;
 }

      template<typename _U1, typename _U2>

 __enable_if_t<__assignable<_U1, _U2>(), tuple&>
 operator=(tuple<_U1, _U2>&& __in)
 noexcept(__nothrow_assignable<_U1, _U2>())
 {
   this->_M_assign(std::move(__in));
   return *this;
 }

      template<typename _U1, typename _U2>

 __enable_if_t<__assignable<const _U1&, const _U2&>(), tuple&>
 operator=(const pair<_U1, _U2>& __in)
 noexcept(__nothrow_assignable<const _U1&, const _U2&>())
 {
   this->_M_head(*this) = __in.first;
   this->_M_tail(*this)._M_head(*this) = __in.second;
   return *this;
 }

      template<typename _U1, typename _U2>

 __enable_if_t<__assignable<_U1, _U2>(), tuple&>
 operator=(pair<_U1, _U2>&& __in)
 noexcept(__nothrow_assignable<_U1, _U2>())
 {
   this->_M_head(*this) = std::forward<_U1>(__in.first);
   this->_M_tail(*this)._M_head(*this) = std::forward<_U2>(__in.second);
   return *this;
 }

     
      void
      swap(tuple& __in)
      noexcept(__and_<__is_nothrow_swappable<_T1>,
        __is_nothrow_swappable<_T2>>::value)
      { _Inherited::_M_swap(__in); }
    };



  template<typename... _Elements>
    struct tuple_size<tuple<_Elements...>>
    : public integral_constant<std::size_t, sizeof...(_Elements)> { };
# 1275 "/usr/include/c++/10/tuple" 3
  template<std::size_t __i, typename _Head, typename... _Tail>
    struct tuple_element<__i, tuple<_Head, _Tail...> >
    : tuple_element<__i - 1, tuple<_Tail...> > { };




  template<typename _Head, typename... _Tail>
    struct tuple_element<0, tuple<_Head, _Tail...> >
    {
      typedef _Head type;
    };




  template<size_t __i>
    struct tuple_element<__i, tuple<>>
    {
      static_assert(__i < tuple_size<tuple<>>::value,
   "tuple index is in range");
    };

  template<std::size_t __i, typename _Head, typename... _Tail>
    constexpr _Head&
    __get_helper(_Tuple_impl<__i, _Head, _Tail...>& __t) noexcept
    { return _Tuple_impl<__i, _Head, _Tail...>::_M_head(__t); }

  template<std::size_t __i, typename _Head, typename... _Tail>
    constexpr const _Head&
    __get_helper(const _Tuple_impl<__i, _Head, _Tail...>& __t) noexcept
    { return _Tuple_impl<__i, _Head, _Tail...>::_M_head(__t); }


  template<std::size_t __i, typename... _Elements>
    constexpr __tuple_element_t<__i, tuple<_Elements...>>&
    get(tuple<_Elements...>& __t) noexcept
    { return std::__get_helper<__i>(__t); }


  template<std::size_t __i, typename... _Elements>
    constexpr const __tuple_element_t<__i, tuple<_Elements...>>&
    get(const tuple<_Elements...>& __t) noexcept
    { return std::__get_helper<__i>(__t); }


  template<std::size_t __i, typename... _Elements>
    constexpr __tuple_element_t<__i, tuple<_Elements...>>&&
    get(tuple<_Elements...>&& __t) noexcept
    {
      typedef __tuple_element_t<__i, tuple<_Elements...>> __element_type;
      return std::forward<__element_type&&>(std::get<__i>(__t));
    }


  template<std::size_t __i, typename... _Elements>
    constexpr const __tuple_element_t<__i, tuple<_Elements...>>&&
    get(const tuple<_Elements...>&& __t) noexcept
    {
      typedef __tuple_element_t<__i, tuple<_Elements...>> __element_type;
      return std::forward<const __element_type&&>(std::get<__i>(__t));
    }





  template<typename _Head, size_t __i, typename... _Tail>
    constexpr _Head&
    __get_helper2(_Tuple_impl<__i, _Head, _Tail...>& __t) noexcept
    { return _Tuple_impl<__i, _Head, _Tail...>::_M_head(__t); }

  template<typename _Head, size_t __i, typename... _Tail>
    constexpr const _Head&
    __get_helper2(const _Tuple_impl<__i, _Head, _Tail...>& __t) noexcept
    { return _Tuple_impl<__i, _Head, _Tail...>::_M_head(__t); }


  template <typename _Tp, typename... _Types>
    constexpr _Tp&
    get(tuple<_Types...>& __t) noexcept
    { return std::__get_helper2<_Tp>(__t); }


  template <typename _Tp, typename... _Types>
    constexpr _Tp&&
    get(tuple<_Types...>&& __t) noexcept
    { return std::forward<_Tp&&>(std::__get_helper2<_Tp>(__t)); }


  template <typename _Tp, typename... _Types>
    constexpr const _Tp&
    get(const tuple<_Types...>& __t) noexcept
    { return std::__get_helper2<_Tp>(__t); }



  template <typename _Tp, typename... _Types>
    constexpr const _Tp&&
    get(const tuple<_Types...>&& __t) noexcept
    { return std::forward<const _Tp&&>(std::__get_helper2<_Tp>(__t)); }



  template<typename _Tp, typename _Up, size_t __i, size_t __size>
    struct __tuple_compare
    {
      static constexpr bool
      __eq(const _Tp& __t, const _Up& __u)
      {
 return bool(std::get<__i>(__t) == std::get<__i>(__u))
   && __tuple_compare<_Tp, _Up, __i + 1, __size>::__eq(__t, __u);
      }

      static constexpr bool
      __less(const _Tp& __t, const _Up& __u)
      {
 return bool(std::get<__i>(__t) < std::get<__i>(__u))
   || (!bool(std::get<__i>(__u) < std::get<__i>(__t))
       && __tuple_compare<_Tp, _Up, __i + 1, __size>::__less(__t, __u));
      }
    };

  template<typename _Tp, typename _Up, size_t __size>
    struct __tuple_compare<_Tp, _Up, __size, __size>
    {
      static constexpr bool
      __eq(const _Tp&, const _Up&) { return true; }

      static constexpr bool
      __less(const _Tp&, const _Up&) { return false; }
    };

  template<typename... _TElements, typename... _UElements>
    constexpr bool
    operator==(const tuple<_TElements...>& __t,
        const tuple<_UElements...>& __u)
    {
      static_assert(sizeof...(_TElements) == sizeof...(_UElements),
   "tuple objects can only be compared if they have equal sizes.");
      using __compare = __tuple_compare<tuple<_TElements...>,
     tuple<_UElements...>,
     0, sizeof...(_TElements)>;
      return __compare::__eq(__t, __u);
    }
# 1450 "/usr/include/c++/10/tuple" 3
  template<typename... _TElements, typename... _UElements>
    constexpr bool
    operator<(const tuple<_TElements...>& __t,
       const tuple<_UElements...>& __u)
    {
      static_assert(sizeof...(_TElements) == sizeof...(_UElements),
   "tuple objects can only be compared if they have equal sizes.");
      using __compare = __tuple_compare<tuple<_TElements...>,
     tuple<_UElements...>,
     0, sizeof...(_TElements)>;
      return __compare::__less(__t, __u);
    }

  template<typename... _TElements, typename... _UElements>
    constexpr bool
    operator!=(const tuple<_TElements...>& __t,
        const tuple<_UElements...>& __u)
    { return !(__t == __u); }

  template<typename... _TElements, typename... _UElements>
    constexpr bool
    operator>(const tuple<_TElements...>& __t,
       const tuple<_UElements...>& __u)
    { return __u < __t; }

  template<typename... _TElements, typename... _UElements>
    constexpr bool
    operator<=(const tuple<_TElements...>& __t,
        const tuple<_UElements...>& __u)
    { return !(__u < __t); }

  template<typename... _TElements, typename... _UElements>
    constexpr bool
    operator>=(const tuple<_TElements...>& __t,
        const tuple<_UElements...>& __u)
    { return !(__t < __u); }



  template<typename... _Elements>
    constexpr tuple<typename __decay_and_strip<_Elements>::__type...>
    make_tuple(_Elements&&... __args)
    {
      typedef tuple<typename __decay_and_strip<_Elements>::__type...>
 __result_type;
      return __result_type(std::forward<_Elements>(__args)...);
    }




  template<typename... _Elements>
    constexpr tuple<_Elements&&...>
    forward_as_tuple(_Elements&&... __args) noexcept
    { return tuple<_Elements&&...>(std::forward<_Elements>(__args)...); }

  template<size_t, typename, typename, size_t>
    struct __make_tuple_impl;

  template<size_t _Idx, typename _Tuple, typename... _Tp, size_t _Nm>
    struct __make_tuple_impl<_Idx, tuple<_Tp...>, _Tuple, _Nm>
    : __make_tuple_impl<_Idx + 1,
   tuple<_Tp..., __tuple_element_t<_Idx, _Tuple>>,
   _Tuple, _Nm>
    { };

  template<std::size_t _Nm, typename _Tuple, typename... _Tp>
    struct __make_tuple_impl<_Nm, tuple<_Tp...>, _Tuple, _Nm>
    {
      typedef tuple<_Tp...> __type;
    };

  template<typename _Tuple>
    struct __do_make_tuple
    : __make_tuple_impl<0, tuple<>, _Tuple, std::tuple_size<_Tuple>::value>
    { };


  template<typename _Tuple>
    struct __make_tuple
    : public __do_make_tuple<__remove_cvref_t<_Tuple>>
    { };


  template<typename...>
    struct __combine_tuples;

  template<>
    struct __combine_tuples<>
    {
      typedef tuple<> __type;
    };

  template<typename... _Ts>
    struct __combine_tuples<tuple<_Ts...>>
    {
      typedef tuple<_Ts...> __type;
    };

  template<typename... _T1s, typename... _T2s, typename... _Rem>
    struct __combine_tuples<tuple<_T1s...>, tuple<_T2s...>, _Rem...>
    {
      typedef typename __combine_tuples<tuple<_T1s..., _T2s...>,
     _Rem...>::__type __type;
    };


  template<typename... _Tpls>
    struct __tuple_cat_result
    {
      typedef typename __combine_tuples
        <typename __make_tuple<_Tpls>::__type...>::__type __type;
    };



  template<typename...>
    struct __make_1st_indices;

  template<>
    struct __make_1st_indices<>
    {
      typedef std::_Index_tuple<> __type;
    };

  template<typename _Tp, typename... _Tpls>
    struct __make_1st_indices<_Tp, _Tpls...>
    {
      typedef typename std::_Build_index_tuple<std::tuple_size<
 typename std::remove_reference<_Tp>::type>::value>::__type __type;
    };




  template<typename _Ret, typename _Indices, typename... _Tpls>
    struct __tuple_concater;

  template<typename _Ret, std::size_t... _Is, typename _Tp, typename... _Tpls>
    struct __tuple_concater<_Ret, std::_Index_tuple<_Is...>, _Tp, _Tpls...>
    {
      template<typename... _Us>
        static constexpr _Ret
        _S_do(_Tp&& __tp, _Tpls&&... __tps, _Us&&... __us)
        {
   typedef typename __make_1st_indices<_Tpls...>::__type __idx;
   typedef __tuple_concater<_Ret, __idx, _Tpls...> __next;
   return __next::_S_do(std::forward<_Tpls>(__tps)...,
          std::forward<_Us>(__us)...,
          std::get<_Is>(std::forward<_Tp>(__tp))...);
 }
    };

  template<typename _Ret>
    struct __tuple_concater<_Ret, std::_Index_tuple<>>
    {
      template<typename... _Us>
 static constexpr _Ret
 _S_do(_Us&&... __us)
        {
   return _Ret(std::forward<_Us>(__us)...);
 }
    };


  template<typename... _Tpls, typename = typename
           enable_if<__and_<__is_tuple_like<_Tpls>...>::value>::type>
    constexpr auto
    tuple_cat(_Tpls&&... __tpls)
    -> typename __tuple_cat_result<_Tpls...>::__type
    {
      typedef typename __tuple_cat_result<_Tpls...>::__type __ret;
      typedef typename __make_1st_indices<_Tpls...>::__type __idx;
      typedef __tuple_concater<__ret, __idx, _Tpls...> __concater;
      return __concater::_S_do(std::forward<_Tpls>(__tpls)...);
    }




  template<typename... _Elements>
    constexpr tuple<_Elements&...>
    tie(_Elements&... __args) noexcept
    { return tuple<_Elements&...>(__args...); }


  template<typename... _Elements>
   
    inline


    typename enable_if<__and_<__is_swappable<_Elements>...>::value
      >::type



    swap(tuple<_Elements...>& __x, tuple<_Elements...>& __y)
    noexcept(noexcept(__x.swap(__y)))
    { __x.swap(__y); }


  template<typename... _Elements>
   
    typename enable_if<!__and_<__is_swappable<_Elements>...>::value>::type
    swap(tuple<_Elements...>&, tuple<_Elements...>&) = delete;






  struct _Swallow_assign
  {
    template<class _Tp>
      constexpr const _Swallow_assign&
      operator=(const _Tp&) const
      { return *this; }
  };



  constexpr _Swallow_assign ignore{};


  template<typename... _Types, typename _Alloc>
    struct uses_allocator<tuple<_Types...>, _Alloc> : true_type { };
# 1686 "/usr/include/c++/10/tuple" 3
  template<class _T1, class _T2>
    template<typename... _Args1, typename... _Args2>
     
      inline
      pair<_T1, _T2>::
      pair(piecewise_construct_t,
    tuple<_Args1...> __first, tuple<_Args2...> __second)
      : pair(__first, __second,
      typename _Build_index_tuple<sizeof...(_Args1)>::__type(),
      typename _Build_index_tuple<sizeof...(_Args2)>::__type())
      { }

  template<class _T1, class _T2>
    template<typename... _Args1, std::size_t... _Indexes1,
             typename... _Args2, std::size_t... _Indexes2>
      inline
      pair<_T1, _T2>::
      pair(tuple<_Args1...>& __tuple1, tuple<_Args2...>& __tuple2,
    _Index_tuple<_Indexes1...>, _Index_tuple<_Indexes2...>)
      : first(std::forward<_Args1>(std::get<_Indexes1>(__tuple1))...),
        second(std::forward<_Args2>(std::get<_Indexes2>(__tuple2))...)
      { }
# 1776 "/usr/include/c++/10/tuple" 3

}
# 35 "/usr/include/c++/10/bits/hashtable_policy.h" 2 3
# 1 "/usr/include/c++/10/limits" 1 3
# 40 "/usr/include/c++/10/limits" 3
       
# 41 "/usr/include/c++/10/limits" 3
# 158 "/usr/include/c++/10/limits" 3
namespace std __attribute__ ((__visibility__ ("default")))
{







  enum float_round_style
  {
    round_indeterminate = -1,
    round_toward_zero = 0,
    round_to_nearest = 1,
    round_toward_infinity = 2,
    round_toward_neg_infinity = 3
  };







  enum float_denorm_style
  {

    denorm_indeterminate = -1,

    denorm_absent = 0,

    denorm_present = 1
  };
# 202 "/usr/include/c++/10/limits" 3
  struct __numeric_limits_base
  {


    static constexpr bool is_specialized = false;




    static constexpr int digits = 0;


    static constexpr int digits10 = 0;




    static constexpr int max_digits10 = 0;



    static constexpr bool is_signed = false;


    static constexpr bool is_integer = false;




    static constexpr bool is_exact = false;



    static constexpr int radix = 0;



    static constexpr int min_exponent = 0;



    static constexpr int min_exponent10 = 0;




    static constexpr int max_exponent = 0;



    static constexpr int max_exponent10 = 0;


    static constexpr bool has_infinity = false;



    static constexpr bool has_quiet_NaN = false;



    static constexpr bool has_signaling_NaN = false;


    static constexpr float_denorm_style has_denorm = denorm_absent;



    static constexpr bool has_denorm_loss = false;



    static constexpr bool is_iec559 = false;




    static constexpr bool is_bounded = false;
# 288 "/usr/include/c++/10/limits" 3
    static constexpr bool is_modulo = false;


    static constexpr bool traps = false;


    static constexpr bool tinyness_before = false;




    static constexpr float_round_style round_style =
          round_toward_zero;
  };
# 311 "/usr/include/c++/10/limits" 3
  template<typename _Tp>
    struct numeric_limits : public __numeric_limits_base
    {


      static constexpr _Tp
      min() noexcept { return _Tp(); }


      static constexpr _Tp
      max() noexcept { return _Tp(); }




      static constexpr _Tp
      lowest() noexcept { return _Tp(); }




      static constexpr _Tp
      epsilon() noexcept { return _Tp(); }


      static constexpr _Tp
      round_error() noexcept { return _Tp(); }


      static constexpr _Tp
      infinity() noexcept { return _Tp(); }



      static constexpr _Tp
      quiet_NaN() noexcept { return _Tp(); }



      static constexpr _Tp
      signaling_NaN() noexcept { return _Tp(); }




      static constexpr _Tp
      denorm_min() noexcept { return _Tp(); }
    };




  template<typename _Tp>
    struct numeric_limits<const _Tp>
    : public numeric_limits<_Tp> { };

  template<typename _Tp>
    struct numeric_limits<volatile _Tp>
    : public numeric_limits<_Tp> { };

  template<typename _Tp>
    struct numeric_limits<const volatile _Tp>
    : public numeric_limits<_Tp> { };
# 383 "/usr/include/c++/10/limits" 3
  template<>
    struct numeric_limits<bool>
    {
      static constexpr bool is_specialized = true;

      static constexpr bool
      min() noexcept { return false; }

      static constexpr bool
      max() noexcept { return true; }


      static constexpr bool
      lowest() noexcept { return min(); }

      static constexpr int digits = 1;
      static constexpr int digits10 = 0;

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = false;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr bool
      epsilon() noexcept { return false; }

      static constexpr bool
      round_error() noexcept { return false; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr bool
      infinity() noexcept { return false; }

      static constexpr bool
      quiet_NaN() noexcept { return false; }

      static constexpr bool
      signaling_NaN() noexcept { return false; }

      static constexpr bool
      denorm_min() noexcept { return false; }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = false;




      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<char>
    {
      static constexpr bool is_specialized = true;

      static constexpr char
      min() noexcept { return (((char)(-1) < 0) ? -(((char)(-1) < 0) ? (((((char)1 << ((sizeof(char) * 8 - ((char)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(char)0) - 1 : (char)0); }

      static constexpr char
      max() noexcept { return (((char)(-1) < 0) ? (((((char)1 << ((sizeof(char) * 8 - ((char)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(char)0); }


      static constexpr char
      lowest() noexcept { return min(); }


      static constexpr int digits = (sizeof(char) * 8 - ((char)(-1) < 0));
      static constexpr int digits10 = ((sizeof(char) * 8 - ((char)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = ((char)(-1) < 0);
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr char
      epsilon() noexcept { return 0; }

      static constexpr char
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr
      char infinity() noexcept { return char(); }

      static constexpr char
      quiet_NaN() noexcept { return char(); }

      static constexpr char
      signaling_NaN() noexcept { return char(); }

      static constexpr char
      denorm_min() noexcept { return static_cast<char>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = !is_signed;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<signed char>
    {
      static constexpr bool is_specialized = true;

      static constexpr signed char
      min() noexcept { return -0x7f - 1; }

      static constexpr signed char
      max() noexcept { return 0x7f; }


      static constexpr signed char
      lowest() noexcept { return min(); }


      static constexpr int digits = (sizeof(signed char) * 8 - ((signed char)(-1) < 0));
      static constexpr int digits10
       = ((sizeof(signed char) * 8 - ((signed char)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = true;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr signed char
      epsilon() noexcept { return 0; }

      static constexpr signed char
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr signed char
      infinity() noexcept { return static_cast<signed char>(0); }

      static constexpr signed char
      quiet_NaN() noexcept { return static_cast<signed char>(0); }

      static constexpr signed char
      signaling_NaN() noexcept
      { return static_cast<signed char>(0); }

      static constexpr signed char
      denorm_min() noexcept
      { return static_cast<signed char>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = false;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<unsigned char>
    {
      static constexpr bool is_specialized = true;

      static constexpr unsigned char
      min() noexcept { return 0; }

      static constexpr unsigned char
      max() noexcept { return 0x7f * 2U + 1; }


      static constexpr unsigned char
      lowest() noexcept { return min(); }


      static constexpr int digits
       = (sizeof(unsigned char) * 8 - ((unsigned char)(-1) < 0));
      static constexpr int digits10
       = ((sizeof(unsigned char) * 8 - ((unsigned char)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = false;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr unsigned char
      epsilon() noexcept { return 0; }

      static constexpr unsigned char
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr unsigned char
      infinity() noexcept
      { return static_cast<unsigned char>(0); }

      static constexpr unsigned char
      quiet_NaN() noexcept
      { return static_cast<unsigned char>(0); }

      static constexpr unsigned char
      signaling_NaN() noexcept
      { return static_cast<unsigned char>(0); }

      static constexpr unsigned char
      denorm_min() noexcept
      { return static_cast<unsigned char>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = true;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<wchar_t>
    {
      static constexpr bool is_specialized = true;

      static constexpr wchar_t
      min() noexcept { return (((wchar_t)(-1) < 0) ? -(((wchar_t)(-1) < 0) ? (((((wchar_t)1 << ((sizeof(wchar_t) * 8 - ((wchar_t)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(wchar_t)0) - 1 : (wchar_t)0); }

      static constexpr wchar_t
      max() noexcept { return (((wchar_t)(-1) < 0) ? (((((wchar_t)1 << ((sizeof(wchar_t) * 8 - ((wchar_t)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(wchar_t)0); }


      static constexpr wchar_t
      lowest() noexcept { return min(); }


      static constexpr int digits = (sizeof(wchar_t) * 8 - ((wchar_t)(-1) < 0));
      static constexpr int digits10
       = ((sizeof(wchar_t) * 8 - ((wchar_t)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = ((wchar_t)(-1) < 0);
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr wchar_t
      epsilon() noexcept { return 0; }

      static constexpr wchar_t
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr wchar_t
      infinity() noexcept { return wchar_t(); }

      static constexpr wchar_t
      quiet_NaN() noexcept { return wchar_t(); }

      static constexpr wchar_t
      signaling_NaN() noexcept { return wchar_t(); }

      static constexpr wchar_t
      denorm_min() noexcept { return wchar_t(); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = !is_signed;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };
# 796 "/usr/include/c++/10/limits" 3
  template<>
    struct numeric_limits<char16_t>
    {
      static constexpr bool is_specialized = true;

      static constexpr char16_t
      min() noexcept { return (((char16_t)(-1) < 0) ? -(((char16_t)(-1) < 0) ? (((((char16_t)1 << ((sizeof(char16_t) * 8 - ((char16_t)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(char16_t)0) - 1 : (char16_t)0); }

      static constexpr char16_t
      max() noexcept { return (((char16_t)(-1) < 0) ? (((((char16_t)1 << ((sizeof(char16_t) * 8 - ((char16_t)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(char16_t)0); }

      static constexpr char16_t
      lowest() noexcept { return min(); }

      static constexpr int digits = (sizeof(char16_t) * 8 - ((char16_t)(-1) < 0));
      static constexpr int digits10 = ((sizeof(char16_t) * 8 - ((char16_t)(-1) < 0)) * 643L / 2136);
      static constexpr int max_digits10 = 0;
      static constexpr bool is_signed = ((char16_t)(-1) < 0);
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr char16_t
      epsilon() noexcept { return 0; }

      static constexpr char16_t
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr char16_t
      infinity() noexcept { return char16_t(); }

      static constexpr char16_t
      quiet_NaN() noexcept { return char16_t(); }

      static constexpr char16_t
      signaling_NaN() noexcept { return char16_t(); }

      static constexpr char16_t
      denorm_min() noexcept { return char16_t(); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = !is_signed;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style = round_toward_zero;
    };


  template<>
    struct numeric_limits<char32_t>
    {
      static constexpr bool is_specialized = true;

      static constexpr char32_t
      min() noexcept { return (((char32_t)(-1) < 0) ? -(((char32_t)(-1) < 0) ? (((((char32_t)1 << ((sizeof(char32_t) * 8 - ((char32_t)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(char32_t)0) - 1 : (char32_t)0); }

      static constexpr char32_t
      max() noexcept { return (((char32_t)(-1) < 0) ? (((((char32_t)1 << ((sizeof(char32_t) * 8 - ((char32_t)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(char32_t)0); }

      static constexpr char32_t
      lowest() noexcept { return min(); }

      static constexpr int digits = (sizeof(char32_t) * 8 - ((char32_t)(-1) < 0));
      static constexpr int digits10 = ((sizeof(char32_t) * 8 - ((char32_t)(-1) < 0)) * 643L / 2136);
      static constexpr int max_digits10 = 0;
      static constexpr bool is_signed = ((char32_t)(-1) < 0);
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr char32_t
      epsilon() noexcept { return 0; }

      static constexpr char32_t
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr char32_t
      infinity() noexcept { return char32_t(); }

      static constexpr char32_t
      quiet_NaN() noexcept { return char32_t(); }

      static constexpr char32_t
      signaling_NaN() noexcept { return char32_t(); }

      static constexpr char32_t
      denorm_min() noexcept { return char32_t(); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = !is_signed;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style = round_toward_zero;
    };



  template<>
    struct numeric_limits<short>
    {
      static constexpr bool is_specialized = true;

      static constexpr short
      min() noexcept { return -0x7fff - 1; }

      static constexpr short
      max() noexcept { return 0x7fff; }


      static constexpr short
      lowest() noexcept { return min(); }


      static constexpr int digits = (sizeof(short) * 8 - ((short)(-1) < 0));
      static constexpr int digits10 = ((sizeof(short) * 8 - ((short)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = true;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr short
      epsilon() noexcept { return 0; }

      static constexpr short
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr short
      infinity() noexcept { return short(); }

      static constexpr short
      quiet_NaN() noexcept { return short(); }

      static constexpr short
      signaling_NaN() noexcept { return short(); }

      static constexpr short
      denorm_min() noexcept { return short(); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = false;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<unsigned short>
    {
      static constexpr bool is_specialized = true;

      static constexpr unsigned short
      min() noexcept { return 0; }

      static constexpr unsigned short
      max() noexcept { return 0x7fff * 2U + 1; }


      static constexpr unsigned short
      lowest() noexcept { return min(); }


      static constexpr int digits
       = (sizeof(unsigned short) * 8 - ((unsigned short)(-1) < 0));
      static constexpr int digits10
       = ((sizeof(unsigned short) * 8 - ((unsigned short)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = false;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr unsigned short
      epsilon() noexcept { return 0; }

      static constexpr unsigned short
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr unsigned short
      infinity() noexcept
      { return static_cast<unsigned short>(0); }

      static constexpr unsigned short
      quiet_NaN() noexcept
      { return static_cast<unsigned short>(0); }

      static constexpr unsigned short
      signaling_NaN() noexcept
      { return static_cast<unsigned short>(0); }

      static constexpr unsigned short
      denorm_min() noexcept
      { return static_cast<unsigned short>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = true;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<int>
    {
      static constexpr bool is_specialized = true;

      static constexpr int
      min() noexcept { return -0x7fffffff - 1; }

      static constexpr int
      max() noexcept { return 0x7fffffff; }


      static constexpr int
      lowest() noexcept { return min(); }


      static constexpr int digits = (sizeof(int) * 8 - ((int)(-1) < 0));
      static constexpr int digits10 = ((sizeof(int) * 8 - ((int)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = true;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr int
      epsilon() noexcept { return 0; }

      static constexpr int
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr int
      infinity() noexcept { return static_cast<int>(0); }

      static constexpr int
      quiet_NaN() noexcept { return static_cast<int>(0); }

      static constexpr int
      signaling_NaN() noexcept { return static_cast<int>(0); }

      static constexpr int
      denorm_min() noexcept { return static_cast<int>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = false;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<unsigned int>
    {
      static constexpr bool is_specialized = true;

      static constexpr unsigned int
      min() noexcept { return 0; }

      static constexpr unsigned int
      max() noexcept { return 0x7fffffff * 2U + 1; }


      static constexpr unsigned int
      lowest() noexcept { return min(); }


      static constexpr int digits
       = (sizeof(unsigned int) * 8 - ((unsigned int)(-1) < 0));
      static constexpr int digits10
       = ((sizeof(unsigned int) * 8 - ((unsigned int)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = false;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr unsigned int
      epsilon() noexcept { return 0; }

      static constexpr unsigned int
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr unsigned int
      infinity() noexcept { return static_cast<unsigned int>(0); }

      static constexpr unsigned int
      quiet_NaN() noexcept
      { return static_cast<unsigned int>(0); }

      static constexpr unsigned int
      signaling_NaN() noexcept
      { return static_cast<unsigned int>(0); }

      static constexpr unsigned int
      denorm_min() noexcept
      { return static_cast<unsigned int>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = true;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<long>
    {
      static constexpr bool is_specialized = true;

      static constexpr long
      min() noexcept { return -0x7fffffffffffffffL - 1; }

      static constexpr long
      max() noexcept { return 0x7fffffffffffffffL; }


      static constexpr long
      lowest() noexcept { return min(); }


      static constexpr int digits = (sizeof(long) * 8 - ((long)(-1) < 0));
      static constexpr int digits10 = ((sizeof(long) * 8 - ((long)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = true;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr long
      epsilon() noexcept { return 0; }

      static constexpr long
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr long
      infinity() noexcept { return static_cast<long>(0); }

      static constexpr long
      quiet_NaN() noexcept { return static_cast<long>(0); }

      static constexpr long
      signaling_NaN() noexcept { return static_cast<long>(0); }

      static constexpr long
      denorm_min() noexcept { return static_cast<long>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = false;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<unsigned long>
    {
      static constexpr bool is_specialized = true;

      static constexpr unsigned long
      min() noexcept { return 0; }

      static constexpr unsigned long
      max() noexcept { return 0x7fffffffffffffffL * 2UL + 1; }


      static constexpr unsigned long
      lowest() noexcept { return min(); }


      static constexpr int digits
       = (sizeof(unsigned long) * 8 - ((unsigned long)(-1) < 0));
      static constexpr int digits10
       = ((sizeof(unsigned long) * 8 - ((unsigned long)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = false;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr unsigned long
      epsilon() noexcept { return 0; }

      static constexpr unsigned long
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr unsigned long
      infinity() noexcept
      { return static_cast<unsigned long>(0); }

      static constexpr unsigned long
      quiet_NaN() noexcept
      { return static_cast<unsigned long>(0); }

      static constexpr unsigned long
      signaling_NaN() noexcept
      { return static_cast<unsigned long>(0); }

      static constexpr unsigned long
      denorm_min() noexcept
      { return static_cast<unsigned long>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = true;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<long long>
    {
      static constexpr bool is_specialized = true;

      static constexpr long long
      min() noexcept { return -0x7fffffffffffffffLL - 1; }

      static constexpr long long
      max() noexcept { return 0x7fffffffffffffffLL; }


      static constexpr long long
      lowest() noexcept { return min(); }


      static constexpr int digits
       = (sizeof(long long) * 8 - ((long long)(-1) < 0));
      static constexpr int digits10
       = ((sizeof(long long) * 8 - ((long long)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = true;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr long long
      epsilon() noexcept { return 0; }

      static constexpr long long
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr long long
      infinity() noexcept { return static_cast<long long>(0); }

      static constexpr long long
      quiet_NaN() noexcept { return static_cast<long long>(0); }

      static constexpr long long
      signaling_NaN() noexcept
      { return static_cast<long long>(0); }

      static constexpr long long
      denorm_min() noexcept { return static_cast<long long>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = false;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<unsigned long long>
    {
      static constexpr bool is_specialized = true;

      static constexpr unsigned long long
      min() noexcept { return 0; }

      static constexpr unsigned long long
      max() noexcept { return 0x7fffffffffffffffLL * 2ULL + 1; }


      static constexpr unsigned long long
      lowest() noexcept { return min(); }


      static constexpr int digits
       = (sizeof(unsigned long long) * 8 - ((unsigned long long)(-1) < 0));
      static constexpr int digits10
       = ((sizeof(unsigned long long) * 8 - ((unsigned long long)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = false;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr unsigned long long
      epsilon() noexcept { return 0; }

      static constexpr unsigned long long
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr unsigned long long
      infinity() noexcept
      { return static_cast<unsigned long long>(0); }

      static constexpr unsigned long long
      quiet_NaN() noexcept
      { return static_cast<unsigned long long>(0); }

      static constexpr unsigned long long
      signaling_NaN() noexcept
      { return static_cast<unsigned long long>(0); }

      static constexpr unsigned long long
      denorm_min() noexcept
      { return static_cast<unsigned long long>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = true;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };
# 1635 "/usr/include/c++/10/limits" 3
  template<> struct numeric_limits<__int128> { static constexpr bool is_specialized = true; static constexpr __int128 min() noexcept { return (((__int128)(-1) < 0) ? -(((__int128)(-1) < 0) ? (((((__int128)1 << ((128 - ((__int128)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(__int128)0) - 1 : (__int128)0); } static constexpr __int128 max() noexcept { return (((__int128)(-1) < 0) ? (((((__int128)1 << ((128 - ((__int128)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(__int128)0); } static constexpr int digits = 128 - 1; static constexpr int digits10 = (128 - 1) * 643L / 2136; static constexpr bool is_signed = true; static constexpr bool is_integer = true; static constexpr bool is_exact = true; static constexpr int radix = 2; static constexpr __int128 epsilon() noexcept { return 0; } static constexpr __int128 round_error() noexcept { return 0; } static constexpr __int128 lowest() noexcept { return min(); } static constexpr int max_digits10 = 0; static constexpr int min_exponent = 0; static constexpr int min_exponent10 = 0; static constexpr int max_exponent = 0; static constexpr int max_exponent10 = 0; static constexpr bool has_infinity = false; static constexpr bool has_quiet_NaN = false; static constexpr bool has_signaling_NaN = false; static constexpr float_denorm_style has_denorm = denorm_absent; static constexpr bool has_denorm_loss = false; static constexpr __int128 infinity() noexcept { return static_cast<__int128>(0); } static constexpr __int128 quiet_NaN() noexcept { return static_cast<__int128>(0); } static constexpr __int128 signaling_NaN() noexcept { return static_cast<__int128>(0); } static constexpr __int128 denorm_min() noexcept { return static_cast<__int128>(0); } static constexpr bool is_iec559 = false; static constexpr bool is_bounded = true; static constexpr bool is_modulo = false; static constexpr bool traps = true; static constexpr bool tinyness_before = false; static constexpr float_round_style round_style = round_toward_zero; }; template<> struct numeric_limits<unsigned __int128> { static constexpr bool is_specialized = true; static constexpr unsigned __int128 min() noexcept { return 0; } static constexpr unsigned __int128 max() noexcept { return (((unsigned __int128)(-1) < 0) ? (((((unsigned __int128)1 << ((128 - ((unsigned __int128)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(unsigned __int128)0); } static constexpr unsigned __int128 lowest() noexcept { return min(); } static constexpr int max_digits10 = 0; static constexpr int digits = 128; static constexpr int digits10 = 128 * 643L / 2136; static constexpr bool is_signed = false; static constexpr bool is_integer = true; static constexpr bool is_exact = true; static constexpr int radix = 2; static constexpr unsigned __int128 epsilon() noexcept { return 0; } static constexpr unsigned __int128 round_error() noexcept { return 0; } static constexpr int min_exponent = 0; static constexpr int min_exponent10 = 0; static constexpr int max_exponent = 0; static constexpr int max_exponent10 = 0; static constexpr bool has_infinity = false; static constexpr bool has_quiet_NaN = false; static constexpr bool has_signaling_NaN = false; static constexpr float_denorm_style has_denorm = denorm_absent; static constexpr bool has_denorm_loss = false; static constexpr unsigned __int128 infinity() noexcept { return static_cast<unsigned __int128>(0); } static constexpr unsigned __int128 quiet_NaN() noexcept { return static_cast<unsigned __int128>(0); } static constexpr unsigned __int128 signaling_NaN() noexcept { return static_cast<unsigned __int128>(0); } static constexpr unsigned __int128 denorm_min() noexcept { return static_cast<unsigned __int128>(0); } static constexpr bool is_iec559 = false; static constexpr bool is_bounded = true; static constexpr bool is_modulo = true; static constexpr bool traps = true; static constexpr bool tinyness_before = false; static constexpr float_round_style round_style = round_toward_zero; };
# 1663 "/usr/include/c++/10/limits" 3
  template<>
    struct numeric_limits<float>
    {
      static constexpr bool is_specialized = true;

      static constexpr float
      min() noexcept { return 1.17549435082228750796873653722224568e-38F; }

      static constexpr float
      max() noexcept { return 3.40282346638528859811704183484516925e+38F; }


      static constexpr float
      lowest() noexcept { return -3.40282346638528859811704183484516925e+38F; }


      static constexpr int digits = 24;
      static constexpr int digits10 = 6;

      static constexpr int max_digits10
  = (2 + (24) * 643L / 2136);

      static constexpr bool is_signed = true;
      static constexpr bool is_integer = false;
      static constexpr bool is_exact = false;
      static constexpr int radix = 2;

      static constexpr float
      epsilon() noexcept { return 1.19209289550781250000000000000000000e-7F; }

      static constexpr float
      round_error() noexcept { return 0.5F; }

      static constexpr int min_exponent = (-125);
      static constexpr int min_exponent10 = (-37);
      static constexpr int max_exponent = 128;
      static constexpr int max_exponent10 = 38;

      static constexpr bool has_infinity = 1;
      static constexpr bool has_quiet_NaN = 1;
      static constexpr bool has_signaling_NaN = has_quiet_NaN;
      static constexpr float_denorm_style has_denorm
 = bool(1) ? denorm_present : denorm_absent;
      static constexpr bool has_denorm_loss
       = false;

      static constexpr float
      infinity() noexcept { return __builtin_huge_valf(); }

      static constexpr float
      quiet_NaN() noexcept { return __builtin_nanf(""); }

      static constexpr float
      signaling_NaN() noexcept { return __builtin_nansf(""); }

      static constexpr float
      denorm_min() noexcept { return 1.40129846432481707092372958328991613e-45F; }

      static constexpr bool is_iec559
 = has_infinity && has_quiet_NaN && has_denorm == denorm_present;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = false;

      static constexpr bool traps = false;
      static constexpr bool tinyness_before
       = false;
      static constexpr float_round_style round_style
       = round_to_nearest;
    };






  template<>
    struct numeric_limits<double>
    {
      static constexpr bool is_specialized = true;

      static constexpr double
      min() noexcept { return double(2.22507385850720138309023271733240406e-308L); }

      static constexpr double
      max() noexcept { return double(1.79769313486231570814527423731704357e+308L); }


      static constexpr double
      lowest() noexcept { return -double(1.79769313486231570814527423731704357e+308L); }


      static constexpr int digits = 53;
      static constexpr int digits10 = 15;

      static constexpr int max_digits10
  = (2 + (53) * 643L / 2136);

      static constexpr bool is_signed = true;
      static constexpr bool is_integer = false;
      static constexpr bool is_exact = false;
      static constexpr int radix = 2;

      static constexpr double
      epsilon() noexcept { return double(2.22044604925031308084726333618164062e-16L); }

      static constexpr double
      round_error() noexcept { return 0.5; }

      static constexpr int min_exponent = (-1021);
      static constexpr int min_exponent10 = (-307);
      static constexpr int max_exponent = 1024;
      static constexpr int max_exponent10 = 308;

      static constexpr bool has_infinity = 1;
      static constexpr bool has_quiet_NaN = 1;
      static constexpr bool has_signaling_NaN = has_quiet_NaN;
      static constexpr float_denorm_style has_denorm
 = bool(1) ? denorm_present : denorm_absent;
      static constexpr bool has_denorm_loss
        = false;

      static constexpr double
      infinity() noexcept { return __builtin_huge_val(); }

      static constexpr double
      quiet_NaN() noexcept { return __builtin_nan(""); }

      static constexpr double
      signaling_NaN() noexcept { return __builtin_nans(""); }

      static constexpr double
      denorm_min() noexcept { return double(4.94065645841246544176568792868221372e-324L); }

      static constexpr bool is_iec559
 = has_infinity && has_quiet_NaN && has_denorm == denorm_present;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = false;

      static constexpr bool traps = false;
      static constexpr bool tinyness_before
       = false;
      static constexpr float_round_style round_style
       = round_to_nearest;
    };






  template<>
    struct numeric_limits<long double>
    {
      static constexpr bool is_specialized = true;

      static constexpr long double
      min() noexcept { return 3.36210314311209350626267781732175260e-4932L; }

      static constexpr long double
      max() noexcept { return 1.18973149535723176502126385303097021e+4932L; }


      static constexpr long double
      lowest() noexcept { return -1.18973149535723176502126385303097021e+4932L; }


      static constexpr int digits = 64;
      static constexpr int digits10 = 18;

      static constexpr int max_digits10
  = (2 + (64) * 643L / 2136);

      static constexpr bool is_signed = true;
      static constexpr bool is_integer = false;
      static constexpr bool is_exact = false;
      static constexpr int radix = 2;

      static constexpr long double
      epsilon() noexcept { return 1.08420217248550443400745280086994171e-19L; }

      static constexpr long double
      round_error() noexcept { return 0.5L; }

      static constexpr int min_exponent = (-16381);
      static constexpr int min_exponent10 = (-4931);
      static constexpr int max_exponent = 16384;
      static constexpr int max_exponent10 = 4932;

      static constexpr bool has_infinity = 1;
      static constexpr bool has_quiet_NaN = 1;
      static constexpr bool has_signaling_NaN = has_quiet_NaN;
      static constexpr float_denorm_style has_denorm
 = bool(1) ? denorm_present : denorm_absent;
      static constexpr bool has_denorm_loss
 = false;

      static constexpr long double
      infinity() noexcept { return __builtin_huge_vall(); }

      static constexpr long double
      quiet_NaN() noexcept { return __builtin_nanl(""); }

      static constexpr long double
      signaling_NaN() noexcept { return __builtin_nansl(""); }

      static constexpr long double
      denorm_min() noexcept { return 3.64519953188247460252840593361941982e-4951L; }

      static constexpr bool is_iec559
 = has_infinity && has_quiet_NaN && has_denorm == denorm_present;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = false;

      static constexpr bool traps = false;
      static constexpr bool tinyness_before =
      false;
      static constexpr float_round_style round_style =
            round_to_nearest;
    };






}
# 36 "/usr/include/c++/10/bits/hashtable_policy.h" 2 3


namespace std __attribute__ ((__visibility__ ("default")))
{


  template<typename _Key, typename _Value, typename _Alloc,
    typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash,
    typename _RehashPolicy, typename _Traits>
    class _Hashtable;

namespace __detail
{





  template<typename _Key, typename _Value,
    typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _Traits>
    struct _Hashtable_base;



  template<class _Iterator>
    inline typename std::iterator_traits<_Iterator>::difference_type
    __distance_fw(_Iterator __first, _Iterator __last,
    std::input_iterator_tag)
    { return __first != __last ? 1 : 0; }

  template<class _Iterator>
    inline typename std::iterator_traits<_Iterator>::difference_type
    __distance_fw(_Iterator __first, _Iterator __last,
    std::forward_iterator_tag)
    { return std::distance(__first, __last); }

  template<class _Iterator>
    inline typename std::iterator_traits<_Iterator>::difference_type
    __distance_fw(_Iterator __first, _Iterator __last)
    { return __distance_fw(__first, __last,
      std::__iterator_category(__first)); }

  struct _Identity
  {
    template<typename _Tp>
      _Tp&&
      operator()(_Tp&& __x) const
      { return std::forward<_Tp>(__x); }
  };

  struct _Select1st
  {
    template<typename _Tp>
      auto
      operator()(_Tp&& __x) const
      -> decltype(std::get<0>(std::forward<_Tp>(__x)))
      { return std::get<0>(std::forward<_Tp>(__x)); }
  };

  template<typename _NodeAlloc>
    struct _Hashtable_alloc;



  template<typename _NodeAlloc>
    struct _ReuseOrAllocNode
    {
    private:
      using __node_alloc_type = _NodeAlloc;
      using __hashtable_alloc = _Hashtable_alloc<__node_alloc_type>;
      using __node_alloc_traits =
 typename __hashtable_alloc::__node_alloc_traits;
      using __node_type = typename __hashtable_alloc::__node_type;

    public:
      _ReuseOrAllocNode(__node_type* __nodes, __hashtable_alloc& __h)
      : _M_nodes(__nodes), _M_h(__h) { }
      _ReuseOrAllocNode(const _ReuseOrAllocNode&) = delete;

      ~_ReuseOrAllocNode()
      { _M_h._M_deallocate_nodes(_M_nodes); }

      template<typename _Arg>
 __node_type*
 operator()(_Arg&& __arg) const
 {
   if (_M_nodes)
     {
       __node_type* __node = _M_nodes;
       _M_nodes = _M_nodes->_M_next();
       __node->_M_nxt = nullptr;
       auto& __a = _M_h._M_node_allocator();
       __node_alloc_traits::destroy(__a, __node->_M_valptr());
       try
  {
    __node_alloc_traits::construct(__a, __node->_M_valptr(),
       std::forward<_Arg>(__arg));
  }
       catch(...)
  {
    _M_h._M_deallocate_node_ptr(__node);
    throw;
  }
       return __node;
     }
   return _M_h._M_allocate_node(std::forward<_Arg>(__arg));
 }

    private:
      mutable __node_type* _M_nodes;
      __hashtable_alloc& _M_h;
    };



  template<typename _NodeAlloc>
    struct _AllocNode
    {
    private:
      using __hashtable_alloc = _Hashtable_alloc<_NodeAlloc>;
      using __node_type = typename __hashtable_alloc::__node_type;

    public:
      _AllocNode(__hashtable_alloc& __h)
      : _M_h(__h) { }

      template<typename _Arg>
 __node_type*
 operator()(_Arg&& __arg) const
 { return _M_h._M_allocate_node(std::forward<_Arg>(__arg)); }

    private:
      __hashtable_alloc& _M_h;
    };
# 198 "/usr/include/c++/10/bits/hashtable_policy.h" 3
  template<bool _Cache_hash_code, bool _Constant_iterators, bool _Unique_keys>
    struct _Hashtable_traits
    {
      using __hash_cached = __bool_constant<_Cache_hash_code>;
      using __constant_iterators = __bool_constant<_Constant_iterators>;
      using __unique_keys = __bool_constant<_Unique_keys>;
    };
# 214 "/usr/include/c++/10/bits/hashtable_policy.h" 3
  struct _Hash_node_base
  {
    _Hash_node_base* _M_nxt;

    _Hash_node_base() noexcept : _M_nxt() { }

    _Hash_node_base(_Hash_node_base* __next) noexcept : _M_nxt(__next) { }
  };






  template<typename _Value>
    struct _Hash_node_value_base : _Hash_node_base
    {
      typedef _Value value_type;

      __gnu_cxx::__aligned_buffer<_Value> _M_storage;

      _Value*
      _M_valptr() noexcept
      { return _M_storage._M_ptr(); }

      const _Value*
      _M_valptr() const noexcept
      { return _M_storage._M_ptr(); }

      _Value&
      _M_v() noexcept
      { return *_M_valptr(); }

      const _Value&
      _M_v() const noexcept
      { return *_M_valptr(); }
    };




  template<typename _Value, bool _Cache_hash_code>
    struct _Hash_node;






  template<typename _Value>
    struct _Hash_node<_Value, true> : _Hash_node_value_base<_Value>
    {
      std::size_t _M_hash_code;

      _Hash_node*
      _M_next() const noexcept
      { return static_cast<_Hash_node*>(this->_M_nxt); }
    };






  template<typename _Value>
    struct _Hash_node<_Value, false> : _Hash_node_value_base<_Value>
    {
      _Hash_node*
      _M_next() const noexcept
      { return static_cast<_Hash_node*>(this->_M_nxt); }
    };


  template<typename _Value, bool _Cache_hash_code>
    struct _Node_iterator_base
    {
      using __node_type = _Hash_node<_Value, _Cache_hash_code>;

      __node_type* _M_cur;

      _Node_iterator_base(__node_type* __p) noexcept
      : _M_cur(__p) { }

      void
      _M_incr() noexcept
      { _M_cur = _M_cur->_M_next(); }
    };

  template<typename _Value, bool _Cache_hash_code>
    inline bool
    operator==(const _Node_iterator_base<_Value, _Cache_hash_code>& __x,
        const _Node_iterator_base<_Value, _Cache_hash_code >& __y)
    noexcept
    { return __x._M_cur == __y._M_cur; }

  template<typename _Value, bool _Cache_hash_code>
    inline bool
    operator!=(const _Node_iterator_base<_Value, _Cache_hash_code>& __x,
        const _Node_iterator_base<_Value, _Cache_hash_code>& __y)
    noexcept
    { return __x._M_cur != __y._M_cur; }


  template<typename _Value, bool __constant_iterators, bool __cache>
    struct _Node_iterator
    : public _Node_iterator_base<_Value, __cache>
    {
    private:
      using __base_type = _Node_iterator_base<_Value, __cache>;
      using __node_type = typename __base_type::__node_type;

    public:
      typedef _Value value_type;
      typedef std::ptrdiff_t difference_type;
      typedef std::forward_iterator_tag iterator_category;

      using pointer = typename std::conditional<__constant_iterators,
      const _Value*, _Value*>::type;

      using reference = typename std::conditional<__constant_iterators,
        const _Value&, _Value&>::type;

      _Node_iterator() noexcept
      : __base_type(0) { }

      explicit
      _Node_iterator(__node_type* __p) noexcept
      : __base_type(__p) { }

      reference
      operator*() const noexcept
      { return this->_M_cur->_M_v(); }

      pointer
      operator->() const noexcept
      { return this->_M_cur->_M_valptr(); }

      _Node_iterator&
      operator++() noexcept
      {
 this->_M_incr();
 return *this;
      }

      _Node_iterator
      operator++(int) noexcept
      {
 _Node_iterator __tmp(*this);
 this->_M_incr();
 return __tmp;
      }
    };


  template<typename _Value, bool __constant_iterators, bool __cache>
    struct _Node_const_iterator
    : public _Node_iterator_base<_Value, __cache>
    {
    private:
      using __base_type = _Node_iterator_base<_Value, __cache>;
      using __node_type = typename __base_type::__node_type;

    public:
      typedef _Value value_type;
      typedef std::ptrdiff_t difference_type;
      typedef std::forward_iterator_tag iterator_category;

      typedef const _Value* pointer;
      typedef const _Value& reference;

      _Node_const_iterator() noexcept
      : __base_type(0) { }

      explicit
      _Node_const_iterator(__node_type* __p) noexcept
      : __base_type(__p) { }

      _Node_const_iterator(const _Node_iterator<_Value, __constant_iterators,
      __cache>& __x) noexcept
      : __base_type(__x._M_cur) { }

      reference
      operator*() const noexcept
      { return this->_M_cur->_M_v(); }

      pointer
      operator->() const noexcept
      { return this->_M_cur->_M_valptr(); }

      _Node_const_iterator&
      operator++() noexcept
      {
 this->_M_incr();
 return *this;
      }

      _Node_const_iterator
      operator++(int) noexcept
      {
 _Node_const_iterator __tmp(*this);
 this->_M_incr();
 return __tmp;
      }
    };






  struct _Mod_range_hashing
  {
    typedef std::size_t first_argument_type;
    typedef std::size_t second_argument_type;
    typedef std::size_t result_type;

    result_type
    operator()(first_argument_type __num,
        second_argument_type __den) const noexcept
    { return __num % __den; }
  };






  struct _Default_ranged_hash { };



  struct _Prime_rehash_policy
  {
    using __has_load_factor = true_type;

    _Prime_rehash_policy(float __z = 1.0) noexcept
    : _M_max_load_factor(__z), _M_next_resize(0) { }

    float
    max_load_factor() const noexcept
    { return _M_max_load_factor; }


    std::size_t
    _M_next_bkt(std::size_t __n) const;


    std::size_t
    _M_bkt_for_elements(std::size_t __n) const
    { return __builtin_ceill(__n / (long double)_M_max_load_factor); }





    std::pair<bool, std::size_t>
    _M_need_rehash(std::size_t __n_bkt, std::size_t __n_elt,
     std::size_t __n_ins) const;

    typedef std::size_t _State;

    _State
    _M_state() const
    { return _M_next_resize; }

    void
    _M_reset() noexcept
    { _M_next_resize = 0; }

    void
    _M_reset(_State __state)
    { _M_next_resize = __state; }

    static const std::size_t _S_growth_factor = 2;

    float _M_max_load_factor;
    mutable std::size_t _M_next_resize;
  };


  struct _Mask_range_hashing
  {
    typedef std::size_t first_argument_type;
    typedef std::size_t second_argument_type;
    typedef std::size_t result_type;

    result_type
    operator()(first_argument_type __num,
        second_argument_type __den) const noexcept
    { return __num & (__den - 1); }
  };


  inline std::size_t
  __clp2(std::size_t __n) noexcept
  {

    if (__n < 2)
      return __n;
    const unsigned __lz = sizeof(size_t) > sizeof(long)
      ? __builtin_clzll(__n - 1ull)
      : __builtin_clzl(__n - 1ul);

    return (size_t(1) << (numeric_limits<size_t>::digits - __lz - 1)) << 1;
  }



  struct _Power2_rehash_policy
  {
    using __has_load_factor = true_type;

    _Power2_rehash_policy(float __z = 1.0) noexcept
    : _M_max_load_factor(__z), _M_next_resize(0) { }

    float
    max_load_factor() const noexcept
    { return _M_max_load_factor; }



    std::size_t
    _M_next_bkt(std::size_t __n) noexcept
    {
      if (__n == 0)



 return 1;

      const auto __max_width = std::min<size_t>(sizeof(size_t), 8);
      const auto __max_bkt = size_t(1) << (__max_width * 8 - 1);
      std::size_t __res = __clp2(__n);

      if (__res == 0)
 __res = __max_bkt;
      else if (__res == 1)



 __res = 2;

      if (__res == __max_bkt)



 _M_next_resize = numeric_limits<size_t>::max();
      else
 _M_next_resize
   = __builtin_floorl(__res * (long double)_M_max_load_factor);

      return __res;
    }


    std::size_t
    _M_bkt_for_elements(std::size_t __n) const noexcept
    { return __builtin_ceill(__n / (long double)_M_max_load_factor); }





    std::pair<bool, std::size_t>
    _M_need_rehash(std::size_t __n_bkt, std::size_t __n_elt,
     std::size_t __n_ins) noexcept
    {
      if (__n_elt + __n_ins > _M_next_resize)
 {



   long double __min_bkts
     = std::max<std::size_t>(__n_elt + __n_ins, _M_next_resize ? 0 : 11)
       / (long double)_M_max_load_factor;
   if (__min_bkts >= __n_bkt)
     return { true,
       _M_next_bkt(std::max<std::size_t>(__builtin_floorl(__min_bkts) + 1,
      __n_bkt * _S_growth_factor)) };

   _M_next_resize
     = __builtin_floorl(__n_bkt * (long double)_M_max_load_factor);
   return { false, 0 };
 }
      else
 return { false, 0 };
    }

    typedef std::size_t _State;

    _State
    _M_state() const noexcept
    { return _M_next_resize; }

    void
    _M_reset() noexcept
    { _M_next_resize = 0; }

    void
    _M_reset(_State __state) noexcept
    { _M_next_resize = __state; }

    static const std::size_t _S_growth_factor = 2;

    float _M_max_load_factor;
    std::size_t _M_next_resize;
  };
# 640 "/usr/include/c++/10/bits/hashtable_policy.h" 3
  template<typename _Key, typename _Value, typename _Alloc,
    typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash,
    typename _RehashPolicy, typename _Traits,
    bool _Unique_keys = _Traits::__unique_keys::value>
    struct _Map_base { };


  template<typename _Key, typename _Pair, typename _Alloc, typename _Equal,
    typename _H1, typename _H2, typename _Hash,
    typename _RehashPolicy, typename _Traits>
    struct _Map_base<_Key, _Pair, _Alloc, _Select1st, _Equal,
       _H1, _H2, _Hash, _RehashPolicy, _Traits, false>
    {
      using mapped_type = typename std::tuple_element<1, _Pair>::type;
    };


  template<typename _Key, typename _Pair, typename _Alloc, typename _Equal,
    typename _H1, typename _H2, typename _Hash,
    typename _RehashPolicy, typename _Traits>
    struct _Map_base<_Key, _Pair, _Alloc, _Select1st, _Equal,
       _H1, _H2, _Hash, _RehashPolicy, _Traits, true>
    {
    private:
      using __hashtable_base = __detail::_Hashtable_base<_Key, _Pair,
        _Select1st,
       _Equal, _H1, _H2, _Hash,
         _Traits>;

      using __hashtable = _Hashtable<_Key, _Pair, _Alloc,
         _Select1st, _Equal,
         _H1, _H2, _Hash, _RehashPolicy, _Traits>;

      using __hash_code = typename __hashtable_base::__hash_code;
      using __node_type = typename __hashtable_base::__node_type;

    public:
      using key_type = typename __hashtable_base::key_type;
      using iterator = typename __hashtable_base::iterator;
      using mapped_type = typename std::tuple_element<1, _Pair>::type;

      mapped_type&
      operator[](const key_type& __k);

      mapped_type&
      operator[](key_type&& __k);



      mapped_type&
      at(const key_type& __k);

      const mapped_type&
      at(const key_type& __k) const;
    };

  template<typename _Key, typename _Pair, typename _Alloc, typename _Equal,
    typename _H1, typename _H2, typename _Hash,
    typename _RehashPolicy, typename _Traits>
    auto
    _Map_base<_Key, _Pair, _Alloc, _Select1st, _Equal,
       _H1, _H2, _Hash, _RehashPolicy, _Traits, true>::
    operator[](const key_type& __k)
    -> mapped_type&
    {
      __hashtable* __h = static_cast<__hashtable*>(this);
      __hash_code __code = __h->_M_hash_code(__k);
      std::size_t __bkt = __h->_M_bucket_index(__k, __code);
      if (__node_type* __node = __h->_M_find_node(__bkt, __k, __code))
 return __node->_M_v().second;

      typename __hashtable::_Scoped_node __node {
 __h,
 std::piecewise_construct,
 std::tuple<const key_type&>(__k),
 std::tuple<>()
      };
      auto __pos
 = __h->_M_insert_unique_node(__k, __bkt, __code, __node._M_node);
      __node._M_node = nullptr;
      return __pos->second;
    }

  template<typename _Key, typename _Pair, typename _Alloc, typename _Equal,
    typename _H1, typename _H2, typename _Hash,
    typename _RehashPolicy, typename _Traits>
    auto
    _Map_base<_Key, _Pair, _Alloc, _Select1st, _Equal,
       _H1, _H2, _Hash, _RehashPolicy, _Traits, true>::
    operator[](key_type&& __k)
    -> mapped_type&
    {
      __hashtable* __h = static_cast<__hashtable*>(this);
      __hash_code __code = __h->_M_hash_code(__k);
      std::size_t __bkt = __h->_M_bucket_index(__k, __code);
      if (__node_type* __node = __h->_M_find_node(__bkt, __k, __code))
 return __node->_M_v().second;

      typename __hashtable::_Scoped_node __node {
 __h,
 std::piecewise_construct,
 std::forward_as_tuple(std::move(__k)),
 std::tuple<>()
      };
      auto __pos
 = __h->_M_insert_unique_node(__k, __bkt, __code, __node._M_node);
      __node._M_node = nullptr;
      return __pos->second;
    }

  template<typename _Key, typename _Pair, typename _Alloc, typename _Equal,
    typename _H1, typename _H2, typename _Hash,
    typename _RehashPolicy, typename _Traits>
    auto
    _Map_base<_Key, _Pair, _Alloc, _Select1st, _Equal,
       _H1, _H2, _Hash, _RehashPolicy, _Traits, true>::
    at(const key_type& __k)
    -> mapped_type&
    {
      __hashtable* __h = static_cast<__hashtable*>(this);
      __hash_code __code = __h->_M_hash_code(__k);
      std::size_t __bkt = __h->_M_bucket_index(__k, __code);
      __node_type* __p = __h->_M_find_node(__bkt, __k, __code);

      if (!__p)
 __throw_out_of_range(("_Map_base::at"));
      return __p->_M_v().second;
    }

  template<typename _Key, typename _Pair, typename _Alloc, typename _Equal,
    typename _H1, typename _H2, typename _Hash,
    typename _RehashPolicy, typename _Traits>
    auto
    _Map_base<_Key, _Pair, _Alloc, _Select1st, _Equal,
       _H1, _H2, _Hash, _RehashPolicy, _Traits, true>::
    at(const key_type& __k) const
    -> const mapped_type&
    {
      const __hashtable* __h = static_cast<const __hashtable*>(this);
      __hash_code __code = __h->_M_hash_code(__k);
      std::size_t __bkt = __h->_M_bucket_index(__k, __code);
      __node_type* __p = __h->_M_find_node(__bkt, __k, __code);

      if (!__p)
 __throw_out_of_range(("_Map_base::at"));
      return __p->_M_v().second;
    }






  template<typename _Key, typename _Value, typename _Alloc,
    typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash,
    typename _RehashPolicy, typename _Traits>
    struct _Insert_base
    {
    protected:
      using __hashtable = _Hashtable<_Key, _Value, _Alloc, _ExtractKey,
         _Equal, _H1, _H2, _Hash,
         _RehashPolicy, _Traits>;

      using __hashtable_base = _Hashtable_base<_Key, _Value, _ExtractKey,
            _Equal, _H1, _H2, _Hash,
            _Traits>;

      using value_type = typename __hashtable_base::value_type;
      using iterator = typename __hashtable_base::iterator;
      using const_iterator = typename __hashtable_base::const_iterator;
      using size_type = typename __hashtable_base::size_type;

      using __unique_keys = typename __hashtable_base::__unique_keys;
      using __ireturn_type = typename __hashtable_base::__ireturn_type;
      using __node_type = _Hash_node<_Value, _Traits::__hash_cached::value>;
      using __node_alloc_type = __alloc_rebind<_Alloc, __node_type>;
      using __node_gen_type = _AllocNode<__node_alloc_type>;

      __hashtable&
      _M_conjure_hashtable()
      { return *(static_cast<__hashtable*>(this)); }

      template<typename _InputIterator, typename _NodeGetter>
 void
 _M_insert_range(_InputIterator __first, _InputIterator __last,
   const _NodeGetter&, true_type);

      template<typename _InputIterator, typename _NodeGetter>
 void
 _M_insert_range(_InputIterator __first, _InputIterator __last,
   const _NodeGetter&, false_type);

    public:
      __ireturn_type
      insert(const value_type& __v)
      {
 __hashtable& __h = _M_conjure_hashtable();
 __node_gen_type __node_gen(__h);
 return __h._M_insert(__v, __node_gen, __unique_keys());
      }

      iterator
      insert(const_iterator __hint, const value_type& __v)
      {
 __hashtable& __h = _M_conjure_hashtable();
 __node_gen_type __node_gen(__h);
 return __h._M_insert(__hint, __v, __node_gen, __unique_keys());
      }

      void
      insert(initializer_list<value_type> __l)
      { this->insert(__l.begin(), __l.end()); }

      template<typename _InputIterator>
 void
 insert(_InputIterator __first, _InputIterator __last)
 {
   __hashtable& __h = _M_conjure_hashtable();
   __node_gen_type __node_gen(__h);
   return _M_insert_range(__first, __last, __node_gen, __unique_keys());
 }
    };

  template<typename _Key, typename _Value, typename _Alloc,
    typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash,
    typename _RehashPolicy, typename _Traits>
    template<typename _InputIterator, typename _NodeGetter>
      void
      _Insert_base<_Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash,
      _RehashPolicy, _Traits>::
      _M_insert_range(_InputIterator __first, _InputIterator __last,
        const _NodeGetter& __node_gen, true_type)
      {
 size_type __n_elt = __detail::__distance_fw(__first, __last);
 if (__n_elt == 0)
   return;

 __hashtable& __h = _M_conjure_hashtable();
 for (; __first != __last; ++__first)
   {
     if (__h._M_insert(*__first, __node_gen, __unique_keys(),
         __n_elt).second)
       __n_elt = 1;
     else if (__n_elt != 1)
       --__n_elt;
   }
      }

  template<typename _Key, typename _Value, typename _Alloc,
    typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash,
    typename _RehashPolicy, typename _Traits>
    template<typename _InputIterator, typename _NodeGetter>
      void
      _Insert_base<_Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash,
      _RehashPolicy, _Traits>::
      _M_insert_range(_InputIterator __first, _InputIterator __last,
        const _NodeGetter& __node_gen, false_type)
      {
 using __rehash_type = typename __hashtable::__rehash_type;
 using __rehash_state = typename __hashtable::__rehash_state;
 using pair_type = std::pair<bool, std::size_t>;

 size_type __n_elt = __detail::__distance_fw(__first, __last);
 if (__n_elt == 0)
   return;

 __hashtable& __h = _M_conjure_hashtable();
 __rehash_type& __rehash = __h._M_rehash_policy;
 const __rehash_state& __saved_state = __rehash._M_state();
 pair_type __do_rehash = __rehash._M_need_rehash(__h._M_bucket_count,
       __h._M_element_count,
       __n_elt);

 if (__do_rehash.first)
   __h._M_rehash(__do_rehash.second, __saved_state);

 for (; __first != __last; ++__first)
   __h._M_insert(*__first, __node_gen, __unique_keys());
      }







  template<typename _Key, typename _Value, typename _Alloc,
    typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash,
    typename _RehashPolicy, typename _Traits,
    bool _Constant_iterators = _Traits::__constant_iterators::value>
    struct _Insert;


  template<typename _Key, typename _Value, typename _Alloc,
    typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash,
    typename _RehashPolicy, typename _Traits>
    struct _Insert<_Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash,
     _RehashPolicy, _Traits, true>
    : public _Insert_base<_Key, _Value, _Alloc, _ExtractKey, _Equal,
      _H1, _H2, _Hash, _RehashPolicy, _Traits>
    {
      using __base_type = _Insert_base<_Key, _Value, _Alloc, _ExtractKey,
     _Equal, _H1, _H2, _Hash,
     _RehashPolicy, _Traits>;

      using __hashtable_base = _Hashtable_base<_Key, _Value, _ExtractKey,
            _Equal, _H1, _H2, _Hash,
            _Traits>;

      using value_type = typename __base_type::value_type;
      using iterator = typename __base_type::iterator;
      using const_iterator = typename __base_type::const_iterator;

      using __unique_keys = typename __base_type::__unique_keys;
      using __ireturn_type = typename __hashtable_base::__ireturn_type;
      using __hashtable = typename __base_type::__hashtable;
      using __node_gen_type = typename __base_type::__node_gen_type;

      using __base_type::insert;

      __ireturn_type
      insert(value_type&& __v)
      {
 __hashtable& __h = this->_M_conjure_hashtable();
 __node_gen_type __node_gen(__h);
 return __h._M_insert(std::move(__v), __node_gen, __unique_keys());
      }

      iterator
      insert(const_iterator __hint, value_type&& __v)
      {
 __hashtable& __h = this->_M_conjure_hashtable();
 __node_gen_type __node_gen(__h);
 return __h._M_insert(__hint, std::move(__v), __node_gen,
        __unique_keys());
      }
    };


  template<typename _Key, typename _Value, typename _Alloc,
    typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash,
    typename _RehashPolicy, typename _Traits>
    struct _Insert<_Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash,
     _RehashPolicy, _Traits, false>
    : public _Insert_base<_Key, _Value, _Alloc, _ExtractKey, _Equal,
      _H1, _H2, _Hash, _RehashPolicy, _Traits>
    {
      using __base_type = _Insert_base<_Key, _Value, _Alloc, _ExtractKey,
           _Equal, _H1, _H2, _Hash,
           _RehashPolicy, _Traits>;
      using value_type = typename __base_type::value_type;
      using iterator = typename __base_type::iterator;
      using const_iterator = typename __base_type::const_iterator;

      using __unique_keys = typename __base_type::__unique_keys;
      using __hashtable = typename __base_type::__hashtable;
      using __ireturn_type = typename __base_type::__ireturn_type;

      using __base_type::insert;

      template<typename _Pair>
 using __is_cons = std::is_constructible<value_type, _Pair&&>;

      template<typename _Pair>
 using _IFcons = std::enable_if<__is_cons<_Pair>::value>;

      template<typename _Pair>
 using _IFconsp = typename _IFcons<_Pair>::type;

      template<typename _Pair, typename = _IFconsp<_Pair>>
 __ireturn_type
 insert(_Pair&& __v)
 {
   __hashtable& __h = this->_M_conjure_hashtable();
   return __h._M_emplace(__unique_keys(), std::forward<_Pair>(__v));
 }

      template<typename _Pair, typename = _IFconsp<_Pair>>
 iterator
 insert(const_iterator __hint, _Pair&& __v)
 {
   __hashtable& __h = this->_M_conjure_hashtable();
   return __h._M_emplace(__hint, __unique_keys(),
    std::forward<_Pair>(__v));
 }
   };

  template<typename _Policy>
    using __has_load_factor = typename _Policy::__has_load_factor;







  template<typename _Key, typename _Value, typename _Alloc,
    typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash,
    typename _RehashPolicy, typename _Traits,
    typename =
      __detected_or_t<false_type, __has_load_factor, _RehashPolicy>>
    struct _Rehash_base;


  template<typename _Key, typename _Value, typename _Alloc,
    typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash,
    typename _RehashPolicy, typename _Traits>
    struct _Rehash_base<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        _H1, _H2, _Hash, _RehashPolicy, _Traits,
        false_type>
    {
    };


  template<typename _Key, typename _Value, typename _Alloc,
    typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash,
    typename _RehashPolicy, typename _Traits>
    struct _Rehash_base<_Key, _Value, _Alloc, _ExtractKey, _Equal,
   _H1, _H2, _Hash, _RehashPolicy, _Traits,
   true_type>
    {
      using __hashtable = _Hashtable<_Key, _Value, _Alloc, _ExtractKey,
         _Equal, _H1, _H2, _Hash,
         _RehashPolicy, _Traits>;

      float
      max_load_factor() const noexcept
      {
 const __hashtable* __this = static_cast<const __hashtable*>(this);
 return __this->__rehash_policy().max_load_factor();
      }

      void
      max_load_factor(float __z)
      {
 __hashtable* __this = static_cast<__hashtable*>(this);
 __this->__rehash_policy(_RehashPolicy(__z));
      }

      void
      reserve(std::size_t __n)
      {
 __hashtable* __this = static_cast<__hashtable*>(this);
 __this->rehash(__this->__rehash_policy()._M_bkt_for_elements(__n));
      }
    };







  template<int _Nm, typename _Tp,
    bool __use_ebo = !__is_final(_Tp) && __is_empty(_Tp)>
    struct _Hashtable_ebo_helper;


  template<int _Nm, typename _Tp>
    struct _Hashtable_ebo_helper<_Nm, _Tp, true>
    : private _Tp
    {
      _Hashtable_ebo_helper() noexcept(noexcept(_Tp())) : _Tp() { }

      template<typename _OtherTp>
 _Hashtable_ebo_helper(_OtherTp&& __tp)
 : _Tp(std::forward<_OtherTp>(__tp))
 { }

      const _Tp& _M_cget() const { return static_cast<const _Tp&>(*this); }
      _Tp& _M_get() { return static_cast<_Tp&>(*this); }
    };


  template<int _Nm, typename _Tp>
    struct _Hashtable_ebo_helper<_Nm, _Tp, false>
    {
      _Hashtable_ebo_helper() = default;

      template<typename _OtherTp>
 _Hashtable_ebo_helper(_OtherTp&& __tp)
 : _M_tp(std::forward<_OtherTp>(__tp))
 { }

      const _Tp& _M_cget() const { return _M_tp; }
      _Tp& _M_get() { return _M_tp; }

    private:
      _Tp _M_tp{};
    };







  template<typename _Key, typename _Value, typename _ExtractKey,
    typename _H1, typename _H2, typename _Hash,
    bool __cache_hash_code>
    struct _Local_iterator_base;
# 1172 "/usr/include/c++/10/bits/hashtable_policy.h" 3
  template<typename _Key, typename _Value, typename _ExtractKey,
    typename _H1, typename _H2, typename _Hash,
    bool __cache_hash_code>
    struct _Hash_code_base;



  template<typename _Key, typename _Value, typename _ExtractKey,
    typename _H1, typename _H2, typename _Hash>
    struct _Hash_code_base<_Key, _Value, _ExtractKey, _H1, _H2, _Hash, false>
    : private _Hashtable_ebo_helper<0, _ExtractKey>,
      private _Hashtable_ebo_helper<1, _Hash>
    {
    private:
      using __ebo_extract_key = _Hashtable_ebo_helper<0, _ExtractKey>;
      using __ebo_hash = _Hashtable_ebo_helper<1, _Hash>;

    protected:
      typedef void* __hash_code;
      typedef _Hash_node<_Value, false> __node_type;



      _Hash_code_base() = default;

      _Hash_code_base(const _ExtractKey& __ex, const _H1&, const _H2&,
        const _Hash& __h)
      : __ebo_extract_key(__ex), __ebo_hash(__h) { }

      __hash_code
      _M_hash_code(const _Key& __key) const
      { return 0; }

      std::size_t
      _M_bucket_index(const _Key& __k, __hash_code,
        std::size_t __bkt_count) const
      { return _M_ranged_hash()(__k, __bkt_count); }

      std::size_t
      _M_bucket_index(const __node_type* __p, std::size_t __bkt_count) const
 noexcept( noexcept(declval<const _Hash&>()(declval<const _Key&>(),
         (std::size_t)0)) )
      { return _M_ranged_hash()(_M_extract()(__p->_M_v()), __bkt_count); }

      void
      _M_store_code(__node_type*, __hash_code) const
      { }

      void
      _M_copy_code(__node_type*, const __node_type*) const
      { }

      void
      _M_swap(_Hash_code_base& __x)
      {
 std::swap(__ebo_extract_key::_M_get(),
    __x.__ebo_extract_key::_M_get());
 std::swap(__ebo_hash::_M_get(), __x.__ebo_hash::_M_get());
      }

      const _ExtractKey&
      _M_extract() const { return __ebo_extract_key::_M_cget(); }

      const _Hash&
      _M_ranged_hash() const { return __ebo_hash::_M_cget(); }
    };







  template<typename _Key, typename _Value, typename _ExtractKey,
    typename _H1, typename _H2, typename _Hash>
    struct _Hash_code_base<_Key, _Value, _ExtractKey, _H1, _H2, _Hash, true>;




  template<typename _Key, typename _Value, typename _ExtractKey,
    typename _H1, typename _H2>
    struct _Hash_code_base<_Key, _Value, _ExtractKey, _H1, _H2,
      _Default_ranged_hash, false>
    : private _Hashtable_ebo_helper<0, _ExtractKey>,
      private _Hashtable_ebo_helper<1, _H1>,
      private _Hashtable_ebo_helper<2, _H2>
    {
    private:
      using __ebo_extract_key = _Hashtable_ebo_helper<0, _ExtractKey>;
      using __ebo_h1 = _Hashtable_ebo_helper<1, _H1>;
      using __ebo_h2 = _Hashtable_ebo_helper<2, _H2>;


      friend struct _Local_iterator_base<_Key, _Value, _ExtractKey, _H1, _H2,
      _Default_ranged_hash, false>;

    public:
      typedef _H1 hasher;

      hasher
      hash_function() const
      { return _M_h1(); }

    protected:
      typedef std::size_t __hash_code;
      typedef _Hash_node<_Value, false> __node_type;



      _Hash_code_base() = default;

      _Hash_code_base(const _ExtractKey& __ex,
        const _H1& __h1, const _H2& __h2,
        const _Default_ranged_hash&)
      : __ebo_extract_key(__ex), __ebo_h1(__h1), __ebo_h2(__h2) { }

      __hash_code
      _M_hash_code(const _Key& __k) const
      {
 static_assert(__is_invocable<const _H1&, const _Key&>{},
     "hash function must be invocable with an argument of key type");
 return _M_h1()(__k);
      }

      std::size_t
      _M_bucket_index(const _Key&, __hash_code __c,
        std::size_t __bkt_count) const
      { return _M_h2()(__c, __bkt_count); }

      std::size_t
      _M_bucket_index(const __node_type* __p, std::size_t __bkt_count) const
 noexcept( noexcept(declval<const _H1&>()(declval<const _Key&>()))
    && noexcept(declval<const _H2&>()((__hash_code)0,
          (std::size_t)0)) )
      { return _M_h2()(_M_h1()(_M_extract()(__p->_M_v())), __bkt_count); }

      void
      _M_store_code(__node_type*, __hash_code) const
      { }

      void
      _M_copy_code(__node_type*, const __node_type*) const
      { }

      void
      _M_swap(_Hash_code_base& __x)
      {
 std::swap(__ebo_extract_key::_M_get(),
    __x.__ebo_extract_key::_M_get());
 std::swap(__ebo_h1::_M_get(), __x.__ebo_h1::_M_get());
 std::swap(__ebo_h2::_M_get(), __x.__ebo_h2::_M_get());
      }

      const _ExtractKey&
      _M_extract() const { return __ebo_extract_key::_M_cget(); }

      const _H1&
      _M_h1() const { return __ebo_h1::_M_cget(); }

      const _H2&
      _M_h2() const { return __ebo_h2::_M_cget(); }
    };




  template<typename _Key, typename _Value, typename _ExtractKey,
    typename _H1, typename _H2>
    struct _Hash_code_base<_Key, _Value, _ExtractKey, _H1, _H2,
      _Default_ranged_hash, true>
    : private _Hashtable_ebo_helper<0, _ExtractKey>,
      private _Hashtable_ebo_helper<1, _H1>,
      private _Hashtable_ebo_helper<2, _H2>
    {
    private:

      friend struct _Local_iterator_base<_Key, _Value, _ExtractKey, _H1, _H2,
      _Default_ranged_hash, true>;

      using __ebo_extract_key = _Hashtable_ebo_helper<0, _ExtractKey>;
      using __ebo_h1 = _Hashtable_ebo_helper<1, _H1>;
      using __ebo_h2 = _Hashtable_ebo_helper<2, _H2>;

    public:
      typedef _H1 hasher;

      hasher
      hash_function() const
      { return _M_h1(); }

    protected:
      typedef std::size_t __hash_code;
      typedef _Hash_node<_Value, true> __node_type;


      _Hash_code_base() = default;
      _Hash_code_base(const _ExtractKey& __ex,
        const _H1& __h1, const _H2& __h2,
        const _Default_ranged_hash&)
      : __ebo_extract_key(__ex), __ebo_h1(__h1), __ebo_h2(__h2) { }

      __hash_code
      _M_hash_code(const _Key& __k) const
      {
 static_assert(__is_invocable<const _H1&, const _Key&>{},
     "hash function must be invocable with an argument of key type");
 return _M_h1()(__k);
      }

      std::size_t
      _M_bucket_index(const _Key&, __hash_code __c,
        std::size_t __bkt_count) const
      { return _M_h2()(__c, __bkt_count); }

      std::size_t
      _M_bucket_index(const __node_type* __p, std::size_t __bkt_count) const
 noexcept( noexcept(declval<const _H2&>()((__hash_code)0,
       (std::size_t)0)) )
      { return _M_h2()(__p->_M_hash_code, __bkt_count); }

      void
      _M_store_code(__node_type* __n, __hash_code __c) const
      { __n->_M_hash_code = __c; }

      void
      _M_copy_code(__node_type* __to, const __node_type* __from) const
      { __to->_M_hash_code = __from->_M_hash_code; }

      void
      _M_swap(_Hash_code_base& __x)
      {
 std::swap(__ebo_extract_key::_M_get(),
    __x.__ebo_extract_key::_M_get());
 std::swap(__ebo_h1::_M_get(), __x.__ebo_h1::_M_get());
 std::swap(__ebo_h2::_M_get(), __x.__ebo_h2::_M_get());
      }

      const _ExtractKey&
      _M_extract() const { return __ebo_extract_key::_M_cget(); }

      const _H1&
      _M_h1() const { return __ebo_h1::_M_cget(); }

      const _H2&
      _M_h2() const { return __ebo_h2::_M_cget(); }
    };


  template<typename _Key, typename _Value, typename _ExtractKey,
    typename _H1, typename _H2, typename _Hash>
    struct _Local_iterator_base<_Key, _Value, _ExtractKey,
    _H1, _H2, _Hash, true>
    : private _Hashtable_ebo_helper<0, _H2>
    {
    protected:
      using __base_type = _Hashtable_ebo_helper<0, _H2>;
      using __hash_code_base = _Hash_code_base<_Key, _Value, _ExtractKey,
            _H1, _H2, _Hash, true>;

      _Local_iterator_base() = default;
      _Local_iterator_base(const __hash_code_base& __base,
      _Hash_node<_Value, true>* __p,
      std::size_t __bkt, std::size_t __bkt_count)
      : __base_type(__base._M_h2()),
 _M_cur(__p), _M_bucket(__bkt), _M_bucket_count(__bkt_count) { }

      void
      _M_incr()
      {
 _M_cur = _M_cur->_M_next();
 if (_M_cur)
   {
     std::size_t __bkt
       = __base_type::_M_get()(_M_cur->_M_hash_code,
        _M_bucket_count);
     if (__bkt != _M_bucket)
       _M_cur = nullptr;
   }
      }

      _Hash_node<_Value, true>* _M_cur;
      std::size_t _M_bucket;
      std::size_t _M_bucket_count;

    public:
      const void*
      _M_curr() const { return _M_cur; }

      std::size_t
      _M_get_bucket() const { return _M_bucket; }
    };





  template<typename _Tp, bool _IsEmpty = std::is_empty<_Tp>::value>
    struct _Hash_code_storage
    {
      __gnu_cxx::__aligned_buffer<_Tp> _M_storage;

      _Tp*
      _M_h() { return _M_storage._M_ptr(); }

      const _Tp*
      _M_h() const { return _M_storage._M_ptr(); }
    };


  template<typename _Tp>
    struct _Hash_code_storage<_Tp, true>
    {
      static_assert( std::is_empty<_Tp>::value, "Type must be empty" );



      _Tp*
      _M_h() { return reinterpret_cast<_Tp*>(this); }

      const _Tp*
      _M_h() const { return reinterpret_cast<const _Tp*>(this); }
    };

  template<typename _Key, typename _Value, typename _ExtractKey,
    typename _H1, typename _H2, typename _Hash>
    using __hash_code_for_local_iter
      = _Hash_code_storage<_Hash_code_base<_Key, _Value, _ExtractKey,
        _H1, _H2, _Hash, false>>;


  template<typename _Key, typename _Value, typename _ExtractKey,
    typename _H1, typename _H2, typename _Hash>
    struct _Local_iterator_base<_Key, _Value, _ExtractKey,
    _H1, _H2, _Hash, false>
    : __hash_code_for_local_iter<_Key, _Value, _ExtractKey, _H1, _H2, _Hash>
    {
    protected:
      using __hash_code_base = _Hash_code_base<_Key, _Value, _ExtractKey,
            _H1, _H2, _Hash, false>;

      _Local_iterator_base() : _M_bucket_count(-1) { }

      _Local_iterator_base(const __hash_code_base& __base,
      _Hash_node<_Value, false>* __p,
      std::size_t __bkt, std::size_t __bkt_count)
      : _M_cur(__p), _M_bucket(__bkt), _M_bucket_count(__bkt_count)
      { _M_init(__base); }

      ~_Local_iterator_base()
      {
 if (_M_bucket_count != -1)
   _M_destroy();
      }

      _Local_iterator_base(const _Local_iterator_base& __iter)
      : _M_cur(__iter._M_cur), _M_bucket(__iter._M_bucket),
        _M_bucket_count(__iter._M_bucket_count)
      {
 if (_M_bucket_count != -1)
   _M_init(*__iter._M_h());
      }

      _Local_iterator_base&
      operator=(const _Local_iterator_base& __iter)
      {
 if (_M_bucket_count != -1)
   _M_destroy();
 _M_cur = __iter._M_cur;
 _M_bucket = __iter._M_bucket;
 _M_bucket_count = __iter._M_bucket_count;
 if (_M_bucket_count != -1)
   _M_init(*__iter._M_h());
 return *this;
      }

      void
      _M_incr()
      {
 _M_cur = _M_cur->_M_next();
 if (_M_cur)
   {
     std::size_t __bkt = this->_M_h()->_M_bucket_index(_M_cur,
             _M_bucket_count);
     if (__bkt != _M_bucket)
       _M_cur = nullptr;
   }
      }

      _Hash_node<_Value, false>* _M_cur;
      std::size_t _M_bucket;
      std::size_t _M_bucket_count;

      void
      _M_init(const __hash_code_base& __base)
      { ::new(this->_M_h()) __hash_code_base(__base); }

      void
      _M_destroy() { this->_M_h()->~__hash_code_base(); }

    public:
      const void*
      _M_curr() const { return _M_cur; }

      std::size_t
      _M_get_bucket() const { return _M_bucket; }
    };

  template<typename _Key, typename _Value, typename _ExtractKey,
    typename _H1, typename _H2, typename _Hash, bool __cache>
    inline bool
    operator==(const _Local_iterator_base<_Key, _Value, _ExtractKey,
       _H1, _H2, _Hash, __cache>& __x,
        const _Local_iterator_base<_Key, _Value, _ExtractKey,
       _H1, _H2, _Hash, __cache>& __y)
    { return __x._M_curr() == __y._M_curr(); }

  template<typename _Key, typename _Value, typename _ExtractKey,
    typename _H1, typename _H2, typename _Hash, bool __cache>
    inline bool
    operator!=(const _Local_iterator_base<_Key, _Value, _ExtractKey,
       _H1, _H2, _Hash, __cache>& __x,
        const _Local_iterator_base<_Key, _Value, _ExtractKey,
       _H1, _H2, _Hash, __cache>& __y)
    { return __x._M_curr() != __y._M_curr(); }


  template<typename _Key, typename _Value, typename _ExtractKey,
    typename _H1, typename _H2, typename _Hash,
    bool __constant_iterators, bool __cache>
    struct _Local_iterator
    : public _Local_iterator_base<_Key, _Value, _ExtractKey,
      _H1, _H2, _Hash, __cache>
    {
    private:
      using __base_type = _Local_iterator_base<_Key, _Value, _ExtractKey,
            _H1, _H2, _Hash, __cache>;
      using __hash_code_base = typename __base_type::__hash_code_base;
    public:
      typedef _Value value_type;
      typedef typename std::conditional<__constant_iterators,
     const _Value*, _Value*>::type
             pointer;
      typedef typename std::conditional<__constant_iterators,
     const _Value&, _Value&>::type
             reference;
      typedef std::ptrdiff_t difference_type;
      typedef std::forward_iterator_tag iterator_category;

      _Local_iterator() = default;

      _Local_iterator(const __hash_code_base& __base,
        _Hash_node<_Value, __cache>* __n,
        std::size_t __bkt, std::size_t __bkt_count)
      : __base_type(__base, __n, __bkt, __bkt_count)
      { }

      reference
      operator*() const
      { return this->_M_cur->_M_v(); }

      pointer
      operator->() const
      { return this->_M_cur->_M_valptr(); }

      _Local_iterator&
      operator++()
      {
 this->_M_incr();
 return *this;
      }

      _Local_iterator
      operator++(int)
      {
 _Local_iterator __tmp(*this);
 this->_M_incr();
 return __tmp;
      }
    };


  template<typename _Key, typename _Value, typename _ExtractKey,
    typename _H1, typename _H2, typename _Hash,
    bool __constant_iterators, bool __cache>
    struct _Local_const_iterator
    : public _Local_iterator_base<_Key, _Value, _ExtractKey,
      _H1, _H2, _Hash, __cache>
    {
    private:
      using __base_type = _Local_iterator_base<_Key, _Value, _ExtractKey,
            _H1, _H2, _Hash, __cache>;
      using __hash_code_base = typename __base_type::__hash_code_base;

    public:
      typedef _Value value_type;
      typedef const _Value* pointer;
      typedef const _Value& reference;
      typedef std::ptrdiff_t difference_type;
      typedef std::forward_iterator_tag iterator_category;

      _Local_const_iterator() = default;

      _Local_const_iterator(const __hash_code_base& __base,
       _Hash_node<_Value, __cache>* __n,
       std::size_t __bkt, std::size_t __bkt_count)
      : __base_type(__base, __n, __bkt, __bkt_count)
      { }

      _Local_const_iterator(const _Local_iterator<_Key, _Value, _ExtractKey,
        _H1, _H2, _Hash,
        __constant_iterators,
        __cache>& __x)
      : __base_type(__x)
      { }

      reference
      operator*() const
      { return this->_M_cur->_M_v(); }

      pointer
      operator->() const
      { return this->_M_cur->_M_valptr(); }

      _Local_const_iterator&
      operator++()
      {
 this->_M_incr();
 return *this;
      }

      _Local_const_iterator
      operator++(int)
      {
 _Local_const_iterator __tmp(*this);
 this->_M_incr();
 return __tmp;
      }
    };
# 1722 "/usr/include/c++/10/bits/hashtable_policy.h" 3
  template<typename _Key, typename _Value,
    typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _Traits>
  struct _Hashtable_base
  : public _Hash_code_base<_Key, _Value, _ExtractKey, _H1, _H2, _Hash,
      _Traits::__hash_cached::value>,
    private _Hashtable_ebo_helper<0, _Equal>
  {
  public:
    typedef _Key key_type;
    typedef _Value value_type;
    typedef _Equal key_equal;
    typedef std::size_t size_type;
    typedef std::ptrdiff_t difference_type;

    using __traits_type = _Traits;
    using __hash_cached = typename __traits_type::__hash_cached;
    using __constant_iterators = typename __traits_type::__constant_iterators;
    using __unique_keys = typename __traits_type::__unique_keys;

    using __hash_code_base = _Hash_code_base<_Key, _Value, _ExtractKey,
          _H1, _H2, _Hash,
          __hash_cached::value>;

    using __hash_code = typename __hash_code_base::__hash_code;
    using __node_type = typename __hash_code_base::__node_type;

    using iterator = __detail::_Node_iterator<value_type,
           __constant_iterators::value,
           __hash_cached::value>;

    using const_iterator = __detail::_Node_const_iterator<value_type,
         __constant_iterators::value,
         __hash_cached::value>;

    using local_iterator = __detail::_Local_iterator<key_type, value_type,
        _ExtractKey, _H1, _H2, _Hash,
        __constant_iterators::value,
           __hash_cached::value>;

    using const_local_iterator = __detail::_Local_const_iterator<key_type,
         value_type,
     _ExtractKey, _H1, _H2, _Hash,
     __constant_iterators::value,
     __hash_cached::value>;

    using __ireturn_type = typename std::conditional<__unique_keys::value,
           std::pair<iterator, bool>,
           iterator>::type;
  private:
    using _EqualEBO = _Hashtable_ebo_helper<0, _Equal>;

    template<typename _NodeT>
      struct _Equal_hash_code
      {
       static bool
       _S_equals(__hash_code, const _NodeT&)
       { return true; }
      };

    template<typename _Ptr2>
      struct _Equal_hash_code<_Hash_node<_Ptr2, true>>
      {
       static bool
       _S_equals(__hash_code __c, const _Hash_node<_Ptr2, true>& __n)
       { return __c == __n._M_hash_code; }
      };

  protected:
    _Hashtable_base() = default;

    _Hashtable_base(const _ExtractKey& __ex, const _H1& __h1, const _H2& __h2,
      const _Hash& __hash, const _Equal& __eq)
    : __hash_code_base(__ex, __h1, __h2, __hash), _EqualEBO(__eq)
    { }

    bool
    _M_equals(const _Key& __k, __hash_code __c, __node_type* __n) const
    {
      static_assert(__is_invocable<const _Equal&, const _Key&, const _Key&>{},
   "key equality predicate must be invocable with two arguments of "
   "key type");
      return _Equal_hash_code<__node_type>::_S_equals(__c, *__n)
 && _M_eq()(__k, this->_M_extract()(__n->_M_v()));
    }

    void
    _M_swap(_Hashtable_base& __x)
    {
      __hash_code_base::_M_swap(__x);
      std::swap(_EqualEBO::_M_get(), __x._EqualEBO::_M_get());
    }

    const _Equal&
    _M_eq() const { return _EqualEBO::_M_cget(); }
  };
# 1827 "/usr/include/c++/10/bits/hashtable_policy.h" 3
  template<typename _Key, typename _Value, typename _Alloc,
    typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash,
    typename _RehashPolicy, typename _Traits,
    bool _Unique_keys = _Traits::__unique_keys::value>
    struct _Equality;


  template<typename _Key, typename _Value, typename _Alloc,
    typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash,
    typename _RehashPolicy, typename _Traits>
    struct _Equality<_Key, _Value, _Alloc, _ExtractKey, _Equal,
       _H1, _H2, _Hash, _RehashPolicy, _Traits, true>
    {
      using __hashtable = _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
         _H1, _H2, _Hash, _RehashPolicy, _Traits>;

      bool
      _M_equal(const __hashtable&) const;
    };

  template<typename _Key, typename _Value, typename _Alloc,
    typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash,
    typename _RehashPolicy, typename _Traits>
    bool
    _Equality<_Key, _Value, _Alloc, _ExtractKey, _Equal,
       _H1, _H2, _Hash, _RehashPolicy, _Traits, true>::
    _M_equal(const __hashtable& __other) const
    {
      using __node_base = typename __hashtable::__node_base;
      using __node_type = typename __hashtable::__node_type;
      const __hashtable* __this = static_cast<const __hashtable*>(this);
      if (__this->size() != __other.size())
 return false;

      for (auto __itx = __this->begin(); __itx != __this->end(); ++__itx)
 {
   std::size_t __ybkt = __other._M_bucket_index(__itx._M_cur);
   __node_base* __prev_n = __other._M_buckets[__ybkt];
   if (!__prev_n)
     return false;

   for (__node_type* __n = static_cast<__node_type*>(__prev_n->_M_nxt);;
        __n = __n->_M_next())
     {
       if (__n->_M_v() == *__itx)
  break;

       if (!__n->_M_nxt
    || __other._M_bucket_index(__n->_M_next()) != __ybkt)
  return false;
     }
 }

      return true;
    }


  template<typename _Key, typename _Value, typename _Alloc,
    typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash,
    typename _RehashPolicy, typename _Traits>
    struct _Equality<_Key, _Value, _Alloc, _ExtractKey, _Equal,
       _H1, _H2, _Hash, _RehashPolicy, _Traits, false>
    {
      using __hashtable = _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
         _H1, _H2, _Hash, _RehashPolicy, _Traits>;

      bool
      _M_equal(const __hashtable&) const;
    };

  template<typename _Key, typename _Value, typename _Alloc,
    typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash,
    typename _RehashPolicy, typename _Traits>
    bool
    _Equality<_Key, _Value, _Alloc, _ExtractKey, _Equal,
       _H1, _H2, _Hash, _RehashPolicy, _Traits, false>::
    _M_equal(const __hashtable& __other) const
    {
      using __node_base = typename __hashtable::__node_base;
      using __node_type = typename __hashtable::__node_type;
      const __hashtable* __this = static_cast<const __hashtable*>(this);
      if (__this->size() != __other.size())
 return false;

      for (auto __itx = __this->begin(); __itx != __this->end();)
 {
   std::size_t __x_count = 1;
   auto __itx_end = __itx;
   for (++__itx_end; __itx_end != __this->end()
   && __this->key_eq()(_ExtractKey()(*__itx),
         _ExtractKey()(*__itx_end));
        ++__itx_end)
     ++__x_count;

   std::size_t __ybkt = __other._M_bucket_index(__itx._M_cur);
   __node_base* __y_prev_n = __other._M_buckets[__ybkt];
   if (!__y_prev_n)
     return false;

   __node_type* __y_n = static_cast<__node_type*>(__y_prev_n->_M_nxt);
   for (;; __y_n = __y_n->_M_next())
     {
       if (__this->key_eq()(_ExtractKey()(__y_n->_M_v()),
       _ExtractKey()(*__itx)))
  break;

       if (!__y_n->_M_nxt
    || __other._M_bucket_index(__y_n->_M_next()) != __ybkt)
  return false;
     }

   typename __hashtable::const_iterator __ity(__y_n);
   for (auto __ity_end = __ity; __ity_end != __other.end(); ++__ity_end)
     if (--__x_count == 0)
       break;

   if (__x_count != 0)
     return false;

   if (!std::is_permutation(__itx, __itx_end, __ity))
     return false;

   __itx = __itx_end;
 }
      return true;
    }





  template<typename _NodeAlloc>
    struct _Hashtable_alloc : private _Hashtable_ebo_helper<0, _NodeAlloc>
    {
    private:
      using __ebo_node_alloc = _Hashtable_ebo_helper<0, _NodeAlloc>;
    public:
      using __node_type = typename _NodeAlloc::value_type;
      using __node_alloc_type = _NodeAlloc;

      using __node_alloc_traits = __gnu_cxx::__alloc_traits<__node_alloc_type>;

      using __value_alloc_traits = typename __node_alloc_traits::template
 rebind_traits<typename __node_type::value_type>;

      using __node_base = __detail::_Hash_node_base;
      using __bucket_type = __node_base*;
      using __bucket_alloc_type =
 __alloc_rebind<__node_alloc_type, __bucket_type>;
      using __bucket_alloc_traits = std::allocator_traits<__bucket_alloc_type>;

      _Hashtable_alloc() = default;
      _Hashtable_alloc(const _Hashtable_alloc&) = default;
      _Hashtable_alloc(_Hashtable_alloc&&) = default;

      template<typename _Alloc>
 _Hashtable_alloc(_Alloc&& __a)
 : __ebo_node_alloc(std::forward<_Alloc>(__a))
 { }

      __node_alloc_type&
      _M_node_allocator()
      { return __ebo_node_alloc::_M_get(); }

      const __node_alloc_type&
      _M_node_allocator() const
      { return __ebo_node_alloc::_M_cget(); }


      template<typename... _Args>
 __node_type*
 _M_allocate_node(_Args&&... __args);


      void
      _M_deallocate_node(__node_type* __n);


      void
      _M_deallocate_node_ptr(__node_type* __n);



      void
      _M_deallocate_nodes(__node_type* __n);

      __bucket_type*
      _M_allocate_buckets(std::size_t __bkt_count);

      void
      _M_deallocate_buckets(__bucket_type*, std::size_t __bkt_count);
    };



  template<typename _NodeAlloc>
    template<typename... _Args>
      auto
      _Hashtable_alloc<_NodeAlloc>::_M_allocate_node(_Args&&... __args)
      -> __node_type*
      {
 auto __nptr = __node_alloc_traits::allocate(_M_node_allocator(), 1);
 __node_type* __n = std::__to_address(__nptr);
 try
   {
     ::new ((void*)__n) __node_type;
     __node_alloc_traits::construct(_M_node_allocator(),
        __n->_M_valptr(),
        std::forward<_Args>(__args)...);
     return __n;
   }
 catch(...)
   {
     __node_alloc_traits::deallocate(_M_node_allocator(), __nptr, 1);
     throw;
   }
      }

  template<typename _NodeAlloc>
    void
    _Hashtable_alloc<_NodeAlloc>::_M_deallocate_node(__node_type* __n)
    {
      __node_alloc_traits::destroy(_M_node_allocator(), __n->_M_valptr());
      _M_deallocate_node_ptr(__n);
    }

  template<typename _NodeAlloc>
    void
    _Hashtable_alloc<_NodeAlloc>::_M_deallocate_node_ptr(__node_type* __n)
    {
      typedef typename __node_alloc_traits::pointer _Ptr;
      auto __ptr = std::pointer_traits<_Ptr>::pointer_to(*__n);
      __n->~__node_type();
      __node_alloc_traits::deallocate(_M_node_allocator(), __ptr, 1);
    }

  template<typename _NodeAlloc>
    void
    _Hashtable_alloc<_NodeAlloc>::_M_deallocate_nodes(__node_type* __n)
    {
      while (__n)
 {
   __node_type* __tmp = __n;
   __n = __n->_M_next();
   _M_deallocate_node(__tmp);
 }
    }

  template<typename _NodeAlloc>
    typename _Hashtable_alloc<_NodeAlloc>::__bucket_type*
    _Hashtable_alloc<_NodeAlloc>::_M_allocate_buckets(std::size_t __bkt_count)
    {
      __bucket_alloc_type __alloc(_M_node_allocator());

      auto __ptr = __bucket_alloc_traits::allocate(__alloc, __bkt_count);
      __bucket_type* __p = std::__to_address(__ptr);
      __builtin_memset(__p, 0, __bkt_count * sizeof(__bucket_type));
      return __p;
    }

  template<typename _NodeAlloc>
    void
    _Hashtable_alloc<_NodeAlloc>::_M_deallocate_buckets(__bucket_type* __bkts,
       std::size_t __bkt_count)
    {
      typedef typename __bucket_alloc_traits::pointer _Ptr;
      auto __ptr = std::pointer_traits<_Ptr>::pointer_to(*__bkts);
      __bucket_alloc_type __alloc(_M_node_allocator());
      __bucket_alloc_traits::deallocate(__alloc, __ptr, __bkt_count);
    }


}

}
# 36 "/usr/include/c++/10/bits/hashtable.h" 2 3
# 1 "/usr/include/c++/10/bits/enable_special_members.h" 1 3
# 33 "/usr/include/c++/10/bits/enable_special_members.h" 3
       
# 34 "/usr/include/c++/10/bits/enable_special_members.h" 3

namespace std __attribute__ ((__visibility__ ("default")))
{


  struct _Enable_default_constructor_tag
  {
    explicit constexpr _Enable_default_constructor_tag() = default;
  };






template<bool _Switch, typename _Tag = void>
  struct _Enable_default_constructor
  {
    constexpr _Enable_default_constructor() noexcept = default;
    constexpr _Enable_default_constructor(_Enable_default_constructor const&)
      noexcept = default;
    constexpr _Enable_default_constructor(_Enable_default_constructor&&)
      noexcept = default;
    _Enable_default_constructor&
    operator=(_Enable_default_constructor const&) noexcept = default;
    _Enable_default_constructor&
    operator=(_Enable_default_constructor&&) noexcept = default;


    constexpr explicit
    _Enable_default_constructor(_Enable_default_constructor_tag) { }
  };







template<bool _Switch, typename _Tag = void>
  struct _Enable_destructor { };






template<bool _Copy, bool _CopyAssignment,
         bool _Move, bool _MoveAssignment,
         typename _Tag = void>
  struct _Enable_copy_move { };
# 93 "/usr/include/c++/10/bits/enable_special_members.h" 3
template<bool _Default, bool _Destructor,
         bool _Copy, bool _CopyAssignment,
         bool _Move, bool _MoveAssignment,
         typename _Tag = void>
  struct _Enable_special_members
  : private _Enable_default_constructor<_Default, _Tag>,
    private _Enable_destructor<_Destructor, _Tag>,
    private _Enable_copy_move<_Copy, _CopyAssignment,
                              _Move, _MoveAssignment,
                              _Tag>
  { };



template<typename _Tag>
  struct _Enable_default_constructor<false, _Tag>
  {
    constexpr _Enable_default_constructor() noexcept = delete;
    constexpr _Enable_default_constructor(_Enable_default_constructor const&)
      noexcept = default;
    constexpr _Enable_default_constructor(_Enable_default_constructor&&)
      noexcept = default;
    _Enable_default_constructor&
    operator=(_Enable_default_constructor const&) noexcept = default;
    _Enable_default_constructor&
    operator=(_Enable_default_constructor&&) noexcept = default;


    constexpr explicit
    _Enable_default_constructor(_Enable_default_constructor_tag) { }
  };

template<typename _Tag>
  struct _Enable_destructor<false, _Tag>
  { ~_Enable_destructor() noexcept = delete; };

template<typename _Tag>
  struct _Enable_copy_move<false, true, true, true, _Tag>
  {
    constexpr _Enable_copy_move() noexcept = default;
    constexpr _Enable_copy_move(_Enable_copy_move const&) noexcept = delete;
    constexpr _Enable_copy_move(_Enable_copy_move&&) noexcept = default;
    _Enable_copy_move&
    operator=(_Enable_copy_move const&) noexcept = default;
    _Enable_copy_move&
    operator=(_Enable_copy_move&&) noexcept = default;
  };

template<typename _Tag>
  struct _Enable_copy_move<true, false, true, true, _Tag>
  {
    constexpr _Enable_copy_move() noexcept = default;
    constexpr _Enable_copy_move(_Enable_copy_move const&) noexcept = default;
    constexpr _Enable_copy_move(_Enable_copy_move&&) noexcept = default;
    _Enable_copy_move&
    operator=(_Enable_copy_move const&) noexcept = delete;
    _Enable_copy_move&
    operator=(_Enable_copy_move&&) noexcept = default;
  };

template<typename _Tag>
  struct _Enable_copy_move<false, false, true, true, _Tag>
  {
    constexpr _Enable_copy_move() noexcept = default;
    constexpr _Enable_copy_move(_Enable_copy_move const&) noexcept = delete;
    constexpr _Enable_copy_move(_Enable_copy_move&&) noexcept = default;
    _Enable_copy_move&
    operator=(_Enable_copy_move const&) noexcept = delete;
    _Enable_copy_move&
    operator=(_Enable_copy_move&&) noexcept = default;
  };

template<typename _Tag>
  struct _Enable_copy_move<true, true, false, true, _Tag>
  {
    constexpr _Enable_copy_move() noexcept = default;
    constexpr _Enable_copy_move(_Enable_copy_move const&) noexcept = default;
    constexpr _Enable_copy_move(_Enable_copy_move&&) noexcept = delete;
    _Enable_copy_move&
    operator=(_Enable_copy_move const&) noexcept = default;
    _Enable_copy_move&
    operator=(_Enable_copy_move&&) noexcept = default;
  };

template<typename _Tag>
  struct _Enable_copy_move<false, true, false, true, _Tag>
  {
    constexpr _Enable_copy_move() noexcept = default;
    constexpr _Enable_copy_move(_Enable_copy_move const&) noexcept = delete;
    constexpr _Enable_copy_move(_Enable_copy_move&&) noexcept = delete;
    _Enable_copy_move&
    operator=(_Enable_copy_move const&) noexcept = default;
    _Enable_copy_move&
    operator=(_Enable_copy_move&&) noexcept = default;
  };

template<typename _Tag>
  struct _Enable_copy_move<true, false, false, true, _Tag>
  {
    constexpr _Enable_copy_move() noexcept = default;
    constexpr _Enable_copy_move(_Enable_copy_move const&) noexcept = default;
    constexpr _Enable_copy_move(_Enable_copy_move&&) noexcept = delete;
    _Enable_copy_move&
    operator=(_Enable_copy_move const&) noexcept = delete;
    _Enable_copy_move&
    operator=(_Enable_copy_move&&) noexcept = default;
  };

template<typename _Tag>
  struct _Enable_copy_move<false, false, false, true, _Tag>
  {
    constexpr _Enable_copy_move() noexcept = default;
    constexpr _Enable_copy_move(_Enable_copy_move const&) noexcept = delete;
    constexpr _Enable_copy_move(_Enable_copy_move&&) noexcept = delete;
    _Enable_copy_move&
    operator=(_Enable_copy_move const&) noexcept = delete;
    _Enable_copy_move&
    operator=(_Enable_copy_move&&) noexcept = default;
  };

template<typename _Tag>
  struct _Enable_copy_move<true, true, true, false, _Tag>
  {
    constexpr _Enable_copy_move() noexcept = default;
    constexpr _Enable_copy_move(_Enable_copy_move const&) noexcept = default;
    constexpr _Enable_copy_move(_Enable_copy_move&&) noexcept = default;
    _Enable_copy_move&
    operator=(_Enable_copy_move const&) noexcept = default;
    _Enable_copy_move&
    operator=(_Enable_copy_move&&) noexcept = delete;
  };

template<typename _Tag>
  struct _Enable_copy_move<false, true, true, false, _Tag>
  {
    constexpr _Enable_copy_move() noexcept = default;
    constexpr _Enable_copy_move(_Enable_copy_move const&) noexcept = delete;
    constexpr _Enable_copy_move(_Enable_copy_move&&) noexcept = default;
    _Enable_copy_move&
    operator=(_Enable_copy_move const&) noexcept = default;
    _Enable_copy_move&
    operator=(_Enable_copy_move&&) noexcept = delete;
  };

template<typename _Tag>
  struct _Enable_copy_move<true, false, true, false, _Tag>
  {
    constexpr _Enable_copy_move() noexcept = default;
    constexpr _Enable_copy_move(_Enable_copy_move const&) noexcept = default;
    constexpr _Enable_copy_move(_Enable_copy_move&&) noexcept = default;
    _Enable_copy_move&
    operator=(_Enable_copy_move const&) noexcept = delete;
    _Enable_copy_move&
    operator=(_Enable_copy_move&&) noexcept = delete;
  };

template<typename _Tag>
  struct _Enable_copy_move<false, false, true, false, _Tag>
  {
    constexpr _Enable_copy_move() noexcept = default;
    constexpr _Enable_copy_move(_Enable_copy_move const&) noexcept = delete;
    constexpr _Enable_copy_move(_Enable_copy_move&&) noexcept = default;
    _Enable_copy_move&
    operator=(_Enable_copy_move const&) noexcept = delete;
    _Enable_copy_move&
    operator=(_Enable_copy_move&&) noexcept = delete;
  };

template<typename _Tag>
  struct _Enable_copy_move<true, true, false, false, _Tag>
  {
    constexpr _Enable_copy_move() noexcept = default;
    constexpr _Enable_copy_move(_Enable_copy_move const&) noexcept = default;
    constexpr _Enable_copy_move(_Enable_copy_move&&) noexcept = delete;
    _Enable_copy_move&
    operator=(_Enable_copy_move const&) noexcept = default;
    _Enable_copy_move&
    operator=(_Enable_copy_move&&) noexcept = delete;
  };

template<typename _Tag>
  struct _Enable_copy_move<false, true, false, false, _Tag>
  {
    constexpr _Enable_copy_move() noexcept = default;
    constexpr _Enable_copy_move(_Enable_copy_move const&) noexcept = delete;
    constexpr _Enable_copy_move(_Enable_copy_move&&) noexcept = delete;
    _Enable_copy_move&
    operator=(_Enable_copy_move const&) noexcept = default;
    _Enable_copy_move&
    operator=(_Enable_copy_move&&) noexcept = delete;
  };

template<typename _Tag>
  struct _Enable_copy_move<true, false, false, false, _Tag>
  {
    constexpr _Enable_copy_move() noexcept = default;
    constexpr _Enable_copy_move(_Enable_copy_move const&) noexcept = default;
    constexpr _Enable_copy_move(_Enable_copy_move&&) noexcept = delete;
    _Enable_copy_move&
    operator=(_Enable_copy_move const&) noexcept = delete;
    _Enable_copy_move&
    operator=(_Enable_copy_move&&) noexcept = delete;
  };

template<typename _Tag>
  struct _Enable_copy_move<false, false, false, false, _Tag>
  {
    constexpr _Enable_copy_move() noexcept = default;
    constexpr _Enable_copy_move(_Enable_copy_move const&) noexcept = delete;
    constexpr _Enable_copy_move(_Enable_copy_move&&) noexcept = delete;
    _Enable_copy_move&
    operator=(_Enable_copy_move const&) noexcept = delete;
    _Enable_copy_move&
    operator=(_Enable_copy_move&&) noexcept = delete;
  };


}
# 37 "/usr/include/c++/10/bits/hashtable.h" 2 3




namespace std __attribute__ ((__visibility__ ("default")))
{


  template<typename _Tp, typename _Hash>
    using __cache_default
      = __not_<__and_<
         __is_fast_hash<_Hash>,

         __is_nothrow_invocable<const _Hash&, const _Tp&>>>;




  template<typename _Equal, typename _Hash, typename _Allocator>
    using _Hashtable_enable_default_ctor
      = _Enable_default_constructor<__and_<is_default_constructible<_Equal>,
           is_default_constructible<_Hash>,
           is_default_constructible<_Allocator>>{},
        __detail::_Hash_node_base>;
# 180 "/usr/include/c++/10/bits/hashtable.h" 3
  template<typename _Key, typename _Value, typename _Alloc,
    typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash,
    typename _RehashPolicy, typename _Traits>
    class _Hashtable
    : public __detail::_Hashtable_base<_Key, _Value, _ExtractKey, _Equal,
           _H1, _H2, _Hash, _Traits>,
      public __detail::_Map_base<_Key, _Value, _Alloc, _ExtractKey, _Equal,
     _H1, _H2, _Hash, _RehashPolicy, _Traits>,
      public __detail::_Insert<_Key, _Value, _Alloc, _ExtractKey, _Equal,
          _H1, _H2, _Hash, _RehashPolicy, _Traits>,
      public __detail::_Rehash_base<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        _H1, _H2, _Hash, _RehashPolicy, _Traits>,
      public __detail::_Equality<_Key, _Value, _Alloc, _ExtractKey, _Equal,
     _H1, _H2, _Hash, _RehashPolicy, _Traits>,
      private __detail::_Hashtable_alloc<
 __alloc_rebind<_Alloc,
         __detail::_Hash_node<_Value,
         _Traits::__hash_cached::value>>>,
      private _Hashtable_enable_default_ctor<_Equal, _H1, _Alloc>
    {
      static_assert(is_same<typename remove_cv<_Value>::type, _Value>::value,
   "unordered container must have a non-const, non-volatile value_type");





      using __traits_type = _Traits;
      using __hash_cached = typename __traits_type::__hash_cached;
      using __node_type = __detail::_Hash_node<_Value, __hash_cached::value>;
      using __node_alloc_type = __alloc_rebind<_Alloc, __node_type>;

      using __hashtable_alloc = __detail::_Hashtable_alloc<__node_alloc_type>;

      using __value_alloc_traits =
 typename __hashtable_alloc::__value_alloc_traits;
      using __node_alloc_traits =
 typename __hashtable_alloc::__node_alloc_traits;
      using __node_base = typename __hashtable_alloc::__node_base;
      using __bucket_type = typename __hashtable_alloc::__bucket_type;
      using __enable_default_ctor
 = _Hashtable_enable_default_ctor<_Equal, _H1, _Alloc>;

    public:
      typedef _Key key_type;
      typedef _Value value_type;
      typedef _Alloc allocator_type;
      typedef _Equal key_equal;



      typedef typename __value_alloc_traits::pointer pointer;
      typedef typename __value_alloc_traits::const_pointer const_pointer;
      typedef value_type& reference;
      typedef const value_type& const_reference;

    private:
      using __rehash_type = _RehashPolicy;
      using __rehash_state = typename __rehash_type::_State;

      using __constant_iterators = typename __traits_type::__constant_iterators;
      using __unique_keys = typename __traits_type::__unique_keys;

      using __key_extract = typename std::conditional<
          __constant_iterators::value,
                 __detail::_Identity,
          __detail::_Select1st>::type;

      using __hashtable_base = __detail::
          _Hashtable_base<_Key, _Value, _ExtractKey,
           _Equal, _H1, _H2, _Hash, _Traits>;

      using __hash_code_base = typename __hashtable_base::__hash_code_base;
      using __hash_code = typename __hashtable_base::__hash_code;
      using __ireturn_type = typename __hashtable_base::__ireturn_type;

      using __map_base = __detail::_Map_base<_Key, _Value, _Alloc, _ExtractKey,
          _Equal, _H1, _H2, _Hash,
          _RehashPolicy, _Traits>;

      using __rehash_base = __detail::_Rehash_base<_Key, _Value, _Alloc,
         _ExtractKey, _Equal,
         _H1, _H2, _Hash,
         _RehashPolicy, _Traits>;

      using __eq_base = __detail::_Equality<_Key, _Value, _Alloc, _ExtractKey,
         _Equal, _H1, _H2, _Hash,
         _RehashPolicy, _Traits>;

      using __reuse_or_alloc_node_gen_t =
 __detail::_ReuseOrAllocNode<__node_alloc_type>;
      using __alloc_node_gen_t =
 __detail::_AllocNode<__node_alloc_type>;


      struct _Scoped_node
      {

 _Scoped_node(__node_type* __n, __hashtable_alloc* __h)
 : _M_h(__h), _M_node(__n) { }


 template<typename... _Args>
   _Scoped_node(__hashtable_alloc* __h, _Args&&... __args)
   : _M_h(__h),
     _M_node(__h->_M_allocate_node(std::forward<_Args>(__args)...))
   { }


 ~_Scoped_node() { if (_M_node) _M_h->_M_deallocate_node(_M_node); };

 _Scoped_node(const _Scoped_node&) = delete;
 _Scoped_node& operator=(const _Scoped_node&) = delete;

 __hashtable_alloc* _M_h;
 __node_type* _M_node;
      };

      template<typename _Ht>
 static constexpr
 typename conditional<std::is_lvalue_reference<_Ht>::value,
        const value_type&, value_type&&>::type
 __fwd_value_for(value_type& __val) noexcept
 { return std::move(__val); }


      template<typename _Cond>
 using __if_hash_cached = __or_<__not_<__hash_cached>, _Cond>;

      template<typename _Cond>
 using __if_hash_not_cached = __or_<__hash_cached, _Cond>;





      struct __hash_code_base_access : __hash_code_base
      { using __hash_code_base::_M_bucket_index; };



      static_assert(noexcept(declval<const __hash_code_base_access&>()
        ._M_bucket_index((const __node_type*)nullptr,
           (std::size_t)0)),
      "Cache the hash code or qualify your functors involved"
      " in hash code and bucket index computation with noexcept");



      static_assert(__if_hash_cached<is_default_constructible<_H2>>::value,
      "Functor used to map hash code to bucket index"
      " must be default constructible");

      template<typename _Keya, typename _Valuea, typename _Alloca,
        typename _ExtractKeya, typename _Equala,
        typename _H1a, typename _H2a, typename _Hasha,
        typename _RehashPolicya, typename _Traitsa,
        bool _Unique_keysa>
 friend struct __detail::_Map_base;

      template<typename _Keya, typename _Valuea, typename _Alloca,
        typename _ExtractKeya, typename _Equala,
        typename _H1a, typename _H2a, typename _Hasha,
        typename _RehashPolicya, typename _Traitsa>
 friend struct __detail::_Insert_base;

      template<typename _Keya, typename _Valuea, typename _Alloca,
        typename _ExtractKeya, typename _Equala,
        typename _H1a, typename _H2a, typename _Hasha,
        typename _RehashPolicya, typename _Traitsa,
        bool _Constant_iteratorsa>
 friend struct __detail::_Insert;

      template<typename _Keya, typename _Valuea, typename _Alloca,
        typename _ExtractKeya, typename _Equala,
        typename _H1a, typename _H2a, typename _Hasha,
        typename _RehashPolicya, typename _Traitsa,
        bool _Unique_keysa>
 friend struct __detail::_Equality;

    public:
      using size_type = typename __hashtable_base::size_type;
      using difference_type = typename __hashtable_base::difference_type;

      using iterator = typename __hashtable_base::iterator;
      using const_iterator = typename __hashtable_base::const_iterator;

      using local_iterator = typename __hashtable_base::local_iterator;
      using const_local_iterator = typename __hashtable_base::
       const_local_iterator;






    private:
      __bucket_type* _M_buckets = &_M_single_bucket;
      size_type _M_bucket_count = 1;
      __node_base _M_before_begin;
      size_type _M_element_count = 0;
      _RehashPolicy _M_rehash_policy;







      __bucket_type _M_single_bucket = nullptr;

      bool
      _M_uses_single_bucket(__bucket_type* __bkts) const
      { return __builtin_expect(__bkts == &_M_single_bucket, false); }

      bool
      _M_uses_single_bucket() const
      { return _M_uses_single_bucket(_M_buckets); }

      __hashtable_alloc&
      _M_base_alloc() { return *this; }

      __bucket_type*
      _M_allocate_buckets(size_type __bkt_count)
      {
 if (__builtin_expect(__bkt_count == 1, false))
   {
     _M_single_bucket = nullptr;
     return &_M_single_bucket;
   }

 return __hashtable_alloc::_M_allocate_buckets(__bkt_count);
      }

      void
      _M_deallocate_buckets(__bucket_type* __bkts, size_type __bkt_count)
      {
 if (_M_uses_single_bucket(__bkts))
   return;

 __hashtable_alloc::_M_deallocate_buckets(__bkts, __bkt_count);
      }

      void
      _M_deallocate_buckets()
      { _M_deallocate_buckets(_M_buckets, _M_bucket_count); }



      __node_type*
      _M_bucket_begin(size_type __bkt) const;

      __node_type*
      _M_begin() const
      { return static_cast<__node_type*>(_M_before_begin._M_nxt); }



      template<typename _Ht>
 void
 _M_assign_elements(_Ht&&);

      template<typename _Ht, typename _NodeGenerator>
 void
 _M_assign(_Ht&&, const _NodeGenerator&);

      void
      _M_move_assign(_Hashtable&&, true_type);

      void
      _M_move_assign(_Hashtable&&, false_type);

      void
      _M_reset() noexcept;

      _Hashtable(const _H1& __h1, const _H2& __h2, const _Hash& __h,
   const _Equal& __eq, const _ExtractKey& __exk,
   const allocator_type& __a)
      : __hashtable_base(__exk, __h1, __h2, __h, __eq),
 __hashtable_alloc(__node_alloc_type(__a)),
 __enable_default_ctor(_Enable_default_constructor_tag{})
      { }

      template<bool _No_realloc = true>
 static constexpr bool
 _S_nothrow_move()
 {

   return __and_<__bool_constant<_No_realloc>,
   is_nothrow_copy_constructible<_H1>,
   is_nothrow_copy_constructible<_Equal>>::value;






 }

      _Hashtable(_Hashtable&& __ht, __node_alloc_type&& __a,
   true_type )
 noexcept(_S_nothrow_move());

      _Hashtable(_Hashtable&&, __node_alloc_type&&,
   false_type );


    public:

      _Hashtable() = default;
      _Hashtable(size_type __bkt_count_hint,
   const _H1&, const _H2&, const _Hash&,
   const _Equal&, const _ExtractKey&,
   const allocator_type&);

      template<typename _InputIterator>
 _Hashtable(_InputIterator __first, _InputIterator __last,
     size_type __bkt_count_hint,
     const _H1&, const _H2&, const _Hash&,
     const _Equal&, const _ExtractKey&,
     const allocator_type&);

      _Hashtable(const _Hashtable&);

      _Hashtable(_Hashtable&& __ht)
 noexcept(_S_nothrow_move())
      : _Hashtable(std::move(__ht), std::move(__ht._M_node_allocator()),
     true_type{})
      { }

      _Hashtable(const _Hashtable&, const allocator_type&);

      _Hashtable(_Hashtable&& __ht, const allocator_type& __a)
 noexcept(_S_nothrow_move<__node_alloc_traits::_S_always_equal()>())
      : _Hashtable(std::move(__ht), __node_alloc_type(__a),
     typename __node_alloc_traits::is_always_equal{})
      { }


      explicit
      _Hashtable(const allocator_type& __a)
      : __hashtable_alloc(__node_alloc_type(__a)),
 __enable_default_ctor(_Enable_default_constructor_tag{})
      { }

      explicit
      _Hashtable(size_type __bkt_count_hint,
   const _H1& __hf = _H1(),
   const key_equal& __eql = key_equal(),
   const allocator_type& __a = allocator_type())
      : _Hashtable(__bkt_count_hint, __hf, _H2(), _Hash(), __eql,
     __key_extract(), __a)
      { }

      template<typename _InputIterator>
 _Hashtable(_InputIterator __f, _InputIterator __l,
     size_type __bkt_count_hint = 0,
     const _H1& __hf = _H1(),
     const key_equal& __eql = key_equal(),
     const allocator_type& __a = allocator_type())
 : _Hashtable(__f, __l, __bkt_count_hint, __hf, _H2(), _Hash(), __eql,
       __key_extract(), __a)
 { }

      _Hashtable(initializer_list<value_type> __l,
   size_type __bkt_count_hint = 0,
   const _H1& __hf = _H1(),
   const key_equal& __eql = key_equal(),
   const allocator_type& __a = allocator_type())
      : _Hashtable(__l.begin(), __l.end(), __bkt_count_hint,
     __hf, _H2(), _Hash(), __eql,
     __key_extract(), __a)
      { }

      _Hashtable&
      operator=(const _Hashtable& __ht);

      _Hashtable&
      operator=(_Hashtable&& __ht)
      noexcept(__node_alloc_traits::_S_nothrow_move()
        && is_nothrow_move_assignable<_H1>::value
        && is_nothrow_move_assignable<_Equal>::value)
      {
        constexpr bool __move_storage =
   __node_alloc_traits::_S_propagate_on_move_assign()
   || __node_alloc_traits::_S_always_equal();
 _M_move_assign(std::move(__ht), __bool_constant<__move_storage>());
 return *this;
      }

      _Hashtable&
      operator=(initializer_list<value_type> __l)
      {
 __reuse_or_alloc_node_gen_t __roan(_M_begin(), *this);
 _M_before_begin._M_nxt = nullptr;
 clear();
 this->_M_insert_range(__l.begin(), __l.end(), __roan, __unique_keys());
 return *this;
      }

      ~_Hashtable() noexcept;

      void
      swap(_Hashtable&)
      noexcept(__and_<__is_nothrow_swappable<_H1>,
                   __is_nothrow_swappable<_Equal>>::value);


      iterator
      begin() noexcept
      { return iterator(_M_begin()); }

      const_iterator
      begin() const noexcept
      { return const_iterator(_M_begin()); }

      iterator
      end() noexcept
      { return iterator(nullptr); }

      const_iterator
      end() const noexcept
      { return const_iterator(nullptr); }

      const_iterator
      cbegin() const noexcept
      { return const_iterator(_M_begin()); }

      const_iterator
      cend() const noexcept
      { return const_iterator(nullptr); }

      size_type
      size() const noexcept
      { return _M_element_count; }

      bool
      empty() const noexcept
      { return size() == 0; }

      allocator_type
      get_allocator() const noexcept
      { return allocator_type(this->_M_node_allocator()); }

      size_type
      max_size() const noexcept
      { return __node_alloc_traits::max_size(this->_M_node_allocator()); }


      key_equal
      key_eq() const
      { return this->_M_eq(); }




      size_type
      bucket_count() const noexcept
      { return _M_bucket_count; }

      size_type
      max_bucket_count() const noexcept
      { return max_size(); }

      size_type
      bucket_size(size_type __bkt) const
      { return std::distance(begin(__bkt), end(__bkt)); }

      size_type
      bucket(const key_type& __k) const
      { return _M_bucket_index(__k, this->_M_hash_code(__k)); }

      local_iterator
      begin(size_type __bkt)
      {
 return local_iterator(*this, _M_bucket_begin(__bkt),
         __bkt, _M_bucket_count);
      }

      local_iterator
      end(size_type __bkt)
      { return local_iterator(*this, nullptr, __bkt, _M_bucket_count); }

      const_local_iterator
      begin(size_type __bkt) const
      {
 return const_local_iterator(*this, _M_bucket_begin(__bkt),
        __bkt, _M_bucket_count);
      }

      const_local_iterator
      end(size_type __bkt) const
      { return const_local_iterator(*this, nullptr, __bkt, _M_bucket_count); }


      const_local_iterator
      cbegin(size_type __bkt) const
      {
 return const_local_iterator(*this, _M_bucket_begin(__bkt),
        __bkt, _M_bucket_count);
      }

      const_local_iterator
      cend(size_type __bkt) const
      { return const_local_iterator(*this, nullptr, __bkt, _M_bucket_count); }

      float
      load_factor() const noexcept
      {
 return static_cast<float>(size()) / static_cast<float>(bucket_count());
      }






      const _RehashPolicy&
      __rehash_policy() const
      { return _M_rehash_policy; }

      void
      __rehash_policy(const _RehashPolicy& __pol)
      { _M_rehash_policy = __pol; }


      iterator
      find(const key_type& __k);

      const_iterator
      find(const key_type& __k) const;

      size_type
      count(const key_type& __k) const;

      std::pair<iterator, iterator>
      equal_range(const key_type& __k);

      std::pair<const_iterator, const_iterator>
      equal_range(const key_type& __k) const;

    protected:

      size_type
      _M_bucket_index(__node_type* __n) const noexcept
      { return __hash_code_base::_M_bucket_index(__n, _M_bucket_count); }

      size_type
      _M_bucket_index(const key_type& __k, __hash_code __c) const
      { return __hash_code_base::_M_bucket_index(__k, __c, _M_bucket_count); }



      __node_base*
      _M_find_before_node(size_type, const key_type&, __hash_code) const;

      __node_type*
      _M_find_node(size_type __bkt, const key_type& __key,
     __hash_code __c) const
      {
 __node_base* __before_n = _M_find_before_node(__bkt, __key, __c);
 if (__before_n)
   return static_cast<__node_type*>(__before_n->_M_nxt);
 return nullptr;
      }


      void
      _M_insert_bucket_begin(size_type, __node_type*);


      void
      _M_remove_bucket_begin(size_type __bkt, __node_type* __next_n,
        size_type __next_bkt);


      __node_base*
      _M_get_previous_node(size_type __bkt, __node_base* __n);




      iterator
      _M_insert_unique_node(const key_type& __k, size_type __bkt,
       __hash_code __code, __node_type* __n,
       size_type __n_elt = 1);



      iterator
      _M_insert_multi_node(__node_type* __hint, const key_type& __k,
      __hash_code __code, __node_type* __n);

      template<typename... _Args>
 std::pair<iterator, bool>
 _M_emplace(true_type, _Args&&... __args);

      template<typename... _Args>
 iterator
 _M_emplace(false_type __uk, _Args&&... __args)
 { return _M_emplace(cend(), __uk, std::forward<_Args>(__args)...); }


      template<typename... _Args>
 iterator
 _M_emplace(const_iterator, true_type __uk, _Args&&... __args)
 { return _M_emplace(__uk, std::forward<_Args>(__args)...).first; }

      template<typename... _Args>
 iterator
 _M_emplace(const_iterator, false_type, _Args&&... __args);

      template<typename _Arg, typename _NodeGenerator>
 std::pair<iterator, bool>
 _M_insert(_Arg&&, const _NodeGenerator&, true_type, size_type = 1);

      template<typename _Arg, typename _NodeGenerator>
 iterator
 _M_insert(_Arg&& __arg, const _NodeGenerator& __node_gen,
    false_type __uk)
 {
   return _M_insert(cend(), std::forward<_Arg>(__arg), __node_gen,
      __uk);
 }


      template<typename _Arg, typename _NodeGenerator>
 iterator
 _M_insert(const_iterator, _Arg&& __arg,
    const _NodeGenerator& __node_gen, true_type __uk)
 {
   return
     _M_insert(std::forward<_Arg>(__arg), __node_gen, __uk).first;
 }


      template<typename _Arg, typename _NodeGenerator>
 iterator
 _M_insert(const_iterator, _Arg&&,
    const _NodeGenerator&, false_type);

      size_type
      _M_erase(true_type, const key_type&);

      size_type
      _M_erase(false_type, const key_type&);

      iterator
      _M_erase(size_type __bkt, __node_base* __prev_n, __node_type* __n);

    public:

      template<typename... _Args>
 __ireturn_type
 emplace(_Args&&... __args)
 { return _M_emplace(__unique_keys(), std::forward<_Args>(__args)...); }

      template<typename... _Args>
 iterator
 emplace_hint(const_iterator __hint, _Args&&... __args)
 {
   return _M_emplace(__hint, __unique_keys(),
       std::forward<_Args>(__args)...);
 }




      iterator
      erase(const_iterator);


      iterator
      erase(iterator __it)
      { return erase(const_iterator(__it)); }

      size_type
      erase(const key_type& __k)
      { return _M_erase(__unique_keys(), __k); }

      iterator
      erase(const_iterator, const_iterator);

      void
      clear() noexcept;



      void rehash(size_type __bkt_count);
# 1010 "/usr/include/c++/10/bits/hashtable.h" 3
    private:

      void _M_rehash_aux(size_type __bkt_count, true_type);


      void _M_rehash_aux(size_type __bkt_count, false_type);



      void _M_rehash(size_type __bkt_count, const __rehash_state& __state);
    };



  template<typename _Key, typename _Value,
    typename _Alloc, typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
    typename _Traits>
    auto
    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        _H1, _H2, _Hash, _RehashPolicy, _Traits>::
    _M_bucket_begin(size_type __bkt) const
    -> __node_type*
    {
      __node_base* __n = _M_buckets[__bkt];
      return __n ? static_cast<__node_type*>(__n->_M_nxt) : nullptr;
    }

  template<typename _Key, typename _Value,
    typename _Alloc, typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
    typename _Traits>
    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        _H1, _H2, _Hash, _RehashPolicy, _Traits>::
    _Hashtable(size_type __bkt_count_hint,
        const _H1& __h1, const _H2& __h2, const _Hash& __h,
        const _Equal& __eq, const _ExtractKey& __exk,
        const allocator_type& __a)
    : _Hashtable(__h1, __h2, __h, __eq, __exk, __a)
    {
      auto __bkt_count = _M_rehash_policy._M_next_bkt(__bkt_count_hint);
      if (__bkt_count > _M_bucket_count)
 {
   _M_buckets = _M_allocate_buckets(__bkt_count);
   _M_bucket_count = __bkt_count;
 }
    }

  template<typename _Key, typename _Value,
    typename _Alloc, typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
    typename _Traits>
    template<typename _InputIterator>
      _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
   _H1, _H2, _Hash, _RehashPolicy, _Traits>::
      _Hashtable(_InputIterator __f, _InputIterator __l,
   size_type __bkt_count_hint,
   const _H1& __h1, const _H2& __h2, const _Hash& __h,
   const _Equal& __eq, const _ExtractKey& __exk,
   const allocator_type& __a)
      : _Hashtable(__h1, __h2, __h, __eq, __exk, __a)
      {
 auto __nb_elems = __detail::__distance_fw(__f, __l);
 auto __bkt_count =
   _M_rehash_policy._M_next_bkt(
     std::max(_M_rehash_policy._M_bkt_for_elements(__nb_elems),
       __bkt_count_hint));

 if (__bkt_count > _M_bucket_count)
   {
     _M_buckets = _M_allocate_buckets(__bkt_count);
     _M_bucket_count = __bkt_count;
   }

 for (; __f != __l; ++__f)
   this->insert(*__f);
      }

  template<typename _Key, typename _Value,
    typename _Alloc, typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
    typename _Traits>
    auto
    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        _H1, _H2, _Hash, _RehashPolicy, _Traits>::
    operator=(const _Hashtable& __ht)
    -> _Hashtable&
    {
      if (&__ht == this)
 return *this;

      if (__node_alloc_traits::_S_propagate_on_copy_assign())
 {
   auto& __this_alloc = this->_M_node_allocator();
   auto& __that_alloc = __ht._M_node_allocator();
   if (!__node_alloc_traits::_S_always_equal()
       && __this_alloc != __that_alloc)
     {

       this->_M_deallocate_nodes(_M_begin());
       _M_before_begin._M_nxt = nullptr;
       _M_deallocate_buckets();
       _M_buckets = nullptr;
       std::__alloc_on_copy(__this_alloc, __that_alloc);
       __hashtable_base::operator=(__ht);
       _M_bucket_count = __ht._M_bucket_count;
       _M_element_count = __ht._M_element_count;
       _M_rehash_policy = __ht._M_rehash_policy;
       __alloc_node_gen_t __alloc_node_gen(*this);
       try
  {
    _M_assign(__ht, __alloc_node_gen);
  }
       catch(...)
  {


    _M_reset();
    throw;
  }
       return *this;
     }
   std::__alloc_on_copy(__this_alloc, __that_alloc);
 }


      _M_assign_elements(__ht);
      return *this;
    }

  template<typename _Key, typename _Value,
    typename _Alloc, typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
    typename _Traits>
    template<typename _Ht>
      void
      _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
   _H1, _H2, _Hash, _RehashPolicy, _Traits>::
      _M_assign_elements(_Ht&& __ht)
      {
 __bucket_type* __former_buckets = nullptr;
 std::size_t __former_bucket_count = _M_bucket_count;
 const __rehash_state& __former_state = _M_rehash_policy._M_state();

 if (_M_bucket_count != __ht._M_bucket_count)
   {
     __former_buckets = _M_buckets;
     _M_buckets = _M_allocate_buckets(__ht._M_bucket_count);
     _M_bucket_count = __ht._M_bucket_count;
   }
 else
   __builtin_memset(_M_buckets, 0,
      _M_bucket_count * sizeof(__bucket_type));

 try
   {
     __hashtable_base::operator=(std::forward<_Ht>(__ht));
     _M_element_count = __ht._M_element_count;
     _M_rehash_policy = __ht._M_rehash_policy;
     __reuse_or_alloc_node_gen_t __roan(_M_begin(), *this);
     _M_before_begin._M_nxt = nullptr;
     _M_assign(std::forward<_Ht>(__ht), __roan);
     if (__former_buckets)
       _M_deallocate_buckets(__former_buckets, __former_bucket_count);
   }
 catch(...)
   {
     if (__former_buckets)
       {

  _M_deallocate_buckets();
  _M_rehash_policy._M_reset(__former_state);
  _M_buckets = __former_buckets;
  _M_bucket_count = __former_bucket_count;
       }
     __builtin_memset(_M_buckets, 0,
        _M_bucket_count * sizeof(__bucket_type));
     throw;
   }
      }

  template<typename _Key, typename _Value,
    typename _Alloc, typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
    typename _Traits>
    template<typename _Ht, typename _NodeGenerator>
      void
      _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
   _H1, _H2, _Hash, _RehashPolicy, _Traits>::
      _M_assign(_Ht&& __ht, const _NodeGenerator& __node_gen)
      {
 __bucket_type* __buckets = nullptr;
 if (!_M_buckets)
   _M_buckets = __buckets = _M_allocate_buckets(_M_bucket_count);

 try
   {
     if (!__ht._M_before_begin._M_nxt)
       return;



     __node_type* __ht_n = __ht._M_begin();
     __node_type* __this_n
       = __node_gen(__fwd_value_for<_Ht>(__ht_n->_M_v()));
     this->_M_copy_code(__this_n, __ht_n);
     _M_before_begin._M_nxt = __this_n;
     _M_buckets[_M_bucket_index(__this_n)] = &_M_before_begin;


     __node_base* __prev_n = __this_n;
     for (__ht_n = __ht_n->_M_next(); __ht_n; __ht_n = __ht_n->_M_next())
       {
  __this_n = __node_gen(__fwd_value_for<_Ht>(__ht_n->_M_v()));
  __prev_n->_M_nxt = __this_n;
  this->_M_copy_code(__this_n, __ht_n);
  size_type __bkt = _M_bucket_index(__this_n);
  if (!_M_buckets[__bkt])
    _M_buckets[__bkt] = __prev_n;
  __prev_n = __this_n;
       }
   }
 catch(...)
   {
     clear();
     if (__buckets)
       _M_deallocate_buckets();
     throw;
   }
      }

  template<typename _Key, typename _Value,
    typename _Alloc, typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
    typename _Traits>
    void
    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        _H1, _H2, _Hash, _RehashPolicy, _Traits>::
    _M_reset() noexcept
    {
      _M_rehash_policy._M_reset();
      _M_bucket_count = 1;
      _M_single_bucket = nullptr;
      _M_buckets = &_M_single_bucket;
      _M_before_begin._M_nxt = nullptr;
      _M_element_count = 0;
    }

  template<typename _Key, typename _Value,
    typename _Alloc, typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
    typename _Traits>
    void
    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        _H1, _H2, _Hash, _RehashPolicy, _Traits>::
    _M_move_assign(_Hashtable&& __ht, true_type)
    {
      this->_M_deallocate_nodes(_M_begin());
      _M_deallocate_buckets();
      __hashtable_base::operator=(std::move(__ht));
      _M_rehash_policy = __ht._M_rehash_policy;
      if (!__ht._M_uses_single_bucket())
 _M_buckets = __ht._M_buckets;
      else
 {
   _M_buckets = &_M_single_bucket;
   _M_single_bucket = __ht._M_single_bucket;
 }
      _M_bucket_count = __ht._M_bucket_count;
      _M_before_begin._M_nxt = __ht._M_before_begin._M_nxt;
      _M_element_count = __ht._M_element_count;
      std::__alloc_on_move(this->_M_node_allocator(), __ht._M_node_allocator());



      if (_M_begin())
 _M_buckets[_M_bucket_index(_M_begin())] = &_M_before_begin;
      __ht._M_reset();
    }

  template<typename _Key, typename _Value,
    typename _Alloc, typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
    typename _Traits>
    void
    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        _H1, _H2, _Hash, _RehashPolicy, _Traits>::
    _M_move_assign(_Hashtable&& __ht, false_type)
    {
      if (__ht._M_node_allocator() == this->_M_node_allocator())
 _M_move_assign(std::move(__ht), true_type());
      else
 {

   _M_assign_elements(std::move(__ht));
   __ht.clear();
 }
    }

  template<typename _Key, typename _Value,
    typename _Alloc, typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
    typename _Traits>
    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        _H1, _H2, _Hash, _RehashPolicy, _Traits>::
    _Hashtable(const _Hashtable& __ht)
    : __hashtable_base(__ht),
      __map_base(__ht),
      __rehash_base(__ht),
      __hashtable_alloc(
 __node_alloc_traits::_S_select_on_copy(__ht._M_node_allocator())),
      __enable_default_ctor(__ht),
      _M_buckets(nullptr),
      _M_bucket_count(__ht._M_bucket_count),
      _M_element_count(__ht._M_element_count),
      _M_rehash_policy(__ht._M_rehash_policy)
    {
      __alloc_node_gen_t __alloc_node_gen(*this);
      _M_assign(__ht, __alloc_node_gen);
    }

  template<typename _Key, typename _Value,
    typename _Alloc, typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
    typename _Traits>
    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        _H1, _H2, _Hash, _RehashPolicy, _Traits>::
    _Hashtable(_Hashtable&& __ht, __node_alloc_type&& __a,
        true_type )
    noexcept(_S_nothrow_move())
    : __hashtable_base(__ht),
      __map_base(__ht),
      __rehash_base(__ht),
      __hashtable_alloc(std::move(__a)),
      __enable_default_ctor(__ht),
      _M_buckets(__ht._M_buckets),
      _M_bucket_count(__ht._M_bucket_count),
      _M_before_begin(__ht._M_before_begin._M_nxt),
      _M_element_count(__ht._M_element_count),
      _M_rehash_policy(__ht._M_rehash_policy)
    {

      if (__ht._M_uses_single_bucket())
 {
   _M_buckets = &_M_single_bucket;
   _M_single_bucket = __ht._M_single_bucket;
 }



      if (_M_begin())
 _M_buckets[_M_bucket_index(_M_begin())] = &_M_before_begin;

      __ht._M_reset();
    }

  template<typename _Key, typename _Value,
    typename _Alloc, typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
    typename _Traits>
    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        _H1, _H2, _Hash, _RehashPolicy, _Traits>::
    _Hashtable(const _Hashtable& __ht, const allocator_type& __a)
    : __hashtable_base(__ht),
      __map_base(__ht),
      __rehash_base(__ht),
      __hashtable_alloc(__node_alloc_type(__a)),
      __enable_default_ctor(__ht),
      _M_buckets(),
      _M_bucket_count(__ht._M_bucket_count),
      _M_element_count(__ht._M_element_count),
      _M_rehash_policy(__ht._M_rehash_policy)
    {
      __alloc_node_gen_t __alloc_node_gen(*this);
      _M_assign(__ht, __alloc_node_gen);
    }

  template<typename _Key, typename _Value,
    typename _Alloc, typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
    typename _Traits>
    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        _H1, _H2, _Hash, _RehashPolicy, _Traits>::
    _Hashtable(_Hashtable&& __ht, __node_alloc_type&& __a,
        false_type )
    : __hashtable_base(__ht),
      __map_base(__ht),
      __rehash_base(__ht),
      __hashtable_alloc(std::move(__a)),
      __enable_default_ctor(__ht),
      _M_buckets(nullptr),
      _M_bucket_count(__ht._M_bucket_count),
      _M_element_count(__ht._M_element_count),
      _M_rehash_policy(__ht._M_rehash_policy)
    {
      if (__ht._M_node_allocator() == this->_M_node_allocator())
 {
   if (__ht._M_uses_single_bucket())
     {
       _M_buckets = &_M_single_bucket;
       _M_single_bucket = __ht._M_single_bucket;
     }
   else
     _M_buckets = __ht._M_buckets;

   _M_before_begin._M_nxt = __ht._M_before_begin._M_nxt;


   if (_M_begin())
     _M_buckets[_M_bucket_index(_M_begin())] = &_M_before_begin;
   __ht._M_reset();
 }
      else
 {
   __alloc_node_gen_t __alloc_gen(*this);

   using _Fwd_Ht = typename
     conditional<__move_if_noexcept_cond<value_type>::value,
   const _Hashtable&, _Hashtable&&>::type;
   _M_assign(std::forward<_Fwd_Ht>(__ht), __alloc_gen);
   __ht.clear();
 }
    }

  template<typename _Key, typename _Value,
    typename _Alloc, typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
    typename _Traits>
    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        _H1, _H2, _Hash, _RehashPolicy, _Traits>::
    ~_Hashtable() noexcept
    {
      clear();
      _M_deallocate_buckets();
    }

  template<typename _Key, typename _Value,
    typename _Alloc, typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
    typename _Traits>
    void
    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        _H1, _H2, _Hash, _RehashPolicy, _Traits>::
    swap(_Hashtable& __x)
    noexcept(__and_<__is_nothrow_swappable<_H1>,
                 __is_nothrow_swappable<_Equal>>::value)
    {



      this->_M_swap(__x);

      std::__alloc_on_swap(this->_M_node_allocator(), __x._M_node_allocator());
      std::swap(_M_rehash_policy, __x._M_rehash_policy);


      if (this->_M_uses_single_bucket())
 {
   if (!__x._M_uses_single_bucket())
     {
       _M_buckets = __x._M_buckets;
       __x._M_buckets = &__x._M_single_bucket;
     }
 }
      else if (__x._M_uses_single_bucket())
 {
   __x._M_buckets = _M_buckets;
   _M_buckets = &_M_single_bucket;
 }
      else
 std::swap(_M_buckets, __x._M_buckets);

      std::swap(_M_bucket_count, __x._M_bucket_count);
      std::swap(_M_before_begin._M_nxt, __x._M_before_begin._M_nxt);
      std::swap(_M_element_count, __x._M_element_count);
      std::swap(_M_single_bucket, __x._M_single_bucket);



      if (_M_begin())
 _M_buckets[_M_bucket_index(_M_begin())] = &_M_before_begin;

      if (__x._M_begin())
 __x._M_buckets[__x._M_bucket_index(__x._M_begin())]
   = &__x._M_before_begin;
    }

  template<typename _Key, typename _Value,
    typename _Alloc, typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
    typename _Traits>
    auto
    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        _H1, _H2, _Hash, _RehashPolicy, _Traits>::
    find(const key_type& __k)
    -> iterator
    {
      __hash_code __code = this->_M_hash_code(__k);
      std::size_t __bkt = _M_bucket_index(__k, __code);
      __node_type* __p = _M_find_node(__bkt, __k, __code);
      return __p ? iterator(__p) : end();
    }

  template<typename _Key, typename _Value,
    typename _Alloc, typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
    typename _Traits>
    auto
    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        _H1, _H2, _Hash, _RehashPolicy, _Traits>::
    find(const key_type& __k) const
    -> const_iterator
    {
      __hash_code __code = this->_M_hash_code(__k);
      std::size_t __bkt = _M_bucket_index(__k, __code);
      __node_type* __p = _M_find_node(__bkt, __k, __code);
      return __p ? const_iterator(__p) : end();
    }

  template<typename _Key, typename _Value,
    typename _Alloc, typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
    typename _Traits>
    auto
    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        _H1, _H2, _Hash, _RehashPolicy, _Traits>::
    count(const key_type& __k) const
    -> size_type
    {
      __hash_code __code = this->_M_hash_code(__k);
      std::size_t __bkt = _M_bucket_index(__k, __code);
      __node_type* __p = _M_bucket_begin(__bkt);
      if (!__p)
 return 0;

      std::size_t __result = 0;
      for (;; __p = __p->_M_next())
 {
   if (this->_M_equals(__k, __code, __p))
     ++__result;
   else if (__result)



     break;
   if (!__p->_M_nxt || _M_bucket_index(__p->_M_next()) != __bkt)
     break;
 }
      return __result;
    }

  template<typename _Key, typename _Value,
    typename _Alloc, typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
    typename _Traits>
    auto
    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        _H1, _H2, _Hash, _RehashPolicy, _Traits>::
    equal_range(const key_type& __k)
    -> pair<iterator, iterator>
    {
      __hash_code __code = this->_M_hash_code(__k);
      std::size_t __bkt = _M_bucket_index(__k, __code);
      __node_type* __p = _M_find_node(__bkt, __k, __code);

      if (__p)
 {
   __node_type* __p1 = __p->_M_next();
   while (__p1 && _M_bucket_index(__p1) == __bkt
   && this->_M_equals(__k, __code, __p1))
     __p1 = __p1->_M_next();

   return std::make_pair(iterator(__p), iterator(__p1));
 }
      else
 return std::make_pair(end(), end());
    }

  template<typename _Key, typename _Value,
    typename _Alloc, typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
    typename _Traits>
    auto
    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        _H1, _H2, _Hash, _RehashPolicy, _Traits>::
    equal_range(const key_type& __k) const
    -> pair<const_iterator, const_iterator>
    {
      __hash_code __code = this->_M_hash_code(__k);
      std::size_t __bkt = _M_bucket_index(__k, __code);
      __node_type* __p = _M_find_node(__bkt, __k, __code);

      if (__p)
 {
   __node_type* __p1 = __p->_M_next();
   while (__p1 && _M_bucket_index(__p1) == __bkt
   && this->_M_equals(__k, __code, __p1))
     __p1 = __p1->_M_next();

   return std::make_pair(const_iterator(__p), const_iterator(__p1));
 }
      else
 return std::make_pair(end(), end());
    }



  template<typename _Key, typename _Value,
    typename _Alloc, typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
    typename _Traits>
    auto
    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        _H1, _H2, _Hash, _RehashPolicy, _Traits>::
    _M_find_before_node(size_type __bkt, const key_type& __k,
   __hash_code __code) const
    -> __node_base*
    {
      __node_base* __prev_p = _M_buckets[__bkt];
      if (!__prev_p)
 return nullptr;

      for (__node_type* __p = static_cast<__node_type*>(__prev_p->_M_nxt);;
    __p = __p->_M_next())
 {
   if (this->_M_equals(__k, __code, __p))
     return __prev_p;

   if (!__p->_M_nxt || _M_bucket_index(__p->_M_next()) != __bkt)
     break;
   __prev_p = __p;
 }
      return nullptr;
    }

  template<typename _Key, typename _Value,
    typename _Alloc, typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
    typename _Traits>
    void
    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        _H1, _H2, _Hash, _RehashPolicy, _Traits>::
    _M_insert_bucket_begin(size_type __bkt, __node_type* __node)
    {
      if (_M_buckets[__bkt])
 {


   __node->_M_nxt = _M_buckets[__bkt]->_M_nxt;
   _M_buckets[__bkt]->_M_nxt = __node;
 }
      else
 {



   __node->_M_nxt = _M_before_begin._M_nxt;
   _M_before_begin._M_nxt = __node;
   if (__node->_M_nxt)


     _M_buckets[_M_bucket_index(__node->_M_next())] = __node;
   _M_buckets[__bkt] = &_M_before_begin;
 }
    }

  template<typename _Key, typename _Value,
    typename _Alloc, typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
    typename _Traits>
    void
    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        _H1, _H2, _Hash, _RehashPolicy, _Traits>::
    _M_remove_bucket_begin(size_type __bkt, __node_type* __next,
      size_type __next_bkt)
    {
      if (!__next || __next_bkt != __bkt)
 {


   if (__next)
     _M_buckets[__next_bkt] = _M_buckets[__bkt];


   if (&_M_before_begin == _M_buckets[__bkt])
     _M_before_begin._M_nxt = __next;
   _M_buckets[__bkt] = nullptr;
 }
    }

  template<typename _Key, typename _Value,
    typename _Alloc, typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
    typename _Traits>
    auto
    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        _H1, _H2, _Hash, _RehashPolicy, _Traits>::
    _M_get_previous_node(size_type __bkt, __node_base* __n)
    -> __node_base*
    {
      __node_base* __prev_n = _M_buckets[__bkt];
      while (__prev_n->_M_nxt != __n)
 __prev_n = __prev_n->_M_nxt;
      return __prev_n;
    }

  template<typename _Key, typename _Value,
    typename _Alloc, typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
    typename _Traits>
    template<typename... _Args>
      auto
      _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
   _H1, _H2, _Hash, _RehashPolicy, _Traits>::
      _M_emplace(true_type, _Args&&... __args)
      -> pair<iterator, bool>
      {

 _Scoped_node __node { this, std::forward<_Args>(__args)... };
 const key_type& __k = this->_M_extract()(__node._M_node->_M_v());
 __hash_code __code = this->_M_hash_code(__k);
 size_type __bkt = _M_bucket_index(__k, __code);
 if (__node_type* __p = _M_find_node(__bkt, __k, __code))

   return std::make_pair(iterator(__p), false);


 auto __pos = _M_insert_unique_node(__k, __bkt, __code, __node._M_node);
 __node._M_node = nullptr;
 return { __pos, true };
      }

  template<typename _Key, typename _Value,
    typename _Alloc, typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
    typename _Traits>
    template<typename... _Args>
      auto
      _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
   _H1, _H2, _Hash, _RehashPolicy, _Traits>::
      _M_emplace(const_iterator __hint, false_type, _Args&&... __args)
      -> iterator
      {

 _Scoped_node __node { this, std::forward<_Args>(__args)... };
 const key_type& __k = this->_M_extract()(__node._M_node->_M_v());

 __hash_code __code = this->_M_hash_code(__k);
 auto __pos
   = _M_insert_multi_node(__hint._M_cur, __k, __code, __node._M_node);
 __node._M_node = nullptr;
 return __pos;
      }

  template<typename _Key, typename _Value,
    typename _Alloc, typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
    typename _Traits>
    auto
    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        _H1, _H2, _Hash, _RehashPolicy, _Traits>::
    _M_insert_unique_node(const key_type& __k, size_type __bkt,
     __hash_code __code, __node_type* __node,
     size_type __n_elt)
    -> iterator
    {
      const __rehash_state& __saved_state = _M_rehash_policy._M_state();
      std::pair<bool, std::size_t> __do_rehash
 = _M_rehash_policy._M_need_rehash(_M_bucket_count, _M_element_count,
       __n_elt);

      if (__do_rehash.first)
 {
   _M_rehash(__do_rehash.second, __saved_state);
   __bkt = _M_bucket_index(__k, __code);
 }

      this->_M_store_code(__node, __code);


      _M_insert_bucket_begin(__bkt, __node);
      ++_M_element_count;
      return iterator(__node);
    }

  template<typename _Key, typename _Value,
    typename _Alloc, typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
    typename _Traits>
    auto
    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        _H1, _H2, _Hash, _RehashPolicy, _Traits>::
    _M_insert_multi_node(__node_type* __hint, const key_type& __k,
    __hash_code __code, __node_type* __node)
    -> iterator
    {
      const __rehash_state& __saved_state = _M_rehash_policy._M_state();
      std::pair<bool, std::size_t> __do_rehash
 = _M_rehash_policy._M_need_rehash(_M_bucket_count, _M_element_count, 1);

      if (__do_rehash.first)
 _M_rehash(__do_rehash.second, __saved_state);

      this->_M_store_code(__node, __code);
      size_type __bkt = _M_bucket_index(__k, __code);



      __node_base* __prev
 = __builtin_expect(__hint != nullptr, false)
   && this->_M_equals(__k, __code, __hint)
     ? __hint
     : _M_find_before_node(__bkt, __k, __code);
      if (__prev)
 {

   __node->_M_nxt = __prev->_M_nxt;
   __prev->_M_nxt = __node;
   if (__builtin_expect(__prev == __hint, false))


     if (__node->_M_nxt
  && !this->_M_equals(__k, __code, __node->_M_next()))
       {
  size_type __next_bkt = _M_bucket_index(__node->_M_next());
  if (__next_bkt != __bkt)
    _M_buckets[__next_bkt] = __node;
       }
 }
      else



 _M_insert_bucket_begin(__bkt, __node);
      ++_M_element_count;
      return iterator(__node);
    }


  template<typename _Key, typename _Value,
    typename _Alloc, typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
    typename _Traits>
    template<typename _Arg, typename _NodeGenerator>
      auto
      _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
   _H1, _H2, _Hash, _RehashPolicy, _Traits>::
      _M_insert(_Arg&& __v, const _NodeGenerator& __node_gen, true_type,
  size_type __n_elt)
      -> pair<iterator, bool>
      {
 const key_type& __k = this->_M_extract()(__v);
 __hash_code __code = this->_M_hash_code(__k);
 size_type __bkt = _M_bucket_index(__k, __code);

 if (__node_type* __node = _M_find_node(__bkt, __k, __code))
   return { iterator(__node), false };

 _Scoped_node __node{ __node_gen(std::forward<_Arg>(__v)), this };
 auto __pos
   = _M_insert_unique_node(__k, __bkt, __code, __node._M_node, __n_elt);
 __node._M_node = nullptr;
 return { __pos, true };
      }


  template<typename _Key, typename _Value,
    typename _Alloc, typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
    typename _Traits>
    template<typename _Arg, typename _NodeGenerator>
      auto
      _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
   _H1, _H2, _Hash, _RehashPolicy, _Traits>::
      _M_insert(const_iterator __hint, _Arg&& __v,
  const _NodeGenerator& __node_gen, false_type)
      -> iterator
      {


 __hash_code __code = this->_M_hash_code(this->_M_extract()(__v));


 _Scoped_node __node{ __node_gen(std::forward<_Arg>(__v)), this };
 const key_type& __k = this->_M_extract()(__node._M_node->_M_v());
 auto __pos
   = _M_insert_multi_node(__hint._M_cur, __k, __code, __node._M_node);
 __node._M_node = nullptr;
 return __pos;
      }

  template<typename _Key, typename _Value,
    typename _Alloc, typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
    typename _Traits>
    auto
    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        _H1, _H2, _Hash, _RehashPolicy, _Traits>::
    erase(const_iterator __it)
    -> iterator
    {
      __node_type* __n = __it._M_cur;
      std::size_t __bkt = _M_bucket_index(__n);




      __node_base* __prev_n = _M_get_previous_node(__bkt, __n);
      return _M_erase(__bkt, __prev_n, __n);
    }

  template<typename _Key, typename _Value,
    typename _Alloc, typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
    typename _Traits>
    auto
    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        _H1, _H2, _Hash, _RehashPolicy, _Traits>::
    _M_erase(size_type __bkt, __node_base* __prev_n, __node_type* __n)
    -> iterator
    {
      if (__prev_n == _M_buckets[__bkt])
 _M_remove_bucket_begin(__bkt, __n->_M_next(),
    __n->_M_nxt ? _M_bucket_index(__n->_M_next()) : 0);
      else if (__n->_M_nxt)
 {
   size_type __next_bkt = _M_bucket_index(__n->_M_next());
   if (__next_bkt != __bkt)
     _M_buckets[__next_bkt] = __prev_n;
 }

      __prev_n->_M_nxt = __n->_M_nxt;
      iterator __result(__n->_M_next());
      this->_M_deallocate_node(__n);
      --_M_element_count;

      return __result;
    }

  template<typename _Key, typename _Value,
    typename _Alloc, typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
    typename _Traits>
    auto
    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        _H1, _H2, _Hash, _RehashPolicy, _Traits>::
    _M_erase(true_type, const key_type& __k)
    -> size_type
    {
      __hash_code __code = this->_M_hash_code(__k);
      std::size_t __bkt = _M_bucket_index(__k, __code);


      __node_base* __prev_n = _M_find_before_node(__bkt, __k, __code);
      if (!__prev_n)
 return 0;


      __node_type* __n = static_cast<__node_type*>(__prev_n->_M_nxt);
      _M_erase(__bkt, __prev_n, __n);
      return 1;
    }

  template<typename _Key, typename _Value,
    typename _Alloc, typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
    typename _Traits>
    auto
    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        _H1, _H2, _Hash, _RehashPolicy, _Traits>::
    _M_erase(false_type, const key_type& __k)
    -> size_type
    {
      __hash_code __code = this->_M_hash_code(__k);
      std::size_t __bkt = _M_bucket_index(__k, __code);


      __node_base* __prev_n = _M_find_before_node(__bkt, __k, __code);
      if (!__prev_n)
 return 0;







      __node_type* __n = static_cast<__node_type*>(__prev_n->_M_nxt);
      __node_type* __n_last = __n;
      std::size_t __n_last_bkt = __bkt;
      do
 {
   __n_last = __n_last->_M_next();
   if (!__n_last)
     break;
   __n_last_bkt = _M_bucket_index(__n_last);
 }
      while (__n_last_bkt == __bkt && this->_M_equals(__k, __code, __n_last));


      size_type __result = 0;
      do
 {
   __node_type* __p = __n->_M_next();
   this->_M_deallocate_node(__n);
   __n = __p;
   ++__result;
   --_M_element_count;
 }
      while (__n != __n_last);

      if (__prev_n == _M_buckets[__bkt])
 _M_remove_bucket_begin(__bkt, __n_last, __n_last_bkt);
      else if (__n_last && __n_last_bkt != __bkt)
 _M_buckets[__n_last_bkt] = __prev_n;
      __prev_n->_M_nxt = __n_last;
      return __result;
    }

  template<typename _Key, typename _Value,
    typename _Alloc, typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
    typename _Traits>
    auto
    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        _H1, _H2, _Hash, _RehashPolicy, _Traits>::
    erase(const_iterator __first, const_iterator __last)
    -> iterator
    {
      __node_type* __n = __first._M_cur;
      __node_type* __last_n = __last._M_cur;
      if (__n == __last_n)
 return iterator(__n);

      std::size_t __bkt = _M_bucket_index(__n);

      __node_base* __prev_n = _M_get_previous_node(__bkt, __n);
      bool __is_bucket_begin = __n == _M_bucket_begin(__bkt);
      std::size_t __n_bkt = __bkt;
      for (;;)
 {
   do
     {
       __node_type* __tmp = __n;
       __n = __n->_M_next();
       this->_M_deallocate_node(__tmp);
       --_M_element_count;
       if (!__n)
  break;
       __n_bkt = _M_bucket_index(__n);
     }
   while (__n != __last_n && __n_bkt == __bkt);
   if (__is_bucket_begin)
     _M_remove_bucket_begin(__bkt, __n, __n_bkt);
   if (__n == __last_n)
     break;
   __is_bucket_begin = true;
   __bkt = __n_bkt;
 }

      if (__n && (__n_bkt != __bkt || __is_bucket_begin))
 _M_buckets[__n_bkt] = __prev_n;
      __prev_n->_M_nxt = __n;
      return iterator(__n);
    }

  template<typename _Key, typename _Value,
    typename _Alloc, typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
    typename _Traits>
    void
    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        _H1, _H2, _Hash, _RehashPolicy, _Traits>::
    clear() noexcept
    {
      this->_M_deallocate_nodes(_M_begin());
      __builtin_memset(_M_buckets, 0, _M_bucket_count * sizeof(__bucket_type));
      _M_element_count = 0;
      _M_before_begin._M_nxt = nullptr;
    }

  template<typename _Key, typename _Value,
    typename _Alloc, typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
    typename _Traits>
    void
    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        _H1, _H2, _Hash, _RehashPolicy, _Traits>::
    rehash(size_type __bkt_count)
    {
      const __rehash_state& __saved_state = _M_rehash_policy._M_state();
      __bkt_count
 = std::max(_M_rehash_policy._M_bkt_for_elements(_M_element_count + 1),
     __bkt_count);
      __bkt_count = _M_rehash_policy._M_next_bkt(__bkt_count);

      if (__bkt_count != _M_bucket_count)
 _M_rehash(__bkt_count, __saved_state);
      else


 _M_rehash_policy._M_reset(__saved_state);
    }

  template<typename _Key, typename _Value,
    typename _Alloc, typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
    typename _Traits>
    void
    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        _H1, _H2, _Hash, _RehashPolicy, _Traits>::
    _M_rehash(size_type __bkt_count, const __rehash_state& __state)
    {
      try
 {
   _M_rehash_aux(__bkt_count, __unique_keys());
 }
      catch(...)
 {


   _M_rehash_policy._M_reset(__state);
   throw;
 }
    }


  template<typename _Key, typename _Value,
    typename _Alloc, typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
    typename _Traits>
    void
    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        _H1, _H2, _Hash, _RehashPolicy, _Traits>::
    _M_rehash_aux(size_type __bkt_count, true_type)
    {
      __bucket_type* __new_buckets = _M_allocate_buckets(__bkt_count);
      __node_type* __p = _M_begin();
      _M_before_begin._M_nxt = nullptr;
      std::size_t __bbegin_bkt = 0;
      while (__p)
 {
   __node_type* __next = __p->_M_next();
   std::size_t __bkt
     = __hash_code_base::_M_bucket_index(__p, __bkt_count);
   if (!__new_buckets[__bkt])
     {
       __p->_M_nxt = _M_before_begin._M_nxt;
       _M_before_begin._M_nxt = __p;
       __new_buckets[__bkt] = &_M_before_begin;
       if (__p->_M_nxt)
  __new_buckets[__bbegin_bkt] = __p;
       __bbegin_bkt = __bkt;
     }
   else
     {
       __p->_M_nxt = __new_buckets[__bkt]->_M_nxt;
       __new_buckets[__bkt]->_M_nxt = __p;
     }
   __p = __next;
 }

      _M_deallocate_buckets();
      _M_bucket_count = __bkt_count;
      _M_buckets = __new_buckets;
    }



  template<typename _Key, typename _Value,
    typename _Alloc, typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
    typename _Traits>
    void
    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        _H1, _H2, _Hash, _RehashPolicy, _Traits>::
    _M_rehash_aux(size_type __bkt_count, false_type)
    {
      __bucket_type* __new_buckets = _M_allocate_buckets(__bkt_count);

      __node_type* __p = _M_begin();
      _M_before_begin._M_nxt = nullptr;
      std::size_t __bbegin_bkt = 0;
      std::size_t __prev_bkt = 0;
      __node_type* __prev_p = nullptr;
      bool __check_bucket = false;

      while (__p)
 {
   __node_type* __next = __p->_M_next();
   std::size_t __bkt
     = __hash_code_base::_M_bucket_index(__p, __bkt_count);

   if (__prev_p && __prev_bkt == __bkt)
     {



       __p->_M_nxt = __prev_p->_M_nxt;
       __prev_p->_M_nxt = __p;






       __check_bucket = true;
     }
   else
     {
       if (__check_bucket)
  {


    if (__prev_p->_M_nxt)
      {
        std::size_t __next_bkt
   = __hash_code_base::_M_bucket_index(__prev_p->_M_next(),
           __bkt_count);
        if (__next_bkt != __prev_bkt)
   __new_buckets[__next_bkt] = __prev_p;
      }
    __check_bucket = false;
  }

       if (!__new_buckets[__bkt])
  {
    __p->_M_nxt = _M_before_begin._M_nxt;
    _M_before_begin._M_nxt = __p;
    __new_buckets[__bkt] = &_M_before_begin;
    if (__p->_M_nxt)
      __new_buckets[__bbegin_bkt] = __p;
    __bbegin_bkt = __bkt;
  }
       else
  {
    __p->_M_nxt = __new_buckets[__bkt]->_M_nxt;
    __new_buckets[__bkt]->_M_nxt = __p;
  }
     }
   __prev_p = __p;
   __prev_bkt = __bkt;
   __p = __next;
 }

      if (__check_bucket && __prev_p->_M_nxt)
 {
   std::size_t __next_bkt
     = __hash_code_base::_M_bucket_index(__prev_p->_M_next(),
      __bkt_count);
   if (__next_bkt != __prev_bkt)
     __new_buckets[__next_bkt] = __prev_p;
 }

      _M_deallocate_buckets();
      _M_bucket_count = __bkt_count;
      _M_buckets = __new_buckets;
    }
# 2280 "/usr/include/c++/10/bits/hashtable.h" 3

}
# 47 "/usr/include/c++/10/unordered_map" 2 3
# 1 "/usr/include/c++/10/bits/unordered_map.h" 1 3
# 33 "/usr/include/c++/10/bits/unordered_map.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{




  template<bool _Cache>
    using __umap_traits = __detail::_Hashtable_traits<_Cache, false, true>;

  template<typename _Key,
    typename _Tp,
    typename _Hash = hash<_Key>,
    typename _Pred = std::equal_to<_Key>,
    typename _Alloc = std::allocator<std::pair<const _Key, _Tp> >,
    typename _Tr = __umap_traits<__cache_default<_Key, _Hash>::value>>
    using __umap_hashtable = _Hashtable<_Key, std::pair<const _Key, _Tp>,
                                        _Alloc, __detail::_Select1st,
            _Pred, _Hash,
            __detail::_Mod_range_hashing,
            __detail::_Default_ranged_hash,
            __detail::_Prime_rehash_policy, _Tr>;


  template<bool _Cache>
    using __ummap_traits = __detail::_Hashtable_traits<_Cache, false, false>;

  template<typename _Key,
    typename _Tp,
    typename _Hash = hash<_Key>,
    typename _Pred = std::equal_to<_Key>,
    typename _Alloc = std::allocator<std::pair<const _Key, _Tp> >,
    typename _Tr = __ummap_traits<__cache_default<_Key, _Hash>::value>>
    using __ummap_hashtable = _Hashtable<_Key, std::pair<const _Key, _Tp>,
      _Alloc, __detail::_Select1st,
      _Pred, _Hash,
      __detail::_Mod_range_hashing,
      __detail::_Default_ranged_hash,
      __detail::_Prime_rehash_policy, _Tr>;

  template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
    class unordered_multimap;
# 98 "/usr/include/c++/10/bits/unordered_map.h" 3
  template<typename _Key, typename _Tp,
    typename _Hash = hash<_Key>,
    typename _Pred = equal_to<_Key>,
    typename _Alloc = allocator<std::pair<const _Key, _Tp>>>
    class unordered_map
    {
      typedef __umap_hashtable<_Key, _Tp, _Hash, _Pred, _Alloc> _Hashtable;
      _Hashtable _M_h;

    public:



      typedef typename _Hashtable::key_type key_type;
      typedef typename _Hashtable::value_type value_type;
      typedef typename _Hashtable::mapped_type mapped_type;
      typedef typename _Hashtable::hasher hasher;
      typedef typename _Hashtable::key_equal key_equal;
      typedef typename _Hashtable::allocator_type allocator_type;




      typedef typename _Hashtable::pointer pointer;
      typedef typename _Hashtable::const_pointer const_pointer;
      typedef typename _Hashtable::reference reference;
      typedef typename _Hashtable::const_reference const_reference;
      typedef typename _Hashtable::iterator iterator;
      typedef typename _Hashtable::const_iterator const_iterator;
      typedef typename _Hashtable::local_iterator local_iterator;
      typedef typename _Hashtable::const_local_iterator const_local_iterator;
      typedef typename _Hashtable::size_type size_type;
      typedef typename _Hashtable::difference_type difference_type;
# 141 "/usr/include/c++/10/bits/unordered_map.h" 3
      unordered_map() = default;
# 150 "/usr/include/c++/10/bits/unordered_map.h" 3
      explicit
      unordered_map(size_type __n,
      const hasher& __hf = hasher(),
      const key_equal& __eql = key_equal(),
      const allocator_type& __a = allocator_type())
      : _M_h(__n, __hf, __eql, __a)
      { }
# 171 "/usr/include/c++/10/bits/unordered_map.h" 3
      template<typename _InputIterator>
 unordered_map(_InputIterator __first, _InputIterator __last,
        size_type __n = 0,
        const hasher& __hf = hasher(),
        const key_equal& __eql = key_equal(),
        const allocator_type& __a = allocator_type())
 : _M_h(__first, __last, __n, __hf, __eql, __a)
 { }


      unordered_map(const unordered_map&) = default;


      unordered_map(unordered_map&&) = default;





      explicit
      unordered_map(const allocator_type& __a)
 : _M_h(__a)
      { }






      unordered_map(const unordered_map& __umap,
      const allocator_type& __a)
      : _M_h(__umap._M_h, __a)
      { }






      unordered_map(unordered_map&& __umap,
      const allocator_type& __a)
 noexcept( noexcept(_Hashtable(std::move(__umap._M_h), __a)) )
      : _M_h(std::move(__umap._M_h), __a)
      { }
# 227 "/usr/include/c++/10/bits/unordered_map.h" 3
      unordered_map(initializer_list<value_type> __l,
      size_type __n = 0,
      const hasher& __hf = hasher(),
      const key_equal& __eql = key_equal(),
      const allocator_type& __a = allocator_type())
      : _M_h(__l, __n, __hf, __eql, __a)
      { }

      unordered_map(size_type __n, const allocator_type& __a)
      : unordered_map(__n, hasher(), key_equal(), __a)
      { }

      unordered_map(size_type __n, const hasher& __hf,
      const allocator_type& __a)
      : unordered_map(__n, __hf, key_equal(), __a)
      { }

      template<typename _InputIterator>
 unordered_map(_InputIterator __first, _InputIterator __last,
        size_type __n,
        const allocator_type& __a)
 : unordered_map(__first, __last, __n, hasher(), key_equal(), __a)
 { }

      template<typename _InputIterator>
 unordered_map(_InputIterator __first, _InputIterator __last,
        size_type __n, const hasher& __hf,
        const allocator_type& __a)
   : unordered_map(__first, __last, __n, __hf, key_equal(), __a)
 { }

      unordered_map(initializer_list<value_type> __l,
      size_type __n,
      const allocator_type& __a)
      : unordered_map(__l, __n, hasher(), key_equal(), __a)
      { }

      unordered_map(initializer_list<value_type> __l,
      size_type __n, const hasher& __hf,
      const allocator_type& __a)
      : unordered_map(__l, __n, __hf, key_equal(), __a)
      { }


      unordered_map&
      operator=(const unordered_map&) = default;


      unordered_map&
      operator=(unordered_map&&) = default;
# 289 "/usr/include/c++/10/bits/unordered_map.h" 3
      unordered_map&
      operator=(initializer_list<value_type> __l)
      {
 _M_h = __l;
 return *this;
      }


      allocator_type
      get_allocator() const noexcept
      { return _M_h.get_allocator(); }




      bool
      empty() const noexcept
      { return _M_h.empty(); }


      size_type
      size() const noexcept
      { return _M_h.size(); }


      size_type
      max_size() const noexcept
      { return _M_h.max_size(); }







      iterator
      begin() noexcept
      { return _M_h.begin(); }






      const_iterator
      begin() const noexcept
      { return _M_h.begin(); }

      const_iterator
      cbegin() const noexcept
      { return _M_h.begin(); }






      iterator
      end() noexcept
      { return _M_h.end(); }






      const_iterator
      end() const noexcept
      { return _M_h.end(); }

      const_iterator
      cend() const noexcept
      { return _M_h.end(); }
# 386 "/usr/include/c++/10/bits/unordered_map.h" 3
      template<typename... _Args>
 std::pair<iterator, bool>
 emplace(_Args&&... __args)
 { return _M_h.emplace(std::forward<_Args>(__args)...); }
# 417 "/usr/include/c++/10/bits/unordered_map.h" 3
      template<typename... _Args>
 iterator
 emplace_hint(const_iterator __pos, _Args&&... __args)
 { return _M_h.emplace_hint(__pos, std::forward<_Args>(__args)...); }
# 579 "/usr/include/c++/10/bits/unordered_map.h" 3
      std::pair<iterator, bool>
      insert(const value_type& __x)
      { return _M_h.insert(__x); }



      std::pair<iterator, bool>
      insert(value_type&& __x)
      { return _M_h.insert(std::move(__x)); }

      template<typename _Pair>
 __enable_if_t<is_constructible<value_type, _Pair&&>::value,
        pair<iterator, bool>>
 insert(_Pair&& __x)
        { return _M_h.emplace(std::forward<_Pair>(__x)); }
# 618 "/usr/include/c++/10/bits/unordered_map.h" 3
      iterator
      insert(const_iterator __hint, const value_type& __x)
      { return _M_h.insert(__hint, __x); }



      iterator
      insert(const_iterator __hint, value_type&& __x)
      { return _M_h.insert(__hint, std::move(__x)); }

      template<typename _Pair>
 __enable_if_t<is_constructible<value_type, _Pair&&>::value, iterator>
 insert(const_iterator __hint, _Pair&& __x)
 { return _M_h.emplace_hint(__hint, std::forward<_Pair>(__x)); }
# 643 "/usr/include/c++/10/bits/unordered_map.h" 3
      template<typename _InputIterator>
 void
 insert(_InputIterator __first, _InputIterator __last)
 { _M_h.insert(__first, __last); }
# 655 "/usr/include/c++/10/bits/unordered_map.h" 3
      void
      insert(initializer_list<value_type> __l)
      { _M_h.insert(__l); }
# 791 "/usr/include/c++/10/bits/unordered_map.h" 3
      iterator
      erase(const_iterator __position)
      { return _M_h.erase(__position); }


      iterator
      erase(iterator __position)
      { return _M_h.erase(__position); }
# 813 "/usr/include/c++/10/bits/unordered_map.h" 3
      size_type
      erase(const key_type& __x)
      { return _M_h.erase(__x); }
# 831 "/usr/include/c++/10/bits/unordered_map.h" 3
      iterator
      erase(const_iterator __first, const_iterator __last)
      { return _M_h.erase(__first, __last); }







      void
      clear() noexcept
      { _M_h.clear(); }
# 855 "/usr/include/c++/10/bits/unordered_map.h" 3
      void
      swap(unordered_map& __x)
      noexcept( noexcept(_M_h.swap(__x._M_h)) )
      { _M_h.swap(__x._M_h); }
# 895 "/usr/include/c++/10/bits/unordered_map.h" 3
      hasher
      hash_function() const
      { return _M_h.hash_function(); }



      key_equal
      key_eq() const
      { return _M_h.key_eq(); }
# 919 "/usr/include/c++/10/bits/unordered_map.h" 3
      iterator
      find(const key_type& __x)
      { return _M_h.find(__x); }

      const_iterator
      find(const key_type& __x) const
      { return _M_h.find(__x); }
# 937 "/usr/include/c++/10/bits/unordered_map.h" 3
      size_type
      count(const key_type& __x) const
      { return _M_h.count(__x); }
# 961 "/usr/include/c++/10/bits/unordered_map.h" 3
      std::pair<iterator, iterator>
      equal_range(const key_type& __x)
      { return _M_h.equal_range(__x); }

      std::pair<const_iterator, const_iterator>
      equal_range(const key_type& __x) const
      { return _M_h.equal_range(__x); }
# 983 "/usr/include/c++/10/bits/unordered_map.h" 3
      mapped_type&
      operator[](const key_type& __k)
      { return _M_h[__k]; }

      mapped_type&
      operator[](key_type&& __k)
      { return _M_h[std::move(__k)]; }
# 1000 "/usr/include/c++/10/bits/unordered_map.h" 3
      mapped_type&
      at(const key_type& __k)
      { return _M_h.at(__k); }

      const mapped_type&
      at(const key_type& __k) const
      { return _M_h.at(__k); }





      size_type
      bucket_count() const noexcept
      { return _M_h.bucket_count(); }


      size_type
      max_bucket_count() const noexcept
      { return _M_h.max_bucket_count(); }






      size_type
      bucket_size(size_type __n) const
      { return _M_h.bucket_size(__n); }






      size_type
      bucket(const key_type& __key) const
      { return _M_h.bucket(__key); }







      local_iterator
      begin(size_type __n)
      { return _M_h.begin(__n); }
# 1056 "/usr/include/c++/10/bits/unordered_map.h" 3
      const_local_iterator
      begin(size_type __n) const
      { return _M_h.begin(__n); }

      const_local_iterator
      cbegin(size_type __n) const
      { return _M_h.cbegin(__n); }
# 1071 "/usr/include/c++/10/bits/unordered_map.h" 3
      local_iterator
      end(size_type __n)
      { return _M_h.end(__n); }
# 1082 "/usr/include/c++/10/bits/unordered_map.h" 3
      const_local_iterator
      end(size_type __n) const
      { return _M_h.end(__n); }

      const_local_iterator
      cend(size_type __n) const
      { return _M_h.cend(__n); }





      float
      load_factor() const noexcept
      { return _M_h.load_factor(); }



      float
      max_load_factor() const noexcept
      { return _M_h.max_load_factor(); }





      void
      max_load_factor(float __z)
      { _M_h.max_load_factor(__z); }
# 1119 "/usr/include/c++/10/bits/unordered_map.h" 3
      void
      rehash(size_type __n)
      { _M_h.rehash(__n); }
# 1130 "/usr/include/c++/10/bits/unordered_map.h" 3
      void
      reserve(size_type __n)
      { _M_h.reserve(__n); }

      template<typename _Key1, typename _Tp1, typename _Hash1, typename _Pred1,
        typename _Alloc1>
        friend bool
 operator==(const unordered_map<_Key1, _Tp1, _Hash1, _Pred1, _Alloc1>&,
     const unordered_map<_Key1, _Tp1, _Hash1, _Pred1, _Alloc1>&);
    };
# 1246 "/usr/include/c++/10/bits/unordered_map.h" 3
  template<typename _Key, typename _Tp,
    typename _Hash = hash<_Key>,
    typename _Pred = equal_to<_Key>,
    typename _Alloc = allocator<std::pair<const _Key, _Tp>>>
    class unordered_multimap
    {
      typedef __ummap_hashtable<_Key, _Tp, _Hash, _Pred, _Alloc> _Hashtable;
      _Hashtable _M_h;

    public:



      typedef typename _Hashtable::key_type key_type;
      typedef typename _Hashtable::value_type value_type;
      typedef typename _Hashtable::mapped_type mapped_type;
      typedef typename _Hashtable::hasher hasher;
      typedef typename _Hashtable::key_equal key_equal;
      typedef typename _Hashtable::allocator_type allocator_type;




      typedef typename _Hashtable::pointer pointer;
      typedef typename _Hashtable::const_pointer const_pointer;
      typedef typename _Hashtable::reference reference;
      typedef typename _Hashtable::const_reference const_reference;
      typedef typename _Hashtable::iterator iterator;
      typedef typename _Hashtable::const_iterator const_iterator;
      typedef typename _Hashtable::local_iterator local_iterator;
      typedef typename _Hashtable::const_local_iterator const_local_iterator;
      typedef typename _Hashtable::size_type size_type;
      typedef typename _Hashtable::difference_type difference_type;
# 1288 "/usr/include/c++/10/bits/unordered_map.h" 3
      unordered_multimap() = default;
# 1297 "/usr/include/c++/10/bits/unordered_map.h" 3
      explicit
      unordered_multimap(size_type __n,
    const hasher& __hf = hasher(),
    const key_equal& __eql = key_equal(),
    const allocator_type& __a = allocator_type())
      : _M_h(__n, __hf, __eql, __a)
      { }
# 1318 "/usr/include/c++/10/bits/unordered_map.h" 3
      template<typename _InputIterator>
 unordered_multimap(_InputIterator __first, _InputIterator __last,
      size_type __n = 0,
      const hasher& __hf = hasher(),
      const key_equal& __eql = key_equal(),
      const allocator_type& __a = allocator_type())
 : _M_h(__first, __last, __n, __hf, __eql, __a)
 { }


      unordered_multimap(const unordered_multimap&) = default;


      unordered_multimap(unordered_multimap&&) = default;





      explicit
      unordered_multimap(const allocator_type& __a)
      : _M_h(__a)
      { }






      unordered_multimap(const unordered_multimap& __ummap,
    const allocator_type& __a)
      : _M_h(__ummap._M_h, __a)
      { }






      unordered_multimap(unordered_multimap&& __ummap,
    const allocator_type& __a)
 noexcept( noexcept(_Hashtable(std::move(__ummap._M_h), __a)) )
      : _M_h(std::move(__ummap._M_h), __a)
      { }
# 1374 "/usr/include/c++/10/bits/unordered_map.h" 3
      unordered_multimap(initializer_list<value_type> __l,
    size_type __n = 0,
    const hasher& __hf = hasher(),
    const key_equal& __eql = key_equal(),
    const allocator_type& __a = allocator_type())
      : _M_h(__l, __n, __hf, __eql, __a)
      { }

      unordered_multimap(size_type __n, const allocator_type& __a)
      : unordered_multimap(__n, hasher(), key_equal(), __a)
      { }

      unordered_multimap(size_type __n, const hasher& __hf,
    const allocator_type& __a)
      : unordered_multimap(__n, __hf, key_equal(), __a)
      { }

      template<typename _InputIterator>
 unordered_multimap(_InputIterator __first, _InputIterator __last,
      size_type __n,
      const allocator_type& __a)
 : unordered_multimap(__first, __last, __n, hasher(), key_equal(), __a)
 { }

      template<typename _InputIterator>
 unordered_multimap(_InputIterator __first, _InputIterator __last,
      size_type __n, const hasher& __hf,
      const allocator_type& __a)
 : unordered_multimap(__first, __last, __n, __hf, key_equal(), __a)
 { }

      unordered_multimap(initializer_list<value_type> __l,
    size_type __n,
    const allocator_type& __a)
      : unordered_multimap(__l, __n, hasher(), key_equal(), __a)
      { }

      unordered_multimap(initializer_list<value_type> __l,
    size_type __n, const hasher& __hf,
    const allocator_type& __a)
      : unordered_multimap(__l, __n, __hf, key_equal(), __a)
      { }


      unordered_multimap&
      operator=(const unordered_multimap&) = default;


      unordered_multimap&
      operator=(unordered_multimap&&) = default;
# 1436 "/usr/include/c++/10/bits/unordered_map.h" 3
      unordered_multimap&
      operator=(initializer_list<value_type> __l)
      {
 _M_h = __l;
 return *this;
      }


      allocator_type
      get_allocator() const noexcept
      { return _M_h.get_allocator(); }




      bool
      empty() const noexcept
      { return _M_h.empty(); }


      size_type
      size() const noexcept
      { return _M_h.size(); }


      size_type
      max_size() const noexcept
      { return _M_h.max_size(); }







      iterator
      begin() noexcept
      { return _M_h.begin(); }






      const_iterator
      begin() const noexcept
      { return _M_h.begin(); }

      const_iterator
      cbegin() const noexcept
      { return _M_h.begin(); }






      iterator
      end() noexcept
      { return _M_h.end(); }






      const_iterator
      end() const noexcept
      { return _M_h.end(); }

      const_iterator
      cend() const noexcept
      { return _M_h.end(); }
# 1528 "/usr/include/c++/10/bits/unordered_map.h" 3
      template<typename... _Args>
 iterator
 emplace(_Args&&... __args)
 { return _M_h.emplace(std::forward<_Args>(__args)...); }
# 1555 "/usr/include/c++/10/bits/unordered_map.h" 3
      template<typename... _Args>
 iterator
 emplace_hint(const_iterator __pos, _Args&&... __args)
 { return _M_h.emplace_hint(__pos, std::forward<_Args>(__args)...); }
# 1570 "/usr/include/c++/10/bits/unordered_map.h" 3
      iterator
      insert(const value_type& __x)
      { return _M_h.insert(__x); }

      iterator
      insert(value_type&& __x)
      { return _M_h.insert(std::move(__x)); }

      template<typename _Pair>
 __enable_if_t<is_constructible<value_type, _Pair&&>::value, iterator>
 insert(_Pair&& __x)
        { return _M_h.emplace(std::forward<_Pair>(__x)); }
# 1604 "/usr/include/c++/10/bits/unordered_map.h" 3
      iterator
      insert(const_iterator __hint, const value_type& __x)
      { return _M_h.insert(__hint, __x); }



      iterator
      insert(const_iterator __hint, value_type&& __x)
      { return _M_h.insert(__hint, std::move(__x)); }

      template<typename _Pair>
 __enable_if_t<is_constructible<value_type, _Pair&&>::value, iterator>
 insert(const_iterator __hint, _Pair&& __x)
        { return _M_h.emplace_hint(__hint, std::forward<_Pair>(__x)); }
# 1629 "/usr/include/c++/10/bits/unordered_map.h" 3
      template<typename _InputIterator>
 void
 insert(_InputIterator __first, _InputIterator __last)
 { _M_h.insert(__first, __last); }
# 1642 "/usr/include/c++/10/bits/unordered_map.h" 3
      void
      insert(initializer_list<value_type> __l)
      { _M_h.insert(__l); }
# 1685 "/usr/include/c++/10/bits/unordered_map.h" 3
      iterator
      erase(const_iterator __position)
      { return _M_h.erase(__position); }


      iterator
      erase(iterator __position)
      { return _M_h.erase(__position); }
# 1706 "/usr/include/c++/10/bits/unordered_map.h" 3
      size_type
      erase(const key_type& __x)
      { return _M_h.erase(__x); }
# 1725 "/usr/include/c++/10/bits/unordered_map.h" 3
      iterator
      erase(const_iterator __first, const_iterator __last)
      { return _M_h.erase(__first, __last); }







      void
      clear() noexcept
      { _M_h.clear(); }
# 1749 "/usr/include/c++/10/bits/unordered_map.h" 3
      void
      swap(unordered_multimap& __x)
      noexcept( noexcept(_M_h.swap(__x._M_h)) )
      { _M_h.swap(__x._M_h); }
# 1791 "/usr/include/c++/10/bits/unordered_map.h" 3
      hasher
      hash_function() const
      { return _M_h.hash_function(); }



      key_equal
      key_eq() const
      { return _M_h.key_eq(); }
# 1815 "/usr/include/c++/10/bits/unordered_map.h" 3
      iterator
      find(const key_type& __x)
      { return _M_h.find(__x); }

      const_iterator
      find(const key_type& __x) const
      { return _M_h.find(__x); }







      size_type
      count(const key_type& __x) const
      { return _M_h.count(__x); }
# 1851 "/usr/include/c++/10/bits/unordered_map.h" 3
      std::pair<iterator, iterator>
      equal_range(const key_type& __x)
      { return _M_h.equal_range(__x); }

      std::pair<const_iterator, const_iterator>
      equal_range(const key_type& __x) const
      { return _M_h.equal_range(__x); }





      size_type
      bucket_count() const noexcept
      { return _M_h.bucket_count(); }


      size_type
      max_bucket_count() const noexcept
      { return _M_h.max_bucket_count(); }






      size_type
      bucket_size(size_type __n) const
      { return _M_h.bucket_size(__n); }






      size_type
      bucket(const key_type& __key) const
      { return _M_h.bucket(__key); }







      local_iterator
      begin(size_type __n)
      { return _M_h.begin(__n); }
# 1907 "/usr/include/c++/10/bits/unordered_map.h" 3
      const_local_iterator
      begin(size_type __n) const
      { return _M_h.begin(__n); }

      const_local_iterator
      cbegin(size_type __n) const
      { return _M_h.cbegin(__n); }
# 1922 "/usr/include/c++/10/bits/unordered_map.h" 3
      local_iterator
      end(size_type __n)
      { return _M_h.end(__n); }
# 1933 "/usr/include/c++/10/bits/unordered_map.h" 3
      const_local_iterator
      end(size_type __n) const
      { return _M_h.end(__n); }

      const_local_iterator
      cend(size_type __n) const
      { return _M_h.cend(__n); }





      float
      load_factor() const noexcept
      { return _M_h.load_factor(); }



      float
      max_load_factor() const noexcept
      { return _M_h.max_load_factor(); }





      void
      max_load_factor(float __z)
      { _M_h.max_load_factor(__z); }
# 1970 "/usr/include/c++/10/bits/unordered_map.h" 3
      void
      rehash(size_type __n)
      { _M_h.rehash(__n); }
# 1981 "/usr/include/c++/10/bits/unordered_map.h" 3
      void
      reserve(size_type __n)
      { _M_h.reserve(__n); }

      template<typename _Key1, typename _Tp1, typename _Hash1, typename _Pred1,
        typename _Alloc1>
        friend bool
 operator==(const unordered_multimap<_Key1, _Tp1,
         _Hash1, _Pred1, _Alloc1>&,
     const unordered_multimap<_Key1, _Tp1,
         _Hash1, _Pred1, _Alloc1>&);
    };
# 2076 "/usr/include/c++/10/bits/unordered_map.h" 3
  template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
    inline void
    swap(unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,
  unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>& __y)
    noexcept(noexcept(__x.swap(__y)))
    { __x.swap(__y); }

  template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
    inline void
    swap(unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,
  unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>& __y)
    noexcept(noexcept(__x.swap(__y)))
    { __x.swap(__y); }

  template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
    inline bool
    operator==(const unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,
        const unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>& __y)
    { return __x._M_h._M_equal(__y._M_h); }


  template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
    inline bool
    operator!=(const unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,
        const unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>& __y)
    { return !(__x == __y); }


  template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
    inline bool
    operator==(const unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,
        const unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>& __y)
    { return __x._M_h._M_equal(__y._M_h); }


  template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
    inline bool
    operator!=(const unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,
        const unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>& __y)
    { return !(__x == __y); }



# 2170 "/usr/include/c++/10/bits/unordered_map.h" 3

}
# 48 "/usr/include/c++/10/unordered_map" 2 3

# 1 "/usr/include/c++/10/bits/erase_if.h" 1 3
# 33 "/usr/include/c++/10/bits/erase_if.h" 3
       
# 34 "/usr/include/c++/10/bits/erase_if.h" 3



namespace std
{






  namespace __detail
  {
    template<typename _Container, typename _Predicate>
      typename _Container::size_type
      __erase_nodes_if(_Container& __cont, _Predicate __pred)
      {
 typename _Container::size_type __num = 0;
 for (auto __iter = __cont.begin(), __last = __cont.end();
      __iter != __last;)
   {
     if (__pred(*__iter))
       {
  __iter = __cont.erase(__iter);
  ++__num;
       }
     else
       ++__iter;
   }
 return __num;
      }
  }


}
# 50 "/usr/include/c++/10/unordered_map" 2 3
# 104 "code/game.h" 2


# 105 "code/game.h"
enum GizmoMode
{
 GIZMO_TRANSLATION,
 GIZMO_SCALE,
 GIZMO_ROTATION
};

struct Editor
{
 bool in_gizmo;
 entity_id selected_entity;

 GizmoMode gizmo_mode;

 int dragging_axis;
 bool did_drag;
 v3 drag_p;


 int s_drag_axis;
 bool s_did_drag;
 float s_init_scale;
 float s_init_drag;

 bool r_did_drag;
 float r_init_rot;
 float r_init_drag;
 v3 r_init_x_axis;
 v3 r_init_y_axis;

 v3 last_camera_p;
};

struct World
{
 Arena arena;

 Editor editor;

 Array<Entity> entities;

 std::unordered_map<entity_id, usize> entities_id_map;

 entity_id next_entity_id;

 v3 player_camera_p;
 v3 player_camera_rotation;
 v3 player_camera_drotation;


 v3 editor_camera_p;
 v3 editor_camera_rotation;



 entity_id editor_selected_entity;
 entity_id player_id;
};


struct Game
{
 b32 is_initialized;

 World *world;

 ShadowMap shadow_map;

 RenderPass mesh_render_pass;
 RenderPass shadow_map_render_pass;
 ConstantBuffer constant_buffer;

 RenderPass debug_lines_render_pass;
 VertexBuffer debug_lines_vertex_buffer;
 ConstantBuffer debug_lines_constant_buffer;

 Arena asset_arena;
 Scene ch43, sponza, cube_asset, sphere_asset;

 Animation animations[ANIMATION_COUNT];

 b32 in_editor;
 bool debug_collision;

 int frame;
 float time;

 RasterizerState default_rasterizer_state;
 DepthStencilState default_depth_stencil_state;
 DepthStencilState disable_depth_state;

 bool show_normals;
};

struct Constants
{
 mat4 view;
 mat4 projection;
 mat4 model;
 mat4 light_transform;
 mat4 bones[96];

 v3 camera_p;
 v3 player_p;
 v3 color;
 float diffuse_factor;

 float specular_factor;
 float specular_exponent_factor;
 int skinned;
 int has_normal_map;
 int show_normals;
};
# 29 "code/game.cpp" 2

Entity *get_entity(World &world, entity_id id);
mat4 get_entity_transform(Entity &e);

# 1 "code/renderer.cpp" 1
void init_render_context(Arena *arena, RenderContext &rc, Platform &platform)
{



 init_render_context_dx11(rc, platform);

 rc.loaded_textures = make_array_max<Texture>(arena, 256);
 rc.debug_lines = make_array_max<v3>(arena, 4 * 500000);

 uint32_t white_color = 0xffffffff;
 rc.white_texture = create_texture(make_cstring("__white_texture"), &white_color, 1, 1, true);
}

void push_line(v3 a, v3 b, v3 color = V3(1))
{
 g_rc->debug_lines.push(a);
 g_rc->debug_lines.push(color);
 g_rc->debug_lines.push(b);
 g_rc->debug_lines.push(color);
}

void push_cube_outline(v3 center, v3 radius, v3 color = V3(1))
{
 v3 p00 = center + V3(-radius.x, -radius.y, -radius.z);
 v3 p01 = center + V3(+radius.x, -radius.y, -radius.z);
 v3 p02 = center + V3(+radius.x, +radius.y, -radius.z);
 v3 p03 = center + V3(-radius.x, +radius.y, -radius.z);
 v3 p10 = center + V3(-radius.x, -radius.y, +radius.z);
 v3 p11 = center + V3(+radius.x, -radius.y, +radius.z);
 v3 p12 = center + V3(+radius.x, +radius.y, +radius.z);
 v3 p13 = center + V3(-radius.x, +radius.y, +radius.z);

 push_line(p00, p01, color);
 push_line(p01, p02, color);
 push_line(p02, p03, color);
 push_line(p03, p00, color);

 push_line(p10, p11, color);
 push_line(p11, p12, color);
 push_line(p12, p13, color);
 push_line(p13, p10, color);

 push_line(p00, p10, color);
 push_line(p01, p11, color);
 push_line(p02, p12, color);
 push_line(p03, p13, color);
}

void push_box_outline(v3 center,
  v3 x_axis, v3 y_axis, v3 z_axis, v3 color = V3(1))
{
# 65 "code/renderer.cpp"
 v3 p[8];
 int i = 0;






 for (int dz = -1; dz <= 1; dz++) {
  for (int dy = -1; dy <= 1; dy++) {
   for (int dx = -1; dx <= 1; dx++) {
    if (dx && dy && dz) {
     p[i++] = center + x_axis * dx
      + y_axis * dy
      + z_axis * dz;
    }
   }
  }
 }

 v3 p00 = p[0];
 v3 p01 = p[1];
 v3 p02 = p[3];
 v3 p03 = p[2];

 v3 p10 = p[4];
 v3 p11 = p[5];
 v3 p12 = p[7];
 v3 p13 = p[6];


 push_line(p00, p01, color);
 push_line(p01, p02, color);
 push_line(p02, p03, color);
 push_line(p03, p00, color);

 push_line(p10, p11, color);
 push_line(p11, p12, color);
 push_line(p12, p13, color);
 push_line(p13, p10, color);

 push_line(p00, p10, color);
 push_line(p01, p11, color);
 push_line(p02, p12, color);
 push_line(p03, p13, color);
}

void push_triangle_outline(v3 p0, v3 p1, v3 p2, v3 color = V3(1))
{
 push_line(p0, p1, color);
 push_line(p1, p2, color);
 push_line(p2, p0, color);
}

void push_ellipsoid_outline(v3 p, v3 r, v3 color = V3(1))
{
 v3 x = V3(r.x, 0, 0);
 v3 y = V3(0, r.y, 0);
 v3 z = V3(0, 0, r.z);

 int itr_count = 60;
 float a = (2 * 3.14159265359f) / itr_count;

 for (int itr = 0; itr < itr_count; itr++)
 {
  float a0 = a * itr;
  float a1 = a * (itr + 1);

  v3 px0 = p + x * cosf(a0) + y * sinf(a0);
  v3 px1 = p + x * cosf(a1) + y * sinf(a1);

  v3 py0 = p + y * cosf(a0) + z * sinf(a0);
  v3 py1 = p + y * cosf(a1) + z * sinf(a1);

  v3 pz0 = p + x * cosf(a0) + z * sinf(a0);
  v3 pz1 = p + x * cosf(a1) + z * sinf(a1);

  push_line(px0, px1, color);
  push_line(py0, py1, color);
  push_line(pz0, pz1, color);
 }
}

void push_circle(v3 p, float r, v3 right_axis, v3 up_axis, v3 color = V3(1))
{
 right_axis = normalize(right_axis);
 up_axis = normalize(up_axis);

 int itr_count = 60;
 float a = (2 * 3.14159265359f) / itr_count;

 for (int itr = 0; itr < itr_count; itr++)
 {
  float a0 = a * itr;
  float a1 = a * (itr + 1);

  v3 p0 = p + r * (right_axis * cosf(a0) + up_axis * sinf(a0));
  v3 p1 = p + r * (right_axis * cosf(a1) + up_axis * sinf(a1));

  push_line(p0, p1, color);
 }
}

void compute_bone_transform(Array<Bone> bones, int i, Array<bool> computed)
{
 if (computed[i] || bones[i].parent == -1)
  return ;
 compute_bone_transform(bones, bones[i].parent, computed);
 bones[i].transform = bones[bones[i].parent].transform * bones[i].transform;
 computed[i] = true;
}

void render_bones(Array<Bone> bones, mat4 transform, Animation *anim, float anim_time)
{
 if (bones.count == 0)
  return ;

 Arena *temp = begin_temp_memory();

 Array<Bone> anim_bones = clone_array(temp, bones);

 if (anim) {
  for (usize i = 0; i < bones.count; i++) {
   int index = -1;
   for (usize j = 0; j < anim->nodes.count; j++) {
    if (strings_equal(anim->nodes[j].name, anim_bones[i].name)) {
     index = (int)j;
     break ;
    }
   }
   if (index != -1)
    anim_bones[i].transform = anim->nodes[index].transform;
  }
 }

 Array<bool> computed = make_array<bool>(temp, anim_bones.count);
 for (int i = 0; i < anim_bones.count; i++)
  computed[i] = false;
 for (int i = 0; i < anim_bones.count; i++)
  compute_bone_transform(anim_bones, i, computed);
 for (int i = 0; i < anim_bones.count; i++)
  anim_bones[i].transform = translate(-2, 0, 0) * transform * anim_bones[i].transform;

 for (usize i = 0; i < anim_bones.count; i++) {
  v3 P = (anim_bones[i].transform * v4{0, 0, 0, 1}).xyz;

  if (anim_bones[i].parent != -1) {
   v3 parentP = (anim_bones[anim_bones[i].parent].transform * v4{0, 0, 0, 1}).xyz;
   push_line(P, parentP);
  }
 }

 end_temp_memory();
}

Array<Bone> get_animated_bones(Arena *arena, Array<Bone> bones, mat4 transform, Animation *anim, float anim_time)
{
 Array<Bone> anim_bones = clone_array(arena, bones);

 for (usize i = 0; i < bones.count; i++) {
  int index = -1;
  for (usize j = 0; j < anim->nodes.count; j++) {
   if (strings_equal(anim->nodes[j].name, anim_bones[i].name)) {
    index = (int)j;
    break ;
   }
  }
  if (index != -1) {
   anim_bones[i].transform = anim->nodes[index].transform;
  }
 }

 Array<bool> computed = make_zero_array<bool>(arena, anim_bones.count);
 for (int i = 0; i < anim_bones.count; i++)
  compute_bone_transform(anim_bones, i, computed);
 for (int i = 0; i < anim_bones.count; i++)
  anim_bones[i].transform = transform * anim_bones[i].transform;
 return anim_bones;
}


void render_scene(Game &game, Scene &scene, Camera camera, SceneNode *node, mat4 scene_transform, mat4 node_transform,
  Animation *anim, float anim_time, v3 color)
{
 if (node->skip_render)
  return ;

 mat4 local_transform = node->local_transform;
 if (anim) {
  for (usize j = 0; j < anim->nodes.count; j++) {
   if (strings_equal(anim->nodes[j].name, node->name)) {
    local_transform = anim->nodes[j].transform;
    break ;
   }
  }
 }
 node_transform = node_transform * local_transform;

 if (node->mesh) {
  Mesh &mesh = *node->mesh;

  Constants constants = {};
  constants.view = camera.view;
  constants.projection = camera.projection;
  constants.camera_p = camera.position;
  constants.light_transform = game.shadow_map.projection * game.shadow_map.view;
  constants.color = color;
  constants.player_p = get_entity(*game.world, game.world->player_id)->position;
  constants.show_normals = game.show_normals;

  mat4 mesh_transform = scene_transform * node_transform * node->geometry_transform;

  constants.model = mesh_transform;

  if (mesh.bones.count && anim) {
   constants.skinned = 1;
   Arena *temp = begin_temp_memory();
   Array<Bone> bones = get_animated_bones(temp, mesh.bones, mesh_transform, anim, anim_time);
   for (usize j = 0; j < bones.count; j++)
    constants.bones[j] = bones[j].transform * bones[j].inv_bind;
   end_temp_memory();
  }

  for (usize j = 0; j < mesh.parts.count; j++) {
   MeshPart &part = mesh.parts[j];

   bind_texture(0, part.material.diffuse.valid ? part.material.diffuse : g_rc->white_texture);
   bind_texture(1, part.material.specular.valid ? part.material.specular : g_rc->white_texture);
   bind_texture(2, part.material.normal_map);
   bind_texture(3, part.material.specular_exponent.valid ? part.material.specular_exponent : g_rc->white_texture);

   constants.diffuse_factor = part.material.diffuse_factor;
   constants.specular_factor = part.material.specular_factor;
   constants.specular_exponent_factor = part.material.specular_exponent_factor;
   constants.has_normal_map = part.material.normal_map.valid;

   update_constant_buffer(game.constant_buffer, &constants);
   bind_vertex_buffer(mesh.vertex_buffer);
   draw((int)part.offset, (int)part.vertices_count);
  }
 }

 for (usize i = 0; i < node->childs.count; i++)
  render_scene(game, scene, camera, node->childs[i], scene_transform, node_transform, anim, anim_time, color);
}

void render_scene(Game &game, Scene &scene, Camera camera, mat4 transform, Animation *anim, float anim_time, v3 color)
{
 if (anim)
  anim_time = fmod(anim_time, anim->duration);
 render_scene(game, scene, camera, scene.root, transform, identity(), anim, anim_time, color);
}
# 34 "code/game.cpp" 2
# 1 "code/collision.cpp" 1
CollisionShape make_ellipsoid_shape(v3 radius)
{
 CollisionShape shape = {};

 shape.type = COLLISION_SHAPE_ELLIPSOID;
 shape.ellipsoid_radius = radius;
 return shape;
}

CollisionShape make_triangles_shape(Array<CollisionTriangle> triangles)
{
 CollisionShape shape = {};

 shape.type = COLLISION_SHAPE_TRIANGLES;
 shape.triangles = triangles;
 return shape;
}

CollisionShape make_box_shape(Arena *arena, v3 radius)
{
 Array<CollisionTriangle> triangles = make_array_max<CollisionTriangle>(arena, 12);

 v3 p00 = V3(-radius.x, -radius.y, -radius.z);
 v3 p01 = V3(+radius.x, -radius.y, -radius.z);
 v3 p02 = V3(+radius.x, +radius.y, -radius.z);
 v3 p03 = V3(-radius.x, +radius.y, -radius.z);
 v3 p10 = V3(-radius.x, -radius.y, +radius.z);
 v3 p11 = V3(+radius.x, -radius.y, +radius.z);
 v3 p12 = V3(+radius.x, +radius.y, +radius.z);
 v3 p13 = V3(-radius.x, +radius.y, +radius.z);


 triangles.push({p00, p02, p01});
 triangles.push({p00, p03, p02});

 triangles.push({p10, p11, p12});
 triangles.push({p10, p12, p13});

 triangles.push({p00, p10, p13});
 triangles.push({p00, p13, p03});

 triangles.push({p01, p12, p11});
 triangles.push({p01, p02, p12});

 triangles.push({p00, p01, p11});
 triangles.push({p00, p11, p10});

 triangles.push({p03, p12, p02});
 triangles.push({p03, p13, p12});

 CollisionShape shape = {};

 shape.type = COLLISION_SHAPE_TRIANGLES;
 shape.triangles = triangles;
 shape.box_radius = radius;
 return shape;
}

struct CollisionInfo
{
 v3 hit_p;
 v3 hit_normal;
 float t;
};





void intersect_line(v3 A, v3 B, v3 dir, CollisionInfo &info)
{
 v3 D = dir;
 v3 d = normalize(B - A);
 v3 V = (A - dot(A, d) * d);
 v3 X = D - d * dot(D, d);

 float a = dot(X, X);
 float b = -2*dot(X, V);
 float c = dot(V, V) - 1;
 float delta = b * b - 4 * a * c;
 if (delta < 0 || fabsf(a) < 1e-6)
  return ;
 delta = sqrtf(delta);

 auto check_t = [&](float t) {
  if (t < 0 || t >= info.t)
   return ;

  v3 h = t * dir;
  v3 p = h - ((h - A) - d * dot(h - A, d));
  if (dot(p - A, B - A) >= 0 && length_sq(p - A) <= length_sq(B - A)) {
   info.t = t;
   info.hit_p = p;
  }
 };
 check_t((-b + delta)/(2*a));
 check_t((-b - delta)/(2*a));
}

void intersect_vertex(v3 p, v3 dir, CollisionInfo &info)
{
 float a = dot(dir, dir);
 float b = -2*dot(dir, p);
 float c = dot(p, p) - 1;
 float delta = b * b - 4 * a * c;
 if (delta < 0)
  return ;
 delta = sqrtf(delta);
 float t0 = (-b - delta)/(2*a);
 float t1 = (-b + delta)/(2*a);

 if (t1 >= 0 && t1 < t0)
  t0 = t1;

 if (t0 >= 0 && t0 <= info.t) {
  info.t = t0;
  info.hit_p = p;
 }
}

void intersect_triangle_plane(v3 v0, v3 v1, v3 v2, v3 dir, CollisionInfo &info)
{
 v3 u = v1 - v0;
 v3 v = v2 - v0;
 v3 n = cross(u, v);

 v3 normal = normalize(n);

 if (fabsf(dot(normal, dir)) < 1e-6)
  return ;

 if (dot(normal, dir) > 0)
  normal *= -1;

 float t0 = (1 + dot(v0, normal)) / (dot(normal, dir));
 float t1 = (-1 + dot(v0, normal)) / (dot(normal, dir));

 float one_over_length_n_sq = 1.f / dot(n, n);

 auto check_t = [&](float t) {
  if (t >= info.t || t < 0)
   return ;

  v3 p = t * dir;
  p = v0 + (p-v0)-dot(p - v0, normal)*normal;
# 154 "code/collision.cpp"
  float A = dot(cross(p - v0, v), n) * one_over_length_n_sq;
  float B = -dot(cross(p - v0, u), n) * one_over_length_n_sq;

  if (A >= 0 && B >= 0 && A + B <= 1) {
   info.t = t;
   info.hit_p = p;
  }
 };
 check_t(t0);
 check_t(t1);
}

CollisionInfo ellipsoid_intersect_triangle(v3 targetP, v3 ep, v3 er, v3 v0, v3 v1, v3 v2)
{
 CollisionInfo info = {};

 info.t = 3.40282346638528859811704183484516925e+38F;

 v3 inv_r = V3(1/er.x, 1/er.y, 1/er.z);
# 183 "code/collision.cpp"
 v3 t0 = inv_r * (v0 - ep);
 v3 t1 = inv_r * (v1 - ep);
 v3 t2 = inv_r * (v2 - ep);
 v3 dir = inv_r * (targetP - ep);

 intersect_triangle_plane(t0, t1, t2, dir, info);

 intersect_vertex(t0, dir, info);
 intersect_vertex(t1, dir, info);
 intersect_vertex(t2, dir, info);

 intersect_line(t0, t1, dir, info);
 intersect_line(t1, t2, dir, info);
 intersect_line(t0, t2, dir, info);




 info.hit_normal = inv_r * (info.t * dir - info.hit_p);
 info.hit_p = ep + (info.hit_p * er);

 return info;
}

CollisionInfo ellipsoid_intersect_ellipsoid(v3 targetP, v3 ep, v3 er, v3 tp, v3 tr)
{
 CollisionInfo info = {};

 info.t = 3.40282346638528859811704183484516925e+38F;







 v3 radius = er + tr;

 mat4 m = translate(tp) * scale(radius);
 mat4 M = scale(1 / radius) * translate(-tp);

 v3 ray_origin = (M * V4(ep, 1)).xyz;
 v3 ray_dir = (M * V4(targetP, 1)).xyz - ray_origin;

 float a = dot(ray_dir, ray_dir);
 float b = 2 * dot(ray_origin, ray_dir);
 float c = dot(ray_origin, ray_origin) - 1;

 float delta = b * b - 4 * a * c;

 if (delta < 0)
  return info;

 delta = sqrtf(delta);
 float t0 = (-b - delta) / (2 * a);
 float t1 = (-b + delta) / (2 * a);

 if (t1 >= 0 && t1 < t0)
  t0 = t1;

 if (t0 >= 0) {
  info.t = t0;


  info.hit_normal = (transpose(M) * V4(ray_origin + t0*ray_dir, 0)).xyz;
 }
 return info;
}

CollisionInfo move_entity(World &world, Entity &e, v3 delta_p, Array<CollisionShape> shapes)
{
 CollisionInfo first_hit = {};

 v3 e_radius = e.scale * e.shape.ellipsoid_radius;

 for (int itr = 0; itr < 4; itr++) {
  if (length_sq(delta_p) < 0.01f*0.01f)
   break ;

  CollisionInfo hit_info = {};
  hit_info.t = 3.40282346638528859811704183484516925e+38F;

  for (int i = 0; i < shapes.count; i++) {
   CollisionInfo info;

   if (shapes[i].type == COLLISION_SHAPE_TRIANGLES) {
    for (int j = 0; j < shapes[i].triangles.count; j++) {
     v3 p0 = (shapes[i].transform * V4(shapes[i].triangles[j].v0, 1)).xyz;
     v3 p1 = (shapes[i].transform * V4(shapes[i].triangles[j].v1, 1)).xyz;
     v3 p2 = (shapes[i].transform * V4(shapes[i].triangles[j].v2, 1)).xyz;

     info = ellipsoid_intersect_triangle(e.position + delta_p, e.position, e_radius,
       p0, p1, p2);
     if (info.t < hit_info.t)
      hit_info = info;
    }
   }
   else if (shapes[i].type == COLLISION_SHAPE_ELLIPSOID) {
    info = ellipsoid_intersect_ellipsoid(e.position + delta_p, e.position, e_radius,
      V3(shapes[i].transform.e[0][3],
       shapes[i].transform.e[1][3],
       shapes[i].transform.e[2][3]),
      shapes[i].ellipsoid_radius
      * shapes[i].scale);
    if (info.t < hit_info.t)
     hit_info = info;
   }
   else
    
# 291 "code/collision.cpp" 3 4
   (static_cast <bool> (
# 291 "code/collision.cpp"
   0
# 291 "code/collision.cpp" 3 4
   ) ? void (0) : __assert_fail (
# 291 "code/collision.cpp"
   "0"
# 291 "code/collision.cpp" 3 4
   , "code/collision.cpp", 291, __extension__ __PRETTY_FUNCTION__))
# 291 "code/collision.cpp"
            ;
  }

  if (!itr)
   first_hit = hit_info;


  if (hit_info.t >= 1) {
   if (hit_info.t != 3.40282346638528859811704183484516925e+38F && length_sq(delta_p * (hit_info.t - 1)) < 0.01f * 0.01f)
    e.position += normalize(delta_p) * (length(delta_p) - (0.01f - length(delta_p * (hit_info.t - 1))));
   else
    e.position += delta_p;
   break ;
  }

  if (length_sq(delta_p*hit_info.t) >= 0.01f*0.01f)
   e.position += normalize(delta_p) * (length(delta_p)*hit_info.t - 0.01f);

  v3 normal = normalize(hit_info.hit_normal);

  v3 old_delta_p = delta_p;
  delta_p *= (1 - hit_info.t);
  delta_p = delta_p - normal*dot(normal, delta_p)*1.2f;
 }

 return first_hit;
}

void move_entity(World &world, Entity &e, v3 delta_p)
{
 
# 321 "code/collision.cpp" 3 4
(static_cast <bool> (
# 321 "code/collision.cpp"
e.shape.type == COLLISION_SHAPE_ELLIPSOID
# 321 "code/collision.cpp" 3 4
) ? void (0) : __assert_fail (
# 321 "code/collision.cpp"
"e.shape.type == COLLISION_SHAPE_ELLIPSOID"
# 321 "code/collision.cpp" 3 4
, "code/collision.cpp", 321, __extension__ __PRETTY_FUNCTION__))
# 321 "code/collision.cpp"
                                                 ;

 Arena *temp = begin_temp_memory();

 Array<CollisionShape> shapes = make_array_max<CollisionShape>(temp, world.entities.count + 64);

 for (int i = 0; i < world.entities.count; i++) {
  Entity &test = world.entities[i];

  if (test.id == e.id)
   continue ;

  CollisionShape shape = test.shape;
  shape.transform = get_entity_transform(test);

  if (shape.type == COLLISION_SHAPE_ELLIPSOID)
   shape.scale = test.scale;

  shapes.push(shape);
 }
# 349 "code/collision.cpp"
 v3 old_p = e.position;
 move_entity(world, e, V3(delta_p.x, delta_p.y, 0), shapes);

 int itr = 1 + roundf(fabsf(delta_p.z) / (0.01f*3.5f));
 for (int i = 0; i < itr; i++)
  move_entity(world, e, V3(0, 0, delta_p.z / itr), shapes);

 if (fabsf(e.position.x - old_p.x) < 1e-7)
  e.dp.x = 0;
 if (fabsf(e.position.y - old_p.y) < 1e-7)
  e.dp.y = 0;
 if (fabsf(e.position.z - old_p.z) < 1e-7)
  e.dp.z = 0;


 v3 save_p = e.position;

 CollisionInfo collision = move_entity(world, e, V3(0, 0, -1), shapes);
 e.position = save_p;



 float height_above_ground = e.position.z - collision.hit_p.z - e.scale.z*e.shape.ellipsoid_radius.z
  - 0.01f;
 if (collision.t < 0 || collision.t == 3.40282346638528859811704183484516925e+38F)
  height_above_ground = 10000;
 if (height_above_ground < 0)
  height_above_ground = 0;
 e.height_above_ground = height_above_ground;

 if (e.height_above_ground > 0.6)
  e.can_jump = false;
 e.on_ground = e.height_above_ground < 0.01f;
 if (e.on_ground)
  e.can_jump = true;

 end_temp_memory();
}
# 35 "code/game.cpp" 2
# 1 "code/world.cpp" 1
Entity *make_entity(World &world, int type, Scene *scene, v3 position, CollisionShape shape, mat4 scene_transform = identity())
{
 Entity e = {};

 e.id = ++world.next_entity_id;
 e.type = type;
 e.position = position;
 e.scene = scene;
 e.scene_transform = scene_transform;
 e.shape = shape;
 e.color = V3(1);
 e.scale = V3(1);
 world.entities.push(e);
 world.entities_id_map[e.id] = world.entities.count - 1;
 return &world.entities[world.entities.count - 1];
}

Entity *get_entity(World &world, entity_id id)
{






 auto it = world.entities_id_map.find(id);
 if (it != world.entities_id_map.end())
  return &world.entities[it->second];

 return 0;
}

mat4 get_entity_transform(Entity &e)
{
 return translate(e.position)
  * zrotation(e.rotation.z) * yrotation(e.rotation.y) * xrotation(e.rotation.x) * scale(e.scale);
}

void render_entities(Game &game, World &world, Camera camera)
{

 bind_constant_buffer(game.constant_buffer, 0);

 for (usize i = 0; i < world.entities.count; i++) {
  Entity &e = world.entities[i];
  if (!e.scene)
   continue ;

  mat4 entity_transform = get_entity_transform(e);
  mat4 scene_transform = entity_transform * e.scene_transform;

  Arena *temp = begin_temp_memory();
  Animation *final_anim = 0;
  Animation anim = {};
  if (e.id == world.player_id) {
   usize max_nodes_count = e.curr_anim->nodes.count;
   if (e.next_anim && e.next_anim->nodes.count > max_nodes_count)
    max_nodes_count = e.next_anim->nodes.count;

   anim.nodes = make_array<NodeAnimation>(temp, max_nodes_count);
   if (e.next_anim)
    
# 62 "code/world.cpp" 3 4
   (static_cast <bool> (
# 62 "code/world.cpp"
   e.curr_anim->nodes.count == e.next_anim->nodes.count
# 62 "code/world.cpp" 3 4
   ) ? void (0) : __assert_fail (
# 62 "code/world.cpp"
   "e.curr_anim->nodes.count == e.next_anim->nodes.count"
# 62 "code/world.cpp" 3 4
   , "code/world.cpp", 62, __extension__ __PRETTY_FUNCTION__))
# 62 "code/world.cpp"
                                                               ;

   float blend_duration = e.next_anim ? e.next_anim->duration*0.2f : 0;
   if (e.blend_time > blend_duration && e.next_anim) {
    e.curr_anim = e.next_anim;
    e.anim_time = e.blend_time;
    e.next_anim = 0;
   }

   if (!e.next_anim) {
    
# 72 "code/world.cpp" 3 4
   (static_cast <bool> (
# 72 "code/world.cpp"
   e.curr_anim
# 72 "code/world.cpp" 3 4
   ) ? void (0) : __assert_fail (
# 72 "code/world.cpp"
   "e.curr_anim"
# 72 "code/world.cpp" 3 4
   , "code/world.cpp", 72, __extension__ __PRETTY_FUNCTION__))
# 72 "code/world.cpp"
                      ;
    for (int j = 0; j < e.curr_anim->nodes.count; j++) {
     anim.nodes[j].name = e.curr_anim->nodes[j].name;
     anim.nodes[j].transform = get_animated_node_transform(*e.curr_anim,
       e.curr_anim->nodes[j], fmod(e.anim_time, e.curr_anim->duration));
    }
   } else {
    float t1 = fmod(e.anim_time, e.curr_anim->duration);
    float t2 = fmod(e.blend_time, e.next_anim->duration);
    float t3 = (e.blend_time) / blend_duration;


    for (int j = 0; j < e.curr_anim->nodes.count; j++) {
     quat q1, q2;
     v3 p1, s1, p2, s2;
     
# 87 "code/world.cpp" 3 4
    (static_cast <bool> (
# 87 "code/world.cpp"
    strings_equal(e.curr_anim->nodes[j].name, e.next_anim->nodes[j].name)
# 87 "code/world.cpp" 3 4
    ) ? void (0) : __assert_fail (
# 87 "code/world.cpp"
    "strings_equal(e.curr_anim->nodes[j].name, e.next_anim->nodes[j].name)"
# 87 "code/world.cpp" 3 4
    , "code/world.cpp", 87, __extension__ __PRETTY_FUNCTION__))
# 87 "code/world.cpp"
                                                                                 ;
     get_animated_node_transform(*e.curr_anim, e.curr_anim->nodes[j], t1, p1, s1, q1);
     get_animated_node_transform(*e.next_anim, e.next_anim->nodes[j], t2, p2, s2, q2);

     anim.nodes[j].name = e.curr_anim->nodes[j].name;

     v3 p = lerp(p1, p2, t3);
     quat q = quat_lerp(q1, q2, t3);
     v3 s = lerp(s1, s2, t3);

     anim.nodes[j].transform = translate(p) * quat_to_mat(q) * scale(s);

    }
   }
   final_anim = &anim;
  }
  else
   
# 104 "code/world.cpp" 3 4
  (static_cast <bool> (
# 104 "code/world.cpp"
  !final_anim
# 104 "code/world.cpp" 3 4
  ) ? void (0) : __assert_fail (
# 104 "code/world.cpp"
  "!final_anim"
# 104 "code/world.cpp" 3 4
  , "code/world.cpp", 104, __extension__ __PRETTY_FUNCTION__))
# 104 "code/world.cpp"
                     ;



  render_scene(game, *e.scene, camera, scene_transform, final_anim, 0, e.color);

  if (game.debug_collision) {

   v3 color = e.id == world.editor_selected_entity ? V3(1, 1, 0) : V3(1, 0, 0);
   if (e.shape.type == COLLISION_SHAPE_TRIANGLES) {
    for (int j = 0; j < e.shape.triangles.count; j++) {
     v3 p0 = (entity_transform * V4(e.shape.triangles[j].v0, 1)).xyz;
     v3 p1 = (entity_transform * V4(e.shape.triangles[j].v1, 1)).xyz;
     v3 p2 = (entity_transform * V4(e.shape.triangles[j].v2, 1)).xyz;

     v3 n = normalize(cross(p1 - p0, p2 - p0));
     v3 o = n * 0.01f;
     push_triangle_outline(p0 + o, p1 + o, p2 + o, color);
    }
   }
   else if (e.shape.type == COLLISION_SHAPE_ELLIPSOID) {
    push_ellipsoid_outline(e.position, e.scale * e.shape.ellipsoid_radius, color);
   }
  }
  end_temp_memory();
 }

}

void update_player(Game &game, World &world, GameInput &input, float dt)
{

 Entity *_player = get_entity(world, world.player_id);
 if (!_player)
  return ;
 Entity &player = *_player;

 player.color = V3(0, 1, 1);

 b32 camera_shoot_mode = false;
 b32 walk_backward = false;
 {
  v3 player_forward = normalize(V3(cosf(player.rotation.z), sinf(player.rotation.z), 0));
  v3 player_up = V3(0, 0, 1);
  v3 player_right = normalize(cross(player_forward, player_up));
  v3 a = {};

  bool forward = false;

  if ((input.buttons[BUTTON_F].is_down))
  {
   a += player_forward;
   forward = true;
  }
  if ((input.buttons[BUTTON_G].is_down))
  {
   a -= player_forward;
   walk_backward = true;
  }
  a = normalize(a);

  player.moved = forward;
  player.run = input.buttons[BUTTON_LEFT_SHIFT].is_down && forward;
  if (!(input.buttons[BUTTON_MOUSE_LEFT].is_down) || player.run || player.moved)
   player.shooting = false;
  else
  {
   player.shooting = true;
   player.run = false;
   player.moved = false;
   a = {};

  }



  a += -40 * player_up;
  a.xy = a.xy * (player.run ? 50 : 30);
  bool jumped = false;
  if ((input.buttons[BUTTON_SPACE].is_down) && player.can_jump)
  {

   a += 200 * player_up;
   a.xy = {};
   jumped = true;
  }



  a -= player.dp * 3;

  {
   v3 delta_p = 0.5f * dt * dt * a + dt * player.dp;

   move_entity(world, player, delta_p);
   player.dp += a * dt;

  }
# 213 "code/world.cpp"
  {


   Animation *next_anim = 0;
   player.anim_time += dt;
   player.blend_time += dt;

   if (!player.curr_anim)
    player.curr_anim = &game.animations[ANIMATION_GUN_IDLE];


   if (!player.on_ground) {
    if (player.curr_anim != &game.animations[ANIMATION_JUMP]
      && player.next_anim != &game.animations[ANIMATION_JUMP]
      && !jumped)
     next_anim = player.next_anim;
    else
     next_anim = &game.animations[ANIMATION_JUMP];
   }
   else if (player.shooting)
    next_anim = &game.animations[ANIMATION_SHOOT];
   else if (player.run)
    next_anim = &game.animations[ANIMATION_RUN];
   else if (walk_backward)
    next_anim = &game.animations[ANIMATION_BACKWARD_GUN_WALK];
   else if (player.moved)
    next_anim = &game.animations[ANIMATION_FORWARD_GUN_WALK];
   else
    next_anim = &game.animations[ANIMATION_GUN_IDLE];

   if (!player.curr_anim)
    player.curr_anim = next_anim;
   else if (!next_anim)
    ;
   else if (!player.next_anim) {
    if (player.curr_anim != next_anim) {
     player.next_anim = next_anim;
     player.blend_time = 0;
    }
   }
   else if (next_anim == player.next_anim)
    ;
   else if (next_anim != player.curr_anim) {






   }
   else {
    player.next_anim = 0;
    player.blend_time = 0;
   }
# 275 "code/world.cpp"
   int curr_anim_idx = -1;
   int next_anim_idx = -1;
   for (int i = 0; i < ANIMATION_COUNT; i++) {
    if (player.curr_anim == &game.animations[i])
     curr_anim_idx = i;
    if (player.next_anim == &game.animations[i])
     next_anim_idx = i;
   }
# 294 "code/world.cpp"
  }
 }
}

void update_enemies(Game &game, World &world, GameInput &input, float dt)
{
 for (int i = 0; i < world.entities.count; i++)
 {
  Entity &e = world.entities[i];

  if (e.type != EntityType_Enemy)
   continue;

  Entity *player = get_entity(world, world.player_id);

  v3 dir = {};
  if (player)
   dir = player->position - e.position;

  if (length(dir) > 1)
   dir = normalize(dir);

  v3 a = normalize(V3(dir.x, dir.y, 0));

  a += -40 * V3(0, 0, 1);
  a.xy = a.xy * e.speed;

  if (dir.z > 0 && e.can_jump) {
   a += 200 * V3(0, 0, 1);
   a.xy *= 0.3f;
  }

  a -= e.dp * 3;

  v3 delta_p = 0.5f * dt * dt * a + dt * e.dp;

  move_entity(world, e, delta_p);


  e.dp += a * dt;

  if (!e.on_ground)
   e.animation = &game.animations[ANIMATION_JUMP];
  else
   e.animation = &game.animations[ANIMATION_RUN];

  e.rotation.z = atan2(dir.y, dir.x);
  e.anim_time += dt;
 }
}

Camera update_camera(Game &game, World &world, GameInput &input, float dt)
{
 Camera camera = {};

 Entity *player = get_entity(world, world.player_id);
 if (!player)
  
# 351 "code/world.cpp" 3 4
 (static_cast <bool> (
# 351 "code/world.cpp"
 0
# 351 "code/world.cpp" 3 4
 ) ? void (0) : __assert_fail (
# 351 "code/world.cpp"
 "0"
# 351 "code/world.cpp" 3 4
 , "code/world.cpp", 351, __extension__ __PRETTY_FUNCTION__))
# 351 "code/world.cpp"
          ;





 if (game.in_editor && (ImGui::GetIO().WantCaptureMouse || !(input.buttons[BUTTON_MOUSE_LEFT].is_down)))
  input.mouse_dp = {};


 v3 camera_rot;
 if (game.in_editor) {
  world.editor_camera_rotation.x += -input.mouse_dp.y * dt * 0.2f;
  world.editor_camera_rotation.z += -input.mouse_dp.x * dt * 0.2f;

  if (world.editor_camera_rotation.x > 3.14159265359f / 2 - 0.001f)
   world.editor_camera_rotation.x = 3.14159265359f / 2 - 0.001f;
  if (world.editor_camera_rotation.x < -3.14159265359f / 2 + 0.001f)
   world.editor_camera_rotation.x = -3.14159265359f / 2 + 0.001f;
  camera_rot = world.editor_camera_rotation;
 }
 else {
  v2 mouse_dp = (input.mouse_dp) * 0.1f;
  v3 a = {-24*mouse_dp.y, 0, -20*mouse_dp.x};


  a -= world.player_camera_drotation * 10;
  world.player_camera_rotation += 0.5 * a * dt * dt + world.player_camera_drotation * dt;
  world.player_camera_drotation += a * dt;
  {
   if (world.player_camera_rotation.x >= 3.14159265359f / 2)
    world.player_camera_rotation.x = 3.14159265359f / 2;
   if (world.player_camera_rotation.x <= -3.14159265359f / 2)
    world.player_camera_rotation.x = -3.14159265359f / 2;
  }
  world.player_camera_rotation.z = fmod(world.player_camera_rotation.z, 2*3.14159265359f);

  camera_rot = world.player_camera_rotation;
  camera_rot.z -= 3.14159265359f / 2;
  player->rotation.z = world.player_camera_rotation.z;
  {
   v3 player_forward = normalize(V3(cosf(player->rotation.z), sinf(player->rotation.z), 0));

   float o = camera_rot.x;

   float t[4] = {-3.14159265359f/2, 0, 3.14159265359f/2.5, 3.14159265359f/2};
   
# 397 "code/world.cpp" 3 4
  (static_cast <bool> (
# 397 "code/world.cpp"
  player->shape.type == COLLISION_SHAPE_ELLIPSOID
# 397 "code/world.cpp" 3 4
  ) ? void (0) : __assert_fail (
# 397 "code/world.cpp"
  "player->shape.type == COLLISION_SHAPE_ELLIPSOID"
# 397 "code/world.cpp" 3 4
  , "code/world.cpp", 397, __extension__ __PRETTY_FUNCTION__))
# 397 "code/world.cpp"
                                                         ;

   v3 v[4] = {
    player->position + V3(0, 0, player->shape.ellipsoid_radius.z*3),
    player->position - player_forward * 3 + V3(0, 0, player->shape.ellipsoid_radius.z * 0.5),
    player->position - player_forward * 1.5
     + V3(0, 0, -player->shape.ellipsoid_radius.z +0.2),
    player->position - V3(0, 0, player->shape.ellipsoid_radius.z-0.1),

   };




   mat4 M;
   mat4 V;

   for (int i = 0; i < 4; i++) {
    for (int j = 0; j < 4; j++) {
     M.e[i][j] = 1;
     for (int k = 0; k < 3 - i; k++)
      M.e[i][j] *= t[j];

     if (i == 3)
      V.e[i][j] = 0;
     else
      V.e[i][j] = v[j].e[i];
    }
   }

   M = inverse(M);

   mat4 A = V * M;

   world.player_camera_p = (A * V4(o*o*o, o*o, o, 1)).xyz;
# 442 "code/world.cpp"
  }
 }



 mat4 camera_transform;
 if (game.in_editor)
  camera_transform = translate(world.editor_camera_p) * zrotation(camera_rot.z) * xrotation(camera_rot.x);
 else
  camera_transform = translate(world.player_camera_p) * zrotation(camera_rot.z) * xrotation(camera_rot.x) ;

 v3 camera_x = (camera_transform * v4{1, 0, 0, 0}).xyz;
 v3 camera_y = (camera_transform * v4{0, 0, 1, 0}).xyz;
 v3 camera_z = (camera_transform * v4{0, -1, 0, 0}).xyz;




  if (game.in_editor && !(input.buttons[BUTTON_LEFT_CONTROL].is_down)
    && !ImGui::GetIO().WantCaptureKeyboard)

  {
   v3 camera_dp = {};
   if ((input.buttons[BUTTON_W].is_down))
    camera_dp -= camera_z;
   if ((input.buttons[BUTTON_S].is_down))
    camera_dp += camera_z;
   if ((input.buttons[BUTTON_A].is_down))
    camera_dp -= camera_x;
   if ((input.buttons[BUTTON_D].is_down))
    camera_dp += camera_x;
   if ((input.buttons[BUTTON_Q].is_down))
    camera_dp += camera_y;
   if ((input.buttons[BUTTON_E].is_down))
    camera_dp -= camera_y;
   world.editor_camera_p += normalize(camera_dp) * dt * 8;
  }

 mat4 rotation = {
  camera_x.x, camera_x.y, camera_x.z, 0,
  camera_y.x, camera_y.y, camera_y.z, 0,
  camera_z.x, camera_z.y, camera_z.z, 0,
  0, 0, 0, 1
 };

 v3 p = game.in_editor ? world.editor_camera_p : world.player_camera_p;
 mat4 view = rotation * translate(-p);


 float fov = 100;
 camera.znear = 0.1f;
 camera.zfar = 100;
 camera.width = 2 * camera.znear * tanf((3.14159265359f / 180.f) * (fov / 2));
 camera.height = camera.width * (float)g_rc->window_height / g_rc->window_width;
 camera.forward = -camera_z;
 camera.right = camera_x;
 camera.up = camera_y;

 mat4 projection = perspective_projection(camera.znear, camera.zfar, fov, (float)g_rc->window_height / g_rc->window_width);

 camera.position = p;
 camera.view = view;
 camera.projection = projection;
 return camera;
}
# 36 "code/game.cpp" 2
# 1 "code/ai.cpp" 1
# 37 "code/game.cpp" 2
# 1 "code/editor.cpp" 1
entity_id raycast_to_entities(World &world, v3 ray_origin, v3 ray_dir,
  float &hit_t)
{
 entity_id hit_id = 0;
 float min_t = 3.40282346638528859811704183484516925e+38F;

 for (usize i = 0; i < world.entities.count; i++) {
  Entity &e = world.entities[i];
  if (!e.scene)
   continue ;

  mat4 transform = get_entity_transform(e) * e.scene_transform;
  for (usize j = 0; j < e.scene->meshes.count; j++) {
   Mesh &mesh = e.scene->meshes[j];
   mat4 mesh_transform = transform * mesh.transform;

   v3 x_axis = normalize((mesh_transform * V4(1, 0, 0, 0)).xyz);
   v3 y_axis = normalize((mesh_transform * V4(0, 1, 0, 0)).xyz);
   v3 z_axis = normalize((mesh_transform * V4(0, 0, 1, 0)).xyz);

   v3 a = (mesh_transform * V4(mesh.box_min, 1)).xyz;
   v3 b = (mesh_transform * V4(mesh.box_max, 1)).xyz;

   v3 c = (a + b) * 0.5f;

   x_axis *= fabsf(dot((b - a)*0.5f, x_axis));
   y_axis *= fabsf(dot((b - a)*0.5f, y_axis));
   z_axis *= fabsf(dot((b - a)*0.5f, z_axis));



   float t = ray_hit_box(ray_origin, ray_dir, c, x_axis, y_axis, z_axis);
   if (t >= 0 && t < min_t) {
    hit_id = e.id;
    min_t = t;
   }


  }
 }
 hit_t = min_t;
 return hit_id;
}

void update_editor(World &world, Editor &editor, GameInput &input, Camera &camera)
{
 v2 mouse_p = (input.mouse_p * V2(1.f / g_rc->window_width, 1.f / g_rc->window_height)) * 2 - V2(1);
 mouse_p.y *= -1;

 v3 ray_origin = camera.position;
 v3 ray_dir = camera.forward * camera.znear
  + mouse_p.x * camera.right * camera.width * 0.5f
  + mouse_p.y * camera.up * camera.height * 0.5f;
 if ((input.buttons[BUTTON_LEFT_CONTROL].is_down)) {
  if ((input.buttons[BUTTON_T].is_down)) editor.gizmo_mode = GIZMO_TRANSLATION;
  else if ((input.buttons[BUTTON_R].is_down)) editor.gizmo_mode = GIZMO_ROTATION;
  else if ((input.buttons[BUTTON_S].is_down)) editor.gizmo_mode = GIZMO_SCALE;
 }
 float rotation_inner_radius = 1.5;
 float rotation_outer_radius = 2;
 float rotation_circle_radius = 0.5f * (rotation_inner_radius + rotation_outer_radius);
 v3 axis[3] = {
  2*V3(1, 0, 0),
  2*V3(0, 1, 0),
  2*V3(0, 0, 1)
 };

 if (editor.gizmo_mode == GIZMO_SCALE) {
  Entity *e = get_entity(world, editor.selected_entity);
  if (e) {
   mat4 transform = get_entity_transform(*e);

   for (int i = 0; i < 3; i++)
    axis[i] = V3(transform.e[0][i], transform.e[1][i], transform.e[2][i]);
   for (int i = 0; i < 3; i++)
    axis[i] = 2 * normalize(axis[i]);
  }
 }

 if ((input.buttons[BUTTON_MOUSE_RIGHT].is_down)) {
  float min_hit_t;
  entity_id hit_entity = raycast_to_entities(world, ray_origin, ray_dir, min_hit_t);

  if (editor.selected_entity && !editor.in_gizmo) {
   Entity *e = get_entity(world, editor.selected_entity);
   if (e) {
    float min_axis_t = 3.40282346638528859811704183484516925e+38F;
    int best_axis = -1;
    for (int i = 0; i < 3; i++) {

     float t = -1;
     if (editor.gizmo_mode == GIZMO_ROTATION) {
      if (ray_hit_plane(ray_origin, ray_dir, axis[i], e->position, &t)) {
       v3 p = ray_origin + t * ray_dir;

       if (t >= 0 &&
        length(p - e->position) > rotation_inner_radius
       && length(p - e->position) < rotation_outer_radius) {
       }
       else
        t = -1;
      }
     }
     else {
      t = ray_hit_box(ray_origin, ray_dir, e->position + 0.5f * axis[i],
       axis[0] * (i == 0 ? 0.5f : 0.25f),
       axis[1] * (i == 1 ? 0.5f : 0.25f),
       axis[2] * (i == 2 ? 0.5f : 0.25f));
     }

     if (t >= 0 && t < min_axis_t) {
      min_axis_t = t;
      best_axis = i;
     }
    }
    if (min_axis_t != 3.40282346638528859811704183484516925e+38F) {


     editor.in_gizmo = true;
     editor.did_drag = false;
     editor.s_did_drag = false;
     editor.r_did_drag = false;
     editor.dragging_axis = best_axis;
    }
   }
  }

   if (editor.in_gizmo) {

    Entity *e = get_entity(world, editor.selected_entity);
    if (e) {
     if (editor.did_drag && !v3_equal(camera.position, editor.last_camera_p))
      editor.did_drag = false;


     v3 plane_normal = cross(axis[editor.dragging_axis], cross(axis[editor.dragging_axis], camera.forward));
     if (editor.gizmo_mode == GIZMO_ROTATION) {

      plane_normal = axis[editor.dragging_axis];
     }

     push_line(e->position, e->position + normalize(plane_normal) * 2,
       V3(1, 0, 1));

     float hit_t;
     if (ray_hit_plane(ray_origin, ray_dir, plane_normal, e->position, &hit_t)) {
      v3 hit_p = ray_origin + hit_t * ray_dir;

      if (editor.gizmo_mode == GIZMO_TRANSLATION) {

       v3 dp = normalize(axis[editor.dragging_axis]) * dot(hit_p - e->position, normalize(axis[editor.dragging_axis]));

       if (!editor.did_drag) {
        editor.did_drag = true;
        editor.drag_p = dp;
       }
       else
        e->position += dp - editor.drag_p;
      }
      else if (editor.gizmo_mode == GIZMO_SCALE) {
       float ds = dot(hit_p - e->position, normalize(axis[editor.dragging_axis]));


       if (!editor.s_did_drag) {
        editor.s_did_drag = true;
        editor.s_init_drag = ds;
        editor.s_init_scale = e->scale.e[editor.dragging_axis];
       }
       else {
        e->scale.e[editor.dragging_axis] =
         editor.s_init_scale + ds - editor.s_init_drag;
        if (e->scale.e[editor.dragging_axis] < 0.01f)
         e->scale.e[editor.dragging_axis] = 0.01f;
       }
      }
      else if (editor.gizmo_mode == GIZMO_ROTATION) {
       v3 p = normalize(hit_p - e->position) * rotation_circle_radius;


       push_cube_outline(e->position + p, V3(0.1), V3(0));

       v3 right_axis = axis[(editor.dragging_axis+1)%3];
       v3 up_axis = axis[(editor.dragging_axis+2)%3];
# 195 "code/editor.cpp"
       mat4 m = inverse(
         mat4_cols(V4(right_axis, 0),
          V4(up_axis, 0), V4(axis[editor.dragging_axis], 0),
          V4(0, 0, 0, 1)));

       p = (m * V4(p, 0)).xyz;

       push_line(e->position, e->position + right_axis, V3(1));
       push_line(e->position, e->position + up_axis, V3(0.2));

       float a = atan2(p.y, p.x);

       if (!editor.r_did_drag) {
        editor.r_did_drag = true;
        editor.r_init_drag = a;
        editor.r_init_rot = e->rotation.e[editor.dragging_axis];
       }
       else {
        e->rotation.e[editor.dragging_axis]
         = editor.r_init_rot + (a - editor.r_init_drag);
       }

      }
     }
    }
   }
   else {



    editor.selected_entity = hit_entity;
   }
  }
  else {
   editor.in_gizmo = 0;
  }
  Entity *e = get_entity(world, editor.selected_entity);
  if (e) {

   for (int i = 0; i < 3; i++) {
    v3 color = {};
    color.e[i] = 1;
    if (editor.in_gizmo && editor.dragging_axis == i)
     color = V3(1, 1, 0);

    if (editor.gizmo_mode == GIZMO_SCALE) {
     push_line(e->position, e->position + axis[i], color);
     push_cube_outline(e->position + axis[i], V3(0.1f), color);
    }
    else if (editor.gizmo_mode == GIZMO_TRANSLATION) {
     push_line(e->position, e->position + axis[i], color);
     push_ellipsoid_outline(e->position + axis[i], V3(0.1f), color);
    }
    else {






     push_circle(e->position,
        rotation_circle_radius
        , axis[(i + 1) % 3], axis[(i + 2) % 3], color);


    }




   }
  }

  world.editor_selected_entity = editor.selected_entity;
  editor.last_camera_p = camera.position;
}
# 38 "code/game.cpp" 2

ShadowMap create_shadow_map(int texture_width, int texture_height,
  v3 light_p, v3 light_dir, mat4 projection, v3 up = V3(0, 0, 1))
{
 ShadowMap shadow_map = {};

 shadow_map.width = texture_width;
 shadow_map.height = texture_height;
 shadow_map.light_p = light_p;
 shadow_map.light_dir = light_dir;

 shadow_map.view = lookat(shadow_map.light_p, shadow_map.light_dir, up);
 shadow_map.projection = projection;

 shadow_map.depth_texture = create_depth_texture(texture_width, texture_height);

 shadow_map.framebuffer = create_frame_buffer();

 bind_framebuffer_depthbuffer(shadow_map.framebuffer, shadow_map.depth_texture);

 if (glad_glCheckFramebufferStatus(0x8D40) != 0x8CD5)
  
# 59 "code/game.cpp" 3 4
 (static_cast <bool> (
# 59 "code/game.cpp"
 0
# 59 "code/game.cpp" 3 4
 ) ? void (0) : __assert_fail (
# 59 "code/game.cpp"
 "0"
# 59 "code/game.cpp" 3 4
 , "code/game.cpp", 59, __extension__ __PRETTY_FUNCTION__))
# 59 "code/game.cpp"
          ;
 return shadow_map;
}

extern "C" void game_update_and_render(Platform &platform, Arena *memory, GameInput &input, float dt)
{
 g_rc = (RenderContext *)platform.render_context;
 g_temp_arena = &platform.temp_arena;
 ImGui::SetCurrentContext((ImGuiContext *)platform.imgui_context);

 Game &game = *((Game *)memory->data);
 if (!game.is_initialized) {

  
# 72 "code/game.cpp" 3 4
 (static_cast <bool> (
# 72 "code/game.cpp"
 memory->used == 0
# 72 "code/game.cpp" 3 4
 ) ? void (0) : __assert_fail (
# 72 "code/game.cpp"
 "memory->used == 0"
# 72 "code/game.cpp" 3 4
 , "code/game.cpp", 72, __extension__ __PRETTY_FUNCTION__))
# 72 "code/game.cpp"
                          ;
  arena_alloc_zero(memory, sizeof(game));

  init_render_context(memory, *g_rc, platform);

  usize temp_arena_size = (1024ULL * (1024ULL * 128));
  g_temp_arena->arena = make_arena(_arena_alloc("code/game.cpp", __func__, 78, memory, temp_arena_size), temp_arena_size);






  game.world = new World();
  World &world = *game.world;

  world.arena = make_arena(_arena_alloc("code/game.cpp", __func__, 88, memory, (1024ULL * (1024ULL * 64))), (1024ULL * (1024ULL * 64)));

  game.asset_arena = make_arena(_arena_alloc("code/game.cpp", __func__, 90, memory, (1024ULL * (1024ULL * 256))), (1024ULL * (1024ULL * 256)));

  game.default_rasterizer_state = create_rasterizer_state(RASTERIZER_FILL_SOLID, RASTERIZER_CULL_NONE);
  game.default_depth_stencil_state = create_depth_stencil_state(true);
  game.disable_depth_state = create_depth_stencil_state(false);


  VertexInputLayout input_layout = create_vertex_input_layout(g_vertex_input_elements,
    (sizeof(g_vertex_input_elements) / sizeof(*g_vertex_input_elements)), sizeof(Vertex));

  game.mesh_render_pass = create_render_pass(




    load_shader(make_cstring("vertex.glsl"), SHADER_TYPE_VERTEX),
    load_shader(make_cstring("fragment.glsl"), SHADER_TYPE_FRAGMENT),

    PRIMITIVE_TRIANGLES, game.default_depth_stencil_state, game.default_rasterizer_state,
    input_layout);

  game.shadow_map_render_pass = create_render_pass(
    load_shader(make_cstring("vertex.glsl"), SHADER_TYPE_VERTEX),
    load_shader(make_cstring("shadow_map_fs.glsl"), SHADER_TYPE_FRAGMENT),
    PRIMITIVE_TRIANGLES, game.default_depth_stencil_state, game.default_rasterizer_state,
    input_layout);

  game.shadow_map = create_shadow_map(4096, 4096,
    V3(24, 0, 24), V3(-1, 0, -1),
    orthographic_projection(1, 75, 50, 40));
  {
   VertexInputElement input_elements[] = {
    {0, 3, INPUT_ELEMENT_FLOAT, "POSITION"},
    {sizeof(v3), 3, INPUT_ELEMENT_FLOAT, "COLOR"},
   };
   VertexInputLayout input_layout = create_vertex_input_layout(input_elements, (sizeof(input_elements) / sizeof(*input_elements)),
     sizeof(v3) * 2);

   game.debug_lines_render_pass = create_render_pass(




     load_shader(make_cstring("debug_lines_vs.glsl"), SHADER_TYPE_VERTEX),
     load_shader(make_cstring("debug_lines_fs.glsl"), SHADER_TYPE_FRAGMENT),

     PRIMITIVE_LINES, game.default_depth_stencil_state, game.default_rasterizer_state,
     input_layout);

   game.debug_lines_vertex_buffer = create_vertex_buffer(VERTEX_BUFFER_DYNAMIC,
     g_rc->debug_lines.capacity * sizeof(v3));

   ConstantBufferElement elems[] = {
    {CONSTANT_BUFFER_ELEMENT_MAT4},
   };
   game.debug_lines_constant_buffer = create_constant_buffer(make_array<ConstantBufferElement>(elems, (sizeof(elems) / sizeof(*elems))));
  }



  ConstantBufferElement elems[] = {
   {CONSTANT_BUFFER_ELEMENT_MAT4},
   {CONSTANT_BUFFER_ELEMENT_MAT4},
   {CONSTANT_BUFFER_ELEMENT_MAT4},
   {CONSTANT_BUFFER_ELEMENT_MAT4},
   {CONSTANT_BUFFER_ELEMENT_MAT4, 96},
   {CONSTANT_BUFFER_ELEMENT_VEC3},
   {CONSTANT_BUFFER_ELEMENT_VEC3},
   {CONSTANT_BUFFER_ELEMENT_VEC3},
   {CONSTANT_BUFFER_ELEMENT_FLOAT},
   {CONSTANT_BUFFER_ELEMENT_FLOAT},
   {CONSTANT_BUFFER_ELEMENT_FLOAT},
   {CONSTANT_BUFFER_ELEMENT_INT},
   {CONSTANT_BUFFER_ELEMENT_INT},
   {CONSTANT_BUFFER_ELEMENT_INT},
  };
  game.constant_buffer = create_constant_buffer(make_array<ConstantBufferElement>(elems, (sizeof(elems) / sizeof(*elems))));

  game.ch43 = load_scene(&game.asset_arena, "data/YBot.fbx");





  game.cube_asset = load_scene(&game.asset_arena, "data/cube.fbx");
  game.sphere_asset = load_scene(&game.asset_arena, "data/sphere.fbx");




  game.animations[ANIMATION_JUMP] = load_scene(&game.asset_arena, "data/jump.fbx").animations[0];
  game.animations[ANIMATION_SHOOT] = load_scene(&game.asset_arena, "data/shoot.fbx").animations[0];
  game.animations[ANIMATION_RUN] = load_scene(&game.asset_arena, "data/run.fbx").animations[0];
  game.animations[ANIMATION_FORWARD_GUN_WALK] = load_scene(&game.asset_arena, "data/forward_gun_walk.fbx").animations[0];
  game.animations[ANIMATION_BACKWARD_GUN_WALK] = load_scene(&game.asset_arena, "data/backward_gun_walk.fbx").animations[0];
  game.animations[ANIMATION_GUN_IDLE] = load_scene(&game.asset_arena, "data/gun_idle.fbx").animations[0];

  world.entities = make_array_max<Entity>(&world.arena, 4096);
# 215 "code/game.cpp"
  Entity *boxes[] = {
   make_entity(world, EntityType_Static, &game.cube_asset, V3(0, 0, -0.5), make_box_shape(memory, V3(25, 25, 0.5))),
   make_entity(world, EntityType_Static, &game.cube_asset, V3(0, 25, 0), make_box_shape(memory, (V3(25, 0.5, 25)))),
   make_entity(world, EntityType_Static, &game.cube_asset, V3(10, 6, 1), make_box_shape(memory, (V3(5, 5.8, 0.3)))),
   make_entity(world, EntityType_Static, &game.cube_asset, V3(10, 6, 1.3), make_box_shape(memory, (V3(2.5, 2.5, 0.3)))),
   make_entity(world, EntityType_Static, &game.cube_asset, V3(10, 6, 1.6), make_box_shape(memory, (V3(1.25, 1.25, 0.3)))),
   make_entity(world, EntityType_Static, &game.cube_asset, V3(-10, 6, 1), make_box_shape(memory, (V3(7, 7, 0.3)))),
   make_entity(world, EntityType_Static, &game.cube_asset, V3(1, 6, 0), make_box_shape(memory, (V3(4, 1, 2)))),
   make_entity(world, EntityType_Static, &game.cube_asset, V3(0, -7, 1), make_box_shape(memory, (V3(4, 4, 0.3)))),
   make_entity(world, EntityType_Static, &game.cube_asset, V3(0, -7, 1.6), make_box_shape(memory, (V3(2, 2, 0.3)))),

   make_entity(world, EntityType_Static, &game.cube_asset, V3(7, -7, 0.1), make_box_shape(memory, (V3(3, 3, 0.1)))),

  };
  for (int i = 0; i < (sizeof(boxes) / sizeof(*boxes)); i++) {

   boxes[i]->scale = boxes[i]->shape.box_radius;
   boxes[i]->shape = make_box_shape(memory, V3(1));

   float r = (float)rand() / 
# 234 "code/game.cpp" 3 4
                            2147483647
# 234 "code/game.cpp"
                                    ;
   float g = (float)rand() / 
# 235 "code/game.cpp" 3 4
                            2147483647
# 235 "code/game.cpp"
                                    ;
   float b = (float)rand() / 
# 236 "code/game.cpp" 3 4
                            2147483647
# 236 "code/game.cpp"
                                    ;

   boxes[i]->color = V3(r, g, b);

  }
  Entity *player = make_entity(world, EntityType_Player, &game.ch43, V3(0, 0, 8), make_ellipsoid_shape(V3(0.55f, 0.55f, 0.95f)));
  world.player_id = player->id;




  player->scene_transform = translate(0, 0, -player->shape.ellipsoid_radius.z) * zrotation(3*3.14159265359f/2) * scale(V3(1.1));
  player->color = V3(0.2, 0.8, 0.8);

  world.editor_camera_p = V3(0, 0, 3);

  game.is_initialized = 1;
 }

 World &world = *game.world;

 if (((input.buttons[BUTTON_F1].is_down) && !(input.buttons[BUTTON_F1].was_down)))
  game.in_editor = !game.in_editor;

 begin_render_frame();

 if (!game.in_editor) {
  update_player(game, world, input, dt);
  update_enemies(game, world, input, dt);
 }

 Camera game_camera = update_camera(game, world, input, dt);

 if (game.in_editor)
  update_editor(world, world.editor, input, game_camera);

 push_cube_outline(game.shadow_map.light_p, V3(0.3));
 push_line(game.shadow_map.light_p, game.shadow_map.light_p + 0.5 * game.shadow_map.light_dir);

 begin_render_pass(game.shadow_map_render_pass);
 {
  set_viewport(0, 0, game.shadow_map.width, game.shadow_map.height);
  bind_framebuffer(game.shadow_map.framebuffer);
  clear_framebuffer_depth(game.shadow_map.framebuffer, 1);
  render_entities(game, world, Camera{game.shadow_map.light_p, game.shadow_map.view, game.shadow_map.projection});
 }
 end_render_pass();

 begin_render_pass(game.mesh_render_pass);
 {
  set_viewport(0, 0, g_rc->window_width, g_rc->window_height);

  bind_framebuffer(g_rc->window_framebuffer);
  clear_framebuffer_color(g_rc->window_framebuffer, V4(0.392f, 0.584f, 0.929f, 1.f));
  clear_framebuffer_depth(g_rc->window_framebuffer, 1);
  bind_texture(4, game.shadow_map.depth_texture);
  render_entities(game, world, game_camera);
 }
 end_render_pass();





 begin_render_pass(game.debug_lines_render_pass);
 {

  clear_framebuffer_depth(g_rc->window_framebuffer, 1);
  update_vertex_buffer(game.debug_lines_vertex_buffer, (int)g_rc->debug_lines.count * sizeof(v3),
    g_rc->debug_lines.data);
  mat4 mvp = game_camera.projection * game_camera.view;
  bind_constant_buffer(game.debug_lines_constant_buffer, 1);
  update_constant_buffer(game.debug_lines_constant_buffer, &mvp);
  bind_vertex_buffer(game.debug_lines_vertex_buffer);
  draw(0, (int)(g_rc->debug_lines.count / 2));
 }
 end_render_pass();


 {
  ImGuiIO &io = ImGui::GetIO();
  ImGui::Begin("debug");
  ImGui::Text("Application average %.3f ms/frame (%.1f FPS)", 1000.0f / io.Framerate, io.Framerate);
  ImGui::Text("resolution: %dx%d", g_rc->window_width, g_rc->window_height);
  ImGui::Checkbox("debug collission", &game.debug_collision);
  ImGui::Checkbox("show normals", &game.show_normals);
  ImGui::Text("in gizmo: %d, gizmo mode: %d", world.editor.in_gizmo,
    world.editor.gizmo_mode);
  if (ImGui::Button("new cube")) {
   Entity *entity = make_entity(world, EntityType_Static,
     &game.cube_asset, game_camera.position
     + game_camera.forward * 4, make_box_shape(&world.arena, V3(1)));
   world.editor.selected_entity = entity->id;
  }
  if (ImGui::Button("new sphere")) {
   Entity *entity = make_entity(world, EntityType_Static,
     &game.sphere_asset, game_camera.position
     + game_camera.forward * 4, make_ellipsoid_shape(V3(1)));
   world.editor.selected_entity = entity->id;
  }
  ImGui::End();
 }

 {
  Entity *e = get_entity(world, world.editor_selected_entity);

  if (e) {
   ImGuiIO &io = ImGui::GetIO();

   v3 r = e->rotation * (180.f / 3.14159265359f);

   ImGui::Begin("Entity");
            ImGui::ColorEdit3("color", e->color.e);
# 358 "code/game.cpp"
   ImGui::End();

   e->rotation = r * (3.14159265359f / 180.f);
  }
 }
 end_render_frame();

 game.time += dt;
 if (game.frame == 0)
  ImGui::SetWindowFocus(
# 367 "code/game.cpp" 3 4
                       __null
# 367 "code/game.cpp"
                           );
 game.frame++;
}
# 22 "code/glfw_main.cpp" 2

extern "C" const char *__asan_default_options() { return "detect_leaks=0"; }

bool g_hide_mouse = true;

void update_game_input(GLFWwindow *window, GameInput &input, int frame)
{
 int button_map[BUTTON_COUNT] = {};

 for (int i = 0; i < 26; i++)
  button_map[BUTTON_A + i] = 65 + i;

 button_map[BUTTON_SPACE] = 32;
 button_map[BUTTON_LEFT_SHIFT] = 340;
 button_map[BUTTON_LEFT_CONTROL] = 341;

 for (int i = BUTTON_F1; i < BUTTON_COUNT; i++)
  button_map[i] = 290 + (i - BUTTON_F1);

 for (int i = 0; i < BUTTON_COUNT; i++) {
  input.buttons[i].was_down = input.buttons[i].is_down;
  input.buttons[i].is_down = glfwGetKey(window, button_map[i]) == 1;
 }

 input.buttons[BUTTON_MOUSE_LEFT].is_down = glfwGetMouseButton(window, 0) == 1;
 input.buttons[BUTTON_MOUSE_RIGHT].is_down = glfwGetMouseButton(window, 1) == 1;

 double mouse_x, mouse_y;
 glfwGetCursorPos(window, &mouse_x, &mouse_y);

 input.last_mouse_p = input.mouse_p;
 input.mouse_p = V2(mouse_x, mouse_y);
 if (frame > 3)
  input.mouse_dp = input.mouse_p - input.last_mouse_p;

 if (((input.buttons[BUTTON_F1].is_down) && !(input.buttons[BUTTON_F1].was_down))) {
  g_hide_mouse = !g_hide_mouse;
  glfwSetInputMode(window, 0x00033001, g_hide_mouse ? 0x00034003 : 0x00034001);
 }
}

void game_update_and_render(Platform &platform, Arena *memory, GameInput &input, float dt);

int main()
{
 if (!glfwInit())
  
# 68 "code/glfw_main.cpp" 3 4
 (static_cast <bool> (
# 68 "code/glfw_main.cpp"
 0
# 68 "code/glfw_main.cpp" 3 4
 ) ? void (0) : __assert_fail (
# 68 "code/glfw_main.cpp"
 "0"
# 68 "code/glfw_main.cpp" 3 4
 , "code/glfw_main.cpp", 68, __extension__ __PRETTY_FUNCTION__))
# 68 "code/glfw_main.cpp"
          ;


 glfwWindowHint(0x00022007, true);

 glfwWindowHint(0x00022002, 4);
 glfwWindowHint(0x00022003, 2);
 glfwWindowHint(0x00022008, 0x00032001);
 glfwWindowHint(0x0002100D, 4);
 glfwWindowHint(0x0002100E, 1);

 GLFWwindow *window = glfwCreateWindow(800, 600, "game", 0, 0);
 if (!window)
  
# 81 "code/glfw_main.cpp" 3 4
 (static_cast <bool> (
# 81 "code/glfw_main.cpp"
 0
# 81 "code/glfw_main.cpp" 3 4
 ) ? void (0) : __assert_fail (
# 81 "code/glfw_main.cpp"
 "0"
# 81 "code/glfw_main.cpp" 3 4
 , "code/glfw_main.cpp", 81, __extension__ __PRETTY_FUNCTION__))
# 81 "code/glfw_main.cpp"
          ;

 glfwMakeContextCurrent(window);


 if (!gladLoadGLLoader((GLADloadproc)glfwGetProcAddress))
  
# 87 "code/glfw_main.cpp" 3 4
 (static_cast <bool> (
# 87 "code/glfw_main.cpp"
 0
# 87 "code/glfw_main.cpp" 3 4
 ) ? void (0) : __assert_fail (
# 87 "code/glfw_main.cpp"
 "0"
# 87 "code/glfw_main.cpp" 3 4
 , "code/glfw_main.cpp", 87, __extension__ __PRETTY_FUNCTION__))
# 87 "code/glfw_main.cpp"
          ;


 ImGui::DebugCheckVersionAndDataLayout("1.90.2 WIP", sizeof(ImGuiIO), sizeof(ImGuiStyle), sizeof(ImVec2), sizeof(ImVec4), sizeof(ImDrawVert), sizeof(ImDrawIdx));
 ImGui::CreateContext();
 ImGuiIO& io = ImGui::GetIO();
 io.ConfigFlags |= ImGuiConfigFlags_NavEnableKeyboard;


 ImGui_ImplGlfw_InitForOpenGL(window, true);
 ImGui_ImplOpenGL3_Init();


 usize memory_size = (1024ULL * (1024ULL * (1024ULL * 1)));
 Arena memory = make_arena(calloc(1, memory_size), memory_size);

 RenderContext rc = {};

 GameInput game_input = {};
 {
  double mouse_x, mouse_y;
  glfwGetCursorPos(window, &mouse_x, &mouse_y);
  game_input.mouse_p = game_input.last_mouse_p = V2(mouse_x, mouse_y);
 }

 if (g_hide_mouse)
  glfwSetInputMode(window, 0x00033001, 0x00034003);

 Platform platform = {};
 platform.render_context = &rc;
 platform.window = window;
 platform.imgui_context = ImGui::GetCurrentContext();

 int frame = 0;

 while (!glfwWindowShouldClose(window)) {
  glfwPollEvents();

  if (glfwGetKey(window, 256) == 1)
   break ;
  update_game_input(window, game_input, frame);
  game_update_and_render(platform, &memory, game_input, 1.f / 60);

  glfwSwapBuffers(window);
  frame++;
 }

 ImGui_ImplOpenGL3_Shutdown();
 ImGui_ImplGlfw_Shutdown();
 ImGui::DestroyContext();

 glfwTerminate();
}
